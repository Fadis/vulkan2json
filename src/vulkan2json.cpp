/*
 * Copyright (c) 2021 Naomasa Matsubayashi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <cstddef>
#include <cstdint>
#include <utility>
#include <cstring>
#include <string>
#include <algorithm>
#include <nlohmann/json.hpp>
#include <vulkan/vulkan.hpp>
#include <vulkan2json/exceptions.hpp>

namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const VendorId &p ) {
  if( VendorId :: eVIV == p ) {
    j = "VIV";
    return;
  }
  if( VendorId :: eVSI == p ) {
    j = "VSI";
    return;
  }
  if( VendorId :: eKazan == p ) {
    j = "Kazan";
    return;
  }
  if( VendorId :: eCodeplay == p ) {
    j = "Codeplay";
    return;
  }
  if( VendorId :: eMESA == p ) {
    j = "MESA";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkVendorId &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: VendorId ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, VendorId &p ) {
  if( j.is_string() ) {
    if( "VIV" == j.get< std::string >() ) {
      p = VendorId :: eVIV ;
      return;
    }
    if( "eVIV" == j.get< std::string >() ) {
      p = VendorId :: eVIV ;
      return;
    }
    if( "VK_VENDOR_ID_VIV" == j.get< std::string >() ) {
      p = VendorId :: eVIV ;
      return;
    }
    if( "VSI" == j.get< std::string >() ) {
      p = VendorId :: eVSI ;
      return;
    }
    if( "eVSI" == j.get< std::string >() ) {
      p = VendorId :: eVSI ;
      return;
    }
    if( "VK_VENDOR_ID_VSI" == j.get< std::string >() ) {
      p = VendorId :: eVSI ;
      return;
    }
    if( "Kazan" == j.get< std::string >() ) {
      p = VendorId :: eKazan ;
      return;
    }
    if( "eKazan" == j.get< std::string >() ) {
      p = VendorId :: eKazan ;
      return;
    }
    if( "VK_VENDOR_ID_KAZAN" == j.get< std::string >() ) {
      p = VendorId :: eKazan ;
      return;
    }
    if( "Codeplay" == j.get< std::string >() ) {
      p = VendorId :: eCodeplay ;
      return;
    }
    if( "eCodeplay" == j.get< std::string >() ) {
      p = VendorId :: eCodeplay ;
      return;
    }
    if( "VK_VENDOR_ID_CODEPLAY" == j.get< std::string >() ) {
      p = VendorId :: eCodeplay ;
      return;
    }
    if( "MESA" == j.get< std::string >() ) {
      p = VendorId :: eMESA ;
      return;
    }
    if( "eMESA" == j.get< std::string >() ) {
      p = VendorId :: eMESA ;
      return;
    }
    if( "VK_VENDOR_ID_MESA" == j.get< std::string >() ) {
      p = VendorId :: eMESA ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for VendorId" );
  }
  if( j.is_number() ) {
    p = VendorId ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VendorId" );
}
}
void from_json( const nlohmann::json &j, VkVendorId &p ) {
  VULKAN_HPP_NAMESPACE :: VendorId temp;
  from_json( j, temp );
  p = VkVendorId ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCacheHeaderVersion &p ) {
}
}
void to_json( nlohmann::json &j, const VkPipelineCacheHeaderVersion &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineCacheHeaderVersion ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineCacheHeaderVersion &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCacheHeaderVersion" );
  }
  if( j.is_number() ) {
    p = PipelineCacheHeaderVersion ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCacheHeaderVersion" );
}
}
void from_json( const nlohmann::json &j, VkPipelineCacheHeaderVersion &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineCacheHeaderVersion temp;
  from_json( j, temp );
  p = VkPipelineCacheHeaderVersion ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const Format &p ) {
  if( Format :: eUndefined == p ) {
    j = "Undefined";
    return;
  }
  if( Format :: eR4G4UnormPack8 == p ) {
    j = "R4G4UnormPack8";
    return;
  }
  if( Format :: eR4G4B4A4UnormPack16 == p ) {
    j = "R4G4B4A4UnormPack16";
    return;
  }
  if( Format :: eB4G4R4A4UnormPack16 == p ) {
    j = "B4G4R4A4UnormPack16";
    return;
  }
  if( Format :: eR5G6B5UnormPack16 == p ) {
    j = "R5G6B5UnormPack16";
    return;
  }
  if( Format :: eB5G6R5UnormPack16 == p ) {
    j = "B5G6R5UnormPack16";
    return;
  }
  if( Format :: eR5G5B5A1UnormPack16 == p ) {
    j = "R5G5B5A1UnormPack16";
    return;
  }
  if( Format :: eB5G5R5A1UnormPack16 == p ) {
    j = "B5G5R5A1UnormPack16";
    return;
  }
  if( Format :: eA1R5G5B5UnormPack16 == p ) {
    j = "A1R5G5B5UnormPack16";
    return;
  }
  if( Format :: eR8Unorm == p ) {
    j = "R8Unorm";
    return;
  }
  if( Format :: eR8Snorm == p ) {
    j = "R8Snorm";
    return;
  }
  if( Format :: eR8Uscaled == p ) {
    j = "R8Uscaled";
    return;
  }
  if( Format :: eR8Sscaled == p ) {
    j = "R8Sscaled";
    return;
  }
  if( Format :: eR8Uint == p ) {
    j = "R8Uint";
    return;
  }
  if( Format :: eR8Sint == p ) {
    j = "R8Sint";
    return;
  }
  if( Format :: eR8Srgb == p ) {
    j = "R8Srgb";
    return;
  }
  if( Format :: eR8G8Unorm == p ) {
    j = "R8G8Unorm";
    return;
  }
  if( Format :: eR8G8Snorm == p ) {
    j = "R8G8Snorm";
    return;
  }
  if( Format :: eR8G8Uscaled == p ) {
    j = "R8G8Uscaled";
    return;
  }
  if( Format :: eR8G8Sscaled == p ) {
    j = "R8G8Sscaled";
    return;
  }
  if( Format :: eR8G8Uint == p ) {
    j = "R8G8Uint";
    return;
  }
  if( Format :: eR8G8Sint == p ) {
    j = "R8G8Sint";
    return;
  }
  if( Format :: eR8G8Srgb == p ) {
    j = "R8G8Srgb";
    return;
  }
  if( Format :: eR8G8B8Unorm == p ) {
    j = "R8G8B8Unorm";
    return;
  }
  if( Format :: eR8G8B8Snorm == p ) {
    j = "R8G8B8Snorm";
    return;
  }
  if( Format :: eR8G8B8Uscaled == p ) {
    j = "R8G8B8Uscaled";
    return;
  }
  if( Format :: eR8G8B8Sscaled == p ) {
    j = "R8G8B8Sscaled";
    return;
  }
  if( Format :: eR8G8B8Uint == p ) {
    j = "R8G8B8Uint";
    return;
  }
  if( Format :: eR8G8B8Sint == p ) {
    j = "R8G8B8Sint";
    return;
  }
  if( Format :: eR8G8B8Srgb == p ) {
    j = "R8G8B8Srgb";
    return;
  }
  if( Format :: eB8G8R8Unorm == p ) {
    j = "B8G8R8Unorm";
    return;
  }
  if( Format :: eB8G8R8Snorm == p ) {
    j = "B8G8R8Snorm";
    return;
  }
  if( Format :: eB8G8R8Uscaled == p ) {
    j = "B8G8R8Uscaled";
    return;
  }
  if( Format :: eB8G8R8Sscaled == p ) {
    j = "B8G8R8Sscaled";
    return;
  }
  if( Format :: eB8G8R8Uint == p ) {
    j = "B8G8R8Uint";
    return;
  }
  if( Format :: eB8G8R8Sint == p ) {
    j = "B8G8R8Sint";
    return;
  }
  if( Format :: eB8G8R8Srgb == p ) {
    j = "B8G8R8Srgb";
    return;
  }
  if( Format :: eR8G8B8A8Unorm == p ) {
    j = "R8G8B8A8Unorm";
    return;
  }
  if( Format :: eR8G8B8A8Snorm == p ) {
    j = "R8G8B8A8Snorm";
    return;
  }
  if( Format :: eR8G8B8A8Uscaled == p ) {
    j = "R8G8B8A8Uscaled";
    return;
  }
  if( Format :: eR8G8B8A8Sscaled == p ) {
    j = "R8G8B8A8Sscaled";
    return;
  }
  if( Format :: eR8G8B8A8Uint == p ) {
    j = "R8G8B8A8Uint";
    return;
  }
  if( Format :: eR8G8B8A8Sint == p ) {
    j = "R8G8B8A8Sint";
    return;
  }
  if( Format :: eR8G8B8A8Srgb == p ) {
    j = "R8G8B8A8Srgb";
    return;
  }
  if( Format :: eB8G8R8A8Unorm == p ) {
    j = "B8G8R8A8Unorm";
    return;
  }
  if( Format :: eB8G8R8A8Snorm == p ) {
    j = "B8G8R8A8Snorm";
    return;
  }
  if( Format :: eB8G8R8A8Uscaled == p ) {
    j = "B8G8R8A8Uscaled";
    return;
  }
  if( Format :: eB8G8R8A8Sscaled == p ) {
    j = "B8G8R8A8Sscaled";
    return;
  }
  if( Format :: eB8G8R8A8Uint == p ) {
    j = "B8G8R8A8Uint";
    return;
  }
  if( Format :: eB8G8R8A8Sint == p ) {
    j = "B8G8R8A8Sint";
    return;
  }
  if( Format :: eB8G8R8A8Srgb == p ) {
    j = "B8G8R8A8Srgb";
    return;
  }
  if( Format :: eA8B8G8R8UnormPack32 == p ) {
    j = "A8B8G8R8UnormPack32";
    return;
  }
  if( Format :: eA8B8G8R8SnormPack32 == p ) {
    j = "A8B8G8R8SnormPack32";
    return;
  }
  if( Format :: eA8B8G8R8UscaledPack32 == p ) {
    j = "A8B8G8R8UscaledPack32";
    return;
  }
  if( Format :: eA8B8G8R8SscaledPack32 == p ) {
    j = "A8B8G8R8SscaledPack32";
    return;
  }
  if( Format :: eA8B8G8R8UintPack32 == p ) {
    j = "A8B8G8R8UintPack32";
    return;
  }
  if( Format :: eA8B8G8R8SintPack32 == p ) {
    j = "A8B8G8R8SintPack32";
    return;
  }
  if( Format :: eA8B8G8R8SrgbPack32 == p ) {
    j = "A8B8G8R8SrgbPack32";
    return;
  }
  if( Format :: eA2R10G10B10UnormPack32 == p ) {
    j = "A2R10G10B10UnormPack32";
    return;
  }
  if( Format :: eA2R10G10B10SnormPack32 == p ) {
    j = "A2R10G10B10SnormPack32";
    return;
  }
  if( Format :: eA2R10G10B10UscaledPack32 == p ) {
    j = "A2R10G10B10UscaledPack32";
    return;
  }
  if( Format :: eA2R10G10B10SscaledPack32 == p ) {
    j = "A2R10G10B10SscaledPack32";
    return;
  }
  if( Format :: eA2R10G10B10UintPack32 == p ) {
    j = "A2R10G10B10UintPack32";
    return;
  }
  if( Format :: eA2R10G10B10SintPack32 == p ) {
    j = "A2R10G10B10SintPack32";
    return;
  }
  if( Format :: eA2B10G10R10UnormPack32 == p ) {
    j = "A2B10G10R10UnormPack32";
    return;
  }
  if( Format :: eA2B10G10R10SnormPack32 == p ) {
    j = "A2B10G10R10SnormPack32";
    return;
  }
  if( Format :: eA2B10G10R10UscaledPack32 == p ) {
    j = "A2B10G10R10UscaledPack32";
    return;
  }
  if( Format :: eA2B10G10R10SscaledPack32 == p ) {
    j = "A2B10G10R10SscaledPack32";
    return;
  }
  if( Format :: eA2B10G10R10UintPack32 == p ) {
    j = "A2B10G10R10UintPack32";
    return;
  }
  if( Format :: eA2B10G10R10SintPack32 == p ) {
    j = "A2B10G10R10SintPack32";
    return;
  }
  if( Format :: eR16Unorm == p ) {
    j = "R16Unorm";
    return;
  }
  if( Format :: eR16Snorm == p ) {
    j = "R16Snorm";
    return;
  }
  if( Format :: eR16Uscaled == p ) {
    j = "R16Uscaled";
    return;
  }
  if( Format :: eR16Sscaled == p ) {
    j = "R16Sscaled";
    return;
  }
  if( Format :: eR16Uint == p ) {
    j = "R16Uint";
    return;
  }
  if( Format :: eR16Sint == p ) {
    j = "R16Sint";
    return;
  }
  if( Format :: eR16Sfloat == p ) {
    j = "R16Sfloat";
    return;
  }
  if( Format :: eR16G16Unorm == p ) {
    j = "R16G16Unorm";
    return;
  }
  if( Format :: eR16G16Snorm == p ) {
    j = "R16G16Snorm";
    return;
  }
  if( Format :: eR16G16Uscaled == p ) {
    j = "R16G16Uscaled";
    return;
  }
  if( Format :: eR16G16Sscaled == p ) {
    j = "R16G16Sscaled";
    return;
  }
  if( Format :: eR16G16Uint == p ) {
    j = "R16G16Uint";
    return;
  }
  if( Format :: eR16G16Sint == p ) {
    j = "R16G16Sint";
    return;
  }
  if( Format :: eR16G16Sfloat == p ) {
    j = "R16G16Sfloat";
    return;
  }
  if( Format :: eR16G16B16Unorm == p ) {
    j = "R16G16B16Unorm";
    return;
  }
  if( Format :: eR16G16B16Snorm == p ) {
    j = "R16G16B16Snorm";
    return;
  }
  if( Format :: eR16G16B16Uscaled == p ) {
    j = "R16G16B16Uscaled";
    return;
  }
  if( Format :: eR16G16B16Sscaled == p ) {
    j = "R16G16B16Sscaled";
    return;
  }
  if( Format :: eR16G16B16Uint == p ) {
    j = "R16G16B16Uint";
    return;
  }
  if( Format :: eR16G16B16Sint == p ) {
    j = "R16G16B16Sint";
    return;
  }
  if( Format :: eR16G16B16Sfloat == p ) {
    j = "R16G16B16Sfloat";
    return;
  }
  if( Format :: eR16G16B16A16Unorm == p ) {
    j = "R16G16B16A16Unorm";
    return;
  }
  if( Format :: eR16G16B16A16Snorm == p ) {
    j = "R16G16B16A16Snorm";
    return;
  }
  if( Format :: eR16G16B16A16Uscaled == p ) {
    j = "R16G16B16A16Uscaled";
    return;
  }
  if( Format :: eR16G16B16A16Sscaled == p ) {
    j = "R16G16B16A16Sscaled";
    return;
  }
  if( Format :: eR16G16B16A16Uint == p ) {
    j = "R16G16B16A16Uint";
    return;
  }
  if( Format :: eR16G16B16A16Sint == p ) {
    j = "R16G16B16A16Sint";
    return;
  }
  if( Format :: eR16G16B16A16Sfloat == p ) {
    j = "R16G16B16A16Sfloat";
    return;
  }
  if( Format :: eR32Uint == p ) {
    j = "R32Uint";
    return;
  }
  if( Format :: eR32Sint == p ) {
    j = "R32Sint";
    return;
  }
  if( Format :: eR32Sfloat == p ) {
    j = "R32Sfloat";
    return;
  }
  if( Format :: eR32G32Uint == p ) {
    j = "R32G32Uint";
    return;
  }
  if( Format :: eR32G32Sint == p ) {
    j = "R32G32Sint";
    return;
  }
  if( Format :: eR32G32Sfloat == p ) {
    j = "R32G32Sfloat";
    return;
  }
  if( Format :: eR32G32B32Uint == p ) {
    j = "R32G32B32Uint";
    return;
  }
  if( Format :: eR32G32B32Sint == p ) {
    j = "R32G32B32Sint";
    return;
  }
  if( Format :: eR32G32B32Sfloat == p ) {
    j = "R32G32B32Sfloat";
    return;
  }
  if( Format :: eR32G32B32A32Uint == p ) {
    j = "R32G32B32A32Uint";
    return;
  }
  if( Format :: eR32G32B32A32Sint == p ) {
    j = "R32G32B32A32Sint";
    return;
  }
  if( Format :: eR32G32B32A32Sfloat == p ) {
    j = "R32G32B32A32Sfloat";
    return;
  }
  if( Format :: eR64Uint == p ) {
    j = "R64Uint";
    return;
  }
  if( Format :: eR64Sint == p ) {
    j = "R64Sint";
    return;
  }
  if( Format :: eR64Sfloat == p ) {
    j = "R64Sfloat";
    return;
  }
  if( Format :: eR64G64Uint == p ) {
    j = "R64G64Uint";
    return;
  }
  if( Format :: eR64G64Sint == p ) {
    j = "R64G64Sint";
    return;
  }
  if( Format :: eR64G64Sfloat == p ) {
    j = "R64G64Sfloat";
    return;
  }
  if( Format :: eR64G64B64Uint == p ) {
    j = "R64G64B64Uint";
    return;
  }
  if( Format :: eR64G64B64Sint == p ) {
    j = "R64G64B64Sint";
    return;
  }
  if( Format :: eR64G64B64Sfloat == p ) {
    j = "R64G64B64Sfloat";
    return;
  }
  if( Format :: eR64G64B64A64Uint == p ) {
    j = "R64G64B64A64Uint";
    return;
  }
  if( Format :: eR64G64B64A64Sint == p ) {
    j = "R64G64B64A64Sint";
    return;
  }
  if( Format :: eR64G64B64A64Sfloat == p ) {
    j = "R64G64B64A64Sfloat";
    return;
  }
  if( Format :: eB10G11R11UfloatPack32 == p ) {
    j = "B10G11R11UfloatPack32";
    return;
  }
  if( Format :: eE5B9G9R9UfloatPack32 == p ) {
    j = "E5B9G9R9UfloatPack32";
    return;
  }
  if( Format :: eD16Unorm == p ) {
    j = "D16Unorm";
    return;
  }
  if( Format :: eX8D24UnormPack32 == p ) {
    j = "X8D24UnormPack32";
    return;
  }
  if( Format :: eD32Sfloat == p ) {
    j = "D32Sfloat";
    return;
  }
  if( Format :: eS8Uint == p ) {
    j = "S8Uint";
    return;
  }
  if( Format :: eD16UnormS8Uint == p ) {
    j = "D16UnormS8Uint";
    return;
  }
  if( Format :: eD24UnormS8Uint == p ) {
    j = "D24UnormS8Uint";
    return;
  }
  if( Format :: eD32SfloatS8Uint == p ) {
    j = "D32SfloatS8Uint";
    return;
  }
  if( Format :: eBc1RgbUnormBlock == p ) {
    j = "Bc1RgbUnormBlock";
    return;
  }
  if( Format :: eBc1RgbSrgbBlock == p ) {
    j = "Bc1RgbSrgbBlock";
    return;
  }
  if( Format :: eBc1RgbaUnormBlock == p ) {
    j = "Bc1RgbaUnormBlock";
    return;
  }
  if( Format :: eBc1RgbaSrgbBlock == p ) {
    j = "Bc1RgbaSrgbBlock";
    return;
  }
  if( Format :: eBc2UnormBlock == p ) {
    j = "Bc2UnormBlock";
    return;
  }
  if( Format :: eBc2SrgbBlock == p ) {
    j = "Bc2SrgbBlock";
    return;
  }
  if( Format :: eBc3UnormBlock == p ) {
    j = "Bc3UnormBlock";
    return;
  }
  if( Format :: eBc3SrgbBlock == p ) {
    j = "Bc3SrgbBlock";
    return;
  }
  if( Format :: eBc4UnormBlock == p ) {
    j = "Bc4UnormBlock";
    return;
  }
  if( Format :: eBc4SnormBlock == p ) {
    j = "Bc4SnormBlock";
    return;
  }
  if( Format :: eBc5UnormBlock == p ) {
    j = "Bc5UnormBlock";
    return;
  }
  if( Format :: eBc5SnormBlock == p ) {
    j = "Bc5SnormBlock";
    return;
  }
  if( Format :: eBc6HUfloatBlock == p ) {
    j = "Bc6HUfloatBlock";
    return;
  }
  if( Format :: eBc6HSfloatBlock == p ) {
    j = "Bc6HSfloatBlock";
    return;
  }
  if( Format :: eBc7UnormBlock == p ) {
    j = "Bc7UnormBlock";
    return;
  }
  if( Format :: eBc7SrgbBlock == p ) {
    j = "Bc7SrgbBlock";
    return;
  }
  if( Format :: eEtc2R8G8B8UnormBlock == p ) {
    j = "Etc2R8G8B8UnormBlock";
    return;
  }
  if( Format :: eEtc2R8G8B8SrgbBlock == p ) {
    j = "Etc2R8G8B8SrgbBlock";
    return;
  }
  if( Format :: eEtc2R8G8B8A1UnormBlock == p ) {
    j = "Etc2R8G8B8A1UnormBlock";
    return;
  }
  if( Format :: eEtc2R8G8B8A1SrgbBlock == p ) {
    j = "Etc2R8G8B8A1SrgbBlock";
    return;
  }
  if( Format :: eEtc2R8G8B8A8UnormBlock == p ) {
    j = "Etc2R8G8B8A8UnormBlock";
    return;
  }
  if( Format :: eEtc2R8G8B8A8SrgbBlock == p ) {
    j = "Etc2R8G8B8A8SrgbBlock";
    return;
  }
  if( Format :: eEacR11UnormBlock == p ) {
    j = "EacR11UnormBlock";
    return;
  }
  if( Format :: eEacR11SnormBlock == p ) {
    j = "EacR11SnormBlock";
    return;
  }
  if( Format :: eEacR11G11UnormBlock == p ) {
    j = "EacR11G11UnormBlock";
    return;
  }
  if( Format :: eEacR11G11SnormBlock == p ) {
    j = "EacR11G11SnormBlock";
    return;
  }
  if( Format :: eAstc4x4UnormBlock == p ) {
    j = "Astc4x4UnormBlock";
    return;
  }
  if( Format :: eAstc4x4SrgbBlock == p ) {
    j = "Astc4x4SrgbBlock";
    return;
  }
  if( Format :: eAstc5x4UnormBlock == p ) {
    j = "Astc5x4UnormBlock";
    return;
  }
  if( Format :: eAstc5x4SrgbBlock == p ) {
    j = "Astc5x4SrgbBlock";
    return;
  }
  if( Format :: eAstc5x5UnormBlock == p ) {
    j = "Astc5x5UnormBlock";
    return;
  }
  if( Format :: eAstc5x5SrgbBlock == p ) {
    j = "Astc5x5SrgbBlock";
    return;
  }
  if( Format :: eAstc6x5UnormBlock == p ) {
    j = "Astc6x5UnormBlock";
    return;
  }
  if( Format :: eAstc6x5SrgbBlock == p ) {
    j = "Astc6x5SrgbBlock";
    return;
  }
  if( Format :: eAstc6x6UnormBlock == p ) {
    j = "Astc6x6UnormBlock";
    return;
  }
  if( Format :: eAstc6x6SrgbBlock == p ) {
    j = "Astc6x6SrgbBlock";
    return;
  }
  if( Format :: eAstc8x5UnormBlock == p ) {
    j = "Astc8x5UnormBlock";
    return;
  }
  if( Format :: eAstc8x5SrgbBlock == p ) {
    j = "Astc8x5SrgbBlock";
    return;
  }
  if( Format :: eAstc8x6UnormBlock == p ) {
    j = "Astc8x6UnormBlock";
    return;
  }
  if( Format :: eAstc8x6SrgbBlock == p ) {
    j = "Astc8x6SrgbBlock";
    return;
  }
  if( Format :: eAstc8x8UnormBlock == p ) {
    j = "Astc8x8UnormBlock";
    return;
  }
  if( Format :: eAstc8x8SrgbBlock == p ) {
    j = "Astc8x8SrgbBlock";
    return;
  }
  if( Format :: eAstc10x5UnormBlock == p ) {
    j = "Astc10x5UnormBlock";
    return;
  }
  if( Format :: eAstc10x5SrgbBlock == p ) {
    j = "Astc10x5SrgbBlock";
    return;
  }
  if( Format :: eAstc10x6UnormBlock == p ) {
    j = "Astc10x6UnormBlock";
    return;
  }
  if( Format :: eAstc10x6SrgbBlock == p ) {
    j = "Astc10x6SrgbBlock";
    return;
  }
  if( Format :: eAstc10x8UnormBlock == p ) {
    j = "Astc10x8UnormBlock";
    return;
  }
  if( Format :: eAstc10x8SrgbBlock == p ) {
    j = "Astc10x8SrgbBlock";
    return;
  }
  if( Format :: eAstc10x10UnormBlock == p ) {
    j = "Astc10x10UnormBlock";
    return;
  }
  if( Format :: eAstc10x10SrgbBlock == p ) {
    j = "Astc10x10SrgbBlock";
    return;
  }
  if( Format :: eAstc12x10UnormBlock == p ) {
    j = "Astc12x10UnormBlock";
    return;
  }
  if( Format :: eAstc12x10SrgbBlock == p ) {
    j = "Astc12x10SrgbBlock";
    return;
  }
  if( Format :: eAstc12x12UnormBlock == p ) {
    j = "Astc12x12UnormBlock";
    return;
  }
  if( Format :: eAstc12x12SrgbBlock == p ) {
    j = "Astc12x12SrgbBlock";
    return;
  }
  if( Format :: eG8B8G8R8422Unorm == p ) {
    j = "G8B8G8R8422Unorm";
    return;
  }
  if( Format :: eB8G8R8G8422Unorm == p ) {
    j = "B8G8R8G8422Unorm";
    return;
  }
  if( Format :: eG8B8R83Plane420Unorm == p ) {
    j = "G8B8R83Plane420Unorm";
    return;
  }
  if( Format :: eG8B8R82Plane420Unorm == p ) {
    j = "G8B8R82Plane420Unorm";
    return;
  }
  if( Format :: eG8B8R83Plane422Unorm == p ) {
    j = "G8B8R83Plane422Unorm";
    return;
  }
  if( Format :: eG8B8R82Plane422Unorm == p ) {
    j = "G8B8R82Plane422Unorm";
    return;
  }
  if( Format :: eG8B8R83Plane444Unorm == p ) {
    j = "G8B8R83Plane444Unorm";
    return;
  }
  if( Format :: eR10X6UnormPack16 == p ) {
    j = "R10X6UnormPack16";
    return;
  }
  if( Format :: eR10X6G10X6Unorm2Pack16 == p ) {
    j = "R10X6G10X6Unorm2Pack16";
    return;
  }
  if( Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16 == p ) {
    j = "R10X6G10X6B10X6A10X6Unorm4Pack16";
    return;
  }
  if( Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16 == p ) {
    j = "G10X6B10X6G10X6R10X6422Unorm4Pack16";
    return;
  }
  if( Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16 == p ) {
    j = "B10X6G10X6R10X6G10X6422Unorm4Pack16";
    return;
  }
  if( Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16 == p ) {
    j = "G10X6B10X6R10X63Plane420Unorm3Pack16";
    return;
  }
  if( Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16 == p ) {
    j = "G10X6B10X6R10X62Plane420Unorm3Pack16";
    return;
  }
  if( Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16 == p ) {
    j = "G10X6B10X6R10X63Plane422Unorm3Pack16";
    return;
  }
  if( Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16 == p ) {
    j = "G10X6B10X6R10X62Plane422Unorm3Pack16";
    return;
  }
  if( Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16 == p ) {
    j = "G10X6B10X6R10X63Plane444Unorm3Pack16";
    return;
  }
  if( Format :: eR12X4UnormPack16 == p ) {
    j = "R12X4UnormPack16";
    return;
  }
  if( Format :: eR12X4G12X4Unorm2Pack16 == p ) {
    j = "R12X4G12X4Unorm2Pack16";
    return;
  }
  if( Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16 == p ) {
    j = "R12X4G12X4B12X4A12X4Unorm4Pack16";
    return;
  }
  if( Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16 == p ) {
    j = "G12X4B12X4G12X4R12X4422Unorm4Pack16";
    return;
  }
  if( Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16 == p ) {
    j = "B12X4G12X4R12X4G12X4422Unorm4Pack16";
    return;
  }
  if( Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16 == p ) {
    j = "G12X4B12X4R12X43Plane420Unorm3Pack16";
    return;
  }
  if( Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16 == p ) {
    j = "G12X4B12X4R12X42Plane420Unorm3Pack16";
    return;
  }
  if( Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16 == p ) {
    j = "G12X4B12X4R12X43Plane422Unorm3Pack16";
    return;
  }
  if( Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16 == p ) {
    j = "G12X4B12X4R12X42Plane422Unorm3Pack16";
    return;
  }
  if( Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16 == p ) {
    j = "G12X4B12X4R12X43Plane444Unorm3Pack16";
    return;
  }
  if( Format :: eG16B16G16R16422Unorm == p ) {
    j = "G16B16G16R16422Unorm";
    return;
  }
  if( Format :: eB16G16R16G16422Unorm == p ) {
    j = "B16G16R16G16422Unorm";
    return;
  }
  if( Format :: eG16B16R163Plane420Unorm == p ) {
    j = "G16B16R163Plane420Unorm";
    return;
  }
  if( Format :: eG16B16R162Plane420Unorm == p ) {
    j = "G16B16R162Plane420Unorm";
    return;
  }
  if( Format :: eG16B16R163Plane422Unorm == p ) {
    j = "G16B16R163Plane422Unorm";
    return;
  }
  if( Format :: eG16B16R162Plane422Unorm == p ) {
    j = "G16B16R162Plane422Unorm";
    return;
  }
  if( Format :: eG16B16R163Plane444Unorm == p ) {
    j = "G16B16R163Plane444Unorm";
    return;
  }
  if( Format :: ePvrtc12BppUnormBlockIMG == p ) {
    j = "Pvrtc12BppUnormBlockIMG";
    return;
  }
  if( Format :: ePvrtc14BppUnormBlockIMG == p ) {
    j = "Pvrtc14BppUnormBlockIMG";
    return;
  }
  if( Format :: ePvrtc22BppUnormBlockIMG == p ) {
    j = "Pvrtc22BppUnormBlockIMG";
    return;
  }
  if( Format :: ePvrtc24BppUnormBlockIMG == p ) {
    j = "Pvrtc24BppUnormBlockIMG";
    return;
  }
  if( Format :: ePvrtc12BppSrgbBlockIMG == p ) {
    j = "Pvrtc12BppSrgbBlockIMG";
    return;
  }
  if( Format :: ePvrtc14BppSrgbBlockIMG == p ) {
    j = "Pvrtc14BppSrgbBlockIMG";
    return;
  }
  if( Format :: ePvrtc22BppSrgbBlockIMG == p ) {
    j = "Pvrtc22BppSrgbBlockIMG";
    return;
  }
  if( Format :: ePvrtc24BppSrgbBlockIMG == p ) {
    j = "Pvrtc24BppSrgbBlockIMG";
    return;
  }
  if( Format :: eAstc4x4SfloatBlockEXT == p ) {
    j = "Astc4x4SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc5x4SfloatBlockEXT == p ) {
    j = "Astc5x4SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc5x5SfloatBlockEXT == p ) {
    j = "Astc5x5SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc6x5SfloatBlockEXT == p ) {
    j = "Astc6x5SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc6x6SfloatBlockEXT == p ) {
    j = "Astc6x6SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc8x5SfloatBlockEXT == p ) {
    j = "Astc8x5SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc8x6SfloatBlockEXT == p ) {
    j = "Astc8x6SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc8x8SfloatBlockEXT == p ) {
    j = "Astc8x8SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc10x5SfloatBlockEXT == p ) {
    j = "Astc10x5SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc10x6SfloatBlockEXT == p ) {
    j = "Astc10x6SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc10x8SfloatBlockEXT == p ) {
    j = "Astc10x8SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc10x10SfloatBlockEXT == p ) {
    j = "Astc10x10SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc12x10SfloatBlockEXT == p ) {
    j = "Astc12x10SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc12x12SfloatBlockEXT == p ) {
    j = "Astc12x12SfloatBlockEXT";
    return;
  }
  if( Format :: eG8B8R82Plane444UnormEXT == p ) {
    j = "G8B8R82Plane444UnormEXT";
    return;
  }
  if( Format :: eG10X6B10X6R10X62Plane444Unorm3Pack16EXT == p ) {
    j = "G10X6B10X6R10X62Plane444Unorm3Pack16EXT";
    return;
  }
  if( Format :: eG12X4B12X4R12X42Plane444Unorm3Pack16EXT == p ) {
    j = "G12X4B12X4R12X42Plane444Unorm3Pack16EXT";
    return;
  }
  if( Format :: eG16B16R162Plane444UnormEXT == p ) {
    j = "G16B16R162Plane444UnormEXT";
    return;
  }
  if( Format :: eA4R4G4B4UnormPack16EXT == p ) {
    j = "A4R4G4B4UnormPack16EXT";
    return;
  }
  if( Format :: eA4B4G4R4UnormPack16EXT == p ) {
    j = "A4B4G4R4UnormPack16EXT";
    return;
  }
  if( Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16KHR == p ) {
    j = "B10X6G10X6R10X6G10X6422Unorm4Pack16KHR";
    return;
  }
  if( Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16KHR == p ) {
    j = "B12X4G12X4R12X4G12X4422Unorm4Pack16KHR";
    return;
  }
  if( Format :: eB16G16R16G16422UnormKHR == p ) {
    j = "B16G16R16G16422UnormKHR";
    return;
  }
  if( Format :: eB8G8R8G8422UnormKHR == p ) {
    j = "B8G8R8G8422UnormKHR";
    return;
  }
  if( Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16KHR == p ) {
    j = "G10X6B10X6G10X6R10X6422Unorm4Pack16KHR";
    return;
  }
  if( Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16KHR == p ) {
    j = "G10X6B10X6R10X62Plane420Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16KHR == p ) {
    j = "G10X6B10X6R10X62Plane422Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16KHR == p ) {
    j = "G10X6B10X6R10X63Plane420Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16KHR == p ) {
    j = "G10X6B10X6R10X63Plane422Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16KHR == p ) {
    j = "G10X6B10X6R10X63Plane444Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16KHR == p ) {
    j = "G12X4B12X4G12X4R12X4422Unorm4Pack16KHR";
    return;
  }
  if( Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16KHR == p ) {
    j = "G12X4B12X4R12X42Plane420Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16KHR == p ) {
    j = "G12X4B12X4R12X42Plane422Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16KHR == p ) {
    j = "G12X4B12X4R12X43Plane420Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16KHR == p ) {
    j = "G12X4B12X4R12X43Plane422Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16KHR == p ) {
    j = "G12X4B12X4R12X43Plane444Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG16B16G16R16422UnormKHR == p ) {
    j = "G16B16G16R16422UnormKHR";
    return;
  }
  if( Format :: eG16B16R162Plane420UnormKHR == p ) {
    j = "G16B16R162Plane420UnormKHR";
    return;
  }
  if( Format :: eG16B16R162Plane422UnormKHR == p ) {
    j = "G16B16R162Plane422UnormKHR";
    return;
  }
  if( Format :: eG16B16R163Plane420UnormKHR == p ) {
    j = "G16B16R163Plane420UnormKHR";
    return;
  }
  if( Format :: eG16B16R163Plane422UnormKHR == p ) {
    j = "G16B16R163Plane422UnormKHR";
    return;
  }
  if( Format :: eG16B16R163Plane444UnormKHR == p ) {
    j = "G16B16R163Plane444UnormKHR";
    return;
  }
  if( Format :: eG8B8G8R8422UnormKHR == p ) {
    j = "G8B8G8R8422UnormKHR";
    return;
  }
  if( Format :: eG8B8R82Plane420UnormKHR == p ) {
    j = "G8B8R82Plane420UnormKHR";
    return;
  }
  if( Format :: eG8B8R82Plane422UnormKHR == p ) {
    j = "G8B8R82Plane422UnormKHR";
    return;
  }
  if( Format :: eG8B8R83Plane420UnormKHR == p ) {
    j = "G8B8R83Plane420UnormKHR";
    return;
  }
  if( Format :: eG8B8R83Plane422UnormKHR == p ) {
    j = "G8B8R83Plane422UnormKHR";
    return;
  }
  if( Format :: eG8B8R83Plane444UnormKHR == p ) {
    j = "G8B8R83Plane444UnormKHR";
    return;
  }
  if( Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16KHR == p ) {
    j = "R10X6G10X6B10X6A10X6Unorm4Pack16KHR";
    return;
  }
  if( Format :: eR10X6G10X6Unorm2Pack16KHR == p ) {
    j = "R10X6G10X6Unorm2Pack16KHR";
    return;
  }
  if( Format :: eR10X6UnormPack16KHR == p ) {
    j = "R10X6UnormPack16KHR";
    return;
  }
  if( Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16KHR == p ) {
    j = "R12X4G12X4B12X4A12X4Unorm4Pack16KHR";
    return;
  }
  if( Format :: eR12X4G12X4Unorm2Pack16KHR == p ) {
    j = "R12X4G12X4Unorm2Pack16KHR";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkFormat &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: Format ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, Format &p ) {
  if( j.is_string() ) {
    if( "Undefined" == j.get< std::string >() ) {
      p = Format :: eUndefined ;
      return;
    }
    if( "eUndefined" == j.get< std::string >() ) {
      p = Format :: eUndefined ;
      return;
    }
    if( "VK_FORMAT_UNDEFINED" == j.get< std::string >() ) {
      p = Format :: eUndefined ;
      return;
    }
    if( "R4G4UnormPack8" == j.get< std::string >() ) {
      p = Format :: eR4G4UnormPack8 ;
      return;
    }
    if( "eR4G4UnormPack8" == j.get< std::string >() ) {
      p = Format :: eR4G4UnormPack8 ;
      return;
    }
    if( "VK_FORMAT_R4G4_UNORM_PACK8" == j.get< std::string >() ) {
      p = Format :: eR4G4UnormPack8 ;
      return;
    }
    if( "R4G4B4A4UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR4G4B4A4UnormPack16 ;
      return;
    }
    if( "eR4G4B4A4UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR4G4B4A4UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_R4G4B4A4_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eR4G4B4A4UnormPack16 ;
      return;
    }
    if( "B4G4R4A4UnormPack16" == j.get< std::string >() ) {
      p = Format :: eB4G4R4A4UnormPack16 ;
      return;
    }
    if( "eB4G4R4A4UnormPack16" == j.get< std::string >() ) {
      p = Format :: eB4G4R4A4UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_B4G4R4A4_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eB4G4R4A4UnormPack16 ;
      return;
    }
    if( "R5G6B5UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR5G6B5UnormPack16 ;
      return;
    }
    if( "eR5G6B5UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR5G6B5UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_R5G6B5_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eR5G6B5UnormPack16 ;
      return;
    }
    if( "B5G6R5UnormPack16" == j.get< std::string >() ) {
      p = Format :: eB5G6R5UnormPack16 ;
      return;
    }
    if( "eB5G6R5UnormPack16" == j.get< std::string >() ) {
      p = Format :: eB5G6R5UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_B5G6R5_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eB5G6R5UnormPack16 ;
      return;
    }
    if( "R5G5B5A1UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR5G5B5A1UnormPack16 ;
      return;
    }
    if( "eR5G5B5A1UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR5G5B5A1UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_R5G5B5A1_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eR5G5B5A1UnormPack16 ;
      return;
    }
    if( "B5G5R5A1UnormPack16" == j.get< std::string >() ) {
      p = Format :: eB5G5R5A1UnormPack16 ;
      return;
    }
    if( "eB5G5R5A1UnormPack16" == j.get< std::string >() ) {
      p = Format :: eB5G5R5A1UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_B5G5R5A1_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eB5G5R5A1UnormPack16 ;
      return;
    }
    if( "A1R5G5B5UnormPack16" == j.get< std::string >() ) {
      p = Format :: eA1R5G5B5UnormPack16 ;
      return;
    }
    if( "eA1R5G5B5UnormPack16" == j.get< std::string >() ) {
      p = Format :: eA1R5G5B5UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_A1R5G5B5_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eA1R5G5B5UnormPack16 ;
      return;
    }
    if( "R8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8Unorm ;
      return;
    }
    if( "eR8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8Unorm ;
      return;
    }
    if( "VK_FORMAT_R8_UNORM" == j.get< std::string >() ) {
      p = Format :: eR8Unorm ;
      return;
    }
    if( "R8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8Snorm ;
      return;
    }
    if( "eR8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8Snorm ;
      return;
    }
    if( "VK_FORMAT_R8_SNORM" == j.get< std::string >() ) {
      p = Format :: eR8Snorm ;
      return;
    }
    if( "R8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8Uscaled ;
      return;
    }
    if( "eR8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8Uscaled ;
      return;
    }
    if( "VK_FORMAT_R8_USCALED" == j.get< std::string >() ) {
      p = Format :: eR8Uscaled ;
      return;
    }
    if( "R8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8Sscaled ;
      return;
    }
    if( "eR8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8Sscaled ;
      return;
    }
    if( "VK_FORMAT_R8_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR8Sscaled ;
      return;
    }
    if( "R8Uint" == j.get< std::string >() ) {
      p = Format :: eR8Uint ;
      return;
    }
    if( "eR8Uint" == j.get< std::string >() ) {
      p = Format :: eR8Uint ;
      return;
    }
    if( "VK_FORMAT_R8_UINT" == j.get< std::string >() ) {
      p = Format :: eR8Uint ;
      return;
    }
    if( "R8Sint" == j.get< std::string >() ) {
      p = Format :: eR8Sint ;
      return;
    }
    if( "eR8Sint" == j.get< std::string >() ) {
      p = Format :: eR8Sint ;
      return;
    }
    if( "VK_FORMAT_R8_SINT" == j.get< std::string >() ) {
      p = Format :: eR8Sint ;
      return;
    }
    if( "R8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8Srgb ;
      return;
    }
    if( "eR8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8Srgb ;
      return;
    }
    if( "VK_FORMAT_R8_SRGB" == j.get< std::string >() ) {
      p = Format :: eR8Srgb ;
      return;
    }
    if( "R8G8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8G8Unorm ;
      return;
    }
    if( "eR8G8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8G8Unorm ;
      return;
    }
    if( "VK_FORMAT_R8G8_UNORM" == j.get< std::string >() ) {
      p = Format :: eR8G8Unorm ;
      return;
    }
    if( "R8G8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8G8Snorm ;
      return;
    }
    if( "eR8G8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8G8Snorm ;
      return;
    }
    if( "VK_FORMAT_R8G8_SNORM" == j.get< std::string >() ) {
      p = Format :: eR8G8Snorm ;
      return;
    }
    if( "R8G8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8Uscaled ;
      return;
    }
    if( "eR8G8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8Uscaled ;
      return;
    }
    if( "VK_FORMAT_R8G8_USCALED" == j.get< std::string >() ) {
      p = Format :: eR8G8Uscaled ;
      return;
    }
    if( "R8G8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8Sscaled ;
      return;
    }
    if( "eR8G8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8Sscaled ;
      return;
    }
    if( "VK_FORMAT_R8G8_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR8G8Sscaled ;
      return;
    }
    if( "R8G8Uint" == j.get< std::string >() ) {
      p = Format :: eR8G8Uint ;
      return;
    }
    if( "eR8G8Uint" == j.get< std::string >() ) {
      p = Format :: eR8G8Uint ;
      return;
    }
    if( "VK_FORMAT_R8G8_UINT" == j.get< std::string >() ) {
      p = Format :: eR8G8Uint ;
      return;
    }
    if( "R8G8Sint" == j.get< std::string >() ) {
      p = Format :: eR8G8Sint ;
      return;
    }
    if( "eR8G8Sint" == j.get< std::string >() ) {
      p = Format :: eR8G8Sint ;
      return;
    }
    if( "VK_FORMAT_R8G8_SINT" == j.get< std::string >() ) {
      p = Format :: eR8G8Sint ;
      return;
    }
    if( "R8G8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8G8Srgb ;
      return;
    }
    if( "eR8G8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8G8Srgb ;
      return;
    }
    if( "VK_FORMAT_R8G8_SRGB" == j.get< std::string >() ) {
      p = Format :: eR8G8Srgb ;
      return;
    }
    if( "R8G8B8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Unorm ;
      return;
    }
    if( "eR8G8B8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Unorm ;
      return;
    }
    if( "VK_FORMAT_R8G8B8_UNORM" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Unorm ;
      return;
    }
    if( "R8G8B8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Snorm ;
      return;
    }
    if( "eR8G8B8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Snorm ;
      return;
    }
    if( "VK_FORMAT_R8G8B8_SNORM" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Snorm ;
      return;
    }
    if( "R8G8B8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Uscaled ;
      return;
    }
    if( "eR8G8B8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Uscaled ;
      return;
    }
    if( "VK_FORMAT_R8G8B8_USCALED" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Uscaled ;
      return;
    }
    if( "R8G8B8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Sscaled ;
      return;
    }
    if( "eR8G8B8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Sscaled ;
      return;
    }
    if( "VK_FORMAT_R8G8B8_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Sscaled ;
      return;
    }
    if( "R8G8B8Uint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Uint ;
      return;
    }
    if( "eR8G8B8Uint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Uint ;
      return;
    }
    if( "VK_FORMAT_R8G8B8_UINT" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Uint ;
      return;
    }
    if( "R8G8B8Sint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Sint ;
      return;
    }
    if( "eR8G8B8Sint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Sint ;
      return;
    }
    if( "VK_FORMAT_R8G8B8_SINT" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Sint ;
      return;
    }
    if( "R8G8B8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Srgb ;
      return;
    }
    if( "eR8G8B8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Srgb ;
      return;
    }
    if( "VK_FORMAT_R8G8B8_SRGB" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Srgb ;
      return;
    }
    if( "B8G8R8Unorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Unorm ;
      return;
    }
    if( "eB8G8R8Unorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Unorm ;
      return;
    }
    if( "VK_FORMAT_B8G8R8_UNORM" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Unorm ;
      return;
    }
    if( "B8G8R8Snorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Snorm ;
      return;
    }
    if( "eB8G8R8Snorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Snorm ;
      return;
    }
    if( "VK_FORMAT_B8G8R8_SNORM" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Snorm ;
      return;
    }
    if( "B8G8R8Uscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Uscaled ;
      return;
    }
    if( "eB8G8R8Uscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Uscaled ;
      return;
    }
    if( "VK_FORMAT_B8G8R8_USCALED" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Uscaled ;
      return;
    }
    if( "B8G8R8Sscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Sscaled ;
      return;
    }
    if( "eB8G8R8Sscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Sscaled ;
      return;
    }
    if( "VK_FORMAT_B8G8R8_SSCALED" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Sscaled ;
      return;
    }
    if( "B8G8R8Uint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Uint ;
      return;
    }
    if( "eB8G8R8Uint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Uint ;
      return;
    }
    if( "VK_FORMAT_B8G8R8_UINT" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Uint ;
      return;
    }
    if( "B8G8R8Sint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Sint ;
      return;
    }
    if( "eB8G8R8Sint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Sint ;
      return;
    }
    if( "VK_FORMAT_B8G8R8_SINT" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Sint ;
      return;
    }
    if( "B8G8R8Srgb" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Srgb ;
      return;
    }
    if( "eB8G8R8Srgb" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Srgb ;
      return;
    }
    if( "VK_FORMAT_B8G8R8_SRGB" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Srgb ;
      return;
    }
    if( "R8G8B8A8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Unorm ;
      return;
    }
    if( "eR8G8B8A8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Unorm ;
      return;
    }
    if( "VK_FORMAT_R8G8B8A8_UNORM" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Unorm ;
      return;
    }
    if( "R8G8B8A8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Snorm ;
      return;
    }
    if( "eR8G8B8A8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Snorm ;
      return;
    }
    if( "VK_FORMAT_R8G8B8A8_SNORM" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Snorm ;
      return;
    }
    if( "R8G8B8A8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Uscaled ;
      return;
    }
    if( "eR8G8B8A8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Uscaled ;
      return;
    }
    if( "VK_FORMAT_R8G8B8A8_USCALED" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Uscaled ;
      return;
    }
    if( "R8G8B8A8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Sscaled ;
      return;
    }
    if( "eR8G8B8A8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Sscaled ;
      return;
    }
    if( "VK_FORMAT_R8G8B8A8_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Sscaled ;
      return;
    }
    if( "R8G8B8A8Uint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Uint ;
      return;
    }
    if( "eR8G8B8A8Uint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Uint ;
      return;
    }
    if( "VK_FORMAT_R8G8B8A8_UINT" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Uint ;
      return;
    }
    if( "R8G8B8A8Sint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Sint ;
      return;
    }
    if( "eR8G8B8A8Sint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Sint ;
      return;
    }
    if( "VK_FORMAT_R8G8B8A8_SINT" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Sint ;
      return;
    }
    if( "R8G8B8A8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Srgb ;
      return;
    }
    if( "eR8G8B8A8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Srgb ;
      return;
    }
    if( "VK_FORMAT_R8G8B8A8_SRGB" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Srgb ;
      return;
    }
    if( "B8G8R8A8Unorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Unorm ;
      return;
    }
    if( "eB8G8R8A8Unorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Unorm ;
      return;
    }
    if( "VK_FORMAT_B8G8R8A8_UNORM" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Unorm ;
      return;
    }
    if( "B8G8R8A8Snorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Snorm ;
      return;
    }
    if( "eB8G8R8A8Snorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Snorm ;
      return;
    }
    if( "VK_FORMAT_B8G8R8A8_SNORM" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Snorm ;
      return;
    }
    if( "B8G8R8A8Uscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Uscaled ;
      return;
    }
    if( "eB8G8R8A8Uscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Uscaled ;
      return;
    }
    if( "VK_FORMAT_B8G8R8A8_USCALED" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Uscaled ;
      return;
    }
    if( "B8G8R8A8Sscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Sscaled ;
      return;
    }
    if( "eB8G8R8A8Sscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Sscaled ;
      return;
    }
    if( "VK_FORMAT_B8G8R8A8_SSCALED" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Sscaled ;
      return;
    }
    if( "B8G8R8A8Uint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Uint ;
      return;
    }
    if( "eB8G8R8A8Uint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Uint ;
      return;
    }
    if( "VK_FORMAT_B8G8R8A8_UINT" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Uint ;
      return;
    }
    if( "B8G8R8A8Sint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Sint ;
      return;
    }
    if( "eB8G8R8A8Sint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Sint ;
      return;
    }
    if( "VK_FORMAT_B8G8R8A8_SINT" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Sint ;
      return;
    }
    if( "B8G8R8A8Srgb" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Srgb ;
      return;
    }
    if( "eB8G8R8A8Srgb" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Srgb ;
      return;
    }
    if( "VK_FORMAT_B8G8R8A8_SRGB" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Srgb ;
      return;
    }
    if( "A8B8G8R8UnormPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UnormPack32 ;
      return;
    }
    if( "eA8B8G8R8UnormPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UnormPack32 ;
      return;
    }
    if( "VK_FORMAT_A8B8G8R8_UNORM_PACK32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UnormPack32 ;
      return;
    }
    if( "A8B8G8R8SnormPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SnormPack32 ;
      return;
    }
    if( "eA8B8G8R8SnormPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SnormPack32 ;
      return;
    }
    if( "VK_FORMAT_A8B8G8R8_SNORM_PACK32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SnormPack32 ;
      return;
    }
    if( "A8B8G8R8UscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UscaledPack32 ;
      return;
    }
    if( "eA8B8G8R8UscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UscaledPack32 ;
      return;
    }
    if( "VK_FORMAT_A8B8G8R8_USCALED_PACK32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UscaledPack32 ;
      return;
    }
    if( "A8B8G8R8SscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SscaledPack32 ;
      return;
    }
    if( "eA8B8G8R8SscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SscaledPack32 ;
      return;
    }
    if( "VK_FORMAT_A8B8G8R8_SSCALED_PACK32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SscaledPack32 ;
      return;
    }
    if( "A8B8G8R8UintPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UintPack32 ;
      return;
    }
    if( "eA8B8G8R8UintPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UintPack32 ;
      return;
    }
    if( "VK_FORMAT_A8B8G8R8_UINT_PACK32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UintPack32 ;
      return;
    }
    if( "A8B8G8R8SintPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SintPack32 ;
      return;
    }
    if( "eA8B8G8R8SintPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SintPack32 ;
      return;
    }
    if( "VK_FORMAT_A8B8G8R8_SINT_PACK32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SintPack32 ;
      return;
    }
    if( "A8B8G8R8SrgbPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SrgbPack32 ;
      return;
    }
    if( "eA8B8G8R8SrgbPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SrgbPack32 ;
      return;
    }
    if( "VK_FORMAT_A8B8G8R8_SRGB_PACK32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SrgbPack32 ;
      return;
    }
    if( "A2R10G10B10UnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UnormPack32 ;
      return;
    }
    if( "eA2R10G10B10UnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UnormPack32 ;
      return;
    }
    if( "VK_FORMAT_A2R10G10B10_UNORM_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UnormPack32 ;
      return;
    }
    if( "A2R10G10B10SnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SnormPack32 ;
      return;
    }
    if( "eA2R10G10B10SnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SnormPack32 ;
      return;
    }
    if( "VK_FORMAT_A2R10G10B10_SNORM_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SnormPack32 ;
      return;
    }
    if( "A2R10G10B10UscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UscaledPack32 ;
      return;
    }
    if( "eA2R10G10B10UscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UscaledPack32 ;
      return;
    }
    if( "VK_FORMAT_A2R10G10B10_USCALED_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UscaledPack32 ;
      return;
    }
    if( "A2R10G10B10SscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SscaledPack32 ;
      return;
    }
    if( "eA2R10G10B10SscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SscaledPack32 ;
      return;
    }
    if( "VK_FORMAT_A2R10G10B10_SSCALED_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SscaledPack32 ;
      return;
    }
    if( "A2R10G10B10UintPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UintPack32 ;
      return;
    }
    if( "eA2R10G10B10UintPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UintPack32 ;
      return;
    }
    if( "VK_FORMAT_A2R10G10B10_UINT_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UintPack32 ;
      return;
    }
    if( "A2R10G10B10SintPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SintPack32 ;
      return;
    }
    if( "eA2R10G10B10SintPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SintPack32 ;
      return;
    }
    if( "VK_FORMAT_A2R10G10B10_SINT_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SintPack32 ;
      return;
    }
    if( "A2B10G10R10UnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UnormPack32 ;
      return;
    }
    if( "eA2B10G10R10UnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UnormPack32 ;
      return;
    }
    if( "VK_FORMAT_A2B10G10R10_UNORM_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UnormPack32 ;
      return;
    }
    if( "A2B10G10R10SnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SnormPack32 ;
      return;
    }
    if( "eA2B10G10R10SnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SnormPack32 ;
      return;
    }
    if( "VK_FORMAT_A2B10G10R10_SNORM_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SnormPack32 ;
      return;
    }
    if( "A2B10G10R10UscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UscaledPack32 ;
      return;
    }
    if( "eA2B10G10R10UscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UscaledPack32 ;
      return;
    }
    if( "VK_FORMAT_A2B10G10R10_USCALED_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UscaledPack32 ;
      return;
    }
    if( "A2B10G10R10SscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SscaledPack32 ;
      return;
    }
    if( "eA2B10G10R10SscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SscaledPack32 ;
      return;
    }
    if( "VK_FORMAT_A2B10G10R10_SSCALED_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SscaledPack32 ;
      return;
    }
    if( "A2B10G10R10UintPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UintPack32 ;
      return;
    }
    if( "eA2B10G10R10UintPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UintPack32 ;
      return;
    }
    if( "VK_FORMAT_A2B10G10R10_UINT_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UintPack32 ;
      return;
    }
    if( "A2B10G10R10SintPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SintPack32 ;
      return;
    }
    if( "eA2B10G10R10SintPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SintPack32 ;
      return;
    }
    if( "VK_FORMAT_A2B10G10R10_SINT_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SintPack32 ;
      return;
    }
    if( "R16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16Unorm ;
      return;
    }
    if( "eR16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16Unorm ;
      return;
    }
    if( "VK_FORMAT_R16_UNORM" == j.get< std::string >() ) {
      p = Format :: eR16Unorm ;
      return;
    }
    if( "R16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16Snorm ;
      return;
    }
    if( "eR16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16Snorm ;
      return;
    }
    if( "VK_FORMAT_R16_SNORM" == j.get< std::string >() ) {
      p = Format :: eR16Snorm ;
      return;
    }
    if( "R16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16Uscaled ;
      return;
    }
    if( "eR16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16Uscaled ;
      return;
    }
    if( "VK_FORMAT_R16_USCALED" == j.get< std::string >() ) {
      p = Format :: eR16Uscaled ;
      return;
    }
    if( "R16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16Sscaled ;
      return;
    }
    if( "eR16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16Sscaled ;
      return;
    }
    if( "VK_FORMAT_R16_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR16Sscaled ;
      return;
    }
    if( "R16Uint" == j.get< std::string >() ) {
      p = Format :: eR16Uint ;
      return;
    }
    if( "eR16Uint" == j.get< std::string >() ) {
      p = Format :: eR16Uint ;
      return;
    }
    if( "VK_FORMAT_R16_UINT" == j.get< std::string >() ) {
      p = Format :: eR16Uint ;
      return;
    }
    if( "R16Sint" == j.get< std::string >() ) {
      p = Format :: eR16Sint ;
      return;
    }
    if( "eR16Sint" == j.get< std::string >() ) {
      p = Format :: eR16Sint ;
      return;
    }
    if( "VK_FORMAT_R16_SINT" == j.get< std::string >() ) {
      p = Format :: eR16Sint ;
      return;
    }
    if( "R16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16Sfloat ;
      return;
    }
    if( "eR16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16Sfloat ;
      return;
    }
    if( "VK_FORMAT_R16_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR16Sfloat ;
      return;
    }
    if( "R16G16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16G16Unorm ;
      return;
    }
    if( "eR16G16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16G16Unorm ;
      return;
    }
    if( "VK_FORMAT_R16G16_UNORM" == j.get< std::string >() ) {
      p = Format :: eR16G16Unorm ;
      return;
    }
    if( "R16G16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16G16Snorm ;
      return;
    }
    if( "eR16G16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16G16Snorm ;
      return;
    }
    if( "VK_FORMAT_R16G16_SNORM" == j.get< std::string >() ) {
      p = Format :: eR16G16Snorm ;
      return;
    }
    if( "R16G16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16Uscaled ;
      return;
    }
    if( "eR16G16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16Uscaled ;
      return;
    }
    if( "VK_FORMAT_R16G16_USCALED" == j.get< std::string >() ) {
      p = Format :: eR16G16Uscaled ;
      return;
    }
    if( "R16G16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16Sscaled ;
      return;
    }
    if( "eR16G16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16Sscaled ;
      return;
    }
    if( "VK_FORMAT_R16G16_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR16G16Sscaled ;
      return;
    }
    if( "R16G16Uint" == j.get< std::string >() ) {
      p = Format :: eR16G16Uint ;
      return;
    }
    if( "eR16G16Uint" == j.get< std::string >() ) {
      p = Format :: eR16G16Uint ;
      return;
    }
    if( "VK_FORMAT_R16G16_UINT" == j.get< std::string >() ) {
      p = Format :: eR16G16Uint ;
      return;
    }
    if( "R16G16Sint" == j.get< std::string >() ) {
      p = Format :: eR16G16Sint ;
      return;
    }
    if( "eR16G16Sint" == j.get< std::string >() ) {
      p = Format :: eR16G16Sint ;
      return;
    }
    if( "VK_FORMAT_R16G16_SINT" == j.get< std::string >() ) {
      p = Format :: eR16G16Sint ;
      return;
    }
    if( "R16G16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16G16Sfloat ;
      return;
    }
    if( "eR16G16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16G16Sfloat ;
      return;
    }
    if( "VK_FORMAT_R16G16_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR16G16Sfloat ;
      return;
    }
    if( "R16G16B16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Unorm ;
      return;
    }
    if( "eR16G16B16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Unorm ;
      return;
    }
    if( "VK_FORMAT_R16G16B16_UNORM" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Unorm ;
      return;
    }
    if( "R16G16B16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Snorm ;
      return;
    }
    if( "eR16G16B16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Snorm ;
      return;
    }
    if( "VK_FORMAT_R16G16B16_SNORM" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Snorm ;
      return;
    }
    if( "R16G16B16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Uscaled ;
      return;
    }
    if( "eR16G16B16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Uscaled ;
      return;
    }
    if( "VK_FORMAT_R16G16B16_USCALED" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Uscaled ;
      return;
    }
    if( "R16G16B16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sscaled ;
      return;
    }
    if( "eR16G16B16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sscaled ;
      return;
    }
    if( "VK_FORMAT_R16G16B16_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sscaled ;
      return;
    }
    if( "R16G16B16Uint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Uint ;
      return;
    }
    if( "eR16G16B16Uint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Uint ;
      return;
    }
    if( "VK_FORMAT_R16G16B16_UINT" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Uint ;
      return;
    }
    if( "R16G16B16Sint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sint ;
      return;
    }
    if( "eR16G16B16Sint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sint ;
      return;
    }
    if( "VK_FORMAT_R16G16B16_SINT" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sint ;
      return;
    }
    if( "R16G16B16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sfloat ;
      return;
    }
    if( "eR16G16B16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sfloat ;
      return;
    }
    if( "VK_FORMAT_R16G16B16_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sfloat ;
      return;
    }
    if( "R16G16B16A16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Unorm ;
      return;
    }
    if( "eR16G16B16A16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Unorm ;
      return;
    }
    if( "VK_FORMAT_R16G16B16A16_UNORM" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Unorm ;
      return;
    }
    if( "R16G16B16A16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Snorm ;
      return;
    }
    if( "eR16G16B16A16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Snorm ;
      return;
    }
    if( "VK_FORMAT_R16G16B16A16_SNORM" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Snorm ;
      return;
    }
    if( "R16G16B16A16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Uscaled ;
      return;
    }
    if( "eR16G16B16A16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Uscaled ;
      return;
    }
    if( "VK_FORMAT_R16G16B16A16_USCALED" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Uscaled ;
      return;
    }
    if( "R16G16B16A16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sscaled ;
      return;
    }
    if( "eR16G16B16A16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sscaled ;
      return;
    }
    if( "VK_FORMAT_R16G16B16A16_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sscaled ;
      return;
    }
    if( "R16G16B16A16Uint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Uint ;
      return;
    }
    if( "eR16G16B16A16Uint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Uint ;
      return;
    }
    if( "VK_FORMAT_R16G16B16A16_UINT" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Uint ;
      return;
    }
    if( "R16G16B16A16Sint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sint ;
      return;
    }
    if( "eR16G16B16A16Sint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sint ;
      return;
    }
    if( "VK_FORMAT_R16G16B16A16_SINT" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sint ;
      return;
    }
    if( "R16G16B16A16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sfloat ;
      return;
    }
    if( "eR16G16B16A16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sfloat ;
      return;
    }
    if( "VK_FORMAT_R16G16B16A16_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sfloat ;
      return;
    }
    if( "R32Uint" == j.get< std::string >() ) {
      p = Format :: eR32Uint ;
      return;
    }
    if( "eR32Uint" == j.get< std::string >() ) {
      p = Format :: eR32Uint ;
      return;
    }
    if( "VK_FORMAT_R32_UINT" == j.get< std::string >() ) {
      p = Format :: eR32Uint ;
      return;
    }
    if( "R32Sint" == j.get< std::string >() ) {
      p = Format :: eR32Sint ;
      return;
    }
    if( "eR32Sint" == j.get< std::string >() ) {
      p = Format :: eR32Sint ;
      return;
    }
    if( "VK_FORMAT_R32_SINT" == j.get< std::string >() ) {
      p = Format :: eR32Sint ;
      return;
    }
    if( "R32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32Sfloat ;
      return;
    }
    if( "eR32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32Sfloat ;
      return;
    }
    if( "VK_FORMAT_R32_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR32Sfloat ;
      return;
    }
    if( "R32G32Uint" == j.get< std::string >() ) {
      p = Format :: eR32G32Uint ;
      return;
    }
    if( "eR32G32Uint" == j.get< std::string >() ) {
      p = Format :: eR32G32Uint ;
      return;
    }
    if( "VK_FORMAT_R32G32_UINT" == j.get< std::string >() ) {
      p = Format :: eR32G32Uint ;
      return;
    }
    if( "R32G32Sint" == j.get< std::string >() ) {
      p = Format :: eR32G32Sint ;
      return;
    }
    if( "eR32G32Sint" == j.get< std::string >() ) {
      p = Format :: eR32G32Sint ;
      return;
    }
    if( "VK_FORMAT_R32G32_SINT" == j.get< std::string >() ) {
      p = Format :: eR32G32Sint ;
      return;
    }
    if( "R32G32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32G32Sfloat ;
      return;
    }
    if( "eR32G32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32G32Sfloat ;
      return;
    }
    if( "VK_FORMAT_R32G32_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR32G32Sfloat ;
      return;
    }
    if( "R32G32B32Uint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Uint ;
      return;
    }
    if( "eR32G32B32Uint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Uint ;
      return;
    }
    if( "VK_FORMAT_R32G32B32_UINT" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Uint ;
      return;
    }
    if( "R32G32B32Sint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Sint ;
      return;
    }
    if( "eR32G32B32Sint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Sint ;
      return;
    }
    if( "VK_FORMAT_R32G32B32_SINT" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Sint ;
      return;
    }
    if( "R32G32B32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Sfloat ;
      return;
    }
    if( "eR32G32B32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Sfloat ;
      return;
    }
    if( "VK_FORMAT_R32G32B32_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Sfloat ;
      return;
    }
    if( "R32G32B32A32Uint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Uint ;
      return;
    }
    if( "eR32G32B32A32Uint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Uint ;
      return;
    }
    if( "VK_FORMAT_R32G32B32A32_UINT" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Uint ;
      return;
    }
    if( "R32G32B32A32Sint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Sint ;
      return;
    }
    if( "eR32G32B32A32Sint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Sint ;
      return;
    }
    if( "VK_FORMAT_R32G32B32A32_SINT" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Sint ;
      return;
    }
    if( "R32G32B32A32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Sfloat ;
      return;
    }
    if( "eR32G32B32A32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Sfloat ;
      return;
    }
    if( "VK_FORMAT_R32G32B32A32_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Sfloat ;
      return;
    }
    if( "R64Uint" == j.get< std::string >() ) {
      p = Format :: eR64Uint ;
      return;
    }
    if( "eR64Uint" == j.get< std::string >() ) {
      p = Format :: eR64Uint ;
      return;
    }
    if( "VK_FORMAT_R64_UINT" == j.get< std::string >() ) {
      p = Format :: eR64Uint ;
      return;
    }
    if( "R64Sint" == j.get< std::string >() ) {
      p = Format :: eR64Sint ;
      return;
    }
    if( "eR64Sint" == j.get< std::string >() ) {
      p = Format :: eR64Sint ;
      return;
    }
    if( "VK_FORMAT_R64_SINT" == j.get< std::string >() ) {
      p = Format :: eR64Sint ;
      return;
    }
    if( "R64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64Sfloat ;
      return;
    }
    if( "eR64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64Sfloat ;
      return;
    }
    if( "VK_FORMAT_R64_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR64Sfloat ;
      return;
    }
    if( "R64G64Uint" == j.get< std::string >() ) {
      p = Format :: eR64G64Uint ;
      return;
    }
    if( "eR64G64Uint" == j.get< std::string >() ) {
      p = Format :: eR64G64Uint ;
      return;
    }
    if( "VK_FORMAT_R64G64_UINT" == j.get< std::string >() ) {
      p = Format :: eR64G64Uint ;
      return;
    }
    if( "R64G64Sint" == j.get< std::string >() ) {
      p = Format :: eR64G64Sint ;
      return;
    }
    if( "eR64G64Sint" == j.get< std::string >() ) {
      p = Format :: eR64G64Sint ;
      return;
    }
    if( "VK_FORMAT_R64G64_SINT" == j.get< std::string >() ) {
      p = Format :: eR64G64Sint ;
      return;
    }
    if( "R64G64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64G64Sfloat ;
      return;
    }
    if( "eR64G64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64G64Sfloat ;
      return;
    }
    if( "VK_FORMAT_R64G64_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR64G64Sfloat ;
      return;
    }
    if( "R64G64B64Uint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Uint ;
      return;
    }
    if( "eR64G64B64Uint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Uint ;
      return;
    }
    if( "VK_FORMAT_R64G64B64_UINT" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Uint ;
      return;
    }
    if( "R64G64B64Sint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Sint ;
      return;
    }
    if( "eR64G64B64Sint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Sint ;
      return;
    }
    if( "VK_FORMAT_R64G64B64_SINT" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Sint ;
      return;
    }
    if( "R64G64B64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Sfloat ;
      return;
    }
    if( "eR64G64B64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Sfloat ;
      return;
    }
    if( "VK_FORMAT_R64G64B64_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Sfloat ;
      return;
    }
    if( "R64G64B64A64Uint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Uint ;
      return;
    }
    if( "eR64G64B64A64Uint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Uint ;
      return;
    }
    if( "VK_FORMAT_R64G64B64A64_UINT" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Uint ;
      return;
    }
    if( "R64G64B64A64Sint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Sint ;
      return;
    }
    if( "eR64G64B64A64Sint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Sint ;
      return;
    }
    if( "VK_FORMAT_R64G64B64A64_SINT" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Sint ;
      return;
    }
    if( "R64G64B64A64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Sfloat ;
      return;
    }
    if( "eR64G64B64A64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Sfloat ;
      return;
    }
    if( "VK_FORMAT_R64G64B64A64_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Sfloat ;
      return;
    }
    if( "B10G11R11UfloatPack32" == j.get< std::string >() ) {
      p = Format :: eB10G11R11UfloatPack32 ;
      return;
    }
    if( "eB10G11R11UfloatPack32" == j.get< std::string >() ) {
      p = Format :: eB10G11R11UfloatPack32 ;
      return;
    }
    if( "VK_FORMAT_B10G11R11_UFLOAT_PACK32" == j.get< std::string >() ) {
      p = Format :: eB10G11R11UfloatPack32 ;
      return;
    }
    if( "E5B9G9R9UfloatPack32" == j.get< std::string >() ) {
      p = Format :: eE5B9G9R9UfloatPack32 ;
      return;
    }
    if( "eE5B9G9R9UfloatPack32" == j.get< std::string >() ) {
      p = Format :: eE5B9G9R9UfloatPack32 ;
      return;
    }
    if( "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32" == j.get< std::string >() ) {
      p = Format :: eE5B9G9R9UfloatPack32 ;
      return;
    }
    if( "D16Unorm" == j.get< std::string >() ) {
      p = Format :: eD16Unorm ;
      return;
    }
    if( "eD16Unorm" == j.get< std::string >() ) {
      p = Format :: eD16Unorm ;
      return;
    }
    if( "VK_FORMAT_D16_UNORM" == j.get< std::string >() ) {
      p = Format :: eD16Unorm ;
      return;
    }
    if( "X8D24UnormPack32" == j.get< std::string >() ) {
      p = Format :: eX8D24UnormPack32 ;
      return;
    }
    if( "eX8D24UnormPack32" == j.get< std::string >() ) {
      p = Format :: eX8D24UnormPack32 ;
      return;
    }
    if( "VK_FORMAT_X8_D24_UNORM_PACK32" == j.get< std::string >() ) {
      p = Format :: eX8D24UnormPack32 ;
      return;
    }
    if( "D32Sfloat" == j.get< std::string >() ) {
      p = Format :: eD32Sfloat ;
      return;
    }
    if( "eD32Sfloat" == j.get< std::string >() ) {
      p = Format :: eD32Sfloat ;
      return;
    }
    if( "VK_FORMAT_D32_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eD32Sfloat ;
      return;
    }
    if( "S8Uint" == j.get< std::string >() ) {
      p = Format :: eS8Uint ;
      return;
    }
    if( "eS8Uint" == j.get< std::string >() ) {
      p = Format :: eS8Uint ;
      return;
    }
    if( "VK_FORMAT_S8_UINT" == j.get< std::string >() ) {
      p = Format :: eS8Uint ;
      return;
    }
    if( "D16UnormS8Uint" == j.get< std::string >() ) {
      p = Format :: eD16UnormS8Uint ;
      return;
    }
    if( "eD16UnormS8Uint" == j.get< std::string >() ) {
      p = Format :: eD16UnormS8Uint ;
      return;
    }
    if( "VK_FORMAT_D16_UNORM_S8_UINT" == j.get< std::string >() ) {
      p = Format :: eD16UnormS8Uint ;
      return;
    }
    if( "D24UnormS8Uint" == j.get< std::string >() ) {
      p = Format :: eD24UnormS8Uint ;
      return;
    }
    if( "eD24UnormS8Uint" == j.get< std::string >() ) {
      p = Format :: eD24UnormS8Uint ;
      return;
    }
    if( "VK_FORMAT_D24_UNORM_S8_UINT" == j.get< std::string >() ) {
      p = Format :: eD24UnormS8Uint ;
      return;
    }
    if( "D32SfloatS8Uint" == j.get< std::string >() ) {
      p = Format :: eD32SfloatS8Uint ;
      return;
    }
    if( "eD32SfloatS8Uint" == j.get< std::string >() ) {
      p = Format :: eD32SfloatS8Uint ;
      return;
    }
    if( "VK_FORMAT_D32_SFLOAT_S8_UINT" == j.get< std::string >() ) {
      p = Format :: eD32SfloatS8Uint ;
      return;
    }
    if( "Bc1RgbUnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbUnormBlock ;
      return;
    }
    if( "eBc1RgbUnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbUnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC1_RGB_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc1RgbUnormBlock ;
      return;
    }
    if( "Bc1RgbSrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbSrgbBlock ;
      return;
    }
    if( "eBc1RgbSrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbSrgbBlock ;
      return;
    }
    if( "VK_FORMAT_BC1_RGB_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc1RgbSrgbBlock ;
      return;
    }
    if( "Bc1RgbaUnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbaUnormBlock ;
      return;
    }
    if( "eBc1RgbaUnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbaUnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC1_RGBA_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc1RgbaUnormBlock ;
      return;
    }
    if( "Bc1RgbaSrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbaSrgbBlock ;
      return;
    }
    if( "eBc1RgbaSrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbaSrgbBlock ;
      return;
    }
    if( "VK_FORMAT_BC1_RGBA_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc1RgbaSrgbBlock ;
      return;
    }
    if( "Bc2UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc2UnormBlock ;
      return;
    }
    if( "eBc2UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc2UnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC2_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc2UnormBlock ;
      return;
    }
    if( "Bc2SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc2SrgbBlock ;
      return;
    }
    if( "eBc2SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc2SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_BC2_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc2SrgbBlock ;
      return;
    }
    if( "Bc3UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc3UnormBlock ;
      return;
    }
    if( "eBc3UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc3UnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC3_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc3UnormBlock ;
      return;
    }
    if( "Bc3SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc3SrgbBlock ;
      return;
    }
    if( "eBc3SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc3SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_BC3_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc3SrgbBlock ;
      return;
    }
    if( "Bc4UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc4UnormBlock ;
      return;
    }
    if( "eBc4UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc4UnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC4_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc4UnormBlock ;
      return;
    }
    if( "Bc4SnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc4SnormBlock ;
      return;
    }
    if( "eBc4SnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc4SnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC4_SNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc4SnormBlock ;
      return;
    }
    if( "Bc5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc5UnormBlock ;
      return;
    }
    if( "eBc5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc5UnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC5_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc5UnormBlock ;
      return;
    }
    if( "Bc5SnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc5SnormBlock ;
      return;
    }
    if( "eBc5SnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc5SnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC5_SNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc5SnormBlock ;
      return;
    }
    if( "Bc6HUfloatBlock" == j.get< std::string >() ) {
      p = Format :: eBc6HUfloatBlock ;
      return;
    }
    if( "eBc6HUfloatBlock" == j.get< std::string >() ) {
      p = Format :: eBc6HUfloatBlock ;
      return;
    }
    if( "VK_FORMAT_BC6H_UFLOAT_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc6HUfloatBlock ;
      return;
    }
    if( "Bc6HSfloatBlock" == j.get< std::string >() ) {
      p = Format :: eBc6HSfloatBlock ;
      return;
    }
    if( "eBc6HSfloatBlock" == j.get< std::string >() ) {
      p = Format :: eBc6HSfloatBlock ;
      return;
    }
    if( "VK_FORMAT_BC6H_SFLOAT_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc6HSfloatBlock ;
      return;
    }
    if( "Bc7UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc7UnormBlock ;
      return;
    }
    if( "eBc7UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc7UnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC7_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc7UnormBlock ;
      return;
    }
    if( "Bc7SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc7SrgbBlock ;
      return;
    }
    if( "eBc7SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc7SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_BC7_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc7SrgbBlock ;
      return;
    }
    if( "Etc2R8G8B8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8UnormBlock ;
      return;
    }
    if( "eEtc2R8G8B8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8UnormBlock ;
      return;
    }
    if( "Etc2R8G8B8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8SrgbBlock ;
      return;
    }
    if( "eEtc2R8G8B8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8SrgbBlock ;
      return;
    }
    if( "Etc2R8G8B8A1UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A1UnormBlock ;
      return;
    }
    if( "eEtc2R8G8B8A1UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A1UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A1UnormBlock ;
      return;
    }
    if( "Etc2R8G8B8A1SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A1SrgbBlock ;
      return;
    }
    if( "eEtc2R8G8B8A1SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A1SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A1SrgbBlock ;
      return;
    }
    if( "Etc2R8G8B8A8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A8UnormBlock ;
      return;
    }
    if( "eEtc2R8G8B8A8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A8UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A8UnormBlock ;
      return;
    }
    if( "Etc2R8G8B8A8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A8SrgbBlock ;
      return;
    }
    if( "eEtc2R8G8B8A8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A8SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A8SrgbBlock ;
      return;
    }
    if( "EacR11UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11UnormBlock ;
      return;
    }
    if( "eEacR11UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11UnormBlock ;
      return;
    }
    if( "VK_FORMAT_EAC_R11_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEacR11UnormBlock ;
      return;
    }
    if( "EacR11SnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11SnormBlock ;
      return;
    }
    if( "eEacR11SnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11SnormBlock ;
      return;
    }
    if( "VK_FORMAT_EAC_R11_SNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEacR11SnormBlock ;
      return;
    }
    if( "EacR11G11UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11G11UnormBlock ;
      return;
    }
    if( "eEacR11G11UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11G11UnormBlock ;
      return;
    }
    if( "VK_FORMAT_EAC_R11G11_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEacR11G11UnormBlock ;
      return;
    }
    if( "EacR11G11SnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11G11SnormBlock ;
      return;
    }
    if( "eEacR11G11SnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11G11SnormBlock ;
      return;
    }
    if( "VK_FORMAT_EAC_R11G11_SNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEacR11G11SnormBlock ;
      return;
    }
    if( "Astc4x4UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc4x4UnormBlock ;
      return;
    }
    if( "eAstc4x4UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc4x4UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_4x4_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc4x4UnormBlock ;
      return;
    }
    if( "Astc4x4SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc4x4SrgbBlock ;
      return;
    }
    if( "eAstc4x4SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc4x4SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_4x4_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc4x4SrgbBlock ;
      return;
    }
    if( "Astc5x4UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x4UnormBlock ;
      return;
    }
    if( "eAstc5x4UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x4UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_5x4_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc5x4UnormBlock ;
      return;
    }
    if( "Astc5x4SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x4SrgbBlock ;
      return;
    }
    if( "eAstc5x4SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x4SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_5x4_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc5x4SrgbBlock ;
      return;
    }
    if( "Astc5x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x5UnormBlock ;
      return;
    }
    if( "eAstc5x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x5UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_5x5_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc5x5UnormBlock ;
      return;
    }
    if( "Astc5x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x5SrgbBlock ;
      return;
    }
    if( "eAstc5x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x5SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_5x5_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc5x5SrgbBlock ;
      return;
    }
    if( "Astc6x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x5UnormBlock ;
      return;
    }
    if( "eAstc6x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x5UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_6x5_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc6x5UnormBlock ;
      return;
    }
    if( "Astc6x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x5SrgbBlock ;
      return;
    }
    if( "eAstc6x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x5SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_6x5_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc6x5SrgbBlock ;
      return;
    }
    if( "Astc6x6UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x6UnormBlock ;
      return;
    }
    if( "eAstc6x6UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x6UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_6x6_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc6x6UnormBlock ;
      return;
    }
    if( "Astc6x6SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x6SrgbBlock ;
      return;
    }
    if( "eAstc6x6SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x6SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_6x6_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc6x6SrgbBlock ;
      return;
    }
    if( "Astc8x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x5UnormBlock ;
      return;
    }
    if( "eAstc8x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x5UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x5_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc8x5UnormBlock ;
      return;
    }
    if( "Astc8x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x5SrgbBlock ;
      return;
    }
    if( "eAstc8x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x5SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x5_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc8x5SrgbBlock ;
      return;
    }
    if( "Astc8x6UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x6UnormBlock ;
      return;
    }
    if( "eAstc8x6UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x6UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x6_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc8x6UnormBlock ;
      return;
    }
    if( "Astc8x6SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x6SrgbBlock ;
      return;
    }
    if( "eAstc8x6SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x6SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x6_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc8x6SrgbBlock ;
      return;
    }
    if( "Astc8x8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x8UnormBlock ;
      return;
    }
    if( "eAstc8x8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x8UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x8_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc8x8UnormBlock ;
      return;
    }
    if( "Astc8x8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x8SrgbBlock ;
      return;
    }
    if( "eAstc8x8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x8SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x8_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc8x8SrgbBlock ;
      return;
    }
    if( "Astc10x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x5UnormBlock ;
      return;
    }
    if( "eAstc10x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x5UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x5_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x5UnormBlock ;
      return;
    }
    if( "Astc10x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x5SrgbBlock ;
      return;
    }
    if( "eAstc10x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x5SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x5_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x5SrgbBlock ;
      return;
    }
    if( "Astc10x6UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x6UnormBlock ;
      return;
    }
    if( "eAstc10x6UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x6UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x6_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x6UnormBlock ;
      return;
    }
    if( "Astc10x6SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x6SrgbBlock ;
      return;
    }
    if( "eAstc10x6SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x6SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x6_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x6SrgbBlock ;
      return;
    }
    if( "Astc10x8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x8UnormBlock ;
      return;
    }
    if( "eAstc10x8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x8UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x8_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x8UnormBlock ;
      return;
    }
    if( "Astc10x8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x8SrgbBlock ;
      return;
    }
    if( "eAstc10x8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x8SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x8_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x8SrgbBlock ;
      return;
    }
    if( "Astc10x10UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x10UnormBlock ;
      return;
    }
    if( "eAstc10x10UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x10UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x10_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x10UnormBlock ;
      return;
    }
    if( "Astc10x10SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x10SrgbBlock ;
      return;
    }
    if( "eAstc10x10SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x10SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x10_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x10SrgbBlock ;
      return;
    }
    if( "Astc12x10UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x10UnormBlock ;
      return;
    }
    if( "eAstc12x10UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x10UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_12x10_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc12x10UnormBlock ;
      return;
    }
    if( "Astc12x10SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x10SrgbBlock ;
      return;
    }
    if( "eAstc12x10SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x10SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_12x10_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc12x10SrgbBlock ;
      return;
    }
    if( "Astc12x12UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x12UnormBlock ;
      return;
    }
    if( "eAstc12x12UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x12UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_12x12_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc12x12UnormBlock ;
      return;
    }
    if( "Astc12x12SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x12SrgbBlock ;
      return;
    }
    if( "eAstc12x12SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x12SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_12x12_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc12x12SrgbBlock ;
      return;
    }
    if( "G8B8G8R8422Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8G8R8422Unorm ;
      return;
    }
    if( "eG8B8G8R8422Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8G8R8422Unorm ;
      return;
    }
    if( "VK_FORMAT_G8B8G8R8_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eG8B8G8R8422Unorm ;
      return;
    }
    if( "B8G8R8G8422Unorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8G8422Unorm ;
      return;
    }
    if( "eB8G8R8G8422Unorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8G8422Unorm ;
      return;
    }
    if( "VK_FORMAT_B8G8R8G8_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eB8G8R8G8422Unorm ;
      return;
    }
    if( "G8B8R83Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane420Unorm ;
      return;
    }
    if( "eG8B8R83Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane420Unorm ;
      return;
    }
    if( "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane420Unorm ;
      return;
    }
    if( "G8B8R82Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane420Unorm ;
      return;
    }
    if( "eG8B8R82Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane420Unorm ;
      return;
    }
    if( "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane420Unorm ;
      return;
    }
    if( "G8B8R83Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane422Unorm ;
      return;
    }
    if( "eG8B8R83Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane422Unorm ;
      return;
    }
    if( "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane422Unorm ;
      return;
    }
    if( "G8B8R82Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane422Unorm ;
      return;
    }
    if( "eG8B8R82Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane422Unorm ;
      return;
    }
    if( "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane422Unorm ;
      return;
    }
    if( "G8B8R83Plane444Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane444Unorm ;
      return;
    }
    if( "eG8B8R83Plane444Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane444Unorm ;
      return;
    }
    if( "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane444Unorm ;
      return;
    }
    if( "R10X6UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR10X6UnormPack16 ;
      return;
    }
    if( "eR10X6UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR10X6UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_R10X6_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eR10X6UnormPack16 ;
      return;
    }
    if( "R10X6G10X6Unorm2Pack16" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6Unorm2Pack16 ;
      return;
    }
    if( "eR10X6G10X6Unorm2Pack16" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6Unorm2Pack16 ;
      return;
    }
    if( "VK_FORMAT_R10X6G10X6_UNORM_2PACK16" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6Unorm2Pack16 ;
      return;
    }
    if( "R10X6G10X6B10X6A10X6Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16 ;
      return;
    }
    if( "eR10X6G10X6B10X6A10X6Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16 ;
      return;
    }
    if( "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16 ;
      return;
    }
    if( "G10X6B10X6G10X6R10X6422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16 ;
      return;
    }
    if( "eG10X6B10X6G10X6R10X6422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16 ;
      return;
    }
    if( "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16 ;
      return;
    }
    if( "B10X6G10X6R10X6G10X6422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16 ;
      return;
    }
    if( "eB10X6G10X6R10X6G10X6422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16 ;
      return;
    }
    if( "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16" == j.get< std::string >() ) {
      p = Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16 ;
      return;
    }
    if( "G10X6B10X6R10X63Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16 ;
      return;
    }
    if( "eG10X6B10X6R10X63Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16 ;
      return;
    }
    if( "G10X6B10X6R10X62Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16 ;
      return;
    }
    if( "eG10X6B10X6R10X62Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16 ;
      return;
    }
    if( "G10X6B10X6R10X63Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16 ;
      return;
    }
    if( "eG10X6B10X6R10X63Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16 ;
      return;
    }
    if( "G10X6B10X6R10X62Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16 ;
      return;
    }
    if( "eG10X6B10X6R10X62Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16 ;
      return;
    }
    if( "G10X6B10X6R10X63Plane444Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16 ;
      return;
    }
    if( "eG10X6B10X6R10X63Plane444Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16 ;
      return;
    }
    if( "R12X4UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR12X4UnormPack16 ;
      return;
    }
    if( "eR12X4UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR12X4UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_R12X4_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eR12X4UnormPack16 ;
      return;
    }
    if( "R12X4G12X4Unorm2Pack16" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4Unorm2Pack16 ;
      return;
    }
    if( "eR12X4G12X4Unorm2Pack16" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4Unorm2Pack16 ;
      return;
    }
    if( "VK_FORMAT_R12X4G12X4_UNORM_2PACK16" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4Unorm2Pack16 ;
      return;
    }
    if( "R12X4G12X4B12X4A12X4Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16 ;
      return;
    }
    if( "eR12X4G12X4B12X4A12X4Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16 ;
      return;
    }
    if( "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16 ;
      return;
    }
    if( "G12X4B12X4G12X4R12X4422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16 ;
      return;
    }
    if( "eG12X4B12X4G12X4R12X4422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16 ;
      return;
    }
    if( "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16 ;
      return;
    }
    if( "B12X4G12X4R12X4G12X4422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16 ;
      return;
    }
    if( "eB12X4G12X4R12X4G12X4422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16 ;
      return;
    }
    if( "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16" == j.get< std::string >() ) {
      p = Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16 ;
      return;
    }
    if( "G12X4B12X4R12X43Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16 ;
      return;
    }
    if( "eG12X4B12X4R12X43Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16 ;
      return;
    }
    if( "G12X4B12X4R12X42Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16 ;
      return;
    }
    if( "eG12X4B12X4R12X42Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16 ;
      return;
    }
    if( "G12X4B12X4R12X43Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16 ;
      return;
    }
    if( "eG12X4B12X4R12X43Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16 ;
      return;
    }
    if( "G12X4B12X4R12X42Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16 ;
      return;
    }
    if( "eG12X4B12X4R12X42Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16 ;
      return;
    }
    if( "G12X4B12X4R12X43Plane444Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16 ;
      return;
    }
    if( "eG12X4B12X4R12X43Plane444Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16 ;
      return;
    }
    if( "G16B16G16R16422Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16G16R16422Unorm ;
      return;
    }
    if( "eG16B16G16R16422Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16G16R16422Unorm ;
      return;
    }
    if( "VK_FORMAT_G16B16G16R16_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eG16B16G16R16422Unorm ;
      return;
    }
    if( "B16G16R16G16422Unorm" == j.get< std::string >() ) {
      p = Format :: eB16G16R16G16422Unorm ;
      return;
    }
    if( "eB16G16R16G16422Unorm" == j.get< std::string >() ) {
      p = Format :: eB16G16R16G16422Unorm ;
      return;
    }
    if( "VK_FORMAT_B16G16R16G16_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eB16G16R16G16422Unorm ;
      return;
    }
    if( "G16B16R163Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane420Unorm ;
      return;
    }
    if( "eG16B16R163Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane420Unorm ;
      return;
    }
    if( "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane420Unorm ;
      return;
    }
    if( "G16B16R162Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane420Unorm ;
      return;
    }
    if( "eG16B16R162Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane420Unorm ;
      return;
    }
    if( "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane420Unorm ;
      return;
    }
    if( "G16B16R163Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane422Unorm ;
      return;
    }
    if( "eG16B16R163Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane422Unorm ;
      return;
    }
    if( "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane422Unorm ;
      return;
    }
    if( "G16B16R162Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane422Unorm ;
      return;
    }
    if( "eG16B16R162Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane422Unorm ;
      return;
    }
    if( "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane422Unorm ;
      return;
    }
    if( "G16B16R163Plane444Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane444Unorm ;
      return;
    }
    if( "eG16B16R163Plane444Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane444Unorm ;
      return;
    }
    if( "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane444Unorm ;
      return;
    }
    if( "Pvrtc12BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc12BppUnormBlockIMG ;
      return;
    }
    if( "ePvrtc12BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc12BppUnormBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc12BppUnormBlockIMG ;
      return;
    }
    if( "Pvrtc14BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc14BppUnormBlockIMG ;
      return;
    }
    if( "ePvrtc14BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc14BppUnormBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc14BppUnormBlockIMG ;
      return;
    }
    if( "Pvrtc22BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc22BppUnormBlockIMG ;
      return;
    }
    if( "ePvrtc22BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc22BppUnormBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc22BppUnormBlockIMG ;
      return;
    }
    if( "Pvrtc24BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc24BppUnormBlockIMG ;
      return;
    }
    if( "ePvrtc24BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc24BppUnormBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc24BppUnormBlockIMG ;
      return;
    }
    if( "Pvrtc12BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc12BppSrgbBlockIMG ;
      return;
    }
    if( "ePvrtc12BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc12BppSrgbBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc12BppSrgbBlockIMG ;
      return;
    }
    if( "Pvrtc14BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc14BppSrgbBlockIMG ;
      return;
    }
    if( "ePvrtc14BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc14BppSrgbBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc14BppSrgbBlockIMG ;
      return;
    }
    if( "Pvrtc22BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc22BppSrgbBlockIMG ;
      return;
    }
    if( "ePvrtc22BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc22BppSrgbBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc22BppSrgbBlockIMG ;
      return;
    }
    if( "Pvrtc24BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc24BppSrgbBlockIMG ;
      return;
    }
    if( "ePvrtc24BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc24BppSrgbBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc24BppSrgbBlockIMG ;
      return;
    }
    if( "Astc4x4SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc4x4SfloatBlockEXT ;
      return;
    }
    if( "eAstc4x4SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc4x4SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc4x4SfloatBlockEXT ;
      return;
    }
    if( "Astc5x4SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc5x4SfloatBlockEXT ;
      return;
    }
    if( "eAstc5x4SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc5x4SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc5x4SfloatBlockEXT ;
      return;
    }
    if( "Astc5x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc5x5SfloatBlockEXT ;
      return;
    }
    if( "eAstc5x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc5x5SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc5x5SfloatBlockEXT ;
      return;
    }
    if( "Astc6x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc6x5SfloatBlockEXT ;
      return;
    }
    if( "eAstc6x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc6x5SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc6x5SfloatBlockEXT ;
      return;
    }
    if( "Astc6x6SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc6x6SfloatBlockEXT ;
      return;
    }
    if( "eAstc6x6SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc6x6SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc6x6SfloatBlockEXT ;
      return;
    }
    if( "Astc8x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x5SfloatBlockEXT ;
      return;
    }
    if( "eAstc8x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x5SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x5SfloatBlockEXT ;
      return;
    }
    if( "Astc8x6SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x6SfloatBlockEXT ;
      return;
    }
    if( "eAstc8x6SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x6SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x6SfloatBlockEXT ;
      return;
    }
    if( "Astc8x8SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x8SfloatBlockEXT ;
      return;
    }
    if( "eAstc8x8SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x8SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x8SfloatBlockEXT ;
      return;
    }
    if( "Astc10x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x5SfloatBlockEXT ;
      return;
    }
    if( "eAstc10x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x5SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x5SfloatBlockEXT ;
      return;
    }
    if( "Astc10x6SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x6SfloatBlockEXT ;
      return;
    }
    if( "eAstc10x6SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x6SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x6SfloatBlockEXT ;
      return;
    }
    if( "Astc10x8SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x8SfloatBlockEXT ;
      return;
    }
    if( "eAstc10x8SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x8SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x8SfloatBlockEXT ;
      return;
    }
    if( "Astc10x10SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x10SfloatBlockEXT ;
      return;
    }
    if( "eAstc10x10SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x10SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x10SfloatBlockEXT ;
      return;
    }
    if( "Astc12x10SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc12x10SfloatBlockEXT ;
      return;
    }
    if( "eAstc12x10SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc12x10SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc12x10SfloatBlockEXT ;
      return;
    }
    if( "Astc12x12SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc12x12SfloatBlockEXT ;
      return;
    }
    if( "eAstc12x12SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc12x12SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc12x12SfloatBlockEXT ;
      return;
    }
    if( "G8B8R82Plane444UnormEXT" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane444UnormEXT ;
      return;
    }
    if( "eG8B8R82Plane444UnormEXT" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane444UnormEXT ;
      return;
    }
    if( "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane444UnormEXT ;
      return;
    }
    if( "G10X6B10X6R10X62Plane444Unorm3Pack16EXT" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane444Unorm3Pack16EXT ;
      return;
    }
    if( "eG10X6B10X6R10X62Plane444Unorm3Pack16EXT" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane444Unorm3Pack16EXT ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane444Unorm3Pack16EXT ;
      return;
    }
    if( "G12X4B12X4R12X42Plane444Unorm3Pack16EXT" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane444Unorm3Pack16EXT ;
      return;
    }
    if( "eG12X4B12X4R12X42Plane444Unorm3Pack16EXT" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane444Unorm3Pack16EXT ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane444Unorm3Pack16EXT ;
      return;
    }
    if( "G16B16R162Plane444UnormEXT" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane444UnormEXT ;
      return;
    }
    if( "eG16B16R162Plane444UnormEXT" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane444UnormEXT ;
      return;
    }
    if( "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane444UnormEXT ;
      return;
    }
    if( "A4R4G4B4UnormPack16EXT" == j.get< std::string >() ) {
      p = Format :: eA4R4G4B4UnormPack16EXT ;
      return;
    }
    if( "eA4R4G4B4UnormPack16EXT" == j.get< std::string >() ) {
      p = Format :: eA4R4G4B4UnormPack16EXT ;
      return;
    }
    if( "VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT" == j.get< std::string >() ) {
      p = Format :: eA4R4G4B4UnormPack16EXT ;
      return;
    }
    if( "A4B4G4R4UnormPack16EXT" == j.get< std::string >() ) {
      p = Format :: eA4B4G4R4UnormPack16EXT ;
      return;
    }
    if( "eA4B4G4R4UnormPack16EXT" == j.get< std::string >() ) {
      p = Format :: eA4B4G4R4UnormPack16EXT ;
      return;
    }
    if( "VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT" == j.get< std::string >() ) {
      p = Format :: eA4B4G4R4UnormPack16EXT ;
      return;
    }
    if( "B10X6G10X6R10X6G10X6422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16KHR ;
      return;
    }
    if( "eB10X6G10X6R10X6G10X6422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16KHR ;
      return;
    }
    if( "B12X4G12X4R12X4G12X4422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16KHR ;
      return;
    }
    if( "eB12X4G12X4R12X4G12X4422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16KHR ;
      return;
    }
    if( "B16G16R16G16422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eB16G16R16G16422UnormKHR ;
      return;
    }
    if( "eB16G16R16G16422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eB16G16R16G16422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_B16G16R16G16_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eB16G16R16G16422UnormKHR ;
      return;
    }
    if( "B8G8R8G8422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eB8G8R8G8422UnormKHR ;
      return;
    }
    if( "eB8G8R8G8422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eB8G8R8G8422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_B8G8R8G8_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eB8G8R8G8422UnormKHR ;
      return;
    }
    if( "G10X6B10X6G10X6R10X6422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16KHR ;
      return;
    }
    if( "eG10X6B10X6G10X6R10X6422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16KHR ;
      return;
    }
    if( "G10X6B10X6R10X62Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "eG10X6B10X6R10X62Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "G10X6B10X6R10X62Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "eG10X6B10X6R10X62Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "G10X6B10X6R10X63Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "eG10X6B10X6R10X63Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "G10X6B10X6R10X63Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "eG10X6B10X6R10X63Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "G10X6B10X6R10X63Plane444Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16KHR ;
      return;
    }
    if( "eG10X6B10X6R10X63Plane444Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16KHR ;
      return;
    }
    if( "G12X4B12X4G12X4R12X4422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16KHR ;
      return;
    }
    if( "eG12X4B12X4G12X4R12X4422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16KHR ;
      return;
    }
    if( "G12X4B12X4R12X42Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "eG12X4B12X4R12X42Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "G12X4B12X4R12X42Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "eG12X4B12X4R12X42Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "G12X4B12X4R12X43Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "eG12X4B12X4R12X43Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "G12X4B12X4R12X43Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "eG12X4B12X4R12X43Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "G12X4B12X4R12X43Plane444Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16KHR ;
      return;
    }
    if( "eG12X4B12X4R12X43Plane444Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16KHR ;
      return;
    }
    if( "G16B16G16R16422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16G16R16422UnormKHR ;
      return;
    }
    if( "eG16B16G16R16422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16G16R16422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G16B16G16R16_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG16B16G16R16422UnormKHR ;
      return;
    }
    if( "G16B16R162Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane420UnormKHR ;
      return;
    }
    if( "eG16B16R162Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane420UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane420UnormKHR ;
      return;
    }
    if( "G16B16R162Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane422UnormKHR ;
      return;
    }
    if( "eG16B16R162Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane422UnormKHR ;
      return;
    }
    if( "G16B16R163Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane420UnormKHR ;
      return;
    }
    if( "eG16B16R163Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane420UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane420UnormKHR ;
      return;
    }
    if( "G16B16R163Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane422UnormKHR ;
      return;
    }
    if( "eG16B16R163Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane422UnormKHR ;
      return;
    }
    if( "G16B16R163Plane444UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane444UnormKHR ;
      return;
    }
    if( "eG16B16R163Plane444UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane444UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane444UnormKHR ;
      return;
    }
    if( "G8B8G8R8422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8G8R8422UnormKHR ;
      return;
    }
    if( "eG8B8G8R8422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8G8R8422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G8B8G8R8_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG8B8G8R8422UnormKHR ;
      return;
    }
    if( "G8B8R82Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane420UnormKHR ;
      return;
    }
    if( "eG8B8R82Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane420UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane420UnormKHR ;
      return;
    }
    if( "G8B8R82Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane422UnormKHR ;
      return;
    }
    if( "eG8B8R82Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane422UnormKHR ;
      return;
    }
    if( "G8B8R83Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane420UnormKHR ;
      return;
    }
    if( "eG8B8R83Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane420UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane420UnormKHR ;
      return;
    }
    if( "G8B8R83Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane422UnormKHR ;
      return;
    }
    if( "eG8B8R83Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane422UnormKHR ;
      return;
    }
    if( "G8B8R83Plane444UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane444UnormKHR ;
      return;
    }
    if( "eG8B8R83Plane444UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane444UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane444UnormKHR ;
      return;
    }
    if( "R10X6G10X6B10X6A10X6Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16KHR ;
      return;
    }
    if( "eR10X6G10X6B10X6A10X6Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16KHR ;
      return;
    }
    if( "R10X6G10X6Unorm2Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6Unorm2Pack16KHR ;
      return;
    }
    if( "eR10X6G10X6Unorm2Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6Unorm2Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6Unorm2Pack16KHR ;
      return;
    }
    if( "R10X6UnormPack16KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6UnormPack16KHR ;
      return;
    }
    if( "eR10X6UnormPack16KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6UnormPack16KHR ;
      return;
    }
    if( "VK_FORMAT_R10X6_UNORM_PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6UnormPack16KHR ;
      return;
    }
    if( "R12X4G12X4B12X4A12X4Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16KHR ;
      return;
    }
    if( "eR12X4G12X4B12X4A12X4Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16KHR ;
      return;
    }
    if( "R12X4G12X4Unorm2Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4Unorm2Pack16KHR ;
      return;
    }
    if( "eR12X4G12X4Unorm2Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4Unorm2Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4Unorm2Pack16KHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for Format" );
  }
  if( j.is_number() ) {
    p = Format ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for Format" );
}
}
void from_json( const nlohmann::json &j, VkFormat &p ) {
  VULKAN_HPP_NAMESPACE :: Format temp;
  from_json( j, temp );
  p = VkFormat ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageTiling &p ) {
  if( ImageTiling :: eOptimal == p ) {
    j = "Optimal";
    return;
  }
  if( ImageTiling :: eLinear == p ) {
    j = "Linear";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkImageTiling &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageTiling ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageTiling &p ) {
  if( j.is_string() ) {
    if( "Optimal" == j.get< std::string >() ) {
      p = ImageTiling :: eOptimal ;
      return;
    }
    if( "eOptimal" == j.get< std::string >() ) {
      p = ImageTiling :: eOptimal ;
      return;
    }
    if( "VK_IMAGE_TILING_OPTIMAL" == j.get< std::string >() ) {
      p = ImageTiling :: eOptimal ;
      return;
    }
    if( "Linear" == j.get< std::string >() ) {
      p = ImageTiling :: eLinear ;
      return;
    }
    if( "eLinear" == j.get< std::string >() ) {
      p = ImageTiling :: eLinear ;
      return;
    }
    if( "VK_IMAGE_TILING_LINEAR" == j.get< std::string >() ) {
      p = ImageTiling :: eLinear ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImageTiling" );
  }
  if( j.is_number() ) {
    p = ImageTiling ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImageTiling" );
}
}
void from_json( const nlohmann::json &j, VkImageTiling &p ) {
  VULKAN_HPP_NAMESPACE :: ImageTiling temp;
  from_json( j, temp );
  p = VkImageTiling ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageType &p ) {
  if( ImageType :: e1D == p ) {
    j = "1D";
    return;
  }
  if( ImageType :: e2D == p ) {
    j = "2D";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkImageType &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageType ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageType &p ) {
  if( j.is_string() ) {
    if( "1D" == j.get< std::string >() ) {
      p = ImageType :: e1D ;
      return;
    }
    if( "e1D" == j.get< std::string >() ) {
      p = ImageType :: e1D ;
      return;
    }
    if( "VK_IMAGE_TYPE_1D" == j.get< std::string >() ) {
      p = ImageType :: e1D ;
      return;
    }
    if( "2D" == j.get< std::string >() ) {
      p = ImageType :: e2D ;
      return;
    }
    if( "e2D" == j.get< std::string >() ) {
      p = ImageType :: e2D ;
      return;
    }
    if( "VK_IMAGE_TYPE_2D" == j.get< std::string >() ) {
      p = ImageType :: e2D ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImageType" );
  }
  if( j.is_number() ) {
    p = ImageType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImageType" );
}
}
void from_json( const nlohmann::json &j, VkImageType &p ) {
  VULKAN_HPP_NAMESPACE :: ImageType temp;
  from_json( j, temp );
  p = VkImageType ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const InternalAllocationType &p ) {
}
}
void to_json( nlohmann::json &j, const VkInternalAllocationType &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: InternalAllocationType ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, InternalAllocationType &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for InternalAllocationType" );
  }
  if( j.is_number() ) {
    p = InternalAllocationType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for InternalAllocationType" );
}
}
void from_json( const nlohmann::json &j, VkInternalAllocationType &p ) {
  VULKAN_HPP_NAMESPACE :: InternalAllocationType temp;
  from_json( j, temp );
  p = VkInternalAllocationType ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceType &p ) {
  if( PhysicalDeviceType :: eOther == p ) {
    j = "Other";
    return;
  }
  if( PhysicalDeviceType :: eIntegratedGpu == p ) {
    j = "IntegratedGpu";
    return;
  }
  if( PhysicalDeviceType :: eDiscreteGpu == p ) {
    j = "DiscreteGpu";
    return;
  }
  if( PhysicalDeviceType :: eVirtualGpu == p ) {
    j = "VirtualGpu";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceType &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceType ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceType &p ) {
  if( j.is_string() ) {
    if( "Other" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eOther ;
      return;
    }
    if( "eOther" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eOther ;
      return;
    }
    if( "VK_PHYSICAL_DEVICE_TYPE_OTHER" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eOther ;
      return;
    }
    if( "IntegratedGpu" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eIntegratedGpu ;
      return;
    }
    if( "eIntegratedGpu" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eIntegratedGpu ;
      return;
    }
    if( "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eIntegratedGpu ;
      return;
    }
    if( "DiscreteGpu" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eDiscreteGpu ;
      return;
    }
    if( "eDiscreteGpu" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eDiscreteGpu ;
      return;
    }
    if( "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eDiscreteGpu ;
      return;
    }
    if( "VirtualGpu" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eVirtualGpu ;
      return;
    }
    if( "eVirtualGpu" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eVirtualGpu ;
      return;
    }
    if( "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eVirtualGpu ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PhysicalDeviceType" );
  }
  if( j.is_number() ) {
    p = PhysicalDeviceType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PhysicalDeviceType" );
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceType &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceType temp;
  from_json( j, temp );
  p = VkPhysicalDeviceType ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SystemAllocationScope &p ) {
  if( SystemAllocationScope :: eCommand == p ) {
    j = "Command";
    return;
  }
  if( SystemAllocationScope :: eObject == p ) {
    j = "Object";
    return;
  }
  if( SystemAllocationScope :: eCache == p ) {
    j = "Cache";
    return;
  }
  if( SystemAllocationScope :: eDevice == p ) {
    j = "Device";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkSystemAllocationScope &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SystemAllocationScope ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SystemAllocationScope &p ) {
  if( j.is_string() ) {
    if( "Command" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eCommand ;
      return;
    }
    if( "eCommand" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eCommand ;
      return;
    }
    if( "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eCommand ;
      return;
    }
    if( "Object" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eObject ;
      return;
    }
    if( "eObject" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eObject ;
      return;
    }
    if( "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eObject ;
      return;
    }
    if( "Cache" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eCache ;
      return;
    }
    if( "eCache" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eCache ;
      return;
    }
    if( "VK_SYSTEM_ALLOCATION_SCOPE_CACHE" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eCache ;
      return;
    }
    if( "Device" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eDevice ;
      return;
    }
    if( "eDevice" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eDevice ;
      return;
    }
    if( "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eDevice ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SystemAllocationScope" );
  }
  if( j.is_number() ) {
    p = SystemAllocationScope ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SystemAllocationScope" );
}
}
void from_json( const nlohmann::json &j, VkSystemAllocationScope &p ) {
  VULKAN_HPP_NAMESPACE :: SystemAllocationScope temp;
  from_json( j, temp );
  p = VkSystemAllocationScope ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SharingMode &p ) {
  if( SharingMode :: eExclusive == p ) {
    j = "Exclusive";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkSharingMode &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SharingMode ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SharingMode &p ) {
  if( j.is_string() ) {
    if( "Exclusive" == j.get< std::string >() ) {
      p = SharingMode :: eExclusive ;
      return;
    }
    if( "eExclusive" == j.get< std::string >() ) {
      p = SharingMode :: eExclusive ;
      return;
    }
    if( "VK_SHARING_MODE_EXCLUSIVE" == j.get< std::string >() ) {
      p = SharingMode :: eExclusive ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SharingMode" );
  }
  if( j.is_number() ) {
    p = SharingMode ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SharingMode" );
}
}
void from_json( const nlohmann::json &j, VkSharingMode &p ) {
  VULKAN_HPP_NAMESPACE :: SharingMode temp;
  from_json( j, temp );
  p = VkSharingMode ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ComponentSwizzle &p ) {
  if( ComponentSwizzle :: eIdentity == p ) {
    j = "Identity";
    return;
  }
  if( ComponentSwizzle :: eZero == p ) {
    j = "Zero";
    return;
  }
  if( ComponentSwizzle :: eOne == p ) {
    j = "One";
    return;
  }
  if( ComponentSwizzle :: eR == p ) {
    j = "R";
    return;
  }
  if( ComponentSwizzle :: eG == p ) {
    j = "G";
    return;
  }
  if( ComponentSwizzle :: eB == p ) {
    j = "B";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkComponentSwizzle &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ComponentSwizzle ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ComponentSwizzle &p ) {
  if( j.is_string() ) {
    if( "Identity" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eIdentity ;
      return;
    }
    if( "eIdentity" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eIdentity ;
      return;
    }
    if( "VK_COMPONENT_SWIZZLE_IDENTITY" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eIdentity ;
      return;
    }
    if( "Zero" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eZero ;
      return;
    }
    if( "eZero" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eZero ;
      return;
    }
    if( "VK_COMPONENT_SWIZZLE_ZERO" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eZero ;
      return;
    }
    if( "One" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eOne ;
      return;
    }
    if( "eOne" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eOne ;
      return;
    }
    if( "VK_COMPONENT_SWIZZLE_ONE" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eOne ;
      return;
    }
    if( "R" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eR ;
      return;
    }
    if( "eR" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eR ;
      return;
    }
    if( "VK_COMPONENT_SWIZZLE_R" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eR ;
      return;
    }
    if( "G" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eG ;
      return;
    }
    if( "eG" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eG ;
      return;
    }
    if( "VK_COMPONENT_SWIZZLE_G" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eG ;
      return;
    }
    if( "B" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eB ;
      return;
    }
    if( "eB" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eB ;
      return;
    }
    if( "VK_COMPONENT_SWIZZLE_B" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eB ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ComponentSwizzle" );
  }
  if( j.is_number() ) {
    p = ComponentSwizzle ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ComponentSwizzle" );
}
}
void from_json( const nlohmann::json &j, VkComponentSwizzle &p ) {
  VULKAN_HPP_NAMESPACE :: ComponentSwizzle temp;
  from_json( j, temp );
  p = VkComponentSwizzle ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageViewType &p ) {
  if( ImageViewType :: e1D == p ) {
    j = "1D";
    return;
  }
  if( ImageViewType :: e2D == p ) {
    j = "2D";
    return;
  }
  if( ImageViewType :: e3D == p ) {
    j = "3D";
    return;
  }
  if( ImageViewType :: eCube == p ) {
    j = "Cube";
    return;
  }
  if( ImageViewType :: e1DArray == p ) {
    j = "1DArray";
    return;
  }
  if( ImageViewType :: e2DArray == p ) {
    j = "2DArray";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkImageViewType &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageViewType ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageViewType &p ) {
  if( j.is_string() ) {
    if( "1D" == j.get< std::string >() ) {
      p = ImageViewType :: e1D ;
      return;
    }
    if( "e1D" == j.get< std::string >() ) {
      p = ImageViewType :: e1D ;
      return;
    }
    if( "VK_IMAGE_VIEW_TYPE_1D" == j.get< std::string >() ) {
      p = ImageViewType :: e1D ;
      return;
    }
    if( "2D" == j.get< std::string >() ) {
      p = ImageViewType :: e2D ;
      return;
    }
    if( "e2D" == j.get< std::string >() ) {
      p = ImageViewType :: e2D ;
      return;
    }
    if( "VK_IMAGE_VIEW_TYPE_2D" == j.get< std::string >() ) {
      p = ImageViewType :: e2D ;
      return;
    }
    if( "3D" == j.get< std::string >() ) {
      p = ImageViewType :: e3D ;
      return;
    }
    if( "e3D" == j.get< std::string >() ) {
      p = ImageViewType :: e3D ;
      return;
    }
    if( "VK_IMAGE_VIEW_TYPE_3D" == j.get< std::string >() ) {
      p = ImageViewType :: e3D ;
      return;
    }
    if( "Cube" == j.get< std::string >() ) {
      p = ImageViewType :: eCube ;
      return;
    }
    if( "eCube" == j.get< std::string >() ) {
      p = ImageViewType :: eCube ;
      return;
    }
    if( "VK_IMAGE_VIEW_TYPE_CUBE" == j.get< std::string >() ) {
      p = ImageViewType :: eCube ;
      return;
    }
    if( "1DArray" == j.get< std::string >() ) {
      p = ImageViewType :: e1DArray ;
      return;
    }
    if( "e1DArray" == j.get< std::string >() ) {
      p = ImageViewType :: e1DArray ;
      return;
    }
    if( "VK_IMAGE_VIEW_TYPE_1D_ARRAY" == j.get< std::string >() ) {
      p = ImageViewType :: e1DArray ;
      return;
    }
    if( "2DArray" == j.get< std::string >() ) {
      p = ImageViewType :: e2DArray ;
      return;
    }
    if( "e2DArray" == j.get< std::string >() ) {
      p = ImageViewType :: e2DArray ;
      return;
    }
    if( "VK_IMAGE_VIEW_TYPE_2D_ARRAY" == j.get< std::string >() ) {
      p = ImageViewType :: e2DArray ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImageViewType" );
  }
  if( j.is_number() ) {
    p = ImageViewType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImageViewType" );
}
}
void from_json( const nlohmann::json &j, VkImageViewType &p ) {
  VULKAN_HPP_NAMESPACE :: ImageViewType temp;
  from_json( j, temp );
  p = VkImageViewType ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BlendFactor &p ) {
  if( BlendFactor :: eZero == p ) {
    j = "Zero";
    return;
  }
  if( BlendFactor :: eOne == p ) {
    j = "One";
    return;
  }
  if( BlendFactor :: eSrcColor == p ) {
    j = "SrcColor";
    return;
  }
  if( BlendFactor :: eOneMinusSrcColor == p ) {
    j = "OneMinusSrcColor";
    return;
  }
  if( BlendFactor :: eDstColor == p ) {
    j = "DstColor";
    return;
  }
  if( BlendFactor :: eOneMinusDstColor == p ) {
    j = "OneMinusDstColor";
    return;
  }
  if( BlendFactor :: eSrcAlpha == p ) {
    j = "SrcAlpha";
    return;
  }
  if( BlendFactor :: eOneMinusSrcAlpha == p ) {
    j = "OneMinusSrcAlpha";
    return;
  }
  if( BlendFactor :: eDstAlpha == p ) {
    j = "DstAlpha";
    return;
  }
  if( BlendFactor :: eOneMinusDstAlpha == p ) {
    j = "OneMinusDstAlpha";
    return;
  }
  if( BlendFactor :: eConstantColor == p ) {
    j = "ConstantColor";
    return;
  }
  if( BlendFactor :: eOneMinusConstantColor == p ) {
    j = "OneMinusConstantColor";
    return;
  }
  if( BlendFactor :: eConstantAlpha == p ) {
    j = "ConstantAlpha";
    return;
  }
  if( BlendFactor :: eOneMinusConstantAlpha == p ) {
    j = "OneMinusConstantAlpha";
    return;
  }
  if( BlendFactor :: eSrcAlphaSaturate == p ) {
    j = "SrcAlphaSaturate";
    return;
  }
  if( BlendFactor :: eSrc1Color == p ) {
    j = "Src1Color";
    return;
  }
  if( BlendFactor :: eOneMinusSrc1Color == p ) {
    j = "OneMinusSrc1Color";
    return;
  }
  if( BlendFactor :: eSrc1Alpha == p ) {
    j = "Src1Alpha";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkBlendFactor &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BlendFactor ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BlendFactor &p ) {
  if( j.is_string() ) {
    if( "Zero" == j.get< std::string >() ) {
      p = BlendFactor :: eZero ;
      return;
    }
    if( "eZero" == j.get< std::string >() ) {
      p = BlendFactor :: eZero ;
      return;
    }
    if( "VK_BLEND_FACTOR_ZERO" == j.get< std::string >() ) {
      p = BlendFactor :: eZero ;
      return;
    }
    if( "One" == j.get< std::string >() ) {
      p = BlendFactor :: eOne ;
      return;
    }
    if( "eOne" == j.get< std::string >() ) {
      p = BlendFactor :: eOne ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE" == j.get< std::string >() ) {
      p = BlendFactor :: eOne ;
      return;
    }
    if( "SrcColor" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcColor ;
      return;
    }
    if( "eSrcColor" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcColor ;
      return;
    }
    if( "VK_BLEND_FACTOR_SRC_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcColor ;
      return;
    }
    if( "OneMinusSrcColor" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrcColor ;
      return;
    }
    if( "eOneMinusSrcColor" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrcColor ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrcColor ;
      return;
    }
    if( "DstColor" == j.get< std::string >() ) {
      p = BlendFactor :: eDstColor ;
      return;
    }
    if( "eDstColor" == j.get< std::string >() ) {
      p = BlendFactor :: eDstColor ;
      return;
    }
    if( "VK_BLEND_FACTOR_DST_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eDstColor ;
      return;
    }
    if( "OneMinusDstColor" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusDstColor ;
      return;
    }
    if( "eOneMinusDstColor" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusDstColor ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusDstColor ;
      return;
    }
    if( "SrcAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcAlpha ;
      return;
    }
    if( "eSrcAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcAlpha ;
      return;
    }
    if( "VK_BLEND_FACTOR_SRC_ALPHA" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcAlpha ;
      return;
    }
    if( "OneMinusSrcAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrcAlpha ;
      return;
    }
    if( "eOneMinusSrcAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrcAlpha ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrcAlpha ;
      return;
    }
    if( "DstAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eDstAlpha ;
      return;
    }
    if( "eDstAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eDstAlpha ;
      return;
    }
    if( "VK_BLEND_FACTOR_DST_ALPHA" == j.get< std::string >() ) {
      p = BlendFactor :: eDstAlpha ;
      return;
    }
    if( "OneMinusDstAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusDstAlpha ;
      return;
    }
    if( "eOneMinusDstAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusDstAlpha ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusDstAlpha ;
      return;
    }
    if( "ConstantColor" == j.get< std::string >() ) {
      p = BlendFactor :: eConstantColor ;
      return;
    }
    if( "eConstantColor" == j.get< std::string >() ) {
      p = BlendFactor :: eConstantColor ;
      return;
    }
    if( "VK_BLEND_FACTOR_CONSTANT_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eConstantColor ;
      return;
    }
    if( "OneMinusConstantColor" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusConstantColor ;
      return;
    }
    if( "eOneMinusConstantColor" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusConstantColor ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusConstantColor ;
      return;
    }
    if( "ConstantAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eConstantAlpha ;
      return;
    }
    if( "eConstantAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eConstantAlpha ;
      return;
    }
    if( "VK_BLEND_FACTOR_CONSTANT_ALPHA" == j.get< std::string >() ) {
      p = BlendFactor :: eConstantAlpha ;
      return;
    }
    if( "OneMinusConstantAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusConstantAlpha ;
      return;
    }
    if( "eOneMinusConstantAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusConstantAlpha ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusConstantAlpha ;
      return;
    }
    if( "SrcAlphaSaturate" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcAlphaSaturate ;
      return;
    }
    if( "eSrcAlphaSaturate" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcAlphaSaturate ;
      return;
    }
    if( "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcAlphaSaturate ;
      return;
    }
    if( "Src1Color" == j.get< std::string >() ) {
      p = BlendFactor :: eSrc1Color ;
      return;
    }
    if( "eSrc1Color" == j.get< std::string >() ) {
      p = BlendFactor :: eSrc1Color ;
      return;
    }
    if( "VK_BLEND_FACTOR_SRC1_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eSrc1Color ;
      return;
    }
    if( "OneMinusSrc1Color" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrc1Color ;
      return;
    }
    if( "eOneMinusSrc1Color" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrc1Color ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrc1Color ;
      return;
    }
    if( "Src1Alpha" == j.get< std::string >() ) {
      p = BlendFactor :: eSrc1Alpha ;
      return;
    }
    if( "eSrc1Alpha" == j.get< std::string >() ) {
      p = BlendFactor :: eSrc1Alpha ;
      return;
    }
    if( "VK_BLEND_FACTOR_SRC1_ALPHA" == j.get< std::string >() ) {
      p = BlendFactor :: eSrc1Alpha ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BlendFactor" );
  }
  if( j.is_number() ) {
    p = BlendFactor ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BlendFactor" );
}
}
void from_json( const nlohmann::json &j, VkBlendFactor &p ) {
  VULKAN_HPP_NAMESPACE :: BlendFactor temp;
  from_json( j, temp );
  p = VkBlendFactor ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BlendOp &p ) {
  if( BlendOp :: eAdd == p ) {
    j = "Add";
    return;
  }
  if( BlendOp :: eSubtract == p ) {
    j = "Subtract";
    return;
  }
  if( BlendOp :: eReverseSubtract == p ) {
    j = "ReverseSubtract";
    return;
  }
  if( BlendOp :: eMin == p ) {
    j = "Min";
    return;
  }
  if( BlendOp :: eMax == p ) {
    j = "Max";
    return;
  }
  if( BlendOp :: eZeroEXT == p ) {
    j = "ZeroEXT";
    return;
  }
  if( BlendOp :: eSrcEXT == p ) {
    j = "SrcEXT";
    return;
  }
  if( BlendOp :: eDstEXT == p ) {
    j = "DstEXT";
    return;
  }
  if( BlendOp :: eSrcOverEXT == p ) {
    j = "SrcOverEXT";
    return;
  }
  if( BlendOp :: eDstOverEXT == p ) {
    j = "DstOverEXT";
    return;
  }
  if( BlendOp :: eSrcInEXT == p ) {
    j = "SrcInEXT";
    return;
  }
  if( BlendOp :: eDstInEXT == p ) {
    j = "DstInEXT";
    return;
  }
  if( BlendOp :: eSrcOutEXT == p ) {
    j = "SrcOutEXT";
    return;
  }
  if( BlendOp :: eDstOutEXT == p ) {
    j = "DstOutEXT";
    return;
  }
  if( BlendOp :: eSrcAtopEXT == p ) {
    j = "SrcAtopEXT";
    return;
  }
  if( BlendOp :: eDstAtopEXT == p ) {
    j = "DstAtopEXT";
    return;
  }
  if( BlendOp :: eXorEXT == p ) {
    j = "XorEXT";
    return;
  }
  if( BlendOp :: eMultiplyEXT == p ) {
    j = "MultiplyEXT";
    return;
  }
  if( BlendOp :: eScreenEXT == p ) {
    j = "ScreenEXT";
    return;
  }
  if( BlendOp :: eOverlayEXT == p ) {
    j = "OverlayEXT";
    return;
  }
  if( BlendOp :: eDarkenEXT == p ) {
    j = "DarkenEXT";
    return;
  }
  if( BlendOp :: eLightenEXT == p ) {
    j = "LightenEXT";
    return;
  }
  if( BlendOp :: eColordodgeEXT == p ) {
    j = "ColordodgeEXT";
    return;
  }
  if( BlendOp :: eColorburnEXT == p ) {
    j = "ColorburnEXT";
    return;
  }
  if( BlendOp :: eHardlightEXT == p ) {
    j = "HardlightEXT";
    return;
  }
  if( BlendOp :: eSoftlightEXT == p ) {
    j = "SoftlightEXT";
    return;
  }
  if( BlendOp :: eDifferenceEXT == p ) {
    j = "DifferenceEXT";
    return;
  }
  if( BlendOp :: eExclusionEXT == p ) {
    j = "ExclusionEXT";
    return;
  }
  if( BlendOp :: eInvertEXT == p ) {
    j = "InvertEXT";
    return;
  }
  if( BlendOp :: eInvertRgbEXT == p ) {
    j = "InvertRgbEXT";
    return;
  }
  if( BlendOp :: eLineardodgeEXT == p ) {
    j = "LineardodgeEXT";
    return;
  }
  if( BlendOp :: eLinearburnEXT == p ) {
    j = "LinearburnEXT";
    return;
  }
  if( BlendOp :: eVividlightEXT == p ) {
    j = "VividlightEXT";
    return;
  }
  if( BlendOp :: eLinearlightEXT == p ) {
    j = "LinearlightEXT";
    return;
  }
  if( BlendOp :: ePinlightEXT == p ) {
    j = "PinlightEXT";
    return;
  }
  if( BlendOp :: eHardmixEXT == p ) {
    j = "HardmixEXT";
    return;
  }
  if( BlendOp :: eHslHueEXT == p ) {
    j = "HslHueEXT";
    return;
  }
  if( BlendOp :: eHslSaturationEXT == p ) {
    j = "HslSaturationEXT";
    return;
  }
  if( BlendOp :: eHslColorEXT == p ) {
    j = "HslColorEXT";
    return;
  }
  if( BlendOp :: eHslLuminosityEXT == p ) {
    j = "HslLuminosityEXT";
    return;
  }
  if( BlendOp :: ePlusEXT == p ) {
    j = "PlusEXT";
    return;
  }
  if( BlendOp :: ePlusClampedEXT == p ) {
    j = "PlusClampedEXT";
    return;
  }
  if( BlendOp :: ePlusClampedAlphaEXT == p ) {
    j = "PlusClampedAlphaEXT";
    return;
  }
  if( BlendOp :: ePlusDarkerEXT == p ) {
    j = "PlusDarkerEXT";
    return;
  }
  if( BlendOp :: eMinusEXT == p ) {
    j = "MinusEXT";
    return;
  }
  if( BlendOp :: eMinusClampedEXT == p ) {
    j = "MinusClampedEXT";
    return;
  }
  if( BlendOp :: eContrastEXT == p ) {
    j = "ContrastEXT";
    return;
  }
  if( BlendOp :: eInvertOvgEXT == p ) {
    j = "InvertOvgEXT";
    return;
  }
  if( BlendOp :: eRedEXT == p ) {
    j = "RedEXT";
    return;
  }
  if( BlendOp :: eGreenEXT == p ) {
    j = "GreenEXT";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkBlendOp &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BlendOp ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BlendOp &p ) {
  if( j.is_string() ) {
    if( "Add" == j.get< std::string >() ) {
      p = BlendOp :: eAdd ;
      return;
    }
    if( "eAdd" == j.get< std::string >() ) {
      p = BlendOp :: eAdd ;
      return;
    }
    if( "VK_BLEND_OP_ADD" == j.get< std::string >() ) {
      p = BlendOp :: eAdd ;
      return;
    }
    if( "Subtract" == j.get< std::string >() ) {
      p = BlendOp :: eSubtract ;
      return;
    }
    if( "eSubtract" == j.get< std::string >() ) {
      p = BlendOp :: eSubtract ;
      return;
    }
    if( "VK_BLEND_OP_SUBTRACT" == j.get< std::string >() ) {
      p = BlendOp :: eSubtract ;
      return;
    }
    if( "ReverseSubtract" == j.get< std::string >() ) {
      p = BlendOp :: eReverseSubtract ;
      return;
    }
    if( "eReverseSubtract" == j.get< std::string >() ) {
      p = BlendOp :: eReverseSubtract ;
      return;
    }
    if( "VK_BLEND_OP_REVERSE_SUBTRACT" == j.get< std::string >() ) {
      p = BlendOp :: eReverseSubtract ;
      return;
    }
    if( "Min" == j.get< std::string >() ) {
      p = BlendOp :: eMin ;
      return;
    }
    if( "eMin" == j.get< std::string >() ) {
      p = BlendOp :: eMin ;
      return;
    }
    if( "VK_BLEND_OP_MIN" == j.get< std::string >() ) {
      p = BlendOp :: eMin ;
      return;
    }
    if( "Max" == j.get< std::string >() ) {
      p = BlendOp :: eMax ;
      return;
    }
    if( "eMax" == j.get< std::string >() ) {
      p = BlendOp :: eMax ;
      return;
    }
    if( "VK_BLEND_OP_MAX" == j.get< std::string >() ) {
      p = BlendOp :: eMax ;
      return;
    }
    if( "ZeroEXT" == j.get< std::string >() ) {
      p = BlendOp :: eZeroEXT ;
      return;
    }
    if( "eZeroEXT" == j.get< std::string >() ) {
      p = BlendOp :: eZeroEXT ;
      return;
    }
    if( "VK_BLEND_OP_ZERO_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eZeroEXT ;
      return;
    }
    if( "SrcEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcEXT ;
      return;
    }
    if( "eSrcEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcEXT ;
      return;
    }
    if( "VK_BLEND_OP_SRC_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcEXT ;
      return;
    }
    if( "DstEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstEXT ;
      return;
    }
    if( "eDstEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstEXT ;
      return;
    }
    if( "VK_BLEND_OP_DST_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstEXT ;
      return;
    }
    if( "SrcOverEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcOverEXT ;
      return;
    }
    if( "eSrcOverEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcOverEXT ;
      return;
    }
    if( "VK_BLEND_OP_SRC_OVER_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcOverEXT ;
      return;
    }
    if( "DstOverEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstOverEXT ;
      return;
    }
    if( "eDstOverEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstOverEXT ;
      return;
    }
    if( "VK_BLEND_OP_DST_OVER_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstOverEXT ;
      return;
    }
    if( "SrcInEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcInEXT ;
      return;
    }
    if( "eSrcInEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcInEXT ;
      return;
    }
    if( "VK_BLEND_OP_SRC_IN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcInEXT ;
      return;
    }
    if( "DstInEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstInEXT ;
      return;
    }
    if( "eDstInEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstInEXT ;
      return;
    }
    if( "VK_BLEND_OP_DST_IN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstInEXT ;
      return;
    }
    if( "SrcOutEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcOutEXT ;
      return;
    }
    if( "eSrcOutEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcOutEXT ;
      return;
    }
    if( "VK_BLEND_OP_SRC_OUT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcOutEXT ;
      return;
    }
    if( "DstOutEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstOutEXT ;
      return;
    }
    if( "eDstOutEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstOutEXT ;
      return;
    }
    if( "VK_BLEND_OP_DST_OUT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstOutEXT ;
      return;
    }
    if( "SrcAtopEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcAtopEXT ;
      return;
    }
    if( "eSrcAtopEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcAtopEXT ;
      return;
    }
    if( "VK_BLEND_OP_SRC_ATOP_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcAtopEXT ;
      return;
    }
    if( "DstAtopEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstAtopEXT ;
      return;
    }
    if( "eDstAtopEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstAtopEXT ;
      return;
    }
    if( "VK_BLEND_OP_DST_ATOP_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstAtopEXT ;
      return;
    }
    if( "XorEXT" == j.get< std::string >() ) {
      p = BlendOp :: eXorEXT ;
      return;
    }
    if( "eXorEXT" == j.get< std::string >() ) {
      p = BlendOp :: eXorEXT ;
      return;
    }
    if( "VK_BLEND_OP_XOR_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eXorEXT ;
      return;
    }
    if( "MultiplyEXT" == j.get< std::string >() ) {
      p = BlendOp :: eMultiplyEXT ;
      return;
    }
    if( "eMultiplyEXT" == j.get< std::string >() ) {
      p = BlendOp :: eMultiplyEXT ;
      return;
    }
    if( "VK_BLEND_OP_MULTIPLY_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eMultiplyEXT ;
      return;
    }
    if( "ScreenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eScreenEXT ;
      return;
    }
    if( "eScreenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eScreenEXT ;
      return;
    }
    if( "VK_BLEND_OP_SCREEN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eScreenEXT ;
      return;
    }
    if( "OverlayEXT" == j.get< std::string >() ) {
      p = BlendOp :: eOverlayEXT ;
      return;
    }
    if( "eOverlayEXT" == j.get< std::string >() ) {
      p = BlendOp :: eOverlayEXT ;
      return;
    }
    if( "VK_BLEND_OP_OVERLAY_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eOverlayEXT ;
      return;
    }
    if( "DarkenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDarkenEXT ;
      return;
    }
    if( "eDarkenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDarkenEXT ;
      return;
    }
    if( "VK_BLEND_OP_DARKEN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eDarkenEXT ;
      return;
    }
    if( "LightenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLightenEXT ;
      return;
    }
    if( "eLightenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLightenEXT ;
      return;
    }
    if( "VK_BLEND_OP_LIGHTEN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eLightenEXT ;
      return;
    }
    if( "ColordodgeEXT" == j.get< std::string >() ) {
      p = BlendOp :: eColordodgeEXT ;
      return;
    }
    if( "eColordodgeEXT" == j.get< std::string >() ) {
      p = BlendOp :: eColordodgeEXT ;
      return;
    }
    if( "VK_BLEND_OP_COLORDODGE_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eColordodgeEXT ;
      return;
    }
    if( "ColorburnEXT" == j.get< std::string >() ) {
      p = BlendOp :: eColorburnEXT ;
      return;
    }
    if( "eColorburnEXT" == j.get< std::string >() ) {
      p = BlendOp :: eColorburnEXT ;
      return;
    }
    if( "VK_BLEND_OP_COLORBURN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eColorburnEXT ;
      return;
    }
    if( "HardlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHardlightEXT ;
      return;
    }
    if( "eHardlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHardlightEXT ;
      return;
    }
    if( "VK_BLEND_OP_HARDLIGHT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eHardlightEXT ;
      return;
    }
    if( "SoftlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSoftlightEXT ;
      return;
    }
    if( "eSoftlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSoftlightEXT ;
      return;
    }
    if( "VK_BLEND_OP_SOFTLIGHT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eSoftlightEXT ;
      return;
    }
    if( "DifferenceEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDifferenceEXT ;
      return;
    }
    if( "eDifferenceEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDifferenceEXT ;
      return;
    }
    if( "VK_BLEND_OP_DIFFERENCE_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eDifferenceEXT ;
      return;
    }
    if( "ExclusionEXT" == j.get< std::string >() ) {
      p = BlendOp :: eExclusionEXT ;
      return;
    }
    if( "eExclusionEXT" == j.get< std::string >() ) {
      p = BlendOp :: eExclusionEXT ;
      return;
    }
    if( "VK_BLEND_OP_EXCLUSION_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eExclusionEXT ;
      return;
    }
    if( "InvertEXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertEXT ;
      return;
    }
    if( "eInvertEXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertEXT ;
      return;
    }
    if( "VK_BLEND_OP_INVERT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertEXT ;
      return;
    }
    if( "InvertRgbEXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertRgbEXT ;
      return;
    }
    if( "eInvertRgbEXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertRgbEXT ;
      return;
    }
    if( "VK_BLEND_OP_INVERT_RGB_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertRgbEXT ;
      return;
    }
    if( "LineardodgeEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLineardodgeEXT ;
      return;
    }
    if( "eLineardodgeEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLineardodgeEXT ;
      return;
    }
    if( "VK_BLEND_OP_LINEARDODGE_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eLineardodgeEXT ;
      return;
    }
    if( "LinearburnEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLinearburnEXT ;
      return;
    }
    if( "eLinearburnEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLinearburnEXT ;
      return;
    }
    if( "VK_BLEND_OP_LINEARBURN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eLinearburnEXT ;
      return;
    }
    if( "VividlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eVividlightEXT ;
      return;
    }
    if( "eVividlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eVividlightEXT ;
      return;
    }
    if( "VK_BLEND_OP_VIVIDLIGHT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eVividlightEXT ;
      return;
    }
    if( "LinearlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLinearlightEXT ;
      return;
    }
    if( "eLinearlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLinearlightEXT ;
      return;
    }
    if( "VK_BLEND_OP_LINEARLIGHT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eLinearlightEXT ;
      return;
    }
    if( "PinlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePinlightEXT ;
      return;
    }
    if( "ePinlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePinlightEXT ;
      return;
    }
    if( "VK_BLEND_OP_PINLIGHT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: ePinlightEXT ;
      return;
    }
    if( "HardmixEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHardmixEXT ;
      return;
    }
    if( "eHardmixEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHardmixEXT ;
      return;
    }
    if( "VK_BLEND_OP_HARDMIX_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eHardmixEXT ;
      return;
    }
    if( "HslHueEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslHueEXT ;
      return;
    }
    if( "eHslHueEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslHueEXT ;
      return;
    }
    if( "VK_BLEND_OP_HSL_HUE_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslHueEXT ;
      return;
    }
    if( "HslSaturationEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslSaturationEXT ;
      return;
    }
    if( "eHslSaturationEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslSaturationEXT ;
      return;
    }
    if( "VK_BLEND_OP_HSL_SATURATION_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslSaturationEXT ;
      return;
    }
    if( "HslColorEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslColorEXT ;
      return;
    }
    if( "eHslColorEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslColorEXT ;
      return;
    }
    if( "VK_BLEND_OP_HSL_COLOR_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslColorEXT ;
      return;
    }
    if( "HslLuminosityEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslLuminosityEXT ;
      return;
    }
    if( "eHslLuminosityEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslLuminosityEXT ;
      return;
    }
    if( "VK_BLEND_OP_HSL_LUMINOSITY_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslLuminosityEXT ;
      return;
    }
    if( "PlusEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusEXT ;
      return;
    }
    if( "ePlusEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusEXT ;
      return;
    }
    if( "VK_BLEND_OP_PLUS_EXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusEXT ;
      return;
    }
    if( "PlusClampedEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusClampedEXT ;
      return;
    }
    if( "ePlusClampedEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusClampedEXT ;
      return;
    }
    if( "VK_BLEND_OP_PLUS_CLAMPED_EXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusClampedEXT ;
      return;
    }
    if( "PlusClampedAlphaEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusClampedAlphaEXT ;
      return;
    }
    if( "ePlusClampedAlphaEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusClampedAlphaEXT ;
      return;
    }
    if( "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusClampedAlphaEXT ;
      return;
    }
    if( "PlusDarkerEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusDarkerEXT ;
      return;
    }
    if( "ePlusDarkerEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusDarkerEXT ;
      return;
    }
    if( "VK_BLEND_OP_PLUS_DARKER_EXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusDarkerEXT ;
      return;
    }
    if( "MinusEXT" == j.get< std::string >() ) {
      p = BlendOp :: eMinusEXT ;
      return;
    }
    if( "eMinusEXT" == j.get< std::string >() ) {
      p = BlendOp :: eMinusEXT ;
      return;
    }
    if( "VK_BLEND_OP_MINUS_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eMinusEXT ;
      return;
    }
    if( "MinusClampedEXT" == j.get< std::string >() ) {
      p = BlendOp :: eMinusClampedEXT ;
      return;
    }
    if( "eMinusClampedEXT" == j.get< std::string >() ) {
      p = BlendOp :: eMinusClampedEXT ;
      return;
    }
    if( "VK_BLEND_OP_MINUS_CLAMPED_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eMinusClampedEXT ;
      return;
    }
    if( "ContrastEXT" == j.get< std::string >() ) {
      p = BlendOp :: eContrastEXT ;
      return;
    }
    if( "eContrastEXT" == j.get< std::string >() ) {
      p = BlendOp :: eContrastEXT ;
      return;
    }
    if( "VK_BLEND_OP_CONTRAST_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eContrastEXT ;
      return;
    }
    if( "InvertOvgEXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertOvgEXT ;
      return;
    }
    if( "eInvertOvgEXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertOvgEXT ;
      return;
    }
    if( "VK_BLEND_OP_INVERT_OVG_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertOvgEXT ;
      return;
    }
    if( "RedEXT" == j.get< std::string >() ) {
      p = BlendOp :: eRedEXT ;
      return;
    }
    if( "eRedEXT" == j.get< std::string >() ) {
      p = BlendOp :: eRedEXT ;
      return;
    }
    if( "VK_BLEND_OP_RED_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eRedEXT ;
      return;
    }
    if( "GreenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eGreenEXT ;
      return;
    }
    if( "eGreenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eGreenEXT ;
      return;
    }
    if( "VK_BLEND_OP_GREEN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eGreenEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BlendOp" );
  }
  if( j.is_number() ) {
    p = BlendOp ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BlendOp" );
}
}
void from_json( const nlohmann::json &j, VkBlendOp &p ) {
  VULKAN_HPP_NAMESPACE :: BlendOp temp;
  from_json( j, temp );
  p = VkBlendOp ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CompareOp &p ) {
  if( CompareOp :: eNever == p ) {
    j = "Never";
    return;
  }
  if( CompareOp :: eLess == p ) {
    j = "Less";
    return;
  }
  if( CompareOp :: eEqual == p ) {
    j = "Equal";
    return;
  }
  if( CompareOp :: eLessOrEqual == p ) {
    j = "LessOrEqual";
    return;
  }
  if( CompareOp :: eGreater == p ) {
    j = "Greater";
    return;
  }
  if( CompareOp :: eNotEqual == p ) {
    j = "NotEqual";
    return;
  }
  if( CompareOp :: eGreaterOrEqual == p ) {
    j = "GreaterOrEqual";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkCompareOp &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CompareOp ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CompareOp &p ) {
  if( j.is_string() ) {
    if( "Never" == j.get< std::string >() ) {
      p = CompareOp :: eNever ;
      return;
    }
    if( "eNever" == j.get< std::string >() ) {
      p = CompareOp :: eNever ;
      return;
    }
    if( "VK_COMPARE_OP_NEVER" == j.get< std::string >() ) {
      p = CompareOp :: eNever ;
      return;
    }
    if( "Less" == j.get< std::string >() ) {
      p = CompareOp :: eLess ;
      return;
    }
    if( "eLess" == j.get< std::string >() ) {
      p = CompareOp :: eLess ;
      return;
    }
    if( "VK_COMPARE_OP_LESS" == j.get< std::string >() ) {
      p = CompareOp :: eLess ;
      return;
    }
    if( "Equal" == j.get< std::string >() ) {
      p = CompareOp :: eEqual ;
      return;
    }
    if( "eEqual" == j.get< std::string >() ) {
      p = CompareOp :: eEqual ;
      return;
    }
    if( "VK_COMPARE_OP_EQUAL" == j.get< std::string >() ) {
      p = CompareOp :: eEqual ;
      return;
    }
    if( "LessOrEqual" == j.get< std::string >() ) {
      p = CompareOp :: eLessOrEqual ;
      return;
    }
    if( "eLessOrEqual" == j.get< std::string >() ) {
      p = CompareOp :: eLessOrEqual ;
      return;
    }
    if( "VK_COMPARE_OP_LESS_OR_EQUAL" == j.get< std::string >() ) {
      p = CompareOp :: eLessOrEqual ;
      return;
    }
    if( "Greater" == j.get< std::string >() ) {
      p = CompareOp :: eGreater ;
      return;
    }
    if( "eGreater" == j.get< std::string >() ) {
      p = CompareOp :: eGreater ;
      return;
    }
    if( "VK_COMPARE_OP_GREATER" == j.get< std::string >() ) {
      p = CompareOp :: eGreater ;
      return;
    }
    if( "NotEqual" == j.get< std::string >() ) {
      p = CompareOp :: eNotEqual ;
      return;
    }
    if( "eNotEqual" == j.get< std::string >() ) {
      p = CompareOp :: eNotEqual ;
      return;
    }
    if( "VK_COMPARE_OP_NOT_EQUAL" == j.get< std::string >() ) {
      p = CompareOp :: eNotEqual ;
      return;
    }
    if( "GreaterOrEqual" == j.get< std::string >() ) {
      p = CompareOp :: eGreaterOrEqual ;
      return;
    }
    if( "eGreaterOrEqual" == j.get< std::string >() ) {
      p = CompareOp :: eGreaterOrEqual ;
      return;
    }
    if( "VK_COMPARE_OP_GREATER_OR_EQUAL" == j.get< std::string >() ) {
      p = CompareOp :: eGreaterOrEqual ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CompareOp" );
  }
  if( j.is_number() ) {
    p = CompareOp ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CompareOp" );
}
}
void from_json( const nlohmann::json &j, VkCompareOp &p ) {
  VULKAN_HPP_NAMESPACE :: CompareOp temp;
  from_json( j, temp );
  p = VkCompareOp ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DynamicState &p ) {
  if( DynamicState :: eViewport == p ) {
    j = "Viewport";
    return;
  }
  if( DynamicState :: eScissor == p ) {
    j = "Scissor";
    return;
  }
  if( DynamicState :: eLineWidth == p ) {
    j = "LineWidth";
    return;
  }
  if( DynamicState :: eDepthBias == p ) {
    j = "DepthBias";
    return;
  }
  if( DynamicState :: eBlendConstants == p ) {
    j = "BlendConstants";
    return;
  }
  if( DynamicState :: eDepthBounds == p ) {
    j = "DepthBounds";
    return;
  }
  if( DynamicState :: eStencilCompareMask == p ) {
    j = "StencilCompareMask";
    return;
  }
  if( DynamicState :: eStencilWriteMask == p ) {
    j = "StencilWriteMask";
    return;
  }
  if( DynamicState :: eStencilReference == p ) {
    j = "StencilReference";
    return;
  }
  if( DynamicState :: eViewportWScalingNV == p ) {
    j = "ViewportWScalingNV";
    return;
  }
  if( DynamicState :: eDiscardRectangleEXT == p ) {
    j = "DiscardRectangleEXT";
    return;
  }
  if( DynamicState :: eSampleLocationsEXT == p ) {
    j = "SampleLocationsEXT";
    return;
  }
  if( DynamicState :: eRayTracingPipelineStackSizeKHR == p ) {
    j = "RayTracingPipelineStackSizeKHR";
    return;
  }
  if( DynamicState :: eViewportShadingRatePaletteNV == p ) {
    j = "ViewportShadingRatePaletteNV";
    return;
  }
  if( DynamicState :: eViewportCoarseSampleOrderNV == p ) {
    j = "ViewportCoarseSampleOrderNV";
    return;
  }
  if( DynamicState :: eExclusiveScissorNV == p ) {
    j = "ExclusiveScissorNV";
    return;
  }
  if( DynamicState :: eFragmentShadingRateKHR == p ) {
    j = "FragmentShadingRateKHR";
    return;
  }
  if( DynamicState :: eLineStippleEXT == p ) {
    j = "LineStippleEXT";
    return;
  }
  if( DynamicState :: eCullModeEXT == p ) {
    j = "CullModeEXT";
    return;
  }
  if( DynamicState :: eFrontFaceEXT == p ) {
    j = "FrontFaceEXT";
    return;
  }
  if( DynamicState :: ePrimitiveTopologyEXT == p ) {
    j = "PrimitiveTopologyEXT";
    return;
  }
  if( DynamicState :: eViewportWithCountEXT == p ) {
    j = "ViewportWithCountEXT";
    return;
  }
  if( DynamicState :: eScissorWithCountEXT == p ) {
    j = "ScissorWithCountEXT";
    return;
  }
  if( DynamicState :: eVertexInputBindingStrideEXT == p ) {
    j = "VertexInputBindingStrideEXT";
    return;
  }
  if( DynamicState :: eDepthTestEnableEXT == p ) {
    j = "DepthTestEnableEXT";
    return;
  }
  if( DynamicState :: eDepthWriteEnableEXT == p ) {
    j = "DepthWriteEnableEXT";
    return;
  }
  if( DynamicState :: eDepthCompareOpEXT == p ) {
    j = "DepthCompareOpEXT";
    return;
  }
  if( DynamicState :: eDepthBoundsTestEnableEXT == p ) {
    j = "DepthBoundsTestEnableEXT";
    return;
  }
  if( DynamicState :: eStencilTestEnableEXT == p ) {
    j = "StencilTestEnableEXT";
    return;
  }
  if( DynamicState :: eStencilOpEXT == p ) {
    j = "StencilOpEXT";
    return;
  }
  if( DynamicState :: eVertexInputEXT == p ) {
    j = "VertexInputEXT";
    return;
  }
  if( DynamicState :: ePatchControlPointsEXT == p ) {
    j = "PatchControlPointsEXT";
    return;
  }
  if( DynamicState :: eRasterizerDiscardEnableEXT == p ) {
    j = "RasterizerDiscardEnableEXT";
    return;
  }
  if( DynamicState :: eDepthBiasEnableEXT == p ) {
    j = "DepthBiasEnableEXT";
    return;
  }
  if( DynamicState :: eLogicOpEXT == p ) {
    j = "LogicOpEXT";
    return;
  }
  if( DynamicState :: ePrimitiveRestartEnableEXT == p ) {
    j = "PrimitiveRestartEnableEXT";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkDynamicState &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DynamicState ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DynamicState &p ) {
  if( j.is_string() ) {
    if( "Viewport" == j.get< std::string >() ) {
      p = DynamicState :: eViewport ;
      return;
    }
    if( "eViewport" == j.get< std::string >() ) {
      p = DynamicState :: eViewport ;
      return;
    }
    if( "VK_DYNAMIC_STATE_VIEWPORT" == j.get< std::string >() ) {
      p = DynamicState :: eViewport ;
      return;
    }
    if( "Scissor" == j.get< std::string >() ) {
      p = DynamicState :: eScissor ;
      return;
    }
    if( "eScissor" == j.get< std::string >() ) {
      p = DynamicState :: eScissor ;
      return;
    }
    if( "VK_DYNAMIC_STATE_SCISSOR" == j.get< std::string >() ) {
      p = DynamicState :: eScissor ;
      return;
    }
    if( "LineWidth" == j.get< std::string >() ) {
      p = DynamicState :: eLineWidth ;
      return;
    }
    if( "eLineWidth" == j.get< std::string >() ) {
      p = DynamicState :: eLineWidth ;
      return;
    }
    if( "VK_DYNAMIC_STATE_LINE_WIDTH" == j.get< std::string >() ) {
      p = DynamicState :: eLineWidth ;
      return;
    }
    if( "DepthBias" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBias ;
      return;
    }
    if( "eDepthBias" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBias ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DEPTH_BIAS" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBias ;
      return;
    }
    if( "BlendConstants" == j.get< std::string >() ) {
      p = DynamicState :: eBlendConstants ;
      return;
    }
    if( "eBlendConstants" == j.get< std::string >() ) {
      p = DynamicState :: eBlendConstants ;
      return;
    }
    if( "VK_DYNAMIC_STATE_BLEND_CONSTANTS" == j.get< std::string >() ) {
      p = DynamicState :: eBlendConstants ;
      return;
    }
    if( "DepthBounds" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBounds ;
      return;
    }
    if( "eDepthBounds" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBounds ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DEPTH_BOUNDS" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBounds ;
      return;
    }
    if( "StencilCompareMask" == j.get< std::string >() ) {
      p = DynamicState :: eStencilCompareMask ;
      return;
    }
    if( "eStencilCompareMask" == j.get< std::string >() ) {
      p = DynamicState :: eStencilCompareMask ;
      return;
    }
    if( "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK" == j.get< std::string >() ) {
      p = DynamicState :: eStencilCompareMask ;
      return;
    }
    if( "StencilWriteMask" == j.get< std::string >() ) {
      p = DynamicState :: eStencilWriteMask ;
      return;
    }
    if( "eStencilWriteMask" == j.get< std::string >() ) {
      p = DynamicState :: eStencilWriteMask ;
      return;
    }
    if( "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK" == j.get< std::string >() ) {
      p = DynamicState :: eStencilWriteMask ;
      return;
    }
    if( "StencilReference" == j.get< std::string >() ) {
      p = DynamicState :: eStencilReference ;
      return;
    }
    if( "eStencilReference" == j.get< std::string >() ) {
      p = DynamicState :: eStencilReference ;
      return;
    }
    if( "VK_DYNAMIC_STATE_STENCIL_REFERENCE" == j.get< std::string >() ) {
      p = DynamicState :: eStencilReference ;
      return;
    }
    if( "ViewportWScalingNV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportWScalingNV ;
      return;
    }
    if( "eViewportWScalingNV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportWScalingNV ;
      return;
    }
    if( "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportWScalingNV ;
      return;
    }
    if( "DiscardRectangleEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDiscardRectangleEXT ;
      return;
    }
    if( "eDiscardRectangleEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDiscardRectangleEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eDiscardRectangleEXT ;
      return;
    }
    if( "SampleLocationsEXT" == j.get< std::string >() ) {
      p = DynamicState :: eSampleLocationsEXT ;
      return;
    }
    if( "eSampleLocationsEXT" == j.get< std::string >() ) {
      p = DynamicState :: eSampleLocationsEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eSampleLocationsEXT ;
      return;
    }
    if( "RayTracingPipelineStackSizeKHR" == j.get< std::string >() ) {
      p = DynamicState :: eRayTracingPipelineStackSizeKHR ;
      return;
    }
    if( "eRayTracingPipelineStackSizeKHR" == j.get< std::string >() ) {
      p = DynamicState :: eRayTracingPipelineStackSizeKHR ;
      return;
    }
    if( "VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR" == j.get< std::string >() ) {
      p = DynamicState :: eRayTracingPipelineStackSizeKHR ;
      return;
    }
    if( "ViewportShadingRatePaletteNV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportShadingRatePaletteNV ;
      return;
    }
    if( "eViewportShadingRatePaletteNV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportShadingRatePaletteNV ;
      return;
    }
    if( "VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportShadingRatePaletteNV ;
      return;
    }
    if( "ViewportCoarseSampleOrderNV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportCoarseSampleOrderNV ;
      return;
    }
    if( "eViewportCoarseSampleOrderNV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportCoarseSampleOrderNV ;
      return;
    }
    if( "VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportCoarseSampleOrderNV ;
      return;
    }
    if( "ExclusiveScissorNV" == j.get< std::string >() ) {
      p = DynamicState :: eExclusiveScissorNV ;
      return;
    }
    if( "eExclusiveScissorNV" == j.get< std::string >() ) {
      p = DynamicState :: eExclusiveScissorNV ;
      return;
    }
    if( "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV" == j.get< std::string >() ) {
      p = DynamicState :: eExclusiveScissorNV ;
      return;
    }
    if( "FragmentShadingRateKHR" == j.get< std::string >() ) {
      p = DynamicState :: eFragmentShadingRateKHR ;
      return;
    }
    if( "eFragmentShadingRateKHR" == j.get< std::string >() ) {
      p = DynamicState :: eFragmentShadingRateKHR ;
      return;
    }
    if( "VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR" == j.get< std::string >() ) {
      p = DynamicState :: eFragmentShadingRateKHR ;
      return;
    }
    if( "LineStippleEXT" == j.get< std::string >() ) {
      p = DynamicState :: eLineStippleEXT ;
      return;
    }
    if( "eLineStippleEXT" == j.get< std::string >() ) {
      p = DynamicState :: eLineStippleEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_LINE_STIPPLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eLineStippleEXT ;
      return;
    }
    if( "CullModeEXT" == j.get< std::string >() ) {
      p = DynamicState :: eCullModeEXT ;
      return;
    }
    if( "eCullModeEXT" == j.get< std::string >() ) {
      p = DynamicState :: eCullModeEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_CULL_MODE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eCullModeEXT ;
      return;
    }
    if( "FrontFaceEXT" == j.get< std::string >() ) {
      p = DynamicState :: eFrontFaceEXT ;
      return;
    }
    if( "eFrontFaceEXT" == j.get< std::string >() ) {
      p = DynamicState :: eFrontFaceEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_FRONT_FACE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eFrontFaceEXT ;
      return;
    }
    if( "PrimitiveTopologyEXT" == j.get< std::string >() ) {
      p = DynamicState :: ePrimitiveTopologyEXT ;
      return;
    }
    if( "ePrimitiveTopologyEXT" == j.get< std::string >() ) {
      p = DynamicState :: ePrimitiveTopologyEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT" == j.get< std::string >() ) {
      p = DynamicState :: ePrimitiveTopologyEXT ;
      return;
    }
    if( "ViewportWithCountEXT" == j.get< std::string >() ) {
      p = DynamicState :: eViewportWithCountEXT ;
      return;
    }
    if( "eViewportWithCountEXT" == j.get< std::string >() ) {
      p = DynamicState :: eViewportWithCountEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eViewportWithCountEXT ;
      return;
    }
    if( "ScissorWithCountEXT" == j.get< std::string >() ) {
      p = DynamicState :: eScissorWithCountEXT ;
      return;
    }
    if( "eScissorWithCountEXT" == j.get< std::string >() ) {
      p = DynamicState :: eScissorWithCountEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eScissorWithCountEXT ;
      return;
    }
    if( "VertexInputBindingStrideEXT" == j.get< std::string >() ) {
      p = DynamicState :: eVertexInputBindingStrideEXT ;
      return;
    }
    if( "eVertexInputBindingStrideEXT" == j.get< std::string >() ) {
      p = DynamicState :: eVertexInputBindingStrideEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eVertexInputBindingStrideEXT ;
      return;
    }
    if( "DepthTestEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthTestEnableEXT ;
      return;
    }
    if( "eDepthTestEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthTestEnableEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthTestEnableEXT ;
      return;
    }
    if( "DepthWriteEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthWriteEnableEXT ;
      return;
    }
    if( "eDepthWriteEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthWriteEnableEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthWriteEnableEXT ;
      return;
    }
    if( "DepthCompareOpEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthCompareOpEXT ;
      return;
    }
    if( "eDepthCompareOpEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthCompareOpEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthCompareOpEXT ;
      return;
    }
    if( "DepthBoundsTestEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBoundsTestEnableEXT ;
      return;
    }
    if( "eDepthBoundsTestEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBoundsTestEnableEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBoundsTestEnableEXT ;
      return;
    }
    if( "StencilTestEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eStencilTestEnableEXT ;
      return;
    }
    if( "eStencilTestEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eStencilTestEnableEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eStencilTestEnableEXT ;
      return;
    }
    if( "StencilOpEXT" == j.get< std::string >() ) {
      p = DynamicState :: eStencilOpEXT ;
      return;
    }
    if( "eStencilOpEXT" == j.get< std::string >() ) {
      p = DynamicState :: eStencilOpEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_STENCIL_OP_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eStencilOpEXT ;
      return;
    }
    if( "VertexInputEXT" == j.get< std::string >() ) {
      p = DynamicState :: eVertexInputEXT ;
      return;
    }
    if( "eVertexInputEXT" == j.get< std::string >() ) {
      p = DynamicState :: eVertexInputEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_VERTEX_INPUT_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eVertexInputEXT ;
      return;
    }
    if( "PatchControlPointsEXT" == j.get< std::string >() ) {
      p = DynamicState :: ePatchControlPointsEXT ;
      return;
    }
    if( "ePatchControlPointsEXT" == j.get< std::string >() ) {
      p = DynamicState :: ePatchControlPointsEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT" == j.get< std::string >() ) {
      p = DynamicState :: ePatchControlPointsEXT ;
      return;
    }
    if( "RasterizerDiscardEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eRasterizerDiscardEnableEXT ;
      return;
    }
    if( "eRasterizerDiscardEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eRasterizerDiscardEnableEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eRasterizerDiscardEnableEXT ;
      return;
    }
    if( "DepthBiasEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBiasEnableEXT ;
      return;
    }
    if( "eDepthBiasEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBiasEnableEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBiasEnableEXT ;
      return;
    }
    if( "LogicOpEXT" == j.get< std::string >() ) {
      p = DynamicState :: eLogicOpEXT ;
      return;
    }
    if( "eLogicOpEXT" == j.get< std::string >() ) {
      p = DynamicState :: eLogicOpEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_LOGIC_OP_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eLogicOpEXT ;
      return;
    }
    if( "PrimitiveRestartEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: ePrimitiveRestartEnableEXT ;
      return;
    }
    if( "ePrimitiveRestartEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: ePrimitiveRestartEnableEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: ePrimitiveRestartEnableEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DynamicState" );
  }
  if( j.is_number() ) {
    p = DynamicState ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DynamicState" );
}
}
void from_json( const nlohmann::json &j, VkDynamicState &p ) {
  VULKAN_HPP_NAMESPACE :: DynamicState temp;
  from_json( j, temp );
  p = VkDynamicState ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FrontFace &p ) {
  if( FrontFace :: eCounterClockwise == p ) {
    j = "CounterClockwise";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkFrontFace &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: FrontFace ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, FrontFace &p ) {
  if( j.is_string() ) {
    if( "CounterClockwise" == j.get< std::string >() ) {
      p = FrontFace :: eCounterClockwise ;
      return;
    }
    if( "eCounterClockwise" == j.get< std::string >() ) {
      p = FrontFace :: eCounterClockwise ;
      return;
    }
    if( "VK_FRONT_FACE_COUNTER_CLOCKWISE" == j.get< std::string >() ) {
      p = FrontFace :: eCounterClockwise ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for FrontFace" );
  }
  if( j.is_number() ) {
    p = FrontFace ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FrontFace" );
}
}
void from_json( const nlohmann::json &j, VkFrontFace &p ) {
  VULKAN_HPP_NAMESPACE :: FrontFace temp;
  from_json( j, temp );
  p = VkFrontFace ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const LogicOp &p ) {
  if( LogicOp :: eClear == p ) {
    j = "Clear";
    return;
  }
  if( LogicOp :: eAnd == p ) {
    j = "And";
    return;
  }
  if( LogicOp :: eAndReverse == p ) {
    j = "AndReverse";
    return;
  }
  if( LogicOp :: eCopy == p ) {
    j = "Copy";
    return;
  }
  if( LogicOp :: eAndInverted == p ) {
    j = "AndInverted";
    return;
  }
  if( LogicOp :: eNoOp == p ) {
    j = "NoOp";
    return;
  }
  if( LogicOp :: eXor == p ) {
    j = "Xor";
    return;
  }
  if( LogicOp :: eOr == p ) {
    j = "Or";
    return;
  }
  if( LogicOp :: eNor == p ) {
    j = "Nor";
    return;
  }
  if( LogicOp :: eEquivalent == p ) {
    j = "Equivalent";
    return;
  }
  if( LogicOp :: eInvert == p ) {
    j = "Invert";
    return;
  }
  if( LogicOp :: eOrReverse == p ) {
    j = "OrReverse";
    return;
  }
  if( LogicOp :: eCopyInverted == p ) {
    j = "CopyInverted";
    return;
  }
  if( LogicOp :: eOrInverted == p ) {
    j = "OrInverted";
    return;
  }
  if( LogicOp :: eNand == p ) {
    j = "Nand";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkLogicOp &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: LogicOp ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, LogicOp &p ) {
  if( j.is_string() ) {
    if( "Clear" == j.get< std::string >() ) {
      p = LogicOp :: eClear ;
      return;
    }
    if( "eClear" == j.get< std::string >() ) {
      p = LogicOp :: eClear ;
      return;
    }
    if( "VK_LOGIC_OP_CLEAR" == j.get< std::string >() ) {
      p = LogicOp :: eClear ;
      return;
    }
    if( "And" == j.get< std::string >() ) {
      p = LogicOp :: eAnd ;
      return;
    }
    if( "eAnd" == j.get< std::string >() ) {
      p = LogicOp :: eAnd ;
      return;
    }
    if( "VK_LOGIC_OP_AND" == j.get< std::string >() ) {
      p = LogicOp :: eAnd ;
      return;
    }
    if( "AndReverse" == j.get< std::string >() ) {
      p = LogicOp :: eAndReverse ;
      return;
    }
    if( "eAndReverse" == j.get< std::string >() ) {
      p = LogicOp :: eAndReverse ;
      return;
    }
    if( "VK_LOGIC_OP_AND_REVERSE" == j.get< std::string >() ) {
      p = LogicOp :: eAndReverse ;
      return;
    }
    if( "Copy" == j.get< std::string >() ) {
      p = LogicOp :: eCopy ;
      return;
    }
    if( "eCopy" == j.get< std::string >() ) {
      p = LogicOp :: eCopy ;
      return;
    }
    if( "VK_LOGIC_OP_COPY" == j.get< std::string >() ) {
      p = LogicOp :: eCopy ;
      return;
    }
    if( "AndInverted" == j.get< std::string >() ) {
      p = LogicOp :: eAndInverted ;
      return;
    }
    if( "eAndInverted" == j.get< std::string >() ) {
      p = LogicOp :: eAndInverted ;
      return;
    }
    if( "VK_LOGIC_OP_AND_INVERTED" == j.get< std::string >() ) {
      p = LogicOp :: eAndInverted ;
      return;
    }
    if( "NoOp" == j.get< std::string >() ) {
      p = LogicOp :: eNoOp ;
      return;
    }
    if( "eNoOp" == j.get< std::string >() ) {
      p = LogicOp :: eNoOp ;
      return;
    }
    if( "VK_LOGIC_OP_NO_OP" == j.get< std::string >() ) {
      p = LogicOp :: eNoOp ;
      return;
    }
    if( "Xor" == j.get< std::string >() ) {
      p = LogicOp :: eXor ;
      return;
    }
    if( "eXor" == j.get< std::string >() ) {
      p = LogicOp :: eXor ;
      return;
    }
    if( "VK_LOGIC_OP_XOR" == j.get< std::string >() ) {
      p = LogicOp :: eXor ;
      return;
    }
    if( "Or" == j.get< std::string >() ) {
      p = LogicOp :: eOr ;
      return;
    }
    if( "eOr" == j.get< std::string >() ) {
      p = LogicOp :: eOr ;
      return;
    }
    if( "VK_LOGIC_OP_OR" == j.get< std::string >() ) {
      p = LogicOp :: eOr ;
      return;
    }
    if( "Nor" == j.get< std::string >() ) {
      p = LogicOp :: eNor ;
      return;
    }
    if( "eNor" == j.get< std::string >() ) {
      p = LogicOp :: eNor ;
      return;
    }
    if( "VK_LOGIC_OP_NOR" == j.get< std::string >() ) {
      p = LogicOp :: eNor ;
      return;
    }
    if( "Equivalent" == j.get< std::string >() ) {
      p = LogicOp :: eEquivalent ;
      return;
    }
    if( "eEquivalent" == j.get< std::string >() ) {
      p = LogicOp :: eEquivalent ;
      return;
    }
    if( "VK_LOGIC_OP_EQUIVALENT" == j.get< std::string >() ) {
      p = LogicOp :: eEquivalent ;
      return;
    }
    if( "Invert" == j.get< std::string >() ) {
      p = LogicOp :: eInvert ;
      return;
    }
    if( "eInvert" == j.get< std::string >() ) {
      p = LogicOp :: eInvert ;
      return;
    }
    if( "VK_LOGIC_OP_INVERT" == j.get< std::string >() ) {
      p = LogicOp :: eInvert ;
      return;
    }
    if( "OrReverse" == j.get< std::string >() ) {
      p = LogicOp :: eOrReverse ;
      return;
    }
    if( "eOrReverse" == j.get< std::string >() ) {
      p = LogicOp :: eOrReverse ;
      return;
    }
    if( "VK_LOGIC_OP_OR_REVERSE" == j.get< std::string >() ) {
      p = LogicOp :: eOrReverse ;
      return;
    }
    if( "CopyInverted" == j.get< std::string >() ) {
      p = LogicOp :: eCopyInverted ;
      return;
    }
    if( "eCopyInverted" == j.get< std::string >() ) {
      p = LogicOp :: eCopyInverted ;
      return;
    }
    if( "VK_LOGIC_OP_COPY_INVERTED" == j.get< std::string >() ) {
      p = LogicOp :: eCopyInverted ;
      return;
    }
    if( "OrInverted" == j.get< std::string >() ) {
      p = LogicOp :: eOrInverted ;
      return;
    }
    if( "eOrInverted" == j.get< std::string >() ) {
      p = LogicOp :: eOrInverted ;
      return;
    }
    if( "VK_LOGIC_OP_OR_INVERTED" == j.get< std::string >() ) {
      p = LogicOp :: eOrInverted ;
      return;
    }
    if( "Nand" == j.get< std::string >() ) {
      p = LogicOp :: eNand ;
      return;
    }
    if( "eNand" == j.get< std::string >() ) {
      p = LogicOp :: eNand ;
      return;
    }
    if( "VK_LOGIC_OP_NAND" == j.get< std::string >() ) {
      p = LogicOp :: eNand ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for LogicOp" );
  }
  if( j.is_number() ) {
    p = LogicOp ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for LogicOp" );
}
}
void from_json( const nlohmann::json &j, VkLogicOp &p ) {
  VULKAN_HPP_NAMESPACE :: LogicOp temp;
  from_json( j, temp );
  p = VkLogicOp ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PolygonMode &p ) {
  if( PolygonMode :: eFill == p ) {
    j = "Fill";
    return;
  }
  if( PolygonMode :: eLine == p ) {
    j = "Line";
    return;
  }
  if( PolygonMode :: ePoint == p ) {
    j = "Point";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkPolygonMode &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PolygonMode ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PolygonMode &p ) {
  if( j.is_string() ) {
    if( "Fill" == j.get< std::string >() ) {
      p = PolygonMode :: eFill ;
      return;
    }
    if( "eFill" == j.get< std::string >() ) {
      p = PolygonMode :: eFill ;
      return;
    }
    if( "VK_POLYGON_MODE_FILL" == j.get< std::string >() ) {
      p = PolygonMode :: eFill ;
      return;
    }
    if( "Line" == j.get< std::string >() ) {
      p = PolygonMode :: eLine ;
      return;
    }
    if( "eLine" == j.get< std::string >() ) {
      p = PolygonMode :: eLine ;
      return;
    }
    if( "VK_POLYGON_MODE_LINE" == j.get< std::string >() ) {
      p = PolygonMode :: eLine ;
      return;
    }
    if( "Point" == j.get< std::string >() ) {
      p = PolygonMode :: ePoint ;
      return;
    }
    if( "ePoint" == j.get< std::string >() ) {
      p = PolygonMode :: ePoint ;
      return;
    }
    if( "VK_POLYGON_MODE_POINT" == j.get< std::string >() ) {
      p = PolygonMode :: ePoint ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PolygonMode" );
  }
  if( j.is_number() ) {
    p = PolygonMode ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PolygonMode" );
}
}
void from_json( const nlohmann::json &j, VkPolygonMode &p ) {
  VULKAN_HPP_NAMESPACE :: PolygonMode temp;
  from_json( j, temp );
  p = VkPolygonMode ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PrimitiveTopology &p ) {
  if( PrimitiveTopology :: ePointList == p ) {
    j = "PointList";
    return;
  }
  if( PrimitiveTopology :: eLineList == p ) {
    j = "LineList";
    return;
  }
  if( PrimitiveTopology :: eLineStrip == p ) {
    j = "LineStrip";
    return;
  }
  if( PrimitiveTopology :: eTriangleList == p ) {
    j = "TriangleList";
    return;
  }
  if( PrimitiveTopology :: eTriangleStrip == p ) {
    j = "TriangleStrip";
    return;
  }
  if( PrimitiveTopology :: eTriangleFan == p ) {
    j = "TriangleFan";
    return;
  }
  if( PrimitiveTopology :: eLineListWithAdjacency == p ) {
    j = "LineListWithAdjacency";
    return;
  }
  if( PrimitiveTopology :: eLineStripWithAdjacency == p ) {
    j = "LineStripWithAdjacency";
    return;
  }
  if( PrimitiveTopology :: eTriangleListWithAdjacency == p ) {
    j = "TriangleListWithAdjacency";
    return;
  }
  if( PrimitiveTopology :: eTriangleStripWithAdjacency == p ) {
    j = "TriangleStripWithAdjacency";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkPrimitiveTopology &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PrimitiveTopology ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PrimitiveTopology &p ) {
  if( j.is_string() ) {
    if( "PointList" == j.get< std::string >() ) {
      p = PrimitiveTopology :: ePointList ;
      return;
    }
    if( "ePointList" == j.get< std::string >() ) {
      p = PrimitiveTopology :: ePointList ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_POINT_LIST" == j.get< std::string >() ) {
      p = PrimitiveTopology :: ePointList ;
      return;
    }
    if( "LineList" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineList ;
      return;
    }
    if( "eLineList" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineList ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_LINE_LIST" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineList ;
      return;
    }
    if( "LineStrip" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineStrip ;
      return;
    }
    if( "eLineStrip" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineStrip ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineStrip ;
      return;
    }
    if( "TriangleList" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleList ;
      return;
    }
    if( "eTriangleList" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleList ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleList ;
      return;
    }
    if( "TriangleStrip" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleStrip ;
      return;
    }
    if( "eTriangleStrip" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleStrip ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleStrip ;
      return;
    }
    if( "TriangleFan" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleFan ;
      return;
    }
    if( "eTriangleFan" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleFan ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleFan ;
      return;
    }
    if( "LineListWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineListWithAdjacency ;
      return;
    }
    if( "eLineListWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineListWithAdjacency ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineListWithAdjacency ;
      return;
    }
    if( "LineStripWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineStripWithAdjacency ;
      return;
    }
    if( "eLineStripWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineStripWithAdjacency ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineStripWithAdjacency ;
      return;
    }
    if( "TriangleListWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleListWithAdjacency ;
      return;
    }
    if( "eTriangleListWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleListWithAdjacency ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleListWithAdjacency ;
      return;
    }
    if( "TriangleStripWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleStripWithAdjacency ;
      return;
    }
    if( "eTriangleStripWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleStripWithAdjacency ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleStripWithAdjacency ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PrimitiveTopology" );
  }
  if( j.is_number() ) {
    p = PrimitiveTopology ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PrimitiveTopology" );
}
}
void from_json( const nlohmann::json &j, VkPrimitiveTopology &p ) {
  VULKAN_HPP_NAMESPACE :: PrimitiveTopology temp;
  from_json( j, temp );
  p = VkPrimitiveTopology ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const StencilOp &p ) {
  if( StencilOp :: eKeep == p ) {
    j = "Keep";
    return;
  }
  if( StencilOp :: eZero == p ) {
    j = "Zero";
    return;
  }
  if( StencilOp :: eReplace == p ) {
    j = "Replace";
    return;
  }
  if( StencilOp :: eIncrementAndClamp == p ) {
    j = "IncrementAndClamp";
    return;
  }
  if( StencilOp :: eDecrementAndClamp == p ) {
    j = "DecrementAndClamp";
    return;
  }
  if( StencilOp :: eInvert == p ) {
    j = "Invert";
    return;
  }
  if( StencilOp :: eIncrementAndWrap == p ) {
    j = "IncrementAndWrap";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkStencilOp &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: StencilOp ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, StencilOp &p ) {
  if( j.is_string() ) {
    if( "Keep" == j.get< std::string >() ) {
      p = StencilOp :: eKeep ;
      return;
    }
    if( "eKeep" == j.get< std::string >() ) {
      p = StencilOp :: eKeep ;
      return;
    }
    if( "VK_STENCIL_OP_KEEP" == j.get< std::string >() ) {
      p = StencilOp :: eKeep ;
      return;
    }
    if( "Zero" == j.get< std::string >() ) {
      p = StencilOp :: eZero ;
      return;
    }
    if( "eZero" == j.get< std::string >() ) {
      p = StencilOp :: eZero ;
      return;
    }
    if( "VK_STENCIL_OP_ZERO" == j.get< std::string >() ) {
      p = StencilOp :: eZero ;
      return;
    }
    if( "Replace" == j.get< std::string >() ) {
      p = StencilOp :: eReplace ;
      return;
    }
    if( "eReplace" == j.get< std::string >() ) {
      p = StencilOp :: eReplace ;
      return;
    }
    if( "VK_STENCIL_OP_REPLACE" == j.get< std::string >() ) {
      p = StencilOp :: eReplace ;
      return;
    }
    if( "IncrementAndClamp" == j.get< std::string >() ) {
      p = StencilOp :: eIncrementAndClamp ;
      return;
    }
    if( "eIncrementAndClamp" == j.get< std::string >() ) {
      p = StencilOp :: eIncrementAndClamp ;
      return;
    }
    if( "VK_STENCIL_OP_INCREMENT_AND_CLAMP" == j.get< std::string >() ) {
      p = StencilOp :: eIncrementAndClamp ;
      return;
    }
    if( "DecrementAndClamp" == j.get< std::string >() ) {
      p = StencilOp :: eDecrementAndClamp ;
      return;
    }
    if( "eDecrementAndClamp" == j.get< std::string >() ) {
      p = StencilOp :: eDecrementAndClamp ;
      return;
    }
    if( "VK_STENCIL_OP_DECREMENT_AND_CLAMP" == j.get< std::string >() ) {
      p = StencilOp :: eDecrementAndClamp ;
      return;
    }
    if( "Invert" == j.get< std::string >() ) {
      p = StencilOp :: eInvert ;
      return;
    }
    if( "eInvert" == j.get< std::string >() ) {
      p = StencilOp :: eInvert ;
      return;
    }
    if( "VK_STENCIL_OP_INVERT" == j.get< std::string >() ) {
      p = StencilOp :: eInvert ;
      return;
    }
    if( "IncrementAndWrap" == j.get< std::string >() ) {
      p = StencilOp :: eIncrementAndWrap ;
      return;
    }
    if( "eIncrementAndWrap" == j.get< std::string >() ) {
      p = StencilOp :: eIncrementAndWrap ;
      return;
    }
    if( "VK_STENCIL_OP_INCREMENT_AND_WRAP" == j.get< std::string >() ) {
      p = StencilOp :: eIncrementAndWrap ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for StencilOp" );
  }
  if( j.is_number() ) {
    p = StencilOp ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for StencilOp" );
}
}
void from_json( const nlohmann::json &j, VkStencilOp &p ) {
  VULKAN_HPP_NAMESPACE :: StencilOp temp;
  from_json( j, temp );
  p = VkStencilOp ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const VertexInputRate &p ) {
  if( VertexInputRate :: eVertex == p ) {
    j = "Vertex";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkVertexInputRate &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: VertexInputRate ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, VertexInputRate &p ) {
  if( j.is_string() ) {
    if( "Vertex" == j.get< std::string >() ) {
      p = VertexInputRate :: eVertex ;
      return;
    }
    if( "eVertex" == j.get< std::string >() ) {
      p = VertexInputRate :: eVertex ;
      return;
    }
    if( "VK_VERTEX_INPUT_RATE_VERTEX" == j.get< std::string >() ) {
      p = VertexInputRate :: eVertex ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for VertexInputRate" );
  }
  if( j.is_number() ) {
    p = VertexInputRate ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VertexInputRate" );
}
}
void from_json( const nlohmann::json &j, VkVertexInputRate &p ) {
  VULKAN_HPP_NAMESPACE :: VertexInputRate temp;
  from_json( j, temp );
  p = VkVertexInputRate ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BorderColor &p ) {
  if( BorderColor :: eFloatTransparentBlack == p ) {
    j = "FloatTransparentBlack";
    return;
  }
  if( BorderColor :: eIntTransparentBlack == p ) {
    j = "IntTransparentBlack";
    return;
  }
  if( BorderColor :: eFloatOpaqueBlack == p ) {
    j = "FloatOpaqueBlack";
    return;
  }
  if( BorderColor :: eIntOpaqueBlack == p ) {
    j = "IntOpaqueBlack";
    return;
  }
  if( BorderColor :: eFloatOpaqueWhite == p ) {
    j = "FloatOpaqueWhite";
    return;
  }
  if( BorderColor :: eIntOpaqueWhite == p ) {
    j = "IntOpaqueWhite";
    return;
  }
  if( BorderColor :: eFloatCustomEXT == p ) {
    j = "FloatCustomEXT";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkBorderColor &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BorderColor ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BorderColor &p ) {
  if( j.is_string() ) {
    if( "FloatTransparentBlack" == j.get< std::string >() ) {
      p = BorderColor :: eFloatTransparentBlack ;
      return;
    }
    if( "eFloatTransparentBlack" == j.get< std::string >() ) {
      p = BorderColor :: eFloatTransparentBlack ;
      return;
    }
    if( "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK" == j.get< std::string >() ) {
      p = BorderColor :: eFloatTransparentBlack ;
      return;
    }
    if( "IntTransparentBlack" == j.get< std::string >() ) {
      p = BorderColor :: eIntTransparentBlack ;
      return;
    }
    if( "eIntTransparentBlack" == j.get< std::string >() ) {
      p = BorderColor :: eIntTransparentBlack ;
      return;
    }
    if( "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK" == j.get< std::string >() ) {
      p = BorderColor :: eIntTransparentBlack ;
      return;
    }
    if( "FloatOpaqueBlack" == j.get< std::string >() ) {
      p = BorderColor :: eFloatOpaqueBlack ;
      return;
    }
    if( "eFloatOpaqueBlack" == j.get< std::string >() ) {
      p = BorderColor :: eFloatOpaqueBlack ;
      return;
    }
    if( "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK" == j.get< std::string >() ) {
      p = BorderColor :: eFloatOpaqueBlack ;
      return;
    }
    if( "IntOpaqueBlack" == j.get< std::string >() ) {
      p = BorderColor :: eIntOpaqueBlack ;
      return;
    }
    if( "eIntOpaqueBlack" == j.get< std::string >() ) {
      p = BorderColor :: eIntOpaqueBlack ;
      return;
    }
    if( "VK_BORDER_COLOR_INT_OPAQUE_BLACK" == j.get< std::string >() ) {
      p = BorderColor :: eIntOpaqueBlack ;
      return;
    }
    if( "FloatOpaqueWhite" == j.get< std::string >() ) {
      p = BorderColor :: eFloatOpaqueWhite ;
      return;
    }
    if( "eFloatOpaqueWhite" == j.get< std::string >() ) {
      p = BorderColor :: eFloatOpaqueWhite ;
      return;
    }
    if( "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE" == j.get< std::string >() ) {
      p = BorderColor :: eFloatOpaqueWhite ;
      return;
    }
    if( "IntOpaqueWhite" == j.get< std::string >() ) {
      p = BorderColor :: eIntOpaqueWhite ;
      return;
    }
    if( "eIntOpaqueWhite" == j.get< std::string >() ) {
      p = BorderColor :: eIntOpaqueWhite ;
      return;
    }
    if( "VK_BORDER_COLOR_INT_OPAQUE_WHITE" == j.get< std::string >() ) {
      p = BorderColor :: eIntOpaqueWhite ;
      return;
    }
    if( "FloatCustomEXT" == j.get< std::string >() ) {
      p = BorderColor :: eFloatCustomEXT ;
      return;
    }
    if( "eFloatCustomEXT" == j.get< std::string >() ) {
      p = BorderColor :: eFloatCustomEXT ;
      return;
    }
    if( "VK_BORDER_COLOR_FLOAT_CUSTOM_EXT" == j.get< std::string >() ) {
      p = BorderColor :: eFloatCustomEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BorderColor" );
  }
  if( j.is_number() ) {
    p = BorderColor ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BorderColor" );
}
}
void from_json( const nlohmann::json &j, VkBorderColor &p ) {
  VULKAN_HPP_NAMESPACE :: BorderColor temp;
  from_json( j, temp );
  p = VkBorderColor ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const Filter &p ) {
  if( Filter :: eNearest == p ) {
    j = "Nearest";
    return;
  }
  if( Filter :: eLinear == p ) {
    j = "Linear";
    return;
  }
  if( Filter :: eCubicIMG == p ) {
    j = "CubicIMG";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkFilter &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: Filter ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, Filter &p ) {
  if( j.is_string() ) {
    if( "Nearest" == j.get< std::string >() ) {
      p = Filter :: eNearest ;
      return;
    }
    if( "eNearest" == j.get< std::string >() ) {
      p = Filter :: eNearest ;
      return;
    }
    if( "VK_FILTER_NEAREST" == j.get< std::string >() ) {
      p = Filter :: eNearest ;
      return;
    }
    if( "Linear" == j.get< std::string >() ) {
      p = Filter :: eLinear ;
      return;
    }
    if( "eLinear" == j.get< std::string >() ) {
      p = Filter :: eLinear ;
      return;
    }
    if( "VK_FILTER_LINEAR" == j.get< std::string >() ) {
      p = Filter :: eLinear ;
      return;
    }
    if( "CubicIMG" == j.get< std::string >() ) {
      p = Filter :: eCubicIMG ;
      return;
    }
    if( "eCubicIMG" == j.get< std::string >() ) {
      p = Filter :: eCubicIMG ;
      return;
    }
    if( "VK_FILTER_CUBIC_IMG" == j.get< std::string >() ) {
      p = Filter :: eCubicIMG ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for Filter" );
  }
  if( j.is_number() ) {
    p = Filter ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for Filter" );
}
}
void from_json( const nlohmann::json &j, VkFilter &p ) {
  VULKAN_HPP_NAMESPACE :: Filter temp;
  from_json( j, temp );
  p = VkFilter ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SamplerAddressMode &p ) {
  if( SamplerAddressMode :: eRepeat == p ) {
    j = "Repeat";
    return;
  }
  if( SamplerAddressMode :: eMirroredRepeat == p ) {
    j = "MirroredRepeat";
    return;
  }
  if( SamplerAddressMode :: eClampToEdge == p ) {
    j = "ClampToEdge";
    return;
  }
  if( SamplerAddressMode :: eClampToBorder == p ) {
    j = "ClampToBorder";
    return;
  }
  if( SamplerAddressMode :: eMirrorClampToEdge == p ) {
    j = "MirrorClampToEdge";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkSamplerAddressMode &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SamplerAddressMode ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SamplerAddressMode &p ) {
  if( j.is_string() ) {
    if( "Repeat" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eRepeat ;
      return;
    }
    if( "eRepeat" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eRepeat ;
      return;
    }
    if( "VK_SAMPLER_ADDRESS_MODE_REPEAT" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eRepeat ;
      return;
    }
    if( "MirroredRepeat" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eMirroredRepeat ;
      return;
    }
    if( "eMirroredRepeat" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eMirroredRepeat ;
      return;
    }
    if( "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eMirroredRepeat ;
      return;
    }
    if( "ClampToEdge" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eClampToEdge ;
      return;
    }
    if( "eClampToEdge" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eClampToEdge ;
      return;
    }
    if( "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eClampToEdge ;
      return;
    }
    if( "ClampToBorder" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eClampToBorder ;
      return;
    }
    if( "eClampToBorder" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eClampToBorder ;
      return;
    }
    if( "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eClampToBorder ;
      return;
    }
    if( "MirrorClampToEdge" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eMirrorClampToEdge ;
      return;
    }
    if( "eMirrorClampToEdge" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eMirrorClampToEdge ;
      return;
    }
    if( "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eMirrorClampToEdge ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SamplerAddressMode" );
  }
  if( j.is_number() ) {
    p = SamplerAddressMode ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SamplerAddressMode" );
}
}
void from_json( const nlohmann::json &j, VkSamplerAddressMode &p ) {
  VULKAN_HPP_NAMESPACE :: SamplerAddressMode temp;
  from_json( j, temp );
  p = VkSamplerAddressMode ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SamplerMipmapMode &p ) {
  if( SamplerMipmapMode :: eNearest == p ) {
    j = "Nearest";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkSamplerMipmapMode &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SamplerMipmapMode ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SamplerMipmapMode &p ) {
  if( j.is_string() ) {
    if( "Nearest" == j.get< std::string >() ) {
      p = SamplerMipmapMode :: eNearest ;
      return;
    }
    if( "eNearest" == j.get< std::string >() ) {
      p = SamplerMipmapMode :: eNearest ;
      return;
    }
    if( "VK_SAMPLER_MIPMAP_MODE_NEAREST" == j.get< std::string >() ) {
      p = SamplerMipmapMode :: eNearest ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SamplerMipmapMode" );
  }
  if( j.is_number() ) {
    p = SamplerMipmapMode ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SamplerMipmapMode" );
}
}
void from_json( const nlohmann::json &j, VkSamplerMipmapMode &p ) {
  VULKAN_HPP_NAMESPACE :: SamplerMipmapMode temp;
  from_json( j, temp );
  p = VkSamplerMipmapMode ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorType &p ) {
  if( DescriptorType :: eSampler == p ) {
    j = "Sampler";
    return;
  }
  if( DescriptorType :: eCombinedImageSampler == p ) {
    j = "CombinedImageSampler";
    return;
  }
  if( DescriptorType :: eSampledImage == p ) {
    j = "SampledImage";
    return;
  }
  if( DescriptorType :: eStorageImage == p ) {
    j = "StorageImage";
    return;
  }
  if( DescriptorType :: eUniformTexelBuffer == p ) {
    j = "UniformTexelBuffer";
    return;
  }
  if( DescriptorType :: eStorageTexelBuffer == p ) {
    j = "StorageTexelBuffer";
    return;
  }
  if( DescriptorType :: eUniformBuffer == p ) {
    j = "UniformBuffer";
    return;
  }
  if( DescriptorType :: eStorageBuffer == p ) {
    j = "StorageBuffer";
    return;
  }
  if( DescriptorType :: eUniformBufferDynamic == p ) {
    j = "UniformBufferDynamic";
    return;
  }
  if( DescriptorType :: eStorageBufferDynamic == p ) {
    j = "StorageBufferDynamic";
    return;
  }
  if( DescriptorType :: eInputAttachment == p ) {
    j = "InputAttachment";
    return;
  }
  if( DescriptorType :: eInlineUniformBlockEXT == p ) {
    j = "InlineUniformBlockEXT";
    return;
  }
  if( DescriptorType :: eAccelerationStructureKHR == p ) {
    j = "AccelerationStructureKHR";
    return;
  }
  if( DescriptorType :: eAccelerationStructureNV == p ) {
    j = "AccelerationStructureNV";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkDescriptorType &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorType ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorType &p ) {
  if( j.is_string() ) {
    if( "Sampler" == j.get< std::string >() ) {
      p = DescriptorType :: eSampler ;
      return;
    }
    if( "eSampler" == j.get< std::string >() ) {
      p = DescriptorType :: eSampler ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_SAMPLER" == j.get< std::string >() ) {
      p = DescriptorType :: eSampler ;
      return;
    }
    if( "CombinedImageSampler" == j.get< std::string >() ) {
      p = DescriptorType :: eCombinedImageSampler ;
      return;
    }
    if( "eCombinedImageSampler" == j.get< std::string >() ) {
      p = DescriptorType :: eCombinedImageSampler ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER" == j.get< std::string >() ) {
      p = DescriptorType :: eCombinedImageSampler ;
      return;
    }
    if( "SampledImage" == j.get< std::string >() ) {
      p = DescriptorType :: eSampledImage ;
      return;
    }
    if( "eSampledImage" == j.get< std::string >() ) {
      p = DescriptorType :: eSampledImage ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE" == j.get< std::string >() ) {
      p = DescriptorType :: eSampledImage ;
      return;
    }
    if( "StorageImage" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageImage ;
      return;
    }
    if( "eStorageImage" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageImage ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageImage ;
      return;
    }
    if( "UniformTexelBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformTexelBuffer ;
      return;
    }
    if( "eUniformTexelBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformTexelBuffer ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformTexelBuffer ;
      return;
    }
    if( "StorageTexelBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageTexelBuffer ;
      return;
    }
    if( "eStorageTexelBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageTexelBuffer ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageTexelBuffer ;
      return;
    }
    if( "UniformBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformBuffer ;
      return;
    }
    if( "eUniformBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformBuffer ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformBuffer ;
      return;
    }
    if( "StorageBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageBuffer ;
      return;
    }
    if( "eStorageBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageBuffer ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageBuffer ;
      return;
    }
    if( "UniformBufferDynamic" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformBufferDynamic ;
      return;
    }
    if( "eUniformBufferDynamic" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformBufferDynamic ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformBufferDynamic ;
      return;
    }
    if( "StorageBufferDynamic" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageBufferDynamic ;
      return;
    }
    if( "eStorageBufferDynamic" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageBufferDynamic ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageBufferDynamic ;
      return;
    }
    if( "InputAttachment" == j.get< std::string >() ) {
      p = DescriptorType :: eInputAttachment ;
      return;
    }
    if( "eInputAttachment" == j.get< std::string >() ) {
      p = DescriptorType :: eInputAttachment ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT" == j.get< std::string >() ) {
      p = DescriptorType :: eInputAttachment ;
      return;
    }
    if( "InlineUniformBlockEXT" == j.get< std::string >() ) {
      p = DescriptorType :: eInlineUniformBlockEXT ;
      return;
    }
    if( "eInlineUniformBlockEXT" == j.get< std::string >() ) {
      p = DescriptorType :: eInlineUniformBlockEXT ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT" == j.get< std::string >() ) {
      p = DescriptorType :: eInlineUniformBlockEXT ;
      return;
    }
    if( "AccelerationStructureKHR" == j.get< std::string >() ) {
      p = DescriptorType :: eAccelerationStructureKHR ;
      return;
    }
    if( "eAccelerationStructureKHR" == j.get< std::string >() ) {
      p = DescriptorType :: eAccelerationStructureKHR ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR" == j.get< std::string >() ) {
      p = DescriptorType :: eAccelerationStructureKHR ;
      return;
    }
    if( "AccelerationStructureNV" == j.get< std::string >() ) {
      p = DescriptorType :: eAccelerationStructureNV ;
      return;
    }
    if( "eAccelerationStructureNV" == j.get< std::string >() ) {
      p = DescriptorType :: eAccelerationStructureNV ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV" == j.get< std::string >() ) {
      p = DescriptorType :: eAccelerationStructureNV ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DescriptorType" );
  }
  if( j.is_number() ) {
    p = DescriptorType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DescriptorType" );
}
}
void from_json( const nlohmann::json &j, VkDescriptorType &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorType temp;
  from_json( j, temp );
  p = VkDescriptorType ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AttachmentLoadOp &p ) {
  if( AttachmentLoadOp :: eLoad == p ) {
    j = "Load";
    return;
  }
  if( AttachmentLoadOp :: eClear == p ) {
    j = "Clear";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkAttachmentLoadOp &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AttachmentLoadOp ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AttachmentLoadOp &p ) {
  if( j.is_string() ) {
    if( "Load" == j.get< std::string >() ) {
      p = AttachmentLoadOp :: eLoad ;
      return;
    }
    if( "eLoad" == j.get< std::string >() ) {
      p = AttachmentLoadOp :: eLoad ;
      return;
    }
    if( "VK_ATTACHMENT_LOAD_OP_LOAD" == j.get< std::string >() ) {
      p = AttachmentLoadOp :: eLoad ;
      return;
    }
    if( "Clear" == j.get< std::string >() ) {
      p = AttachmentLoadOp :: eClear ;
      return;
    }
    if( "eClear" == j.get< std::string >() ) {
      p = AttachmentLoadOp :: eClear ;
      return;
    }
    if( "VK_ATTACHMENT_LOAD_OP_CLEAR" == j.get< std::string >() ) {
      p = AttachmentLoadOp :: eClear ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AttachmentLoadOp" );
  }
  if( j.is_number() ) {
    p = AttachmentLoadOp ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AttachmentLoadOp" );
}
}
void from_json( const nlohmann::json &j, VkAttachmentLoadOp &p ) {
  VULKAN_HPP_NAMESPACE :: AttachmentLoadOp temp;
  from_json( j, temp );
  p = VkAttachmentLoadOp ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AttachmentStoreOp &p ) {
  if( AttachmentStoreOp :: eStore == p ) {
    j = "Store";
    return;
  }
  if( AttachmentStoreOp :: eDontCare == p ) {
    j = "DontCare";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkAttachmentStoreOp &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AttachmentStoreOp ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AttachmentStoreOp &p ) {
  if( j.is_string() ) {
    if( "Store" == j.get< std::string >() ) {
      p = AttachmentStoreOp :: eStore ;
      return;
    }
    if( "eStore" == j.get< std::string >() ) {
      p = AttachmentStoreOp :: eStore ;
      return;
    }
    if( "VK_ATTACHMENT_STORE_OP_STORE" == j.get< std::string >() ) {
      p = AttachmentStoreOp :: eStore ;
      return;
    }
    if( "DontCare" == j.get< std::string >() ) {
      p = AttachmentStoreOp :: eDontCare ;
      return;
    }
    if( "eDontCare" == j.get< std::string >() ) {
      p = AttachmentStoreOp :: eDontCare ;
      return;
    }
    if( "VK_ATTACHMENT_STORE_OP_DONT_CARE" == j.get< std::string >() ) {
      p = AttachmentStoreOp :: eDontCare ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AttachmentStoreOp" );
  }
  if( j.is_number() ) {
    p = AttachmentStoreOp ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AttachmentStoreOp" );
}
}
void from_json( const nlohmann::json &j, VkAttachmentStoreOp &p ) {
  VULKAN_HPP_NAMESPACE :: AttachmentStoreOp temp;
  from_json( j, temp );
  p = VkAttachmentStoreOp ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineBindPoint &p ) {
  if( PipelineBindPoint :: eGraphics == p ) {
    j = "Graphics";
    return;
  }
  if( PipelineBindPoint :: eCompute == p ) {
    j = "Compute";
    return;
  }
  if( PipelineBindPoint :: eRayTracingKHR == p ) {
    j = "RayTracingKHR";
    return;
  }
  if( PipelineBindPoint :: eSubpassShadingHUAWEI == p ) {
    j = "SubpassShadingHUAWEI";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkPipelineBindPoint &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineBindPoint ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineBindPoint &p ) {
  if( j.is_string() ) {
    if( "Graphics" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eGraphics ;
      return;
    }
    if( "eGraphics" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eGraphics ;
      return;
    }
    if( "VK_PIPELINE_BIND_POINT_GRAPHICS" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eGraphics ;
      return;
    }
    if( "Compute" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eCompute ;
      return;
    }
    if( "eCompute" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eCompute ;
      return;
    }
    if( "VK_PIPELINE_BIND_POINT_COMPUTE" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eCompute ;
      return;
    }
    if( "RayTracingKHR" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eRayTracingKHR ;
      return;
    }
    if( "eRayTracingKHR" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eRayTracingKHR ;
      return;
    }
    if( "VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eRayTracingKHR ;
      return;
    }
    if( "SubpassShadingHUAWEI" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eSubpassShadingHUAWEI ;
      return;
    }
    if( "eSubpassShadingHUAWEI" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eSubpassShadingHUAWEI ;
      return;
    }
    if( "VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eSubpassShadingHUAWEI ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineBindPoint" );
  }
  if( j.is_number() ) {
    p = PipelineBindPoint ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineBindPoint" );
}
}
void from_json( const nlohmann::json &j, VkPipelineBindPoint &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineBindPoint temp;
  from_json( j, temp );
  p = VkPipelineBindPoint ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CommandBufferLevel &p ) {
  if( CommandBufferLevel :: ePrimary == p ) {
    j = "Primary";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkCommandBufferLevel &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CommandBufferLevel ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CommandBufferLevel &p ) {
  if( j.is_string() ) {
    if( "Primary" == j.get< std::string >() ) {
      p = CommandBufferLevel :: ePrimary ;
      return;
    }
    if( "ePrimary" == j.get< std::string >() ) {
      p = CommandBufferLevel :: ePrimary ;
      return;
    }
    if( "VK_COMMAND_BUFFER_LEVEL_PRIMARY" == j.get< std::string >() ) {
      p = CommandBufferLevel :: ePrimary ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CommandBufferLevel" );
  }
  if( j.is_number() ) {
    p = CommandBufferLevel ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CommandBufferLevel" );
}
}
void from_json( const nlohmann::json &j, VkCommandBufferLevel &p ) {
  VULKAN_HPP_NAMESPACE :: CommandBufferLevel temp;
  from_json( j, temp );
  p = VkCommandBufferLevel ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const IndexType &p ) {
  if( IndexType :: eUint16 == p ) {
    j = "Uint16";
    return;
  }
  if( IndexType :: eUint32 == p ) {
    j = "Uint32";
    return;
  }
  if( IndexType :: eNoneKHR == p ) {
    j = "NoneKHR";
    return;
  }
  if( IndexType :: eUint8EXT == p ) {
    j = "Uint8EXT";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkIndexType &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: IndexType ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, IndexType &p ) {
  if( j.is_string() ) {
    if( "Uint16" == j.get< std::string >() ) {
      p = IndexType :: eUint16 ;
      return;
    }
    if( "eUint16" == j.get< std::string >() ) {
      p = IndexType :: eUint16 ;
      return;
    }
    if( "VK_INDEX_TYPE_UINT16" == j.get< std::string >() ) {
      p = IndexType :: eUint16 ;
      return;
    }
    if( "Uint32" == j.get< std::string >() ) {
      p = IndexType :: eUint32 ;
      return;
    }
    if( "eUint32" == j.get< std::string >() ) {
      p = IndexType :: eUint32 ;
      return;
    }
    if( "VK_INDEX_TYPE_UINT32" == j.get< std::string >() ) {
      p = IndexType :: eUint32 ;
      return;
    }
    if( "NoneKHR" == j.get< std::string >() ) {
      p = IndexType :: eNoneKHR ;
      return;
    }
    if( "eNoneKHR" == j.get< std::string >() ) {
      p = IndexType :: eNoneKHR ;
      return;
    }
    if( "VK_INDEX_TYPE_NONE_KHR" == j.get< std::string >() ) {
      p = IndexType :: eNoneKHR ;
      return;
    }
    if( "Uint8EXT" == j.get< std::string >() ) {
      p = IndexType :: eUint8EXT ;
      return;
    }
    if( "eUint8EXT" == j.get< std::string >() ) {
      p = IndexType :: eUint8EXT ;
      return;
    }
    if( "VK_INDEX_TYPE_UINT8_EXT" == j.get< std::string >() ) {
      p = IndexType :: eUint8EXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for IndexType" );
  }
  if( j.is_number() ) {
    p = IndexType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for IndexType" );
}
}
void from_json( const nlohmann::json &j, VkIndexType &p ) {
  VULKAN_HPP_NAMESPACE :: IndexType temp;
  from_json( j, temp );
  p = VkIndexType ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubpassContents &p ) {
  if( SubpassContents :: eInline == p ) {
    j = "Inline";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkSubpassContents &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SubpassContents ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SubpassContents &p ) {
  if( j.is_string() ) {
    if( "Inline" == j.get< std::string >() ) {
      p = SubpassContents :: eInline ;
      return;
    }
    if( "eInline" == j.get< std::string >() ) {
      p = SubpassContents :: eInline ;
      return;
    }
    if( "VK_SUBPASS_CONTENTS_INLINE" == j.get< std::string >() ) {
      p = SubpassContents :: eInline ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SubpassContents" );
  }
  if( j.is_number() ) {
    p = SubpassContents ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SubpassContents" );
}
}
void from_json( const nlohmann::json &j, VkSubpassContents &p ) {
  VULKAN_HPP_NAMESPACE :: SubpassContents temp;
  from_json( j, temp );
  p = VkSubpassContents ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PointClippingBehavior &p ) {
  if( PointClippingBehavior :: eAllClipPlanes == p ) {
    j = "AllClipPlanes";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkPointClippingBehavior &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PointClippingBehavior ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PointClippingBehavior &p ) {
  if( j.is_string() ) {
    if( "AllClipPlanes" == j.get< std::string >() ) {
      p = PointClippingBehavior :: eAllClipPlanes ;
      return;
    }
    if( "eAllClipPlanes" == j.get< std::string >() ) {
      p = PointClippingBehavior :: eAllClipPlanes ;
      return;
    }
    if( "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES" == j.get< std::string >() ) {
      p = PointClippingBehavior :: eAllClipPlanes ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PointClippingBehavior" );
  }
  if( j.is_number() ) {
    p = PointClippingBehavior ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PointClippingBehavior" );
}
}
void from_json( const nlohmann::json &j, VkPointClippingBehavior &p ) {
  VULKAN_HPP_NAMESPACE :: PointClippingBehavior temp;
  from_json( j, temp );
  p = VkPointClippingBehavior ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const TessellationDomainOrigin &p ) {
  if( TessellationDomainOrigin :: eUpperLeft == p ) {
    j = "UpperLeft";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkTessellationDomainOrigin &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: TessellationDomainOrigin ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, TessellationDomainOrigin &p ) {
  if( j.is_string() ) {
    if( "UpperLeft" == j.get< std::string >() ) {
      p = TessellationDomainOrigin :: eUpperLeft ;
      return;
    }
    if( "eUpperLeft" == j.get< std::string >() ) {
      p = TessellationDomainOrigin :: eUpperLeft ;
      return;
    }
    if( "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT" == j.get< std::string >() ) {
      p = TessellationDomainOrigin :: eUpperLeft ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for TessellationDomainOrigin" );
  }
  if( j.is_number() ) {
    p = TessellationDomainOrigin ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for TessellationDomainOrigin" );
}
}
void from_json( const nlohmann::json &j, VkTessellationDomainOrigin &p ) {
  VULKAN_HPP_NAMESPACE :: TessellationDomainOrigin temp;
  from_json( j, temp );
  p = VkTessellationDomainOrigin ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SamplerYcbcrModelConversion &p ) {
  if( SamplerYcbcrModelConversion :: eRgbIdentity == p ) {
    j = "RgbIdentity";
    return;
  }
  if( SamplerYcbcrModelConversion :: eYcbcrIdentity == p ) {
    j = "YcbcrIdentity";
    return;
  }
  if( SamplerYcbcrModelConversion :: eYcbcr709 == p ) {
    j = "Ycbcr709";
    return;
  }
  if( SamplerYcbcrModelConversion :: eYcbcr601 == p ) {
    j = "Ycbcr601";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkSamplerYcbcrModelConversion &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SamplerYcbcrModelConversion ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SamplerYcbcrModelConversion &p ) {
  if( j.is_string() ) {
    if( "RgbIdentity" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eRgbIdentity ;
      return;
    }
    if( "eRgbIdentity" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eRgbIdentity ;
      return;
    }
    if( "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eRgbIdentity ;
      return;
    }
    if( "YcbcrIdentity" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcrIdentity ;
      return;
    }
    if( "eYcbcrIdentity" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcrIdentity ;
      return;
    }
    if( "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcrIdentity ;
      return;
    }
    if( "Ycbcr709" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcr709 ;
      return;
    }
    if( "eYcbcr709" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcr709 ;
      return;
    }
    if( "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcr709 ;
      return;
    }
    if( "Ycbcr601" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcr601 ;
      return;
    }
    if( "eYcbcr601" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcr601 ;
      return;
    }
    if( "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcr601 ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SamplerYcbcrModelConversion" );
  }
  if( j.is_number() ) {
    p = SamplerYcbcrModelConversion ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SamplerYcbcrModelConversion" );
}
}
void from_json( const nlohmann::json &j, VkSamplerYcbcrModelConversion &p ) {
  VULKAN_HPP_NAMESPACE :: SamplerYcbcrModelConversion temp;
  from_json( j, temp );
  p = VkSamplerYcbcrModelConversion ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SamplerYcbcrRange &p ) {
  if( SamplerYcbcrRange :: eItuFull == p ) {
    j = "ItuFull";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkSamplerYcbcrRange &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SamplerYcbcrRange ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SamplerYcbcrRange &p ) {
  if( j.is_string() ) {
    if( "ItuFull" == j.get< std::string >() ) {
      p = SamplerYcbcrRange :: eItuFull ;
      return;
    }
    if( "eItuFull" == j.get< std::string >() ) {
      p = SamplerYcbcrRange :: eItuFull ;
      return;
    }
    if( "VK_SAMPLER_YCBCR_RANGE_ITU_FULL" == j.get< std::string >() ) {
      p = SamplerYcbcrRange :: eItuFull ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SamplerYcbcrRange" );
  }
  if( j.is_number() ) {
    p = SamplerYcbcrRange ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SamplerYcbcrRange" );
}
}
void from_json( const nlohmann::json &j, VkSamplerYcbcrRange &p ) {
  VULKAN_HPP_NAMESPACE :: SamplerYcbcrRange temp;
  from_json( j, temp );
  p = VkSamplerYcbcrRange ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ChromaLocation &p ) {
  if( ChromaLocation :: eCositedEven == p ) {
    j = "CositedEven";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkChromaLocation &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ChromaLocation ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ChromaLocation &p ) {
  if( j.is_string() ) {
    if( "CositedEven" == j.get< std::string >() ) {
      p = ChromaLocation :: eCositedEven ;
      return;
    }
    if( "eCositedEven" == j.get< std::string >() ) {
      p = ChromaLocation :: eCositedEven ;
      return;
    }
    if( "VK_CHROMA_LOCATION_COSITED_EVEN" == j.get< std::string >() ) {
      p = ChromaLocation :: eCositedEven ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ChromaLocation" );
  }
  if( j.is_number() ) {
    p = ChromaLocation ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ChromaLocation" );
}
}
void from_json( const nlohmann::json &j, VkChromaLocation &p ) {
  VULKAN_HPP_NAMESPACE :: ChromaLocation temp;
  from_json( j, temp );
  p = VkChromaLocation ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorUpdateTemplateType &p ) {
  if( DescriptorUpdateTemplateType :: eDescriptorSet == p ) {
    j = "DescriptorSet";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkDescriptorUpdateTemplateType &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorUpdateTemplateType ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorUpdateTemplateType &p ) {
  if( j.is_string() ) {
    if( "DescriptorSet" == j.get< std::string >() ) {
      p = DescriptorUpdateTemplateType :: eDescriptorSet ;
      return;
    }
    if( "eDescriptorSet" == j.get< std::string >() ) {
      p = DescriptorUpdateTemplateType :: eDescriptorSet ;
      return;
    }
    if( "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET" == j.get< std::string >() ) {
      p = DescriptorUpdateTemplateType :: eDescriptorSet ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DescriptorUpdateTemplateType" );
  }
  if( j.is_number() ) {
    p = DescriptorUpdateTemplateType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DescriptorUpdateTemplateType" );
}
}
void from_json( const nlohmann::json &j, VkDescriptorUpdateTemplateType &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorUpdateTemplateType temp;
  from_json( j, temp );
  p = VkDescriptorUpdateTemplateType ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DriverId &p ) {
  if( DriverId :: eAmdProprietary == p ) {
    j = "AmdProprietary";
    return;
  }
  if( DriverId :: eAmdOpenSource == p ) {
    j = "AmdOpenSource";
    return;
  }
  if( DriverId :: eMesaRadv == p ) {
    j = "MesaRadv";
    return;
  }
  if( DriverId :: eNvidiaProprietary == p ) {
    j = "NvidiaProprietary";
    return;
  }
  if( DriverId :: eIntelProprietaryWindows == p ) {
    j = "IntelProprietaryWindows";
    return;
  }
  if( DriverId :: eIntelOpenSourceMESA == p ) {
    j = "IntelOpenSourceMESA";
    return;
  }
  if( DriverId :: eImaginationProprietary == p ) {
    j = "ImaginationProprietary";
    return;
  }
  if( DriverId :: eQualcommProprietary == p ) {
    j = "QualcommProprietary";
    return;
  }
  if( DriverId :: eArmProprietary == p ) {
    j = "ArmProprietary";
    return;
  }
  if( DriverId :: eGoogleSwiftshader == p ) {
    j = "GoogleSwiftshader";
    return;
  }
  if( DriverId :: eGgpProprietary == p ) {
    j = "GgpProprietary";
    return;
  }
  if( DriverId :: eBroadcomProprietary == p ) {
    j = "BroadcomProprietary";
    return;
  }
  if( DriverId :: eMesaLlvmpipe == p ) {
    j = "MesaLlvmpipe";
    return;
  }
  if( DriverId :: eMoltenvk == p ) {
    j = "Moltenvk";
    return;
  }
  if( DriverId :: eCoreaviProprietary == p ) {
    j = "CoreaviProprietary";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkDriverId &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DriverId ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DriverId &p ) {
  if( j.is_string() ) {
    if( "AmdProprietary" == j.get< std::string >() ) {
      p = DriverId :: eAmdProprietary ;
      return;
    }
    if( "eAmdProprietary" == j.get< std::string >() ) {
      p = DriverId :: eAmdProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_AMD_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eAmdProprietary ;
      return;
    }
    if( "AmdOpenSource" == j.get< std::string >() ) {
      p = DriverId :: eAmdOpenSource ;
      return;
    }
    if( "eAmdOpenSource" == j.get< std::string >() ) {
      p = DriverId :: eAmdOpenSource ;
      return;
    }
    if( "VK_DRIVER_ID_AMD_OPEN_SOURCE" == j.get< std::string >() ) {
      p = DriverId :: eAmdOpenSource ;
      return;
    }
    if( "MesaRadv" == j.get< std::string >() ) {
      p = DriverId :: eMesaRadv ;
      return;
    }
    if( "eMesaRadv" == j.get< std::string >() ) {
      p = DriverId :: eMesaRadv ;
      return;
    }
    if( "VK_DRIVER_ID_MESA_RADV" == j.get< std::string >() ) {
      p = DriverId :: eMesaRadv ;
      return;
    }
    if( "NvidiaProprietary" == j.get< std::string >() ) {
      p = DriverId :: eNvidiaProprietary ;
      return;
    }
    if( "eNvidiaProprietary" == j.get< std::string >() ) {
      p = DriverId :: eNvidiaProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_NVIDIA_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eNvidiaProprietary ;
      return;
    }
    if( "IntelProprietaryWindows" == j.get< std::string >() ) {
      p = DriverId :: eIntelProprietaryWindows ;
      return;
    }
    if( "eIntelProprietaryWindows" == j.get< std::string >() ) {
      p = DriverId :: eIntelProprietaryWindows ;
      return;
    }
    if( "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS" == j.get< std::string >() ) {
      p = DriverId :: eIntelProprietaryWindows ;
      return;
    }
    if( "IntelOpenSourceMESA" == j.get< std::string >() ) {
      p = DriverId :: eIntelOpenSourceMESA ;
      return;
    }
    if( "eIntelOpenSourceMESA" == j.get< std::string >() ) {
      p = DriverId :: eIntelOpenSourceMESA ;
      return;
    }
    if( "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA" == j.get< std::string >() ) {
      p = DriverId :: eIntelOpenSourceMESA ;
      return;
    }
    if( "ImaginationProprietary" == j.get< std::string >() ) {
      p = DriverId :: eImaginationProprietary ;
      return;
    }
    if( "eImaginationProprietary" == j.get< std::string >() ) {
      p = DriverId :: eImaginationProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_IMAGINATION_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eImaginationProprietary ;
      return;
    }
    if( "QualcommProprietary" == j.get< std::string >() ) {
      p = DriverId :: eQualcommProprietary ;
      return;
    }
    if( "eQualcommProprietary" == j.get< std::string >() ) {
      p = DriverId :: eQualcommProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_QUALCOMM_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eQualcommProprietary ;
      return;
    }
    if( "ArmProprietary" == j.get< std::string >() ) {
      p = DriverId :: eArmProprietary ;
      return;
    }
    if( "eArmProprietary" == j.get< std::string >() ) {
      p = DriverId :: eArmProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_ARM_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eArmProprietary ;
      return;
    }
    if( "GoogleSwiftshader" == j.get< std::string >() ) {
      p = DriverId :: eGoogleSwiftshader ;
      return;
    }
    if( "eGoogleSwiftshader" == j.get< std::string >() ) {
      p = DriverId :: eGoogleSwiftshader ;
      return;
    }
    if( "VK_DRIVER_ID_GOOGLE_SWIFTSHADER" == j.get< std::string >() ) {
      p = DriverId :: eGoogleSwiftshader ;
      return;
    }
    if( "GgpProprietary" == j.get< std::string >() ) {
      p = DriverId :: eGgpProprietary ;
      return;
    }
    if( "eGgpProprietary" == j.get< std::string >() ) {
      p = DriverId :: eGgpProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_GGP_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eGgpProprietary ;
      return;
    }
    if( "BroadcomProprietary" == j.get< std::string >() ) {
      p = DriverId :: eBroadcomProprietary ;
      return;
    }
    if( "eBroadcomProprietary" == j.get< std::string >() ) {
      p = DriverId :: eBroadcomProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_BROADCOM_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eBroadcomProprietary ;
      return;
    }
    if( "MesaLlvmpipe" == j.get< std::string >() ) {
      p = DriverId :: eMesaLlvmpipe ;
      return;
    }
    if( "eMesaLlvmpipe" == j.get< std::string >() ) {
      p = DriverId :: eMesaLlvmpipe ;
      return;
    }
    if( "VK_DRIVER_ID_MESA_LLVMPIPE" == j.get< std::string >() ) {
      p = DriverId :: eMesaLlvmpipe ;
      return;
    }
    if( "Moltenvk" == j.get< std::string >() ) {
      p = DriverId :: eMoltenvk ;
      return;
    }
    if( "eMoltenvk" == j.get< std::string >() ) {
      p = DriverId :: eMoltenvk ;
      return;
    }
    if( "VK_DRIVER_ID_MOLTENVK" == j.get< std::string >() ) {
      p = DriverId :: eMoltenvk ;
      return;
    }
    if( "CoreaviProprietary" == j.get< std::string >() ) {
      p = DriverId :: eCoreaviProprietary ;
      return;
    }
    if( "eCoreaviProprietary" == j.get< std::string >() ) {
      p = DriverId :: eCoreaviProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_COREAVI_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eCoreaviProprietary ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DriverId" );
  }
  if( j.is_number() ) {
    p = DriverId ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DriverId" );
}
}
void from_json( const nlohmann::json &j, VkDriverId &p ) {
  VULKAN_HPP_NAMESPACE :: DriverId temp;
  from_json( j, temp );
  p = VkDriverId ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ShaderFloatControlsIndependence &p ) {
  if( ShaderFloatControlsIndependence :: e32BitOnly == p ) {
    j = "32BitOnly";
    return;
  }
  if( ShaderFloatControlsIndependence :: eAll == p ) {
    j = "All";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkShaderFloatControlsIndependence &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ShaderFloatControlsIndependence ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ShaderFloatControlsIndependence &p ) {
  if( j.is_string() ) {
    if( "32BitOnly" == j.get< std::string >() ) {
      p = ShaderFloatControlsIndependence :: e32BitOnly ;
      return;
    }
    if( "e32BitOnly" == j.get< std::string >() ) {
      p = ShaderFloatControlsIndependence :: e32BitOnly ;
      return;
    }
    if( "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY" == j.get< std::string >() ) {
      p = ShaderFloatControlsIndependence :: e32BitOnly ;
      return;
    }
    if( "All" == j.get< std::string >() ) {
      p = ShaderFloatControlsIndependence :: eAll ;
      return;
    }
    if( "eAll" == j.get< std::string >() ) {
      p = ShaderFloatControlsIndependence :: eAll ;
      return;
    }
    if( "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL" == j.get< std::string >() ) {
      p = ShaderFloatControlsIndependence :: eAll ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ShaderFloatControlsIndependence" );
  }
  if( j.is_number() ) {
    p = ShaderFloatControlsIndependence ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ShaderFloatControlsIndependence" );
}
}
void from_json( const nlohmann::json &j, VkShaderFloatControlsIndependence &p ) {
  VULKAN_HPP_NAMESPACE :: ShaderFloatControlsIndependence temp;
  from_json( j, temp );
  p = VkShaderFloatControlsIndependence ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SamplerReductionMode &p ) {
  if( SamplerReductionMode :: eWeightedAverage == p ) {
    j = "WeightedAverage";
    return;
  }
  if( SamplerReductionMode :: eMin == p ) {
    j = "Min";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkSamplerReductionMode &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SamplerReductionMode ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SamplerReductionMode &p ) {
  if( j.is_string() ) {
    if( "WeightedAverage" == j.get< std::string >() ) {
      p = SamplerReductionMode :: eWeightedAverage ;
      return;
    }
    if( "eWeightedAverage" == j.get< std::string >() ) {
      p = SamplerReductionMode :: eWeightedAverage ;
      return;
    }
    if( "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE" == j.get< std::string >() ) {
      p = SamplerReductionMode :: eWeightedAverage ;
      return;
    }
    if( "Min" == j.get< std::string >() ) {
      p = SamplerReductionMode :: eMin ;
      return;
    }
    if( "eMin" == j.get< std::string >() ) {
      p = SamplerReductionMode :: eMin ;
      return;
    }
    if( "VK_SAMPLER_REDUCTION_MODE_MIN" == j.get< std::string >() ) {
      p = SamplerReductionMode :: eMin ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SamplerReductionMode" );
  }
  if( j.is_number() ) {
    p = SamplerReductionMode ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SamplerReductionMode" );
}
}
void from_json( const nlohmann::json &j, VkSamplerReductionMode &p ) {
  VULKAN_HPP_NAMESPACE :: SamplerReductionMode temp;
  from_json( j, temp );
  p = VkSamplerReductionMode ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SemaphoreType &p ) {
  if( SemaphoreType :: eBinary == p ) {
    j = "Binary";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkSemaphoreType &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SemaphoreType ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SemaphoreType &p ) {
  if( j.is_string() ) {
    if( "Binary" == j.get< std::string >() ) {
      p = SemaphoreType :: eBinary ;
      return;
    }
    if( "eBinary" == j.get< std::string >() ) {
      p = SemaphoreType :: eBinary ;
      return;
    }
    if( "VK_SEMAPHORE_TYPE_BINARY" == j.get< std::string >() ) {
      p = SemaphoreType :: eBinary ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SemaphoreType" );
  }
  if( j.is_number() ) {
    p = SemaphoreType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SemaphoreType" );
}
}
void from_json( const nlohmann::json &j, VkSemaphoreType &p ) {
  VULKAN_HPP_NAMESPACE :: SemaphoreType temp;
  from_json( j, temp );
  p = VkSemaphoreType ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PresentModeKHR &p ) {
  if( PresentModeKHR :: eImmediate == p ) {
    j = "Immediate";
    return;
  }
  if( PresentModeKHR :: eMailbox == p ) {
    j = "Mailbox";
    return;
  }
  if( PresentModeKHR :: eFifo == p ) {
    j = "Fifo";
    return;
  }
  if( PresentModeKHR :: eFifoRelaxed == p ) {
    j = "FifoRelaxed";
    return;
  }
  if( PresentModeKHR :: eSharedDemandRefresh == p ) {
    j = "SharedDemandRefresh";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkPresentModeKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PresentModeKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PresentModeKHR &p ) {
  if( j.is_string() ) {
    if( "Immediate" == j.get< std::string >() ) {
      p = PresentModeKHR :: eImmediate ;
      return;
    }
    if( "eImmediate" == j.get< std::string >() ) {
      p = PresentModeKHR :: eImmediate ;
      return;
    }
    if( "VK_PRESENT_MODE_IMMEDIATE_KHR" == j.get< std::string >() ) {
      p = PresentModeKHR :: eImmediate ;
      return;
    }
    if( "Mailbox" == j.get< std::string >() ) {
      p = PresentModeKHR :: eMailbox ;
      return;
    }
    if( "eMailbox" == j.get< std::string >() ) {
      p = PresentModeKHR :: eMailbox ;
      return;
    }
    if( "VK_PRESENT_MODE_MAILBOX_KHR" == j.get< std::string >() ) {
      p = PresentModeKHR :: eMailbox ;
      return;
    }
    if( "Fifo" == j.get< std::string >() ) {
      p = PresentModeKHR :: eFifo ;
      return;
    }
    if( "eFifo" == j.get< std::string >() ) {
      p = PresentModeKHR :: eFifo ;
      return;
    }
    if( "VK_PRESENT_MODE_FIFO_KHR" == j.get< std::string >() ) {
      p = PresentModeKHR :: eFifo ;
      return;
    }
    if( "FifoRelaxed" == j.get< std::string >() ) {
      p = PresentModeKHR :: eFifoRelaxed ;
      return;
    }
    if( "eFifoRelaxed" == j.get< std::string >() ) {
      p = PresentModeKHR :: eFifoRelaxed ;
      return;
    }
    if( "VK_PRESENT_MODE_FIFO_RELAXED_KHR" == j.get< std::string >() ) {
      p = PresentModeKHR :: eFifoRelaxed ;
      return;
    }
    if( "SharedDemandRefresh" == j.get< std::string >() ) {
      p = PresentModeKHR :: eSharedDemandRefresh ;
      return;
    }
    if( "eSharedDemandRefresh" == j.get< std::string >() ) {
      p = PresentModeKHR :: eSharedDemandRefresh ;
      return;
    }
    if( "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR" == j.get< std::string >() ) {
      p = PresentModeKHR :: eSharedDemandRefresh ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PresentModeKHR" );
  }
  if( j.is_number() ) {
    p = PresentModeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PresentModeKHR" );
}
}
void from_json( const nlohmann::json &j, VkPresentModeKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PresentModeKHR temp;
  from_json( j, temp );
  p = VkPresentModeKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ColorSpaceKHR &p ) {
  if( ColorSpaceKHR :: eSrgbNonlinear == p ) {
    j = "SrgbNonlinear";
    return;
  }
  if( ColorSpaceKHR :: eDisplayP3NonlinearEXT == p ) {
    j = "DisplayP3NonlinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eExtendedSrgbLinearEXT == p ) {
    j = "ExtendedSrgbLinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eDisplayP3LinearEXT == p ) {
    j = "DisplayP3LinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eDciP3NonlinearEXT == p ) {
    j = "DciP3NonlinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eBt709LinearEXT == p ) {
    j = "Bt709LinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eBt709NonlinearEXT == p ) {
    j = "Bt709NonlinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eBt2020LinearEXT == p ) {
    j = "Bt2020LinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eHdr10St2084EXT == p ) {
    j = "Hdr10St2084EXT";
    return;
  }
  if( ColorSpaceKHR :: eDolbyvisionEXT == p ) {
    j = "DolbyvisionEXT";
    return;
  }
  if( ColorSpaceKHR :: eHdr10HlgEXT == p ) {
    j = "Hdr10HlgEXT";
    return;
  }
  if( ColorSpaceKHR :: eAdobergbLinearEXT == p ) {
    j = "AdobergbLinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eAdobergbNonlinearEXT == p ) {
    j = "AdobergbNonlinearEXT";
    return;
  }
  if( ColorSpaceKHR :: ePassThroughEXT == p ) {
    j = "PassThroughEXT";
    return;
  }
  if( ColorSpaceKHR :: eExtendedSrgbNonlinearEXT == p ) {
    j = "ExtendedSrgbNonlinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eDisplayNativeAMD == p ) {
    j = "DisplayNativeAMD";
    return;
  }
  if( ColorSpaceKHR :: eVkColorspaceSrgbNonlinear == p ) {
    j = "VkColorspaceSrgbNonlinear";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkColorSpaceKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ColorSpaceKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ColorSpaceKHR &p ) {
  if( j.is_string() ) {
    if( "SrgbNonlinear" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eSrgbNonlinear ;
      return;
    }
    if( "eSrgbNonlinear" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eSrgbNonlinear ;
      return;
    }
    if( "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eSrgbNonlinear ;
      return;
    }
    if( "DisplayP3NonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayP3NonlinearEXT ;
      return;
    }
    if( "eDisplayP3NonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayP3NonlinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayP3NonlinearEXT ;
      return;
    }
    if( "ExtendedSrgbLinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eExtendedSrgbLinearEXT ;
      return;
    }
    if( "eExtendedSrgbLinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eExtendedSrgbLinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eExtendedSrgbLinearEXT ;
      return;
    }
    if( "DisplayP3LinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayP3LinearEXT ;
      return;
    }
    if( "eDisplayP3LinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayP3LinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayP3LinearEXT ;
      return;
    }
    if( "DciP3NonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDciP3NonlinearEXT ;
      return;
    }
    if( "eDciP3NonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDciP3NonlinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDciP3NonlinearEXT ;
      return;
    }
    if( "Bt709LinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt709LinearEXT ;
      return;
    }
    if( "eBt709LinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt709LinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_BT709_LINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt709LinearEXT ;
      return;
    }
    if( "Bt709NonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt709NonlinearEXT ;
      return;
    }
    if( "eBt709NonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt709NonlinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_BT709_NONLINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt709NonlinearEXT ;
      return;
    }
    if( "Bt2020LinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt2020LinearEXT ;
      return;
    }
    if( "eBt2020LinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt2020LinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_BT2020_LINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt2020LinearEXT ;
      return;
    }
    if( "Hdr10St2084EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eHdr10St2084EXT ;
      return;
    }
    if( "eHdr10St2084EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eHdr10St2084EXT ;
      return;
    }
    if( "VK_COLOR_SPACE_HDR10_ST2084_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eHdr10St2084EXT ;
      return;
    }
    if( "DolbyvisionEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDolbyvisionEXT ;
      return;
    }
    if( "eDolbyvisionEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDolbyvisionEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_DOLBYVISION_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDolbyvisionEXT ;
      return;
    }
    if( "Hdr10HlgEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eHdr10HlgEXT ;
      return;
    }
    if( "eHdr10HlgEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eHdr10HlgEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_HDR10_HLG_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eHdr10HlgEXT ;
      return;
    }
    if( "AdobergbLinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eAdobergbLinearEXT ;
      return;
    }
    if( "eAdobergbLinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eAdobergbLinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eAdobergbLinearEXT ;
      return;
    }
    if( "AdobergbNonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eAdobergbNonlinearEXT ;
      return;
    }
    if( "eAdobergbNonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eAdobergbNonlinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eAdobergbNonlinearEXT ;
      return;
    }
    if( "PassThroughEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: ePassThroughEXT ;
      return;
    }
    if( "ePassThroughEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: ePassThroughEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_PASS_THROUGH_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: ePassThroughEXT ;
      return;
    }
    if( "ExtendedSrgbNonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eExtendedSrgbNonlinearEXT ;
      return;
    }
    if( "eExtendedSrgbNonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eExtendedSrgbNonlinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eExtendedSrgbNonlinearEXT ;
      return;
    }
    if( "DisplayNativeAMD" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayNativeAMD ;
      return;
    }
    if( "eDisplayNativeAMD" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayNativeAMD ;
      return;
    }
    if( "VK_COLOR_SPACE_DISPLAY_NATIVE_AMD" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayNativeAMD ;
      return;
    }
    if( "VkColorspaceSrgbNonlinear" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eVkColorspaceSrgbNonlinear ;
      return;
    }
    if( "eVkColorspaceSrgbNonlinear" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eVkColorspaceSrgbNonlinear ;
      return;
    }
    if( "VK_COLORSPACE_SRGB_NONLINEAR_KHR" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eVkColorspaceSrgbNonlinear ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ColorSpaceKHR" );
  }
  if( j.is_number() ) {
    p = ColorSpaceKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ColorSpaceKHR" );
}
}
void from_json( const nlohmann::json &j, VkColorSpaceKHR &p ) {
  VULKAN_HPP_NAMESPACE :: ColorSpaceKHR temp;
  from_json( j, temp );
  p = VkColorSpaceKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugReportObjectTypeEXT &p ) {
  if( DebugReportObjectTypeEXT :: eUnknown == p ) {
    j = "Unknown";
    return;
  }
  if( DebugReportObjectTypeEXT :: eInstance == p ) {
    j = "Instance";
    return;
  }
  if( DebugReportObjectTypeEXT :: ePhysicalDevice == p ) {
    j = "PhysicalDevice";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDevice == p ) {
    j = "Device";
    return;
  }
  if( DebugReportObjectTypeEXT :: eQueue == p ) {
    j = "Queue";
    return;
  }
  if( DebugReportObjectTypeEXT :: eSemaphore == p ) {
    j = "Semaphore";
    return;
  }
  if( DebugReportObjectTypeEXT :: eCommandBuffer == p ) {
    j = "CommandBuffer";
    return;
  }
  if( DebugReportObjectTypeEXT :: eFence == p ) {
    j = "Fence";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDeviceMemory == p ) {
    j = "DeviceMemory";
    return;
  }
  if( DebugReportObjectTypeEXT :: eBuffer == p ) {
    j = "Buffer";
    return;
  }
  if( DebugReportObjectTypeEXT :: eImage == p ) {
    j = "Image";
    return;
  }
  if( DebugReportObjectTypeEXT :: eEvent == p ) {
    j = "Event";
    return;
  }
  if( DebugReportObjectTypeEXT :: eQueryPool == p ) {
    j = "QueryPool";
    return;
  }
  if( DebugReportObjectTypeEXT :: eBufferView == p ) {
    j = "BufferView";
    return;
  }
  if( DebugReportObjectTypeEXT :: eImageView == p ) {
    j = "ImageView";
    return;
  }
  if( DebugReportObjectTypeEXT :: eShaderModule == p ) {
    j = "ShaderModule";
    return;
  }
  if( DebugReportObjectTypeEXT :: ePipelineCache == p ) {
    j = "PipelineCache";
    return;
  }
  if( DebugReportObjectTypeEXT :: ePipelineLayout == p ) {
    j = "PipelineLayout";
    return;
  }
  if( DebugReportObjectTypeEXT :: eRenderPass == p ) {
    j = "RenderPass";
    return;
  }
  if( DebugReportObjectTypeEXT :: ePipeline == p ) {
    j = "Pipeline";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDescriptorSetLayout == p ) {
    j = "DescriptorSetLayout";
    return;
  }
  if( DebugReportObjectTypeEXT :: eSampler == p ) {
    j = "Sampler";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDescriptorPool == p ) {
    j = "DescriptorPool";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDescriptorSet == p ) {
    j = "DescriptorSet";
    return;
  }
  if( DebugReportObjectTypeEXT :: eFramebuffer == p ) {
    j = "Framebuffer";
    return;
  }
  if( DebugReportObjectTypeEXT :: eCommandPool == p ) {
    j = "CommandPool";
    return;
  }
  if( DebugReportObjectTypeEXT :: eSurfaceKHR == p ) {
    j = "SurfaceKHR";
    return;
  }
  if( DebugReportObjectTypeEXT :: eSwapchainKHR == p ) {
    j = "SwapchainKHR";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDebugReportCallbackEXT == p ) {
    j = "DebugReportCallbackEXT";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDisplayKHR == p ) {
    j = "DisplayKHR";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDisplayModeKHR == p ) {
    j = "DisplayModeKHR";
    return;
  }
  if( DebugReportObjectTypeEXT :: eValidationCacheEXT == p ) {
    j = "ValidationCacheEXT";
    return;
  }
  if( DebugReportObjectTypeEXT :: eSamplerYcbcrConversion == p ) {
    j = "SamplerYcbcrConversion";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDescriptorUpdateTemplate == p ) {
    j = "DescriptorUpdateTemplate";
    return;
  }
  if( DebugReportObjectTypeEXT :: eCuModuleNVX == p ) {
    j = "CuModuleNVX";
    return;
  }
  if( DebugReportObjectTypeEXT :: eCuFunctionNVX == p ) {
    j = "CuFunctionNVX";
    return;
  }
  if( DebugReportObjectTypeEXT :: eAccelerationStructureKHR == p ) {
    j = "AccelerationStructureKHR";
    return;
  }
  if( DebugReportObjectTypeEXT :: eAccelerationStructureNV == p ) {
    j = "AccelerationStructureNV";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDebugReport == p ) {
    j = "DebugReport";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDescriptorUpdateTemplateKHR == p ) {
    j = "DescriptorUpdateTemplateKHR";
    return;
  }
  if( DebugReportObjectTypeEXT :: eSamplerYcbcrConversionKHR == p ) {
    j = "SamplerYcbcrConversionKHR";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkDebugReportObjectTypeEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DebugReportObjectTypeEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DebugReportObjectTypeEXT &p ) {
  if( j.is_string() ) {
    if( "Unknown" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eUnknown ;
      return;
    }
    if( "eUnknown" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eUnknown ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eUnknown ;
      return;
    }
    if( "Instance" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eInstance ;
      return;
    }
    if( "eInstance" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eInstance ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eInstance ;
      return;
    }
    if( "PhysicalDevice" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePhysicalDevice ;
      return;
    }
    if( "ePhysicalDevice" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePhysicalDevice ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePhysicalDevice ;
      return;
    }
    if( "Device" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDevice ;
      return;
    }
    if( "eDevice" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDevice ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDevice ;
      return;
    }
    if( "Queue" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eQueue ;
      return;
    }
    if( "eQueue" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eQueue ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eQueue ;
      return;
    }
    if( "Semaphore" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSemaphore ;
      return;
    }
    if( "eSemaphore" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSemaphore ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSemaphore ;
      return;
    }
    if( "CommandBuffer" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCommandBuffer ;
      return;
    }
    if( "eCommandBuffer" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCommandBuffer ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCommandBuffer ;
      return;
    }
    if( "Fence" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eFence ;
      return;
    }
    if( "eFence" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eFence ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eFence ;
      return;
    }
    if( "DeviceMemory" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDeviceMemory ;
      return;
    }
    if( "eDeviceMemory" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDeviceMemory ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDeviceMemory ;
      return;
    }
    if( "Buffer" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eBuffer ;
      return;
    }
    if( "eBuffer" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eBuffer ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eBuffer ;
      return;
    }
    if( "Image" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eImage ;
      return;
    }
    if( "eImage" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eImage ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eImage ;
      return;
    }
    if( "Event" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eEvent ;
      return;
    }
    if( "eEvent" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eEvent ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eEvent ;
      return;
    }
    if( "QueryPool" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eQueryPool ;
      return;
    }
    if( "eQueryPool" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eQueryPool ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eQueryPool ;
      return;
    }
    if( "BufferView" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eBufferView ;
      return;
    }
    if( "eBufferView" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eBufferView ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eBufferView ;
      return;
    }
    if( "ImageView" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eImageView ;
      return;
    }
    if( "eImageView" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eImageView ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eImageView ;
      return;
    }
    if( "ShaderModule" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eShaderModule ;
      return;
    }
    if( "eShaderModule" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eShaderModule ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eShaderModule ;
      return;
    }
    if( "PipelineCache" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipelineCache ;
      return;
    }
    if( "ePipelineCache" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipelineCache ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipelineCache ;
      return;
    }
    if( "PipelineLayout" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipelineLayout ;
      return;
    }
    if( "ePipelineLayout" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipelineLayout ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipelineLayout ;
      return;
    }
    if( "RenderPass" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eRenderPass ;
      return;
    }
    if( "eRenderPass" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eRenderPass ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eRenderPass ;
      return;
    }
    if( "Pipeline" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipeline ;
      return;
    }
    if( "ePipeline" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipeline ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipeline ;
      return;
    }
    if( "DescriptorSetLayout" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorSetLayout ;
      return;
    }
    if( "eDescriptorSetLayout" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorSetLayout ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorSetLayout ;
      return;
    }
    if( "Sampler" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSampler ;
      return;
    }
    if( "eSampler" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSampler ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSampler ;
      return;
    }
    if( "DescriptorPool" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorPool ;
      return;
    }
    if( "eDescriptorPool" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorPool ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorPool ;
      return;
    }
    if( "DescriptorSet" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorSet ;
      return;
    }
    if( "eDescriptorSet" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorSet ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorSet ;
      return;
    }
    if( "Framebuffer" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eFramebuffer ;
      return;
    }
    if( "eFramebuffer" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eFramebuffer ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eFramebuffer ;
      return;
    }
    if( "CommandPool" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCommandPool ;
      return;
    }
    if( "eCommandPool" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCommandPool ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCommandPool ;
      return;
    }
    if( "SurfaceKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSurfaceKHR ;
      return;
    }
    if( "eSurfaceKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSurfaceKHR ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSurfaceKHR ;
      return;
    }
    if( "SwapchainKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSwapchainKHR ;
      return;
    }
    if( "eSwapchainKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSwapchainKHR ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSwapchainKHR ;
      return;
    }
    if( "DebugReportCallbackEXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDebugReportCallbackEXT ;
      return;
    }
    if( "eDebugReportCallbackEXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDebugReportCallbackEXT ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDebugReportCallbackEXT ;
      return;
    }
    if( "DisplayKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDisplayKHR ;
      return;
    }
    if( "eDisplayKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDisplayKHR ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDisplayKHR ;
      return;
    }
    if( "DisplayModeKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDisplayModeKHR ;
      return;
    }
    if( "eDisplayModeKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDisplayModeKHR ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDisplayModeKHR ;
      return;
    }
    if( "ValidationCacheEXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eValidationCacheEXT ;
      return;
    }
    if( "eValidationCacheEXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eValidationCacheEXT ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eValidationCacheEXT ;
      return;
    }
    if( "SamplerYcbcrConversion" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSamplerYcbcrConversion ;
      return;
    }
    if( "eSamplerYcbcrConversion" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSamplerYcbcrConversion ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSamplerYcbcrConversion ;
      return;
    }
    if( "DescriptorUpdateTemplate" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorUpdateTemplate ;
      return;
    }
    if( "eDescriptorUpdateTemplate" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorUpdateTemplate ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorUpdateTemplate ;
      return;
    }
    if( "CuModuleNVX" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCuModuleNVX ;
      return;
    }
    if( "eCuModuleNVX" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCuModuleNVX ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCuModuleNVX ;
      return;
    }
    if( "CuFunctionNVX" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCuFunctionNVX ;
      return;
    }
    if( "eCuFunctionNVX" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCuFunctionNVX ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCuFunctionNVX ;
      return;
    }
    if( "AccelerationStructureKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eAccelerationStructureKHR ;
      return;
    }
    if( "eAccelerationStructureKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eAccelerationStructureKHR ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eAccelerationStructureKHR ;
      return;
    }
    if( "AccelerationStructureNV" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eAccelerationStructureNV ;
      return;
    }
    if( "eAccelerationStructureNV" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eAccelerationStructureNV ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eAccelerationStructureNV ;
      return;
    }
    if( "DebugReport" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDebugReport ;
      return;
    }
    if( "eDebugReport" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDebugReport ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDebugReport ;
      return;
    }
    if( "DescriptorUpdateTemplateKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorUpdateTemplateKHR ;
      return;
    }
    if( "eDescriptorUpdateTemplateKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorUpdateTemplateKHR ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorUpdateTemplateKHR ;
      return;
    }
    if( "SamplerYcbcrConversionKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSamplerYcbcrConversionKHR ;
      return;
    }
    if( "eSamplerYcbcrConversionKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSamplerYcbcrConversionKHR ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSamplerYcbcrConversionKHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DebugReportObjectTypeEXT" );
  }
  if( j.is_number() ) {
    p = DebugReportObjectTypeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DebugReportObjectTypeEXT" );
}
}
void from_json( const nlohmann::json &j, VkDebugReportObjectTypeEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DebugReportObjectTypeEXT temp;
  from_json( j, temp );
  p = VkDebugReportObjectTypeEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RasterizationOrderAMD &p ) {
  if( RasterizationOrderAMD :: eStrict == p ) {
    j = "Strict";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkRasterizationOrderAMD &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RasterizationOrderAMD ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RasterizationOrderAMD &p ) {
  if( j.is_string() ) {
    if( "Strict" == j.get< std::string >() ) {
      p = RasterizationOrderAMD :: eStrict ;
      return;
    }
    if( "eStrict" == j.get< std::string >() ) {
      p = RasterizationOrderAMD :: eStrict ;
      return;
    }
    if( "VK_RASTERIZATION_ORDER_STRICT_AMD" == j.get< std::string >() ) {
      p = RasterizationOrderAMD :: eStrict ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for RasterizationOrderAMD" );
  }
  if( j.is_number() ) {
    p = RasterizationOrderAMD ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for RasterizationOrderAMD" );
}
}
void from_json( const nlohmann::json &j, VkRasterizationOrderAMD &p ) {
  VULKAN_HPP_NAMESPACE :: RasterizationOrderAMD temp;
  from_json( j, temp );
  p = VkRasterizationOrderAMD ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ShaderInfoTypeAMD &p ) {
  if( ShaderInfoTypeAMD :: eStatistics == p ) {
    j = "Statistics";
    return;
  }
  if( ShaderInfoTypeAMD :: eBinary == p ) {
    j = "Binary";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkShaderInfoTypeAMD &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ShaderInfoTypeAMD ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ShaderInfoTypeAMD &p ) {
  if( j.is_string() ) {
    if( "Statistics" == j.get< std::string >() ) {
      p = ShaderInfoTypeAMD :: eStatistics ;
      return;
    }
    if( "eStatistics" == j.get< std::string >() ) {
      p = ShaderInfoTypeAMD :: eStatistics ;
      return;
    }
    if( "VK_SHADER_INFO_TYPE_STATISTICS_AMD" == j.get< std::string >() ) {
      p = ShaderInfoTypeAMD :: eStatistics ;
      return;
    }
    if( "Binary" == j.get< std::string >() ) {
      p = ShaderInfoTypeAMD :: eBinary ;
      return;
    }
    if( "eBinary" == j.get< std::string >() ) {
      p = ShaderInfoTypeAMD :: eBinary ;
      return;
    }
    if( "VK_SHADER_INFO_TYPE_BINARY_AMD" == j.get< std::string >() ) {
      p = ShaderInfoTypeAMD :: eBinary ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ShaderInfoTypeAMD" );
  }
  if( j.is_number() ) {
    p = ShaderInfoTypeAMD ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ShaderInfoTypeAMD" );
}
}
void from_json( const nlohmann::json &j, VkShaderInfoTypeAMD &p ) {
  VULKAN_HPP_NAMESPACE :: ShaderInfoTypeAMD temp;
  from_json( j, temp );
  p = VkShaderInfoTypeAMD ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ValidationCheckEXT &p ) {
  if( ValidationCheckEXT :: eAll == p ) {
    j = "All";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkValidationCheckEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ValidationCheckEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ValidationCheckEXT &p ) {
  if( j.is_string() ) {
    if( "All" == j.get< std::string >() ) {
      p = ValidationCheckEXT :: eAll ;
      return;
    }
    if( "eAll" == j.get< std::string >() ) {
      p = ValidationCheckEXT :: eAll ;
      return;
    }
    if( "VK_VALIDATION_CHECK_ALL_EXT" == j.get< std::string >() ) {
      p = ValidationCheckEXT :: eAll ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ValidationCheckEXT" );
  }
  if( j.is_number() ) {
    p = ValidationCheckEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ValidationCheckEXT" );
}
}
void from_json( const nlohmann::json &j, VkValidationCheckEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ValidationCheckEXT temp;
  from_json( j, temp );
  p = VkValidationCheckEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayPowerStateEXT &p ) {
  if( DisplayPowerStateEXT :: eOff == p ) {
    j = "Off";
    return;
  }
  if( DisplayPowerStateEXT :: eSuspend == p ) {
    j = "Suspend";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkDisplayPowerStateEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayPowerStateEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayPowerStateEXT &p ) {
  if( j.is_string() ) {
    if( "Off" == j.get< std::string >() ) {
      p = DisplayPowerStateEXT :: eOff ;
      return;
    }
    if( "eOff" == j.get< std::string >() ) {
      p = DisplayPowerStateEXT :: eOff ;
      return;
    }
    if( "VK_DISPLAY_POWER_STATE_OFF_EXT" == j.get< std::string >() ) {
      p = DisplayPowerStateEXT :: eOff ;
      return;
    }
    if( "Suspend" == j.get< std::string >() ) {
      p = DisplayPowerStateEXT :: eSuspend ;
      return;
    }
    if( "eSuspend" == j.get< std::string >() ) {
      p = DisplayPowerStateEXT :: eSuspend ;
      return;
    }
    if( "VK_DISPLAY_POWER_STATE_SUSPEND_EXT" == j.get< std::string >() ) {
      p = DisplayPowerStateEXT :: eSuspend ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DisplayPowerStateEXT" );
  }
  if( j.is_number() ) {
    p = DisplayPowerStateEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DisplayPowerStateEXT" );
}
}
void from_json( const nlohmann::json &j, VkDisplayPowerStateEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayPowerStateEXT temp;
  from_json( j, temp );
  p = VkDisplayPowerStateEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceEventTypeEXT &p ) {
}
}
void to_json( nlohmann::json &j, const VkDeviceEventTypeEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceEventTypeEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceEventTypeEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DeviceEventTypeEXT" );
  }
  if( j.is_number() ) {
    p = DeviceEventTypeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DeviceEventTypeEXT" );
}
}
void from_json( const nlohmann::json &j, VkDeviceEventTypeEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceEventTypeEXT temp;
  from_json( j, temp );
  p = VkDeviceEventTypeEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayEventTypeEXT &p ) {
}
}
void to_json( nlohmann::json &j, const VkDisplayEventTypeEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayEventTypeEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayEventTypeEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DisplayEventTypeEXT" );
  }
  if( j.is_number() ) {
    p = DisplayEventTypeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DisplayEventTypeEXT" );
}
}
void from_json( const nlohmann::json &j, VkDisplayEventTypeEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayEventTypeEXT temp;
  from_json( j, temp );
  p = VkDisplayEventTypeEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ViewportCoordinateSwizzleNV &p ) {
  if( ViewportCoordinateSwizzleNV :: ePositiveX == p ) {
    j = "PositiveX";
    return;
  }
  if( ViewportCoordinateSwizzleNV :: eNegativeX == p ) {
    j = "NegativeX";
    return;
  }
  if( ViewportCoordinateSwizzleNV :: ePositiveY == p ) {
    j = "PositiveY";
    return;
  }
  if( ViewportCoordinateSwizzleNV :: eNegativeY == p ) {
    j = "NegativeY";
    return;
  }
  if( ViewportCoordinateSwizzleNV :: ePositiveZ == p ) {
    j = "PositiveZ";
    return;
  }
  if( ViewportCoordinateSwizzleNV :: eNegativeZ == p ) {
    j = "NegativeZ";
    return;
  }
  if( ViewportCoordinateSwizzleNV :: ePositiveW == p ) {
    j = "PositiveW";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkViewportCoordinateSwizzleNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ViewportCoordinateSwizzleNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ViewportCoordinateSwizzleNV &p ) {
  if( j.is_string() ) {
    if( "PositiveX" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveX ;
      return;
    }
    if( "ePositiveX" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveX ;
      return;
    }
    if( "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveX ;
      return;
    }
    if( "NegativeX" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeX ;
      return;
    }
    if( "eNegativeX" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeX ;
      return;
    }
    if( "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeX ;
      return;
    }
    if( "PositiveY" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveY ;
      return;
    }
    if( "ePositiveY" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveY ;
      return;
    }
    if( "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveY ;
      return;
    }
    if( "NegativeY" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeY ;
      return;
    }
    if( "eNegativeY" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeY ;
      return;
    }
    if( "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeY ;
      return;
    }
    if( "PositiveZ" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveZ ;
      return;
    }
    if( "ePositiveZ" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveZ ;
      return;
    }
    if( "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveZ ;
      return;
    }
    if( "NegativeZ" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeZ ;
      return;
    }
    if( "eNegativeZ" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeZ ;
      return;
    }
    if( "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeZ ;
      return;
    }
    if( "PositiveW" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveW ;
      return;
    }
    if( "ePositiveW" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveW ;
      return;
    }
    if( "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveW ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ViewportCoordinateSwizzleNV" );
  }
  if( j.is_number() ) {
    p = ViewportCoordinateSwizzleNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ViewportCoordinateSwizzleNV" );
}
}
void from_json( const nlohmann::json &j, VkViewportCoordinateSwizzleNV &p ) {
  VULKAN_HPP_NAMESPACE :: ViewportCoordinateSwizzleNV temp;
  from_json( j, temp );
  p = VkViewportCoordinateSwizzleNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DiscardRectangleModeEXT &p ) {
  if( DiscardRectangleModeEXT :: eInclusive == p ) {
    j = "Inclusive";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkDiscardRectangleModeEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DiscardRectangleModeEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DiscardRectangleModeEXT &p ) {
  if( j.is_string() ) {
    if( "Inclusive" == j.get< std::string >() ) {
      p = DiscardRectangleModeEXT :: eInclusive ;
      return;
    }
    if( "eInclusive" == j.get< std::string >() ) {
      p = DiscardRectangleModeEXT :: eInclusive ;
      return;
    }
    if( "VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT" == j.get< std::string >() ) {
      p = DiscardRectangleModeEXT :: eInclusive ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DiscardRectangleModeEXT" );
  }
  if( j.is_number() ) {
    p = DiscardRectangleModeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DiscardRectangleModeEXT" );
}
}
void from_json( const nlohmann::json &j, VkDiscardRectangleModeEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DiscardRectangleModeEXT temp;
  from_json( j, temp );
  p = VkDiscardRectangleModeEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ConservativeRasterizationModeEXT &p ) {
  if( ConservativeRasterizationModeEXT :: eDisabled == p ) {
    j = "Disabled";
    return;
  }
  if( ConservativeRasterizationModeEXT :: eOverestimate == p ) {
    j = "Overestimate";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkConservativeRasterizationModeEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ConservativeRasterizationModeEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ConservativeRasterizationModeEXT &p ) {
  if( j.is_string() ) {
    if( "Disabled" == j.get< std::string >() ) {
      p = ConservativeRasterizationModeEXT :: eDisabled ;
      return;
    }
    if( "eDisabled" == j.get< std::string >() ) {
      p = ConservativeRasterizationModeEXT :: eDisabled ;
      return;
    }
    if( "VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT" == j.get< std::string >() ) {
      p = ConservativeRasterizationModeEXT :: eDisabled ;
      return;
    }
    if( "Overestimate" == j.get< std::string >() ) {
      p = ConservativeRasterizationModeEXT :: eOverestimate ;
      return;
    }
    if( "eOverestimate" == j.get< std::string >() ) {
      p = ConservativeRasterizationModeEXT :: eOverestimate ;
      return;
    }
    if( "VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT" == j.get< std::string >() ) {
      p = ConservativeRasterizationModeEXT :: eOverestimate ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ConservativeRasterizationModeEXT" );
  }
  if( j.is_number() ) {
    p = ConservativeRasterizationModeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ConservativeRasterizationModeEXT" );
}
}
void from_json( const nlohmann::json &j, VkConservativeRasterizationModeEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ConservativeRasterizationModeEXT temp;
  from_json( j, temp );
  p = VkConservativeRasterizationModeEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceCounterScopeKHR &p ) {
  if( PerformanceCounterScopeKHR :: eCommandBuffer == p ) {
    j = "CommandBuffer";
    return;
  }
  if( PerformanceCounterScopeKHR :: eRenderPass == p ) {
    j = "RenderPass";
    return;
  }
  if( PerformanceCounterScopeKHR :: eCommand == p ) {
    j = "Command";
    return;
  }
  if( PerformanceCounterScopeKHR :: eVkQueryScopeCommandBuffer == p ) {
    j = "VkQueryScopeCommandBuffer";
    return;
  }
  if( PerformanceCounterScopeKHR :: eVkQueryScopeCommand == p ) {
    j = "VkQueryScopeCommand";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkPerformanceCounterScopeKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceCounterScopeKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceCounterScopeKHR &p ) {
  if( j.is_string() ) {
    if( "CommandBuffer" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eCommandBuffer ;
      return;
    }
    if( "eCommandBuffer" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eCommandBuffer ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eCommandBuffer ;
      return;
    }
    if( "RenderPass" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eRenderPass ;
      return;
    }
    if( "eRenderPass" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eRenderPass ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eRenderPass ;
      return;
    }
    if( "Command" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eCommand ;
      return;
    }
    if( "eCommand" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eCommand ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eCommand ;
      return;
    }
    if( "VkQueryScopeCommandBuffer" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eVkQueryScopeCommandBuffer ;
      return;
    }
    if( "eVkQueryScopeCommandBuffer" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eVkQueryScopeCommandBuffer ;
      return;
    }
    if( "VK_QUERY_SCOPE_COMMAND_BUFFER_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eVkQueryScopeCommandBuffer ;
      return;
    }
    if( "VkQueryScopeCommand" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eVkQueryScopeCommand ;
      return;
    }
    if( "eVkQueryScopeCommand" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eVkQueryScopeCommand ;
      return;
    }
    if( "VK_QUERY_SCOPE_COMMAND_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eVkQueryScopeCommand ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceCounterScopeKHR" );
  }
  if( j.is_number() ) {
    p = PerformanceCounterScopeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceCounterScopeKHR" );
}
}
void from_json( const nlohmann::json &j, VkPerformanceCounterScopeKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceCounterScopeKHR temp;
  from_json( j, temp );
  p = VkPerformanceCounterScopeKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceCounterStorageKHR &p ) {
  if( PerformanceCounterStorageKHR :: eInt32 == p ) {
    j = "Int32";
    return;
  }
  if( PerformanceCounterStorageKHR :: eInt64 == p ) {
    j = "Int64";
    return;
  }
  if( PerformanceCounterStorageKHR :: eUint32 == p ) {
    j = "Uint32";
    return;
  }
  if( PerformanceCounterStorageKHR :: eUint64 == p ) {
    j = "Uint64";
    return;
  }
  if( PerformanceCounterStorageKHR :: eFloat32 == p ) {
    j = "Float32";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkPerformanceCounterStorageKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceCounterStorageKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceCounterStorageKHR &p ) {
  if( j.is_string() ) {
    if( "Int32" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eInt32 ;
      return;
    }
    if( "eInt32" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eInt32 ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eInt32 ;
      return;
    }
    if( "Int64" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eInt64 ;
      return;
    }
    if( "eInt64" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eInt64 ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eInt64 ;
      return;
    }
    if( "Uint32" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eUint32 ;
      return;
    }
    if( "eUint32" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eUint32 ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eUint32 ;
      return;
    }
    if( "Uint64" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eUint64 ;
      return;
    }
    if( "eUint64" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eUint64 ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eUint64 ;
      return;
    }
    if( "Float32" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eFloat32 ;
      return;
    }
    if( "eFloat32" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eFloat32 ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eFloat32 ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceCounterStorageKHR" );
  }
  if( j.is_number() ) {
    p = PerformanceCounterStorageKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceCounterStorageKHR" );
}
}
void from_json( const nlohmann::json &j, VkPerformanceCounterStorageKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceCounterStorageKHR temp;
  from_json( j, temp );
  p = VkPerformanceCounterStorageKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceCounterUnitKHR &p ) {
  if( PerformanceCounterUnitKHR :: eGeneric == p ) {
    j = "Generic";
    return;
  }
  if( PerformanceCounterUnitKHR :: ePercentage == p ) {
    j = "Percentage";
    return;
  }
  if( PerformanceCounterUnitKHR :: eNanoseconds == p ) {
    j = "Nanoseconds";
    return;
  }
  if( PerformanceCounterUnitKHR :: eBytes == p ) {
    j = "Bytes";
    return;
  }
  if( PerformanceCounterUnitKHR :: eBytesPerSecond == p ) {
    j = "BytesPerSecond";
    return;
  }
  if( PerformanceCounterUnitKHR :: eKelvin == p ) {
    j = "Kelvin";
    return;
  }
  if( PerformanceCounterUnitKHR :: eWatts == p ) {
    j = "Watts";
    return;
  }
  if( PerformanceCounterUnitKHR :: eVolts == p ) {
    j = "Volts";
    return;
  }
  if( PerformanceCounterUnitKHR :: eAmps == p ) {
    j = "Amps";
    return;
  }
  if( PerformanceCounterUnitKHR :: eHertz == p ) {
    j = "Hertz";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkPerformanceCounterUnitKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceCounterUnitKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceCounterUnitKHR &p ) {
  if( j.is_string() ) {
    if( "Generic" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eGeneric ;
      return;
    }
    if( "eGeneric" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eGeneric ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eGeneric ;
      return;
    }
    if( "Percentage" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: ePercentage ;
      return;
    }
    if( "ePercentage" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: ePercentage ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: ePercentage ;
      return;
    }
    if( "Nanoseconds" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eNanoseconds ;
      return;
    }
    if( "eNanoseconds" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eNanoseconds ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eNanoseconds ;
      return;
    }
    if( "Bytes" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eBytes ;
      return;
    }
    if( "eBytes" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eBytes ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eBytes ;
      return;
    }
    if( "BytesPerSecond" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eBytesPerSecond ;
      return;
    }
    if( "eBytesPerSecond" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eBytesPerSecond ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eBytesPerSecond ;
      return;
    }
    if( "Kelvin" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eKelvin ;
      return;
    }
    if( "eKelvin" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eKelvin ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eKelvin ;
      return;
    }
    if( "Watts" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eWatts ;
      return;
    }
    if( "eWatts" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eWatts ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eWatts ;
      return;
    }
    if( "Volts" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eVolts ;
      return;
    }
    if( "eVolts" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eVolts ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eVolts ;
      return;
    }
    if( "Amps" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eAmps ;
      return;
    }
    if( "eAmps" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eAmps ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eAmps ;
      return;
    }
    if( "Hertz" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eHertz ;
      return;
    }
    if( "eHertz" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eHertz ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eHertz ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceCounterUnitKHR" );
  }
  if( j.is_number() ) {
    p = PerformanceCounterUnitKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceCounterUnitKHR" );
}
}
void from_json( const nlohmann::json &j, VkPerformanceCounterUnitKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceCounterUnitKHR temp;
  from_json( j, temp );
  p = VkPerformanceCounterUnitKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BlendOverlapEXT &p ) {
  if( BlendOverlapEXT :: eUncorrelated == p ) {
    j = "Uncorrelated";
    return;
  }
  if( BlendOverlapEXT :: eDisjoint == p ) {
    j = "Disjoint";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkBlendOverlapEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BlendOverlapEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BlendOverlapEXT &p ) {
  if( j.is_string() ) {
    if( "Uncorrelated" == j.get< std::string >() ) {
      p = BlendOverlapEXT :: eUncorrelated ;
      return;
    }
    if( "eUncorrelated" == j.get< std::string >() ) {
      p = BlendOverlapEXT :: eUncorrelated ;
      return;
    }
    if( "VK_BLEND_OVERLAP_UNCORRELATED_EXT" == j.get< std::string >() ) {
      p = BlendOverlapEXT :: eUncorrelated ;
      return;
    }
    if( "Disjoint" == j.get< std::string >() ) {
      p = BlendOverlapEXT :: eDisjoint ;
      return;
    }
    if( "eDisjoint" == j.get< std::string >() ) {
      p = BlendOverlapEXT :: eDisjoint ;
      return;
    }
    if( "VK_BLEND_OVERLAP_DISJOINT_EXT" == j.get< std::string >() ) {
      p = BlendOverlapEXT :: eDisjoint ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BlendOverlapEXT" );
  }
  if( j.is_number() ) {
    p = BlendOverlapEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BlendOverlapEXT" );
}
}
void from_json( const nlohmann::json &j, VkBlendOverlapEXT &p ) {
  VULKAN_HPP_NAMESPACE :: BlendOverlapEXT temp;
  from_json( j, temp );
  p = VkBlendOverlapEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureTypeKHR &p ) {
  if( AccelerationStructureTypeKHR :: eTopLevel == p ) {
    j = "TopLevel";
    return;
  }
  if( AccelerationStructureTypeKHR :: eBottomLevel == p ) {
    j = "BottomLevel";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureTypeKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureTypeKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureTypeKHR &p ) {
  if( j.is_string() ) {
    if( "TopLevel" == j.get< std::string >() ) {
      p = AccelerationStructureTypeKHR :: eTopLevel ;
      return;
    }
    if( "eTopLevel" == j.get< std::string >() ) {
      p = AccelerationStructureTypeKHR :: eTopLevel ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR" == j.get< std::string >() ) {
      p = AccelerationStructureTypeKHR :: eTopLevel ;
      return;
    }
    if( "BottomLevel" == j.get< std::string >() ) {
      p = AccelerationStructureTypeKHR :: eBottomLevel ;
      return;
    }
    if( "eBottomLevel" == j.get< std::string >() ) {
      p = AccelerationStructureTypeKHR :: eBottomLevel ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR" == j.get< std::string >() ) {
      p = AccelerationStructureTypeKHR :: eBottomLevel ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureTypeKHR" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureTypeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureTypeKHR" );
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureTypeKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureTypeKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureTypeKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureBuildTypeKHR &p ) {
  if( AccelerationStructureBuildTypeKHR :: eHost == p ) {
    j = "Host";
    return;
  }
  if( AccelerationStructureBuildTypeKHR :: eDevice == p ) {
    j = "Device";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureBuildTypeKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureBuildTypeKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureBuildTypeKHR &p ) {
  if( j.is_string() ) {
    if( "Host" == j.get< std::string >() ) {
      p = AccelerationStructureBuildTypeKHR :: eHost ;
      return;
    }
    if( "eHost" == j.get< std::string >() ) {
      p = AccelerationStructureBuildTypeKHR :: eHost ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR" == j.get< std::string >() ) {
      p = AccelerationStructureBuildTypeKHR :: eHost ;
      return;
    }
    if( "Device" == j.get< std::string >() ) {
      p = AccelerationStructureBuildTypeKHR :: eDevice ;
      return;
    }
    if( "eDevice" == j.get< std::string >() ) {
      p = AccelerationStructureBuildTypeKHR :: eDevice ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR" == j.get< std::string >() ) {
      p = AccelerationStructureBuildTypeKHR :: eDevice ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureBuildTypeKHR" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureBuildTypeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureBuildTypeKHR" );
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureBuildTypeKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureBuildTypeKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureBuildTypeKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CopyAccelerationStructureModeKHR &p ) {
  if( CopyAccelerationStructureModeKHR :: eClone == p ) {
    j = "Clone";
    return;
  }
  if( CopyAccelerationStructureModeKHR :: eCompact == p ) {
    j = "Compact";
    return;
  }
  if( CopyAccelerationStructureModeKHR :: eSerialize == p ) {
    j = "Serialize";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkCopyAccelerationStructureModeKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CopyAccelerationStructureModeKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CopyAccelerationStructureModeKHR &p ) {
  if( j.is_string() ) {
    if( "Clone" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eClone ;
      return;
    }
    if( "eClone" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eClone ;
      return;
    }
    if( "VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eClone ;
      return;
    }
    if( "Compact" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eCompact ;
      return;
    }
    if( "eCompact" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eCompact ;
      return;
    }
    if( "VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eCompact ;
      return;
    }
    if( "Serialize" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eSerialize ;
      return;
    }
    if( "eSerialize" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eSerialize ;
      return;
    }
    if( "VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eSerialize ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CopyAccelerationStructureModeKHR" );
  }
  if( j.is_number() ) {
    p = CopyAccelerationStructureModeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CopyAccelerationStructureModeKHR" );
}
}
void from_json( const nlohmann::json &j, VkCopyAccelerationStructureModeKHR &p ) {
  VULKAN_HPP_NAMESPACE :: CopyAccelerationStructureModeKHR temp;
  from_json( j, temp );
  p = VkCopyAccelerationStructureModeKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const GeometryTypeKHR &p ) {
  if( GeometryTypeKHR :: eTriangles == p ) {
    j = "Triangles";
    return;
  }
  if( GeometryTypeKHR :: eAabbs == p ) {
    j = "Aabbs";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkGeometryTypeKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: GeometryTypeKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, GeometryTypeKHR &p ) {
  if( j.is_string() ) {
    if( "Triangles" == j.get< std::string >() ) {
      p = GeometryTypeKHR :: eTriangles ;
      return;
    }
    if( "eTriangles" == j.get< std::string >() ) {
      p = GeometryTypeKHR :: eTriangles ;
      return;
    }
    if( "VK_GEOMETRY_TYPE_TRIANGLES_KHR" == j.get< std::string >() ) {
      p = GeometryTypeKHR :: eTriangles ;
      return;
    }
    if( "Aabbs" == j.get< std::string >() ) {
      p = GeometryTypeKHR :: eAabbs ;
      return;
    }
    if( "eAabbs" == j.get< std::string >() ) {
      p = GeometryTypeKHR :: eAabbs ;
      return;
    }
    if( "VK_GEOMETRY_TYPE_AABBS_KHR" == j.get< std::string >() ) {
      p = GeometryTypeKHR :: eAabbs ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for GeometryTypeKHR" );
  }
  if( j.is_number() ) {
    p = GeometryTypeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for GeometryTypeKHR" );
}
}
void from_json( const nlohmann::json &j, VkGeometryTypeKHR &p ) {
  VULKAN_HPP_NAMESPACE :: GeometryTypeKHR temp;
  from_json( j, temp );
  p = VkGeometryTypeKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureCompatibilityKHR &p ) {
  if( AccelerationStructureCompatibilityKHR :: eCompatible == p ) {
    j = "Compatible";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureCompatibilityKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureCompatibilityKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureCompatibilityKHR &p ) {
  if( j.is_string() ) {
    if( "Compatible" == j.get< std::string >() ) {
      p = AccelerationStructureCompatibilityKHR :: eCompatible ;
      return;
    }
    if( "eCompatible" == j.get< std::string >() ) {
      p = AccelerationStructureCompatibilityKHR :: eCompatible ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR" == j.get< std::string >() ) {
      p = AccelerationStructureCompatibilityKHR :: eCompatible ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureCompatibilityKHR" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureCompatibilityKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureCompatibilityKHR" );
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureCompatibilityKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureCompatibilityKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureCompatibilityKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BuildAccelerationStructureModeKHR &p ) {
  if( BuildAccelerationStructureModeKHR :: eBuild == p ) {
    j = "Build";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkBuildAccelerationStructureModeKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BuildAccelerationStructureModeKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BuildAccelerationStructureModeKHR &p ) {
  if( j.is_string() ) {
    if( "Build" == j.get< std::string >() ) {
      p = BuildAccelerationStructureModeKHR :: eBuild ;
      return;
    }
    if( "eBuild" == j.get< std::string >() ) {
      p = BuildAccelerationStructureModeKHR :: eBuild ;
      return;
    }
    if( "VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR" == j.get< std::string >() ) {
      p = BuildAccelerationStructureModeKHR :: eBuild ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BuildAccelerationStructureModeKHR" );
  }
  if( j.is_number() ) {
    p = BuildAccelerationStructureModeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BuildAccelerationStructureModeKHR" );
}
}
void from_json( const nlohmann::json &j, VkBuildAccelerationStructureModeKHR &p ) {
  VULKAN_HPP_NAMESPACE :: BuildAccelerationStructureModeKHR temp;
  from_json( j, temp );
  p = VkBuildAccelerationStructureModeKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CoverageModulationModeNV &p ) {
  if( CoverageModulationModeNV :: eNone == p ) {
    j = "None";
    return;
  }
  if( CoverageModulationModeNV :: eRgb == p ) {
    j = "Rgb";
    return;
  }
  if( CoverageModulationModeNV :: eAlpha == p ) {
    j = "Alpha";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkCoverageModulationModeNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CoverageModulationModeNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CoverageModulationModeNV &p ) {
  if( j.is_string() ) {
    if( "None" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eNone ;
      return;
    }
    if( "eNone" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eNone ;
      return;
    }
    if( "VK_COVERAGE_MODULATION_MODE_NONE_NV" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eNone ;
      return;
    }
    if( "Rgb" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eRgb ;
      return;
    }
    if( "eRgb" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eRgb ;
      return;
    }
    if( "VK_COVERAGE_MODULATION_MODE_RGB_NV" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eRgb ;
      return;
    }
    if( "Alpha" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eAlpha ;
      return;
    }
    if( "eAlpha" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eAlpha ;
      return;
    }
    if( "VK_COVERAGE_MODULATION_MODE_ALPHA_NV" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eAlpha ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CoverageModulationModeNV" );
  }
  if( j.is_number() ) {
    p = CoverageModulationModeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CoverageModulationModeNV" );
}
}
void from_json( const nlohmann::json &j, VkCoverageModulationModeNV &p ) {
  VULKAN_HPP_NAMESPACE :: CoverageModulationModeNV temp;
  from_json( j, temp );
  p = VkCoverageModulationModeNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ValidationCacheHeaderVersionEXT &p ) {
}
}
void to_json( nlohmann::json &j, const VkValidationCacheHeaderVersionEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ValidationCacheHeaderVersionEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ValidationCacheHeaderVersionEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for ValidationCacheHeaderVersionEXT" );
  }
  if( j.is_number() ) {
    p = ValidationCacheHeaderVersionEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ValidationCacheHeaderVersionEXT" );
}
}
void from_json( const nlohmann::json &j, VkValidationCacheHeaderVersionEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ValidationCacheHeaderVersionEXT temp;
  from_json( j, temp );
  p = VkValidationCacheHeaderVersionEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ShadingRatePaletteEntryNV &p ) {
  if( ShadingRatePaletteEntryNV :: eNoInvocations == p ) {
    j = "NoInvocations";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e16InvocationsPerPixel == p ) {
    j = "16InvocationsPerPixel";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e8InvocationsPerPixel == p ) {
    j = "8InvocationsPerPixel";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e4InvocationsPerPixel == p ) {
    j = "4InvocationsPerPixel";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e2InvocationsPerPixel == p ) {
    j = "2InvocationsPerPixel";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e1InvocationPerPixel == p ) {
    j = "1InvocationPerPixel";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e1InvocationPer2X1Pixels == p ) {
    j = "1InvocationPer2X1Pixels";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e1InvocationPer1X2Pixels == p ) {
    j = "1InvocationPer1X2Pixels";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e1InvocationPer2X2Pixels == p ) {
    j = "1InvocationPer2X2Pixels";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e1InvocationPer4X2Pixels == p ) {
    j = "1InvocationPer4X2Pixels";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e1InvocationPer2X4Pixels == p ) {
    j = "1InvocationPer2X4Pixels";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkShadingRatePaletteEntryNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ShadingRatePaletteEntryNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ShadingRatePaletteEntryNV &p ) {
  if( j.is_string() ) {
    if( "NoInvocations" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: eNoInvocations ;
      return;
    }
    if( "eNoInvocations" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: eNoInvocations ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: eNoInvocations ;
      return;
    }
    if( "16InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e16InvocationsPerPixel ;
      return;
    }
    if( "e16InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e16InvocationsPerPixel ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e16InvocationsPerPixel ;
      return;
    }
    if( "8InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e8InvocationsPerPixel ;
      return;
    }
    if( "e8InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e8InvocationsPerPixel ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e8InvocationsPerPixel ;
      return;
    }
    if( "4InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e4InvocationsPerPixel ;
      return;
    }
    if( "e4InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e4InvocationsPerPixel ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e4InvocationsPerPixel ;
      return;
    }
    if( "2InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e2InvocationsPerPixel ;
      return;
    }
    if( "e2InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e2InvocationsPerPixel ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e2InvocationsPerPixel ;
      return;
    }
    if( "1InvocationPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPerPixel ;
      return;
    }
    if( "e1InvocationPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPerPixel ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPerPixel ;
      return;
    }
    if( "1InvocationPer2X1Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X1Pixels ;
      return;
    }
    if( "e1InvocationPer2X1Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X1Pixels ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X1Pixels ;
      return;
    }
    if( "1InvocationPer1X2Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer1X2Pixels ;
      return;
    }
    if( "e1InvocationPer1X2Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer1X2Pixels ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer1X2Pixels ;
      return;
    }
    if( "1InvocationPer2X2Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X2Pixels ;
      return;
    }
    if( "e1InvocationPer2X2Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X2Pixels ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X2Pixels ;
      return;
    }
    if( "1InvocationPer4X2Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer4X2Pixels ;
      return;
    }
    if( "e1InvocationPer4X2Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer4X2Pixels ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer4X2Pixels ;
      return;
    }
    if( "1InvocationPer2X4Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X4Pixels ;
      return;
    }
    if( "e1InvocationPer2X4Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X4Pixels ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X4Pixels ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ShadingRatePaletteEntryNV" );
  }
  if( j.is_number() ) {
    p = ShadingRatePaletteEntryNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ShadingRatePaletteEntryNV" );
}
}
void from_json( const nlohmann::json &j, VkShadingRatePaletteEntryNV &p ) {
  VULKAN_HPP_NAMESPACE :: ShadingRatePaletteEntryNV temp;
  from_json( j, temp );
  p = VkShadingRatePaletteEntryNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CoarseSampleOrderTypeNV &p ) {
  if( CoarseSampleOrderTypeNV :: eDefault == p ) {
    j = "Default";
    return;
  }
  if( CoarseSampleOrderTypeNV :: eCustom == p ) {
    j = "Custom";
    return;
  }
  if( CoarseSampleOrderTypeNV :: ePixelMajor == p ) {
    j = "PixelMajor";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkCoarseSampleOrderTypeNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CoarseSampleOrderTypeNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CoarseSampleOrderTypeNV &p ) {
  if( j.is_string() ) {
    if( "Default" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: eDefault ;
      return;
    }
    if( "eDefault" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: eDefault ;
      return;
    }
    if( "VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: eDefault ;
      return;
    }
    if( "Custom" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: eCustom ;
      return;
    }
    if( "eCustom" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: eCustom ;
      return;
    }
    if( "VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: eCustom ;
      return;
    }
    if( "PixelMajor" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: ePixelMajor ;
      return;
    }
    if( "ePixelMajor" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: ePixelMajor ;
      return;
    }
    if( "VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: ePixelMajor ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CoarseSampleOrderTypeNV" );
  }
  if( j.is_number() ) {
    p = CoarseSampleOrderTypeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CoarseSampleOrderTypeNV" );
}
}
void from_json( const nlohmann::json &j, VkCoarseSampleOrderTypeNV &p ) {
  VULKAN_HPP_NAMESPACE :: CoarseSampleOrderTypeNV temp;
  from_json( j, temp );
  p = VkCoarseSampleOrderTypeNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureMemoryRequirementsTypeNV &p ) {
  if( AccelerationStructureMemoryRequirementsTypeNV :: eObject == p ) {
    j = "Object";
    return;
  }
  if( AccelerationStructureMemoryRequirementsTypeNV :: eBuildScratch == p ) {
    j = "BuildScratch";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureMemoryRequirementsTypeNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureMemoryRequirementsTypeNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureMemoryRequirementsTypeNV &p ) {
  if( j.is_string() ) {
    if( "Object" == j.get< std::string >() ) {
      p = AccelerationStructureMemoryRequirementsTypeNV :: eObject ;
      return;
    }
    if( "eObject" == j.get< std::string >() ) {
      p = AccelerationStructureMemoryRequirementsTypeNV :: eObject ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV" == j.get< std::string >() ) {
      p = AccelerationStructureMemoryRequirementsTypeNV :: eObject ;
      return;
    }
    if( "BuildScratch" == j.get< std::string >() ) {
      p = AccelerationStructureMemoryRequirementsTypeNV :: eBuildScratch ;
      return;
    }
    if( "eBuildScratch" == j.get< std::string >() ) {
      p = AccelerationStructureMemoryRequirementsTypeNV :: eBuildScratch ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV" == j.get< std::string >() ) {
      p = AccelerationStructureMemoryRequirementsTypeNV :: eBuildScratch ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureMemoryRequirementsTypeNV" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureMemoryRequirementsTypeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureMemoryRequirementsTypeNV" );
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureMemoryRequirementsTypeNV &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureMemoryRequirementsTypeNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureMemoryRequirementsTypeNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const QueueGlobalPriorityEXT &p ) {
  if( QueueGlobalPriorityEXT :: eLow == p ) {
    j = "Low";
    return;
  }
  if( QueueGlobalPriorityEXT :: eMedium == p ) {
    j = "Medium";
    return;
  }
  if( QueueGlobalPriorityEXT :: eHigh == p ) {
    j = "High";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkQueueGlobalPriorityEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: QueueGlobalPriorityEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, QueueGlobalPriorityEXT &p ) {
  if( j.is_string() ) {
    if( "Low" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eLow ;
      return;
    }
    if( "eLow" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eLow ;
      return;
    }
    if( "VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eLow ;
      return;
    }
    if( "Medium" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eMedium ;
      return;
    }
    if( "eMedium" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eMedium ;
      return;
    }
    if( "VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eMedium ;
      return;
    }
    if( "High" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eHigh ;
      return;
    }
    if( "eHigh" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eHigh ;
      return;
    }
    if( "VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eHigh ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueueGlobalPriorityEXT" );
  }
  if( j.is_number() ) {
    p = QueueGlobalPriorityEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueueGlobalPriorityEXT" );
}
}
void from_json( const nlohmann::json &j, VkQueueGlobalPriorityEXT &p ) {
  VULKAN_HPP_NAMESPACE :: QueueGlobalPriorityEXT temp;
  from_json( j, temp );
  p = VkQueueGlobalPriorityEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const TimeDomainEXT &p ) {
  if( TimeDomainEXT :: eDevice == p ) {
    j = "Device";
    return;
  }
  if( TimeDomainEXT :: eClockMonotonic == p ) {
    j = "ClockMonotonic";
    return;
  }
  if( TimeDomainEXT :: eClockMonotonicRaw == p ) {
    j = "ClockMonotonicRaw";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkTimeDomainEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: TimeDomainEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, TimeDomainEXT &p ) {
  if( j.is_string() ) {
    if( "Device" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eDevice ;
      return;
    }
    if( "eDevice" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eDevice ;
      return;
    }
    if( "VK_TIME_DOMAIN_DEVICE_EXT" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eDevice ;
      return;
    }
    if( "ClockMonotonic" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eClockMonotonic ;
      return;
    }
    if( "eClockMonotonic" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eClockMonotonic ;
      return;
    }
    if( "VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eClockMonotonic ;
      return;
    }
    if( "ClockMonotonicRaw" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eClockMonotonicRaw ;
      return;
    }
    if( "eClockMonotonicRaw" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eClockMonotonicRaw ;
      return;
    }
    if( "VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eClockMonotonicRaw ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for TimeDomainEXT" );
  }
  if( j.is_number() ) {
    p = TimeDomainEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for TimeDomainEXT" );
}
}
void from_json( const nlohmann::json &j, VkTimeDomainEXT &p ) {
  VULKAN_HPP_NAMESPACE :: TimeDomainEXT temp;
  from_json( j, temp );
  p = VkTimeDomainEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryOverallocationBehaviorAMD &p ) {
  if( MemoryOverallocationBehaviorAMD :: eDefault == p ) {
    j = "Default";
    return;
  }
  if( MemoryOverallocationBehaviorAMD :: eAllowed == p ) {
    j = "Allowed";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkMemoryOverallocationBehaviorAMD &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryOverallocationBehaviorAMD ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryOverallocationBehaviorAMD &p ) {
  if( j.is_string() ) {
    if( "Default" == j.get< std::string >() ) {
      p = MemoryOverallocationBehaviorAMD :: eDefault ;
      return;
    }
    if( "eDefault" == j.get< std::string >() ) {
      p = MemoryOverallocationBehaviorAMD :: eDefault ;
      return;
    }
    if( "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD" == j.get< std::string >() ) {
      p = MemoryOverallocationBehaviorAMD :: eDefault ;
      return;
    }
    if( "Allowed" == j.get< std::string >() ) {
      p = MemoryOverallocationBehaviorAMD :: eAllowed ;
      return;
    }
    if( "eAllowed" == j.get< std::string >() ) {
      p = MemoryOverallocationBehaviorAMD :: eAllowed ;
      return;
    }
    if( "VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD" == j.get< std::string >() ) {
      p = MemoryOverallocationBehaviorAMD :: eAllowed ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for MemoryOverallocationBehaviorAMD" );
  }
  if( j.is_number() ) {
    p = MemoryOverallocationBehaviorAMD ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for MemoryOverallocationBehaviorAMD" );
}
}
void from_json( const nlohmann::json &j, VkMemoryOverallocationBehaviorAMD &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryOverallocationBehaviorAMD temp;
  from_json( j, temp );
  p = VkMemoryOverallocationBehaviorAMD ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceConfigurationTypeINTEL &p ) {
}
}
void to_json( nlohmann::json &j, const VkPerformanceConfigurationTypeINTEL &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceConfigurationTypeINTEL ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceConfigurationTypeINTEL &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceConfigurationTypeINTEL" );
  }
  if( j.is_number() ) {
    p = PerformanceConfigurationTypeINTEL ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceConfigurationTypeINTEL" );
}
}
void from_json( const nlohmann::json &j, VkPerformanceConfigurationTypeINTEL &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceConfigurationTypeINTEL temp;
  from_json( j, temp );
  p = VkPerformanceConfigurationTypeINTEL ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const QueryPoolSamplingModeINTEL &p ) {
}
}
void to_json( nlohmann::json &j, const VkQueryPoolSamplingModeINTEL &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: QueryPoolSamplingModeINTEL ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, QueryPoolSamplingModeINTEL &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueryPoolSamplingModeINTEL" );
  }
  if( j.is_number() ) {
    p = QueryPoolSamplingModeINTEL ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueryPoolSamplingModeINTEL" );
}
}
void from_json( const nlohmann::json &j, VkQueryPoolSamplingModeINTEL &p ) {
  VULKAN_HPP_NAMESPACE :: QueryPoolSamplingModeINTEL temp;
  from_json( j, temp );
  p = VkQueryPoolSamplingModeINTEL ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceOverrideTypeINTEL &p ) {
  if( PerformanceOverrideTypeINTEL :: eNullHardware == p ) {
    j = "NullHardware";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkPerformanceOverrideTypeINTEL &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceOverrideTypeINTEL ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceOverrideTypeINTEL &p ) {
  if( j.is_string() ) {
    if( "NullHardware" == j.get< std::string >() ) {
      p = PerformanceOverrideTypeINTEL :: eNullHardware ;
      return;
    }
    if( "eNullHardware" == j.get< std::string >() ) {
      p = PerformanceOverrideTypeINTEL :: eNullHardware ;
      return;
    }
    if( "VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL" == j.get< std::string >() ) {
      p = PerformanceOverrideTypeINTEL :: eNullHardware ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceOverrideTypeINTEL" );
  }
  if( j.is_number() ) {
    p = PerformanceOverrideTypeINTEL ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceOverrideTypeINTEL" );
}
}
void from_json( const nlohmann::json &j, VkPerformanceOverrideTypeINTEL &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceOverrideTypeINTEL temp;
  from_json( j, temp );
  p = VkPerformanceOverrideTypeINTEL ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceParameterTypeINTEL &p ) {
  if( PerformanceParameterTypeINTEL :: eHwCountersSupported == p ) {
    j = "HwCountersSupported";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkPerformanceParameterTypeINTEL &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceParameterTypeINTEL ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceParameterTypeINTEL &p ) {
  if( j.is_string() ) {
    if( "HwCountersSupported" == j.get< std::string >() ) {
      p = PerformanceParameterTypeINTEL :: eHwCountersSupported ;
      return;
    }
    if( "eHwCountersSupported" == j.get< std::string >() ) {
      p = PerformanceParameterTypeINTEL :: eHwCountersSupported ;
      return;
    }
    if( "VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL" == j.get< std::string >() ) {
      p = PerformanceParameterTypeINTEL :: eHwCountersSupported ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceParameterTypeINTEL" );
  }
  if( j.is_number() ) {
    p = PerformanceParameterTypeINTEL ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceParameterTypeINTEL" );
}
}
void from_json( const nlohmann::json &j, VkPerformanceParameterTypeINTEL &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceParameterTypeINTEL temp;
  from_json( j, temp );
  p = VkPerformanceParameterTypeINTEL ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceValueTypeINTEL &p ) {
  if( PerformanceValueTypeINTEL :: eUint32 == p ) {
    j = "Uint32";
    return;
  }
  if( PerformanceValueTypeINTEL :: eUint64 == p ) {
    j = "Uint64";
    return;
  }
  if( PerformanceValueTypeINTEL :: eFloat == p ) {
    j = "Float";
    return;
  }
  if( PerformanceValueTypeINTEL :: eBool == p ) {
    j = "Bool";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkPerformanceValueTypeINTEL &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceValueTypeINTEL ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceValueTypeINTEL &p ) {
  if( j.is_string() ) {
    if( "Uint32" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eUint32 ;
      return;
    }
    if( "eUint32" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eUint32 ;
      return;
    }
    if( "VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eUint32 ;
      return;
    }
    if( "Uint64" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eUint64 ;
      return;
    }
    if( "eUint64" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eUint64 ;
      return;
    }
    if( "VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eUint64 ;
      return;
    }
    if( "Float" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eFloat ;
      return;
    }
    if( "eFloat" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eFloat ;
      return;
    }
    if( "VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eFloat ;
      return;
    }
    if( "Bool" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eBool ;
      return;
    }
    if( "eBool" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eBool ;
      return;
    }
    if( "VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eBool ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceValueTypeINTEL" );
  }
  if( j.is_number() ) {
    p = PerformanceValueTypeINTEL ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceValueTypeINTEL" );
}
}
void from_json( const nlohmann::json &j, VkPerformanceValueTypeINTEL &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceValueTypeINTEL temp;
  from_json( j, temp );
  p = VkPerformanceValueTypeINTEL ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FragmentShadingRateCombinerOpKHR &p ) {
  if( FragmentShadingRateCombinerOpKHR :: eKeep == p ) {
    j = "Keep";
    return;
  }
  if( FragmentShadingRateCombinerOpKHR :: eReplace == p ) {
    j = "Replace";
    return;
  }
  if( FragmentShadingRateCombinerOpKHR :: eMin == p ) {
    j = "Min";
    return;
  }
  if( FragmentShadingRateCombinerOpKHR :: eMax == p ) {
    j = "Max";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkFragmentShadingRateCombinerOpKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: FragmentShadingRateCombinerOpKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, FragmentShadingRateCombinerOpKHR &p ) {
  if( j.is_string() ) {
    if( "Keep" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eKeep ;
      return;
    }
    if( "eKeep" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eKeep ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eKeep ;
      return;
    }
    if( "Replace" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eReplace ;
      return;
    }
    if( "eReplace" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eReplace ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eReplace ;
      return;
    }
    if( "Min" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eMin ;
      return;
    }
    if( "eMin" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eMin ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eMin ;
      return;
    }
    if( "Max" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eMax ;
      return;
    }
    if( "eMax" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eMax ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eMax ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for FragmentShadingRateCombinerOpKHR" );
  }
  if( j.is_number() ) {
    p = FragmentShadingRateCombinerOpKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FragmentShadingRateCombinerOpKHR" );
}
}
void from_json( const nlohmann::json &j, VkFragmentShadingRateCombinerOpKHR &p ) {
  VULKAN_HPP_NAMESPACE :: FragmentShadingRateCombinerOpKHR temp;
  from_json( j, temp );
  p = VkFragmentShadingRateCombinerOpKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ValidationFeatureEnableEXT &p ) {
  if( ValidationFeatureEnableEXT :: eGpuAssisted == p ) {
    j = "GpuAssisted";
    return;
  }
  if( ValidationFeatureEnableEXT :: eGpuAssistedReserveBindingSlot == p ) {
    j = "GpuAssistedReserveBindingSlot";
    return;
  }
  if( ValidationFeatureEnableEXT :: eBestPractices == p ) {
    j = "BestPractices";
    return;
  }
  if( ValidationFeatureEnableEXT :: eDebugPrintf == p ) {
    j = "DebugPrintf";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkValidationFeatureEnableEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ValidationFeatureEnableEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ValidationFeatureEnableEXT &p ) {
  if( j.is_string() ) {
    if( "GpuAssisted" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eGpuAssisted ;
      return;
    }
    if( "eGpuAssisted" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eGpuAssisted ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eGpuAssisted ;
      return;
    }
    if( "GpuAssistedReserveBindingSlot" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eGpuAssistedReserveBindingSlot ;
      return;
    }
    if( "eGpuAssistedReserveBindingSlot" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eGpuAssistedReserveBindingSlot ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eGpuAssistedReserveBindingSlot ;
      return;
    }
    if( "BestPractices" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eBestPractices ;
      return;
    }
    if( "eBestPractices" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eBestPractices ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eBestPractices ;
      return;
    }
    if( "DebugPrintf" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eDebugPrintf ;
      return;
    }
    if( "eDebugPrintf" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eDebugPrintf ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eDebugPrintf ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ValidationFeatureEnableEXT" );
  }
  if( j.is_number() ) {
    p = ValidationFeatureEnableEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ValidationFeatureEnableEXT" );
}
}
void from_json( const nlohmann::json &j, VkValidationFeatureEnableEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ValidationFeatureEnableEXT temp;
  from_json( j, temp );
  p = VkValidationFeatureEnableEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ValidationFeatureDisableEXT &p ) {
  if( ValidationFeatureDisableEXT :: eAll == p ) {
    j = "All";
    return;
  }
  if( ValidationFeatureDisableEXT :: eShaders == p ) {
    j = "Shaders";
    return;
  }
  if( ValidationFeatureDisableEXT :: eThreadSafety == p ) {
    j = "ThreadSafety";
    return;
  }
  if( ValidationFeatureDisableEXT :: eApiParameters == p ) {
    j = "ApiParameters";
    return;
  }
  if( ValidationFeatureDisableEXT :: eObjectLifetimes == p ) {
    j = "ObjectLifetimes";
    return;
  }
  if( ValidationFeatureDisableEXT :: eCoreChecks == p ) {
    j = "CoreChecks";
    return;
  }
  if( ValidationFeatureDisableEXT :: eUniqueHandles == p ) {
    j = "UniqueHandles";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkValidationFeatureDisableEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ValidationFeatureDisableEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ValidationFeatureDisableEXT &p ) {
  if( j.is_string() ) {
    if( "All" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eAll ;
      return;
    }
    if( "eAll" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eAll ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_DISABLE_ALL_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eAll ;
      return;
    }
    if( "Shaders" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eShaders ;
      return;
    }
    if( "eShaders" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eShaders ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eShaders ;
      return;
    }
    if( "ThreadSafety" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eThreadSafety ;
      return;
    }
    if( "eThreadSafety" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eThreadSafety ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eThreadSafety ;
      return;
    }
    if( "ApiParameters" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eApiParameters ;
      return;
    }
    if( "eApiParameters" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eApiParameters ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eApiParameters ;
      return;
    }
    if( "ObjectLifetimes" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eObjectLifetimes ;
      return;
    }
    if( "eObjectLifetimes" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eObjectLifetimes ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eObjectLifetimes ;
      return;
    }
    if( "CoreChecks" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eCoreChecks ;
      return;
    }
    if( "eCoreChecks" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eCoreChecks ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eCoreChecks ;
      return;
    }
    if( "UniqueHandles" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eUniqueHandles ;
      return;
    }
    if( "eUniqueHandles" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eUniqueHandles ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eUniqueHandles ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ValidationFeatureDisableEXT" );
  }
  if( j.is_number() ) {
    p = ValidationFeatureDisableEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ValidationFeatureDisableEXT" );
}
}
void from_json( const nlohmann::json &j, VkValidationFeatureDisableEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ValidationFeatureDisableEXT temp;
  from_json( j, temp );
  p = VkValidationFeatureDisableEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ScopeNV &p ) {
  if( ScopeNV :: eDevice == p ) {
    j = "Device";
    return;
  }
  if( ScopeNV :: eWorkgroup == p ) {
    j = "Workgroup";
    return;
  }
  if( ScopeNV :: eSubgroup == p ) {
    j = "Subgroup";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkScopeNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ScopeNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ScopeNV &p ) {
  if( j.is_string() ) {
    if( "Device" == j.get< std::string >() ) {
      p = ScopeNV :: eDevice ;
      return;
    }
    if( "eDevice" == j.get< std::string >() ) {
      p = ScopeNV :: eDevice ;
      return;
    }
    if( "VK_SCOPE_DEVICE_NV" == j.get< std::string >() ) {
      p = ScopeNV :: eDevice ;
      return;
    }
    if( "Workgroup" == j.get< std::string >() ) {
      p = ScopeNV :: eWorkgroup ;
      return;
    }
    if( "eWorkgroup" == j.get< std::string >() ) {
      p = ScopeNV :: eWorkgroup ;
      return;
    }
    if( "VK_SCOPE_WORKGROUP_NV" == j.get< std::string >() ) {
      p = ScopeNV :: eWorkgroup ;
      return;
    }
    if( "Subgroup" == j.get< std::string >() ) {
      p = ScopeNV :: eSubgroup ;
      return;
    }
    if( "eSubgroup" == j.get< std::string >() ) {
      p = ScopeNV :: eSubgroup ;
      return;
    }
    if( "VK_SCOPE_SUBGROUP_NV" == j.get< std::string >() ) {
      p = ScopeNV :: eSubgroup ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ScopeNV" );
  }
  if( j.is_number() ) {
    p = ScopeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ScopeNV" );
}
}
void from_json( const nlohmann::json &j, VkScopeNV &p ) {
  VULKAN_HPP_NAMESPACE :: ScopeNV temp;
  from_json( j, temp );
  p = VkScopeNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ComponentTypeNV &p ) {
  if( ComponentTypeNV :: eFloat16 == p ) {
    j = "Float16";
    return;
  }
  if( ComponentTypeNV :: eFloat32 == p ) {
    j = "Float32";
    return;
  }
  if( ComponentTypeNV :: eFloat64 == p ) {
    j = "Float64";
    return;
  }
  if( ComponentTypeNV :: eSint8 == p ) {
    j = "Sint8";
    return;
  }
  if( ComponentTypeNV :: eSint16 == p ) {
    j = "Sint16";
    return;
  }
  if( ComponentTypeNV :: eSint32 == p ) {
    j = "Sint32";
    return;
  }
  if( ComponentTypeNV :: eSint64 == p ) {
    j = "Sint64";
    return;
  }
  if( ComponentTypeNV :: eUint8 == p ) {
    j = "Uint8";
    return;
  }
  if( ComponentTypeNV :: eUint16 == p ) {
    j = "Uint16";
    return;
  }
  if( ComponentTypeNV :: eUint32 == p ) {
    j = "Uint32";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkComponentTypeNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ComponentTypeNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ComponentTypeNV &p ) {
  if( j.is_string() ) {
    if( "Float16" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat16 ;
      return;
    }
    if( "eFloat16" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat16 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_FLOAT16_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat16 ;
      return;
    }
    if( "Float32" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat32 ;
      return;
    }
    if( "eFloat32" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat32 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_FLOAT32_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat32 ;
      return;
    }
    if( "Float64" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat64 ;
      return;
    }
    if( "eFloat64" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat64 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_FLOAT64_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat64 ;
      return;
    }
    if( "Sint8" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint8 ;
      return;
    }
    if( "eSint8" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint8 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_SINT8_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint8 ;
      return;
    }
    if( "Sint16" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint16 ;
      return;
    }
    if( "eSint16" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint16 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_SINT16_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint16 ;
      return;
    }
    if( "Sint32" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint32 ;
      return;
    }
    if( "eSint32" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint32 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_SINT32_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint32 ;
      return;
    }
    if( "Sint64" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint64 ;
      return;
    }
    if( "eSint64" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint64 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_SINT64_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint64 ;
      return;
    }
    if( "Uint8" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint8 ;
      return;
    }
    if( "eUint8" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint8 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_UINT8_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint8 ;
      return;
    }
    if( "Uint16" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint16 ;
      return;
    }
    if( "eUint16" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint16 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_UINT16_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint16 ;
      return;
    }
    if( "Uint32" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint32 ;
      return;
    }
    if( "eUint32" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint32 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_UINT32_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint32 ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ComponentTypeNV" );
  }
  if( j.is_number() ) {
    p = ComponentTypeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ComponentTypeNV" );
}
}
void from_json( const nlohmann::json &j, VkComponentTypeNV &p ) {
  VULKAN_HPP_NAMESPACE :: ComponentTypeNV temp;
  from_json( j, temp );
  p = VkComponentTypeNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CoverageReductionModeNV &p ) {
  if( CoverageReductionModeNV :: eMerge == p ) {
    j = "Merge";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkCoverageReductionModeNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CoverageReductionModeNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CoverageReductionModeNV &p ) {
  if( j.is_string() ) {
    if( "Merge" == j.get< std::string >() ) {
      p = CoverageReductionModeNV :: eMerge ;
      return;
    }
    if( "eMerge" == j.get< std::string >() ) {
      p = CoverageReductionModeNV :: eMerge ;
      return;
    }
    if( "VK_COVERAGE_REDUCTION_MODE_MERGE_NV" == j.get< std::string >() ) {
      p = CoverageReductionModeNV :: eMerge ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CoverageReductionModeNV" );
  }
  if( j.is_number() ) {
    p = CoverageReductionModeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CoverageReductionModeNV" );
}
}
void from_json( const nlohmann::json &j, VkCoverageReductionModeNV &p ) {
  VULKAN_HPP_NAMESPACE :: CoverageReductionModeNV temp;
  from_json( j, temp );
  p = VkCoverageReductionModeNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ProvokingVertexModeEXT &p ) {
  if( ProvokingVertexModeEXT :: eFirstVertex == p ) {
    j = "FirstVertex";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkProvokingVertexModeEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ProvokingVertexModeEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ProvokingVertexModeEXT &p ) {
  if( j.is_string() ) {
    if( "FirstVertex" == j.get< std::string >() ) {
      p = ProvokingVertexModeEXT :: eFirstVertex ;
      return;
    }
    if( "eFirstVertex" == j.get< std::string >() ) {
      p = ProvokingVertexModeEXT :: eFirstVertex ;
      return;
    }
    if( "VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT" == j.get< std::string >() ) {
      p = ProvokingVertexModeEXT :: eFirstVertex ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ProvokingVertexModeEXT" );
  }
  if( j.is_number() ) {
    p = ProvokingVertexModeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ProvokingVertexModeEXT" );
}
}
void from_json( const nlohmann::json &j, VkProvokingVertexModeEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ProvokingVertexModeEXT temp;
  from_json( j, temp );
  p = VkProvokingVertexModeEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const LineRasterizationModeEXT &p ) {
  if( LineRasterizationModeEXT :: eDefault == p ) {
    j = "Default";
    return;
  }
  if( LineRasterizationModeEXT :: eRectangular == p ) {
    j = "Rectangular";
    return;
  }
  if( LineRasterizationModeEXT :: eBresenham == p ) {
    j = "Bresenham";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkLineRasterizationModeEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: LineRasterizationModeEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, LineRasterizationModeEXT &p ) {
  if( j.is_string() ) {
    if( "Default" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eDefault ;
      return;
    }
    if( "eDefault" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eDefault ;
      return;
    }
    if( "VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eDefault ;
      return;
    }
    if( "Rectangular" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eRectangular ;
      return;
    }
    if( "eRectangular" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eRectangular ;
      return;
    }
    if( "VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eRectangular ;
      return;
    }
    if( "Bresenham" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eBresenham ;
      return;
    }
    if( "eBresenham" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eBresenham ;
      return;
    }
    if( "VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eBresenham ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for LineRasterizationModeEXT" );
  }
  if( j.is_number() ) {
    p = LineRasterizationModeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for LineRasterizationModeEXT" );
}
}
void from_json( const nlohmann::json &j, VkLineRasterizationModeEXT &p ) {
  VULKAN_HPP_NAMESPACE :: LineRasterizationModeEXT temp;
  from_json( j, temp );
  p = VkLineRasterizationModeEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineExecutableStatisticFormatKHR &p ) {
  if( PipelineExecutableStatisticFormatKHR :: eBool32 == p ) {
    j = "Bool32";
    return;
  }
  if( PipelineExecutableStatisticFormatKHR :: eInt64 == p ) {
    j = "Int64";
    return;
  }
  if( PipelineExecutableStatisticFormatKHR :: eUint64 == p ) {
    j = "Uint64";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkPipelineExecutableStatisticFormatKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineExecutableStatisticFormatKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineExecutableStatisticFormatKHR &p ) {
  if( j.is_string() ) {
    if( "Bool32" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eBool32 ;
      return;
    }
    if( "eBool32" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eBool32 ;
      return;
    }
    if( "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eBool32 ;
      return;
    }
    if( "Int64" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eInt64 ;
      return;
    }
    if( "eInt64" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eInt64 ;
      return;
    }
    if( "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eInt64 ;
      return;
    }
    if( "Uint64" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eUint64 ;
      return;
    }
    if( "eUint64" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eUint64 ;
      return;
    }
    if( "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eUint64 ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineExecutableStatisticFormatKHR" );
  }
  if( j.is_number() ) {
    p = PipelineExecutableStatisticFormatKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineExecutableStatisticFormatKHR" );
}
}
void from_json( const nlohmann::json &j, VkPipelineExecutableStatisticFormatKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineExecutableStatisticFormatKHR temp;
  from_json( j, temp );
  p = VkPipelineExecutableStatisticFormatKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const IndirectCommandsTokenTypeNV &p ) {
  if( IndirectCommandsTokenTypeNV :: eShaderGroup == p ) {
    j = "ShaderGroup";
    return;
  }
  if( IndirectCommandsTokenTypeNV :: eStateFlags == p ) {
    j = "StateFlags";
    return;
  }
  if( IndirectCommandsTokenTypeNV :: eIndexBuffer == p ) {
    j = "IndexBuffer";
    return;
  }
  if( IndirectCommandsTokenTypeNV :: eVertexBuffer == p ) {
    j = "VertexBuffer";
    return;
  }
  if( IndirectCommandsTokenTypeNV :: ePushConstant == p ) {
    j = "PushConstant";
    return;
  }
  if( IndirectCommandsTokenTypeNV :: eDrawIndexed == p ) {
    j = "DrawIndexed";
    return;
  }
  if( IndirectCommandsTokenTypeNV :: eDraw == p ) {
    j = "Draw";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkIndirectCommandsTokenTypeNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: IndirectCommandsTokenTypeNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, IndirectCommandsTokenTypeNV &p ) {
  if( j.is_string() ) {
    if( "ShaderGroup" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eShaderGroup ;
      return;
    }
    if( "eShaderGroup" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eShaderGroup ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eShaderGroup ;
      return;
    }
    if( "StateFlags" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eStateFlags ;
      return;
    }
    if( "eStateFlags" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eStateFlags ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eStateFlags ;
      return;
    }
    if( "IndexBuffer" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eIndexBuffer ;
      return;
    }
    if( "eIndexBuffer" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eIndexBuffer ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eIndexBuffer ;
      return;
    }
    if( "VertexBuffer" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eVertexBuffer ;
      return;
    }
    if( "eVertexBuffer" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eVertexBuffer ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eVertexBuffer ;
      return;
    }
    if( "PushConstant" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: ePushConstant ;
      return;
    }
    if( "ePushConstant" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: ePushConstant ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: ePushConstant ;
      return;
    }
    if( "DrawIndexed" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eDrawIndexed ;
      return;
    }
    if( "eDrawIndexed" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eDrawIndexed ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eDrawIndexed ;
      return;
    }
    if( "Draw" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eDraw ;
      return;
    }
    if( "eDraw" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eDraw ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eDraw ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for IndirectCommandsTokenTypeNV" );
  }
  if( j.is_number() ) {
    p = IndirectCommandsTokenTypeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for IndirectCommandsTokenTypeNV" );
}
}
void from_json( const nlohmann::json &j, VkIndirectCommandsTokenTypeNV &p ) {
  VULKAN_HPP_NAMESPACE :: IndirectCommandsTokenTypeNV temp;
  from_json( j, temp );
  p = VkIndirectCommandsTokenTypeNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceMemoryReportEventTypeEXT &p ) {
  if( DeviceMemoryReportEventTypeEXT :: eAllocate == p ) {
    j = "Allocate";
    return;
  }
  if( DeviceMemoryReportEventTypeEXT :: eFree == p ) {
    j = "Free";
    return;
  }
  if( DeviceMemoryReportEventTypeEXT :: eImport == p ) {
    j = "Import";
    return;
  }
  if( DeviceMemoryReportEventTypeEXT :: eUnimport == p ) {
    j = "Unimport";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkDeviceMemoryReportEventTypeEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceMemoryReportEventTypeEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceMemoryReportEventTypeEXT &p ) {
  if( j.is_string() ) {
    if( "Allocate" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eAllocate ;
      return;
    }
    if( "eAllocate" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eAllocate ;
      return;
    }
    if( "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eAllocate ;
      return;
    }
    if( "Free" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eFree ;
      return;
    }
    if( "eFree" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eFree ;
      return;
    }
    if( "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eFree ;
      return;
    }
    if( "Import" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eImport ;
      return;
    }
    if( "eImport" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eImport ;
      return;
    }
    if( "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eImport ;
      return;
    }
    if( "Unimport" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eUnimport ;
      return;
    }
    if( "eUnimport" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eUnimport ;
      return;
    }
    if( "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eUnimport ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DeviceMemoryReportEventTypeEXT" );
  }
  if( j.is_number() ) {
    p = DeviceMemoryReportEventTypeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DeviceMemoryReportEventTypeEXT" );
}
}
void from_json( const nlohmann::json &j, VkDeviceMemoryReportEventTypeEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceMemoryReportEventTypeEXT temp;
  from_json( j, temp );
  p = VkDeviceMemoryReportEventTypeEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FragmentShadingRateNV &p ) {
  if( FragmentShadingRateNV :: e1InvocationPerPixel == p ) {
    j = "1InvocationPerPixel";
    return;
  }
  if( FragmentShadingRateNV :: e1InvocationPer1X2Pixels == p ) {
    j = "1InvocationPer1X2Pixels";
    return;
  }
  if( FragmentShadingRateNV :: e1InvocationPer2X1Pixels == p ) {
    j = "1InvocationPer2X1Pixels";
    return;
  }
  if( FragmentShadingRateNV :: e1InvocationPer2X2Pixels == p ) {
    j = "1InvocationPer2X2Pixels";
    return;
  }
  if( FragmentShadingRateNV :: e1InvocationPer2X4Pixels == p ) {
    j = "1InvocationPer2X4Pixels";
    return;
  }
  if( FragmentShadingRateNV :: e1InvocationPer4X2Pixels == p ) {
    j = "1InvocationPer4X2Pixels";
    return;
  }
  if( FragmentShadingRateNV :: e1InvocationPer4X4Pixels == p ) {
    j = "1InvocationPer4X4Pixels";
    return;
  }
  if( FragmentShadingRateNV :: e2InvocationsPerPixel == p ) {
    j = "2InvocationsPerPixel";
    return;
  }
  if( FragmentShadingRateNV :: e4InvocationsPerPixel == p ) {
    j = "4InvocationsPerPixel";
    return;
  }
  if( FragmentShadingRateNV :: e8InvocationsPerPixel == p ) {
    j = "8InvocationsPerPixel";
    return;
  }
  if( FragmentShadingRateNV :: e16InvocationsPerPixel == p ) {
    j = "16InvocationsPerPixel";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkFragmentShadingRateNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: FragmentShadingRateNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, FragmentShadingRateNV &p ) {
  if( j.is_string() ) {
    if( "1InvocationPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPerPixel ;
      return;
    }
    if( "e1InvocationPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPerPixel ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPerPixel ;
      return;
    }
    if( "1InvocationPer1X2Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer1X2Pixels ;
      return;
    }
    if( "e1InvocationPer1X2Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer1X2Pixels ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer1X2Pixels ;
      return;
    }
    if( "1InvocationPer2X1Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X1Pixels ;
      return;
    }
    if( "e1InvocationPer2X1Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X1Pixels ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X1Pixels ;
      return;
    }
    if( "1InvocationPer2X2Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X2Pixels ;
      return;
    }
    if( "e1InvocationPer2X2Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X2Pixels ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X2Pixels ;
      return;
    }
    if( "1InvocationPer2X4Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X4Pixels ;
      return;
    }
    if( "e1InvocationPer2X4Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X4Pixels ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X4Pixels ;
      return;
    }
    if( "1InvocationPer4X2Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer4X2Pixels ;
      return;
    }
    if( "e1InvocationPer4X2Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer4X2Pixels ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer4X2Pixels ;
      return;
    }
    if( "1InvocationPer4X4Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer4X4Pixels ;
      return;
    }
    if( "e1InvocationPer4X4Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer4X4Pixels ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer4X4Pixels ;
      return;
    }
    if( "2InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e2InvocationsPerPixel ;
      return;
    }
    if( "e2InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e2InvocationsPerPixel ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e2InvocationsPerPixel ;
      return;
    }
    if( "4InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e4InvocationsPerPixel ;
      return;
    }
    if( "e4InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e4InvocationsPerPixel ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e4InvocationsPerPixel ;
      return;
    }
    if( "8InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e8InvocationsPerPixel ;
      return;
    }
    if( "e8InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e8InvocationsPerPixel ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e8InvocationsPerPixel ;
      return;
    }
    if( "16InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e16InvocationsPerPixel ;
      return;
    }
    if( "e16InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e16InvocationsPerPixel ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e16InvocationsPerPixel ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for FragmentShadingRateNV" );
  }
  if( j.is_number() ) {
    p = FragmentShadingRateNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FragmentShadingRateNV" );
}
}
void from_json( const nlohmann::json &j, VkFragmentShadingRateNV &p ) {
  VULKAN_HPP_NAMESPACE :: FragmentShadingRateNV temp;
  from_json( j, temp );
  p = VkFragmentShadingRateNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FragmentShadingRateTypeNV &p ) {
  if( FragmentShadingRateTypeNV :: eFragmentSize == p ) {
    j = "FragmentSize";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkFragmentShadingRateTypeNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: FragmentShadingRateTypeNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, FragmentShadingRateTypeNV &p ) {
  if( j.is_string() ) {
    if( "FragmentSize" == j.get< std::string >() ) {
      p = FragmentShadingRateTypeNV :: eFragmentSize ;
      return;
    }
    if( "eFragmentSize" == j.get< std::string >() ) {
      p = FragmentShadingRateTypeNV :: eFragmentSize ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateTypeNV :: eFragmentSize ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for FragmentShadingRateTypeNV" );
  }
  if( j.is_number() ) {
    p = FragmentShadingRateTypeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FragmentShadingRateTypeNV" );
}
}
void from_json( const nlohmann::json &j, VkFragmentShadingRateTypeNV &p ) {
  VULKAN_HPP_NAMESPACE :: FragmentShadingRateTypeNV temp;
  from_json( j, temp );
  p = VkFragmentShadingRateTypeNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureMotionInstanceTypeNV &p ) {
  if( AccelerationStructureMotionInstanceTypeNV :: eStatic == p ) {
    j = "Static";
    return;
  }
  if( AccelerationStructureMotionInstanceTypeNV :: eMatrixMotion == p ) {
    j = "MatrixMotion";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureMotionInstanceTypeNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureMotionInstanceTypeNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureMotionInstanceTypeNV &p ) {
  if( j.is_string() ) {
    if( "Static" == j.get< std::string >() ) {
      p = AccelerationStructureMotionInstanceTypeNV :: eStatic ;
      return;
    }
    if( "eStatic" == j.get< std::string >() ) {
      p = AccelerationStructureMotionInstanceTypeNV :: eStatic ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV" == j.get< std::string >() ) {
      p = AccelerationStructureMotionInstanceTypeNV :: eStatic ;
      return;
    }
    if( "MatrixMotion" == j.get< std::string >() ) {
      p = AccelerationStructureMotionInstanceTypeNV :: eMatrixMotion ;
      return;
    }
    if( "eMatrixMotion" == j.get< std::string >() ) {
      p = AccelerationStructureMotionInstanceTypeNV :: eMatrixMotion ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV" == j.get< std::string >() ) {
      p = AccelerationStructureMotionInstanceTypeNV :: eMatrixMotion ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureMotionInstanceTypeNV" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureMotionInstanceTypeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureMotionInstanceTypeNV" );
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureMotionInstanceTypeNV &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureMotionInstanceTypeNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureMotionInstanceTypeNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RayTracingShaderGroupTypeKHR &p ) {
  if( RayTracingShaderGroupTypeKHR :: eGeneral == p ) {
    j = "General";
    return;
  }
  if( RayTracingShaderGroupTypeKHR :: eTrianglesHitGroup == p ) {
    j = "TrianglesHitGroup";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkRayTracingShaderGroupTypeKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RayTracingShaderGroupTypeKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RayTracingShaderGroupTypeKHR &p ) {
  if( j.is_string() ) {
    if( "General" == j.get< std::string >() ) {
      p = RayTracingShaderGroupTypeKHR :: eGeneral ;
      return;
    }
    if( "eGeneral" == j.get< std::string >() ) {
      p = RayTracingShaderGroupTypeKHR :: eGeneral ;
      return;
    }
    if( "VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR" == j.get< std::string >() ) {
      p = RayTracingShaderGroupTypeKHR :: eGeneral ;
      return;
    }
    if( "TrianglesHitGroup" == j.get< std::string >() ) {
      p = RayTracingShaderGroupTypeKHR :: eTrianglesHitGroup ;
      return;
    }
    if( "eTrianglesHitGroup" == j.get< std::string >() ) {
      p = RayTracingShaderGroupTypeKHR :: eTrianglesHitGroup ;
      return;
    }
    if( "VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR" == j.get< std::string >() ) {
      p = RayTracingShaderGroupTypeKHR :: eTrianglesHitGroup ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for RayTracingShaderGroupTypeKHR" );
  }
  if( j.is_number() ) {
    p = RayTracingShaderGroupTypeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for RayTracingShaderGroupTypeKHR" );
}
}
void from_json( const nlohmann::json &j, VkRayTracingShaderGroupTypeKHR &p ) {
  VULKAN_HPP_NAMESPACE :: RayTracingShaderGroupTypeKHR temp;
  from_json( j, temp );
  p = VkRayTracingShaderGroupTypeKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ShaderGroupShaderKHR &p ) {
  if( ShaderGroupShaderKHR :: eGeneral == p ) {
    j = "General";
    return;
  }
  if( ShaderGroupShaderKHR :: eClosestHit == p ) {
    j = "ClosestHit";
    return;
  }
  if( ShaderGroupShaderKHR :: eAnyHit == p ) {
    j = "AnyHit";
    return;
  }
}
}
void to_json( nlohmann::json &j, const VkShaderGroupShaderKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ShaderGroupShaderKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ShaderGroupShaderKHR &p ) {
  if( j.is_string() ) {
    if( "General" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eGeneral ;
      return;
    }
    if( "eGeneral" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eGeneral ;
      return;
    }
    if( "VK_SHADER_GROUP_SHADER_GENERAL_KHR" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eGeneral ;
      return;
    }
    if( "ClosestHit" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eClosestHit ;
      return;
    }
    if( "eClosestHit" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eClosestHit ;
      return;
    }
    if( "VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eClosestHit ;
      return;
    }
    if( "AnyHit" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eAnyHit ;
      return;
    }
    if( "eAnyHit" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eAnyHit ;
      return;
    }
    if( "VK_SHADER_GROUP_SHADER_ANY_HIT_KHR" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eAnyHit ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ShaderGroupShaderKHR" );
  }
  if( j.is_number() ) {
    p = ShaderGroupShaderKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ShaderGroupShaderKHR" );
}
}
void from_json( const nlohmann::json &j, VkShaderGroupShaderKHR &p ) {
  VULKAN_HPP_NAMESPACE :: ShaderGroupShaderKHR temp;
  from_json( j, temp );
  p = VkShaderGroupShaderKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageCreateFlagBits &p ) {
  if( ImageCreateFlagBits :: eSparseBinding == p ) {
    j = "SparseBinding";
    return;
  }
  if( ImageCreateFlagBits :: eSparseResidency == p ) {
    j = "SparseResidency";
    return;
  }
  if( ImageCreateFlagBits :: eSparseAliased == p ) {
    j = "SparseAliased";
    return;
  }
  if( ImageCreateFlagBits :: eMutableFormat == p ) {
    j = "MutableFormat";
    return;
  }
  if( ImageCreateFlagBits :: eCubeCompatible == p ) {
    j = "CubeCompatible";
    return;
  }
  if( ImageCreateFlagBits :: eAlias == p ) {
    j = "Alias";
    return;
  }
  if( ImageCreateFlagBits :: eSplitInstanceBindRegions == p ) {
    j = "SplitInstanceBindRegions";
    return;
  }
  if( ImageCreateFlagBits :: e2DArrayCompatible == p ) {
    j = "2DArrayCompatible";
    return;
  }
  if( ImageCreateFlagBits :: eBlockTexelViewCompatible == p ) {
    j = "BlockTexelViewCompatible";
    return;
  }
  if( ImageCreateFlagBits :: eExtendedUsage == p ) {
    j = "ExtendedUsage";
    return;
  }
  if( ImageCreateFlagBits :: eProtected == p ) {
    j = "Protected";
    return;
  }
  if( ImageCreateFlagBits :: eDisjoint == p ) {
    j = "Disjoint";
    return;
  }
  if( ImageCreateFlagBits :: eCornerSampledNV == p ) {
    j = "CornerSampledNV";
    return;
  }
  if( ImageCreateFlagBits :: eSampleLocationsCompatibleDepthEXT == p ) {
    j = "SampleLocationsCompatibleDepthEXT";
    return;
  }
  if( ImageCreateFlagBits :: eSubsampledEXT == p ) {
    j = "SubsampledEXT";
    return;
  }
  if( ImageCreateFlagBits :: e2DArrayCompatibleKHR == p ) {
    j = "2DArrayCompatibleKHR";
    return;
  }
  if( ImageCreateFlagBits :: eAliasKHR == p ) {
    j = "AliasKHR";
    return;
  }
  if( ImageCreateFlagBits :: eBlockTexelViewCompatibleKHR == p ) {
    j = "BlockTexelViewCompatibleKHR";
    return;
  }
  if( ImageCreateFlagBits :: eDisjointKHR == p ) {
    j = "DisjointKHR";
    return;
  }
  if( ImageCreateFlagBits :: eExtendedUsageKHR == p ) {
    j = "ExtendedUsageKHR";
    return;
  }
}
void from_json( const nlohmann::json &j, ImageCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "SparseBinding" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseBinding ;
      return;
    }
    if( "eSparseBinding" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseBinding ;
      return;
    }
    if( "VK_IMAGE_CREATE_SPARSE_BINDING_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseBinding ;
      return;
    }
    if( "SparseResidency" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseResidency ;
      return;
    }
    if( "eSparseResidency" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseResidency ;
      return;
    }
    if( "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseResidency ;
      return;
    }
    if( "SparseAliased" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseAliased ;
      return;
    }
    if( "eSparseAliased" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseAliased ;
      return;
    }
    if( "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseAliased ;
      return;
    }
    if( "MutableFormat" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eMutableFormat ;
      return;
    }
    if( "eMutableFormat" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eMutableFormat ;
      return;
    }
    if( "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eMutableFormat ;
      return;
    }
    if( "CubeCompatible" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eCubeCompatible ;
      return;
    }
    if( "eCubeCompatible" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eCubeCompatible ;
      return;
    }
    if( "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eCubeCompatible ;
      return;
    }
    if( "Alias" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eAlias ;
      return;
    }
    if( "eAlias" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eAlias ;
      return;
    }
    if( "VK_IMAGE_CREATE_ALIAS_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eAlias ;
      return;
    }
    if( "SplitInstanceBindRegions" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSplitInstanceBindRegions ;
      return;
    }
    if( "eSplitInstanceBindRegions" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSplitInstanceBindRegions ;
      return;
    }
    if( "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSplitInstanceBindRegions ;
      return;
    }
    if( "2DArrayCompatible" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: e2DArrayCompatible ;
      return;
    }
    if( "e2DArrayCompatible" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: e2DArrayCompatible ;
      return;
    }
    if( "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: e2DArrayCompatible ;
      return;
    }
    if( "BlockTexelViewCompatible" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eBlockTexelViewCompatible ;
      return;
    }
    if( "eBlockTexelViewCompatible" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eBlockTexelViewCompatible ;
      return;
    }
    if( "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eBlockTexelViewCompatible ;
      return;
    }
    if( "ExtendedUsage" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eExtendedUsage ;
      return;
    }
    if( "eExtendedUsage" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eExtendedUsage ;
      return;
    }
    if( "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eExtendedUsage ;
      return;
    }
    if( "Protected" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eProtected ;
      return;
    }
    if( "eProtected" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eProtected ;
      return;
    }
    if( "VK_IMAGE_CREATE_PROTECTED_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eProtected ;
      return;
    }
    if( "Disjoint" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eDisjoint ;
      return;
    }
    if( "eDisjoint" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eDisjoint ;
      return;
    }
    if( "VK_IMAGE_CREATE_DISJOINT_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eDisjoint ;
      return;
    }
    if( "CornerSampledNV" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eCornerSampledNV ;
      return;
    }
    if( "eCornerSampledNV" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eCornerSampledNV ;
      return;
    }
    if( "VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eCornerSampledNV ;
      return;
    }
    if( "SampleLocationsCompatibleDepthEXT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSampleLocationsCompatibleDepthEXT ;
      return;
    }
    if( "eSampleLocationsCompatibleDepthEXT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSampleLocationsCompatibleDepthEXT ;
      return;
    }
    if( "VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSampleLocationsCompatibleDepthEXT ;
      return;
    }
    if( "SubsampledEXT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSubsampledEXT ;
      return;
    }
    if( "eSubsampledEXT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSubsampledEXT ;
      return;
    }
    if( "VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSubsampledEXT ;
      return;
    }
    if( "2DArrayCompatibleKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: e2DArrayCompatibleKHR ;
      return;
    }
    if( "e2DArrayCompatibleKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: e2DArrayCompatibleKHR ;
      return;
    }
    if( "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: e2DArrayCompatibleKHR ;
      return;
    }
    if( "AliasKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eAliasKHR ;
      return;
    }
    if( "eAliasKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eAliasKHR ;
      return;
    }
    if( "VK_IMAGE_CREATE_ALIAS_BIT_KHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eAliasKHR ;
      return;
    }
    if( "BlockTexelViewCompatibleKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eBlockTexelViewCompatibleKHR ;
      return;
    }
    if( "eBlockTexelViewCompatibleKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eBlockTexelViewCompatibleKHR ;
      return;
    }
    if( "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eBlockTexelViewCompatibleKHR ;
      return;
    }
    if( "DisjointKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eDisjointKHR ;
      return;
    }
    if( "eDisjointKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eDisjointKHR ;
      return;
    }
    if( "VK_IMAGE_CREATE_DISJOINT_BIT_KHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eDisjointKHR ;
      return;
    }
    if( "ExtendedUsageKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eExtendedUsageKHR ;
      return;
    }
    if( "eExtendedUsageKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eExtendedUsageKHR ;
      return;
    }
    if( "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eExtendedUsageKHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImageCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = ImageCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImageCreateFlagBits" );
}
void to_json( nlohmann::json &j, const ImageCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ImageCreateFlagBits ) * 8u; ++n ) {
    if( p & ImageCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ImageCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ImageCreateFlags &p ) {
  if( j.is_array() ) {
    p = ImageCreateFlags ( 0 );
    for( auto &e:  j ) {
      ImageCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ImageCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryHeapFlagBits &p ) {
  if( MemoryHeapFlagBits :: eDeviceLocal == p ) {
    j = "DeviceLocal";
    return;
  }
  if( MemoryHeapFlagBits :: eMultiInstance == p ) {
    j = "MultiInstance";
    return;
  }
}
void from_json( const nlohmann::json &j, MemoryHeapFlagBits &p ) {
  if( j.is_string() ) {
    if( "DeviceLocal" == j.get< std::string >() ) {
      p = MemoryHeapFlagBits :: eDeviceLocal ;
      return;
    }
    if( "eDeviceLocal" == j.get< std::string >() ) {
      p = MemoryHeapFlagBits :: eDeviceLocal ;
      return;
    }
    if( "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT" == j.get< std::string >() ) {
      p = MemoryHeapFlagBits :: eDeviceLocal ;
      return;
    }
    if( "MultiInstance" == j.get< std::string >() ) {
      p = MemoryHeapFlagBits :: eMultiInstance ;
      return;
    }
    if( "eMultiInstance" == j.get< std::string >() ) {
      p = MemoryHeapFlagBits :: eMultiInstance ;
      return;
    }
    if( "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT" == j.get< std::string >() ) {
      p = MemoryHeapFlagBits :: eMultiInstance ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for MemoryHeapFlagBits" );
  }
  if( j.is_number() ) {
    p = MemoryHeapFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for MemoryHeapFlagBits" );
}
void to_json( nlohmann::json &j, const MemoryHeapFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( MemoryHeapFlagBits ) * 8u; ++n ) {
    if( p & MemoryHeapFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, MemoryHeapFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, MemoryHeapFlags &p ) {
  if( j.is_array() ) {
    p = MemoryHeapFlags ( 0 );
    for( auto &e:  j ) {
      MemoryHeapFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for MemoryHeapFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryPropertyFlagBits &p ) {
  if( MemoryPropertyFlagBits :: eDeviceLocal == p ) {
    j = "DeviceLocal";
    return;
  }
  if( MemoryPropertyFlagBits :: eHostVisible == p ) {
    j = "HostVisible";
    return;
  }
  if( MemoryPropertyFlagBits :: eHostCoherent == p ) {
    j = "HostCoherent";
    return;
  }
  if( MemoryPropertyFlagBits :: eHostCached == p ) {
    j = "HostCached";
    return;
  }
  if( MemoryPropertyFlagBits :: eLazilyAllocated == p ) {
    j = "LazilyAllocated";
    return;
  }
  if( MemoryPropertyFlagBits :: eProtected == p ) {
    j = "Protected";
    return;
  }
  if( MemoryPropertyFlagBits :: eDeviceCoherentAMD == p ) {
    j = "DeviceCoherentAMD";
    return;
  }
}
void from_json( const nlohmann::json &j, MemoryPropertyFlagBits &p ) {
  if( j.is_string() ) {
    if( "DeviceLocal" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eDeviceLocal ;
      return;
    }
    if( "eDeviceLocal" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eDeviceLocal ;
      return;
    }
    if( "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eDeviceLocal ;
      return;
    }
    if( "HostVisible" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostVisible ;
      return;
    }
    if( "eHostVisible" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostVisible ;
      return;
    }
    if( "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostVisible ;
      return;
    }
    if( "HostCoherent" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostCoherent ;
      return;
    }
    if( "eHostCoherent" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostCoherent ;
      return;
    }
    if( "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostCoherent ;
      return;
    }
    if( "HostCached" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostCached ;
      return;
    }
    if( "eHostCached" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostCached ;
      return;
    }
    if( "VK_MEMORY_PROPERTY_HOST_CACHED_BIT" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostCached ;
      return;
    }
    if( "LazilyAllocated" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eLazilyAllocated ;
      return;
    }
    if( "eLazilyAllocated" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eLazilyAllocated ;
      return;
    }
    if( "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eLazilyAllocated ;
      return;
    }
    if( "Protected" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eProtected ;
      return;
    }
    if( "eProtected" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eProtected ;
      return;
    }
    if( "VK_MEMORY_PROPERTY_PROTECTED_BIT" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eProtected ;
      return;
    }
    if( "DeviceCoherentAMD" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eDeviceCoherentAMD ;
      return;
    }
    if( "eDeviceCoherentAMD" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eDeviceCoherentAMD ;
      return;
    }
    if( "VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eDeviceCoherentAMD ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for MemoryPropertyFlagBits" );
  }
  if( j.is_number() ) {
    p = MemoryPropertyFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for MemoryPropertyFlagBits" );
}
void to_json( nlohmann::json &j, const MemoryPropertyFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( MemoryPropertyFlagBits ) * 8u; ++n ) {
    if( p & MemoryPropertyFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, MemoryPropertyFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, MemoryPropertyFlags &p ) {
  if( j.is_array() ) {
    p = MemoryPropertyFlags ( 0 );
    for( auto &e:  j ) {
      MemoryPropertyFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for MemoryPropertyFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SampleCountFlagBits &p ) {
  if( SampleCountFlagBits :: e1 == p ) {
    j = "1";
    return;
  }
  if( SampleCountFlagBits :: e2 == p ) {
    j = "2";
    return;
  }
  if( SampleCountFlagBits :: e4 == p ) {
    j = "4";
    return;
  }
  if( SampleCountFlagBits :: e8 == p ) {
    j = "8";
    return;
  }
  if( SampleCountFlagBits :: e16 == p ) {
    j = "16";
    return;
  }
  if( SampleCountFlagBits :: e32 == p ) {
    j = "32";
    return;
  }
}
void from_json( const nlohmann::json &j, SampleCountFlagBits &p ) {
  if( j.is_string() ) {
    if( "1" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e1 ;
      return;
    }
    if( "e1" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e1 ;
      return;
    }
    if( "VK_SAMPLE_COUNT_1_BIT" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e1 ;
      return;
    }
    if( "2" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e2 ;
      return;
    }
    if( "e2" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e2 ;
      return;
    }
    if( "VK_SAMPLE_COUNT_2_BIT" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e2 ;
      return;
    }
    if( "4" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e4 ;
      return;
    }
    if( "e4" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e4 ;
      return;
    }
    if( "VK_SAMPLE_COUNT_4_BIT" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e4 ;
      return;
    }
    if( "8" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e8 ;
      return;
    }
    if( "e8" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e8 ;
      return;
    }
    if( "VK_SAMPLE_COUNT_8_BIT" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e8 ;
      return;
    }
    if( "16" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e16 ;
      return;
    }
    if( "e16" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e16 ;
      return;
    }
    if( "VK_SAMPLE_COUNT_16_BIT" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e16 ;
      return;
    }
    if( "32" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e32 ;
      return;
    }
    if( "e32" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e32 ;
      return;
    }
    if( "VK_SAMPLE_COUNT_32_BIT" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e32 ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SampleCountFlagBits" );
  }
  if( j.is_number() ) {
    p = SampleCountFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SampleCountFlagBits" );
}
void to_json( nlohmann::json &j, const SampleCountFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SampleCountFlagBits ) * 8u; ++n ) {
    if( p & SampleCountFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SampleCountFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, SampleCountFlags &p ) {
  if( j.is_array() ) {
    p = SampleCountFlags ( 0 );
    for( auto &e:  j ) {
      SampleCountFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SampleCountFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceQueueCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, DeviceQueueCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DeviceQueueCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = DeviceQueueCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DeviceQueueCreateFlagBits" );
}
void to_json( nlohmann::json &j, const DeviceQueueCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DeviceQueueCreateFlagBits ) * 8u; ++n ) {
    if( p & DeviceQueueCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DeviceQueueCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DeviceQueueCreateFlags &p ) {
  if( j.is_array() ) {
    p = DeviceQueueCreateFlags ( 0 );
    for( auto &e:  j ) {
      DeviceQueueCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DeviceQueueCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineStageFlagBits &p ) {
  if( PipelineStageFlagBits :: eTopOfPipe == p ) {
    j = "TopOfPipe";
    return;
  }
  if( PipelineStageFlagBits :: eDrawIndirect == p ) {
    j = "DrawIndirect";
    return;
  }
  if( PipelineStageFlagBits :: eVertexInput == p ) {
    j = "VertexInput";
    return;
  }
  if( PipelineStageFlagBits :: eVertexShader == p ) {
    j = "VertexShader";
    return;
  }
  if( PipelineStageFlagBits :: eTessellationControlShader == p ) {
    j = "TessellationControlShader";
    return;
  }
  if( PipelineStageFlagBits :: eTessellationEvaluationShader == p ) {
    j = "TessellationEvaluationShader";
    return;
  }
  if( PipelineStageFlagBits :: eGeometryShader == p ) {
    j = "GeometryShader";
    return;
  }
  if( PipelineStageFlagBits :: eFragmentShader == p ) {
    j = "FragmentShader";
    return;
  }
  if( PipelineStageFlagBits :: eEarlyFragmentTests == p ) {
    j = "EarlyFragmentTests";
    return;
  }
  if( PipelineStageFlagBits :: eLateFragmentTests == p ) {
    j = "LateFragmentTests";
    return;
  }
  if( PipelineStageFlagBits :: eColorAttachmentOutput == p ) {
    j = "ColorAttachmentOutput";
    return;
  }
  if( PipelineStageFlagBits :: eComputeShader == p ) {
    j = "ComputeShader";
    return;
  }
  if( PipelineStageFlagBits :: eTransfer == p ) {
    j = "Transfer";
    return;
  }
  if( PipelineStageFlagBits :: eBottomOfPipe == p ) {
    j = "BottomOfPipe";
    return;
  }
  if( PipelineStageFlagBits :: eHost == p ) {
    j = "Host";
    return;
  }
  if( PipelineStageFlagBits :: eAllGraphics == p ) {
    j = "AllGraphics";
    return;
  }
  if( PipelineStageFlagBits :: eAllCommands == p ) {
    j = "AllCommands";
    return;
  }
  if( PipelineStageFlagBits :: eTransformFeedbackEXT == p ) {
    j = "TransformFeedbackEXT";
    return;
  }
  if( PipelineStageFlagBits :: eConditionalRenderingEXT == p ) {
    j = "ConditionalRenderingEXT";
    return;
  }
  if( PipelineStageFlagBits :: eAccelerationStructureBuildKHR == p ) {
    j = "AccelerationStructureBuildKHR";
    return;
  }
  if( PipelineStageFlagBits :: eRayTracingShaderKHR == p ) {
    j = "RayTracingShaderKHR";
    return;
  }
  if( PipelineStageFlagBits :: eTaskShaderNV == p ) {
    j = "TaskShaderNV";
    return;
  }
  if( PipelineStageFlagBits :: eMeshShaderNV == p ) {
    j = "MeshShaderNV";
    return;
  }
  if( PipelineStageFlagBits :: eFragmentDensityProcessEXT == p ) {
    j = "FragmentDensityProcessEXT";
    return;
  }
  if( PipelineStageFlagBits :: eFragmentShadingRateAttachmentKHR == p ) {
    j = "FragmentShadingRateAttachmentKHR";
    return;
  }
  if( PipelineStageFlagBits :: eCommandPreprocessNV == p ) {
    j = "CommandPreprocessNV";
    return;
  }
  if( PipelineStageFlagBits :: eNoneKHR == p ) {
    j = "NoneKHR";
    return;
  }
  if( PipelineStageFlagBits :: eAccelerationStructureBuildNV == p ) {
    j = "AccelerationStructureBuildNV";
    return;
  }
  if( PipelineStageFlagBits :: eRayTracingShaderNV == p ) {
    j = "RayTracingShaderNV";
    return;
  }
}
void from_json( const nlohmann::json &j, PipelineStageFlagBits &p ) {
  if( j.is_string() ) {
    if( "TopOfPipe" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTopOfPipe ;
      return;
    }
    if( "eTopOfPipe" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTopOfPipe ;
      return;
    }
    if( "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTopOfPipe ;
      return;
    }
    if( "DrawIndirect" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eDrawIndirect ;
      return;
    }
    if( "eDrawIndirect" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eDrawIndirect ;
      return;
    }
    if( "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eDrawIndirect ;
      return;
    }
    if( "VertexInput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eVertexInput ;
      return;
    }
    if( "eVertexInput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eVertexInput ;
      return;
    }
    if( "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eVertexInput ;
      return;
    }
    if( "VertexShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eVertexShader ;
      return;
    }
    if( "eVertexShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eVertexShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eVertexShader ;
      return;
    }
    if( "TessellationControlShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTessellationControlShader ;
      return;
    }
    if( "eTessellationControlShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTessellationControlShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTessellationControlShader ;
      return;
    }
    if( "TessellationEvaluationShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTessellationEvaluationShader ;
      return;
    }
    if( "eTessellationEvaluationShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTessellationEvaluationShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTessellationEvaluationShader ;
      return;
    }
    if( "GeometryShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eGeometryShader ;
      return;
    }
    if( "eGeometryShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eGeometryShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eGeometryShader ;
      return;
    }
    if( "FragmentShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentShader ;
      return;
    }
    if( "eFragmentShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentShader ;
      return;
    }
    if( "EarlyFragmentTests" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eEarlyFragmentTests ;
      return;
    }
    if( "eEarlyFragmentTests" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eEarlyFragmentTests ;
      return;
    }
    if( "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eEarlyFragmentTests ;
      return;
    }
    if( "LateFragmentTests" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eLateFragmentTests ;
      return;
    }
    if( "eLateFragmentTests" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eLateFragmentTests ;
      return;
    }
    if( "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eLateFragmentTests ;
      return;
    }
    if( "ColorAttachmentOutput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eColorAttachmentOutput ;
      return;
    }
    if( "eColorAttachmentOutput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eColorAttachmentOutput ;
      return;
    }
    if( "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eColorAttachmentOutput ;
      return;
    }
    if( "ComputeShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eComputeShader ;
      return;
    }
    if( "eComputeShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eComputeShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eComputeShader ;
      return;
    }
    if( "Transfer" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTransfer ;
      return;
    }
    if( "eTransfer" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTransfer ;
      return;
    }
    if( "VK_PIPELINE_STAGE_TRANSFER_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTransfer ;
      return;
    }
    if( "BottomOfPipe" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eBottomOfPipe ;
      return;
    }
    if( "eBottomOfPipe" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eBottomOfPipe ;
      return;
    }
    if( "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eBottomOfPipe ;
      return;
    }
    if( "Host" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eHost ;
      return;
    }
    if( "eHost" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eHost ;
      return;
    }
    if( "VK_PIPELINE_STAGE_HOST_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eHost ;
      return;
    }
    if( "AllGraphics" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAllGraphics ;
      return;
    }
    if( "eAllGraphics" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAllGraphics ;
      return;
    }
    if( "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAllGraphics ;
      return;
    }
    if( "AllCommands" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAllCommands ;
      return;
    }
    if( "eAllCommands" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAllCommands ;
      return;
    }
    if( "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAllCommands ;
      return;
    }
    if( "TransformFeedbackEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTransformFeedbackEXT ;
      return;
    }
    if( "eTransformFeedbackEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTransformFeedbackEXT ;
      return;
    }
    if( "VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTransformFeedbackEXT ;
      return;
    }
    if( "ConditionalRenderingEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eConditionalRenderingEXT ;
      return;
    }
    if( "eConditionalRenderingEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eConditionalRenderingEXT ;
      return;
    }
    if( "VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eConditionalRenderingEXT ;
      return;
    }
    if( "AccelerationStructureBuildKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAccelerationStructureBuildKHR ;
      return;
    }
    if( "eAccelerationStructureBuildKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAccelerationStructureBuildKHR ;
      return;
    }
    if( "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAccelerationStructureBuildKHR ;
      return;
    }
    if( "RayTracingShaderKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eRayTracingShaderKHR ;
      return;
    }
    if( "eRayTracingShaderKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eRayTracingShaderKHR ;
      return;
    }
    if( "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eRayTracingShaderKHR ;
      return;
    }
    if( "TaskShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTaskShaderNV ;
      return;
    }
    if( "eTaskShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTaskShaderNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTaskShaderNV ;
      return;
    }
    if( "MeshShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eMeshShaderNV ;
      return;
    }
    if( "eMeshShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eMeshShaderNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eMeshShaderNV ;
      return;
    }
    if( "FragmentDensityProcessEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentDensityProcessEXT ;
      return;
    }
    if( "eFragmentDensityProcessEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentDensityProcessEXT ;
      return;
    }
    if( "VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentDensityProcessEXT ;
      return;
    }
    if( "FragmentShadingRateAttachmentKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentShadingRateAttachmentKHR ;
      return;
    }
    if( "eFragmentShadingRateAttachmentKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentShadingRateAttachmentKHR ;
      return;
    }
    if( "VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentShadingRateAttachmentKHR ;
      return;
    }
    if( "CommandPreprocessNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eCommandPreprocessNV ;
      return;
    }
    if( "eCommandPreprocessNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eCommandPreprocessNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eCommandPreprocessNV ;
      return;
    }
    if( "NoneKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eNoneKHR ;
      return;
    }
    if( "eNoneKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eNoneKHR ;
      return;
    }
    if( "VK_PIPELINE_STAGE_NONE_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eNoneKHR ;
      return;
    }
    if( "AccelerationStructureBuildNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAccelerationStructureBuildNV ;
      return;
    }
    if( "eAccelerationStructureBuildNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAccelerationStructureBuildNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAccelerationStructureBuildNV ;
      return;
    }
    if( "RayTracingShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eRayTracingShaderNV ;
      return;
    }
    if( "eRayTracingShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eRayTracingShaderNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eRayTracingShaderNV ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineStageFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineStageFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineStageFlagBits" );
}
void to_json( nlohmann::json &j, const PipelineStageFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineStageFlagBits ) * 8u; ++n ) {
    if( p & PipelineStageFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineStageFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineStageFlags &p ) {
  if( j.is_array() ) {
    p = PipelineStageFlags ( 0 );
    for( auto &e:  j ) {
      PipelineStageFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineStageFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageAspectFlagBits &p ) {
  if( ImageAspectFlagBits :: eColor == p ) {
    j = "Color";
    return;
  }
  if( ImageAspectFlagBits :: eDepth == p ) {
    j = "Depth";
    return;
  }
  if( ImageAspectFlagBits :: eStencil == p ) {
    j = "Stencil";
    return;
  }
  if( ImageAspectFlagBits :: eMetadata == p ) {
    j = "Metadata";
    return;
  }
  if( ImageAspectFlagBits :: ePlane0 == p ) {
    j = "Plane0";
    return;
  }
  if( ImageAspectFlagBits :: ePlane1 == p ) {
    j = "Plane1";
    return;
  }
  if( ImageAspectFlagBits :: ePlane2 == p ) {
    j = "Plane2";
    return;
  }
  if( ImageAspectFlagBits :: eMemoryPlane0EXT == p ) {
    j = "MemoryPlane0EXT";
    return;
  }
  if( ImageAspectFlagBits :: eMemoryPlane1EXT == p ) {
    j = "MemoryPlane1EXT";
    return;
  }
  if( ImageAspectFlagBits :: eMemoryPlane2EXT == p ) {
    j = "MemoryPlane2EXT";
    return;
  }
  if( ImageAspectFlagBits :: eMemoryPlane3EXT == p ) {
    j = "MemoryPlane3EXT";
    return;
  }
  if( ImageAspectFlagBits :: ePlane0KHR == p ) {
    j = "Plane0KHR";
    return;
  }
  if( ImageAspectFlagBits :: ePlane1KHR == p ) {
    j = "Plane1KHR";
    return;
  }
}
void from_json( const nlohmann::json &j, ImageAspectFlagBits &p ) {
  if( j.is_string() ) {
    if( "Color" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eColor ;
      return;
    }
    if( "eColor" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eColor ;
      return;
    }
    if( "VK_IMAGE_ASPECT_COLOR_BIT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eColor ;
      return;
    }
    if( "Depth" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eDepth ;
      return;
    }
    if( "eDepth" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eDepth ;
      return;
    }
    if( "VK_IMAGE_ASPECT_DEPTH_BIT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eDepth ;
      return;
    }
    if( "Stencil" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eStencil ;
      return;
    }
    if( "eStencil" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eStencil ;
      return;
    }
    if( "VK_IMAGE_ASPECT_STENCIL_BIT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eStencil ;
      return;
    }
    if( "Metadata" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMetadata ;
      return;
    }
    if( "eMetadata" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMetadata ;
      return;
    }
    if( "VK_IMAGE_ASPECT_METADATA_BIT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMetadata ;
      return;
    }
    if( "Plane0" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane0 ;
      return;
    }
    if( "ePlane0" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane0 ;
      return;
    }
    if( "VK_IMAGE_ASPECT_PLANE_0_BIT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane0 ;
      return;
    }
    if( "Plane1" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane1 ;
      return;
    }
    if( "ePlane1" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane1 ;
      return;
    }
    if( "VK_IMAGE_ASPECT_PLANE_1_BIT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane1 ;
      return;
    }
    if( "Plane2" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane2 ;
      return;
    }
    if( "ePlane2" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane2 ;
      return;
    }
    if( "VK_IMAGE_ASPECT_PLANE_2_BIT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane2 ;
      return;
    }
    if( "MemoryPlane0EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane0EXT ;
      return;
    }
    if( "eMemoryPlane0EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane0EXT ;
      return;
    }
    if( "VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane0EXT ;
      return;
    }
    if( "MemoryPlane1EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane1EXT ;
      return;
    }
    if( "eMemoryPlane1EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane1EXT ;
      return;
    }
    if( "VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane1EXT ;
      return;
    }
    if( "MemoryPlane2EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane2EXT ;
      return;
    }
    if( "eMemoryPlane2EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane2EXT ;
      return;
    }
    if( "VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane2EXT ;
      return;
    }
    if( "MemoryPlane3EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane3EXT ;
      return;
    }
    if( "eMemoryPlane3EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane3EXT ;
      return;
    }
    if( "VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane3EXT ;
      return;
    }
    if( "Plane0KHR" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane0KHR ;
      return;
    }
    if( "ePlane0KHR" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane0KHR ;
      return;
    }
    if( "VK_IMAGE_ASPECT_PLANE_0_BIT_KHR" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane0KHR ;
      return;
    }
    if( "Plane1KHR" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane1KHR ;
      return;
    }
    if( "ePlane1KHR" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane1KHR ;
      return;
    }
    if( "VK_IMAGE_ASPECT_PLANE_1_BIT_KHR" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane1KHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImageAspectFlagBits" );
  }
  if( j.is_number() ) {
    p = ImageAspectFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImageAspectFlagBits" );
}
void to_json( nlohmann::json &j, const ImageAspectFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ImageAspectFlagBits ) * 8u; ++n ) {
    if( p & ImageAspectFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ImageAspectFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ImageAspectFlags &p ) {
  if( j.is_array() ) {
    p = ImageAspectFlags ( 0 );
    for( auto &e:  j ) {
      ImageAspectFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ImageAspectFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SparseImageFormatFlagBits &p ) {
  if( SparseImageFormatFlagBits :: eSingleMiptail == p ) {
    j = "SingleMiptail";
    return;
  }
  if( SparseImageFormatFlagBits :: eAlignedMipSize == p ) {
    j = "AlignedMipSize";
    return;
  }
}
void from_json( const nlohmann::json &j, SparseImageFormatFlagBits &p ) {
  if( j.is_string() ) {
    if( "SingleMiptail" == j.get< std::string >() ) {
      p = SparseImageFormatFlagBits :: eSingleMiptail ;
      return;
    }
    if( "eSingleMiptail" == j.get< std::string >() ) {
      p = SparseImageFormatFlagBits :: eSingleMiptail ;
      return;
    }
    if( "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT" == j.get< std::string >() ) {
      p = SparseImageFormatFlagBits :: eSingleMiptail ;
      return;
    }
    if( "AlignedMipSize" == j.get< std::string >() ) {
      p = SparseImageFormatFlagBits :: eAlignedMipSize ;
      return;
    }
    if( "eAlignedMipSize" == j.get< std::string >() ) {
      p = SparseImageFormatFlagBits :: eAlignedMipSize ;
      return;
    }
    if( "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT" == j.get< std::string >() ) {
      p = SparseImageFormatFlagBits :: eAlignedMipSize ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SparseImageFormatFlagBits" );
  }
  if( j.is_number() ) {
    p = SparseImageFormatFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SparseImageFormatFlagBits" );
}
void to_json( nlohmann::json &j, const SparseImageFormatFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SparseImageFormatFlagBits ) * 8u; ++n ) {
    if( p & SparseImageFormatFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SparseImageFormatFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, SparseImageFormatFlags &p ) {
  if( j.is_array() ) {
    p = SparseImageFormatFlags ( 0 );
    for( auto &e:  j ) {
      SparseImageFormatFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SparseImageFormatFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SparseMemoryBindFlagBits &p ) {
}
void from_json( const nlohmann::json &j, SparseMemoryBindFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for SparseMemoryBindFlagBits" );
  }
  if( j.is_number() ) {
    p = SparseMemoryBindFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SparseMemoryBindFlagBits" );
}
void to_json( nlohmann::json &j, const SparseMemoryBindFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SparseMemoryBindFlagBits ) * 8u; ++n ) {
    if( p & SparseMemoryBindFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SparseMemoryBindFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, SparseMemoryBindFlags &p ) {
  if( j.is_array() ) {
    p = SparseMemoryBindFlags ( 0 );
    for( auto &e:  j ) {
      SparseMemoryBindFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SparseMemoryBindFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FenceCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, FenceCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for FenceCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = FenceCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FenceCreateFlagBits" );
}
void to_json( nlohmann::json &j, const FenceCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( FenceCreateFlagBits ) * 8u; ++n ) {
    if( p & FenceCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, FenceCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, FenceCreateFlags &p ) {
  if( j.is_array() ) {
    p = FenceCreateFlags ( 0 );
    for( auto &e:  j ) {
      FenceCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for FenceCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const EventCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, EventCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for EventCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = EventCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for EventCreateFlagBits" );
}
void to_json( nlohmann::json &j, const EventCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( EventCreateFlagBits ) * 8u; ++n ) {
    if( p & EventCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, EventCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, EventCreateFlags &p ) {
  if( j.is_array() ) {
    p = EventCreateFlags ( 0 );
    for( auto &e:  j ) {
      EventCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for EventCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const QueryPipelineStatisticFlagBits &p ) {
  if( QueryPipelineStatisticFlagBits :: eInputAssemblyVertices == p ) {
    j = "InputAssemblyVertices";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eInputAssemblyPrimitives == p ) {
    j = "InputAssemblyPrimitives";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eVertexShaderInvocations == p ) {
    j = "VertexShaderInvocations";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eGeometryShaderInvocations == p ) {
    j = "GeometryShaderInvocations";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eGeometryShaderPrimitives == p ) {
    j = "GeometryShaderPrimitives";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eClippingInvocations == p ) {
    j = "ClippingInvocations";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eClippingPrimitives == p ) {
    j = "ClippingPrimitives";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eFragmentShaderInvocations == p ) {
    j = "FragmentShaderInvocations";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eTessellationControlShaderPatches == p ) {
    j = "TessellationControlShaderPatches";
    return;
  }
}
void from_json( const nlohmann::json &j, QueryPipelineStatisticFlagBits &p ) {
  if( j.is_string() ) {
    if( "InputAssemblyVertices" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eInputAssemblyVertices ;
      return;
    }
    if( "eInputAssemblyVertices" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eInputAssemblyVertices ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eInputAssemblyVertices ;
      return;
    }
    if( "InputAssemblyPrimitives" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eInputAssemblyPrimitives ;
      return;
    }
    if( "eInputAssemblyPrimitives" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eInputAssemblyPrimitives ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eInputAssemblyPrimitives ;
      return;
    }
    if( "VertexShaderInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eVertexShaderInvocations ;
      return;
    }
    if( "eVertexShaderInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eVertexShaderInvocations ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eVertexShaderInvocations ;
      return;
    }
    if( "GeometryShaderInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eGeometryShaderInvocations ;
      return;
    }
    if( "eGeometryShaderInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eGeometryShaderInvocations ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eGeometryShaderInvocations ;
      return;
    }
    if( "GeometryShaderPrimitives" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eGeometryShaderPrimitives ;
      return;
    }
    if( "eGeometryShaderPrimitives" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eGeometryShaderPrimitives ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eGeometryShaderPrimitives ;
      return;
    }
    if( "ClippingInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eClippingInvocations ;
      return;
    }
    if( "eClippingInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eClippingInvocations ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eClippingInvocations ;
      return;
    }
    if( "ClippingPrimitives" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eClippingPrimitives ;
      return;
    }
    if( "eClippingPrimitives" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eClippingPrimitives ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eClippingPrimitives ;
      return;
    }
    if( "FragmentShaderInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eFragmentShaderInvocations ;
      return;
    }
    if( "eFragmentShaderInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eFragmentShaderInvocations ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eFragmentShaderInvocations ;
      return;
    }
    if( "TessellationControlShaderPatches" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eTessellationControlShaderPatches ;
      return;
    }
    if( "eTessellationControlShaderPatches" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eTessellationControlShaderPatches ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eTessellationControlShaderPatches ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueryPipelineStatisticFlagBits" );
  }
  if( j.is_number() ) {
    p = QueryPipelineStatisticFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueryPipelineStatisticFlagBits" );
}
void to_json( nlohmann::json &j, const QueryPipelineStatisticFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( QueryPipelineStatisticFlagBits ) * 8u; ++n ) {
    if( p & QueryPipelineStatisticFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, QueryPipelineStatisticFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, QueryPipelineStatisticFlags &p ) {
  if( j.is_array() ) {
    p = QueryPipelineStatisticFlags ( 0 );
    for( auto &e:  j ) {
      QueryPipelineStatisticFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for QueryPipelineStatisticFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const QueryResultFlagBits &p ) {
  if( QueryResultFlagBits :: e64 == p ) {
    j = "64";
    return;
  }
  if( QueryResultFlagBits :: eWait == p ) {
    j = "Wait";
    return;
  }
  if( QueryResultFlagBits :: eWithAvailability == p ) {
    j = "WithAvailability";
    return;
  }
  if( QueryResultFlagBits :: ePartial == p ) {
    j = "Partial";
    return;
  }
}
void from_json( const nlohmann::json &j, QueryResultFlagBits &p ) {
  if( j.is_string() ) {
    if( "64" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: e64 ;
      return;
    }
    if( "e64" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: e64 ;
      return;
    }
    if( "VK_QUERY_RESULT_64_BIT" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: e64 ;
      return;
    }
    if( "Wait" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: eWait ;
      return;
    }
    if( "eWait" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: eWait ;
      return;
    }
    if( "VK_QUERY_RESULT_WAIT_BIT" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: eWait ;
      return;
    }
    if( "WithAvailability" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: eWithAvailability ;
      return;
    }
    if( "eWithAvailability" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: eWithAvailability ;
      return;
    }
    if( "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: eWithAvailability ;
      return;
    }
    if( "Partial" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: ePartial ;
      return;
    }
    if( "ePartial" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: ePartial ;
      return;
    }
    if( "VK_QUERY_RESULT_PARTIAL_BIT" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: ePartial ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueryResultFlagBits" );
  }
  if( j.is_number() ) {
    p = QueryResultFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueryResultFlagBits" );
}
void to_json( nlohmann::json &j, const QueryResultFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( QueryResultFlagBits ) * 8u; ++n ) {
    if( p & QueryResultFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, QueryResultFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, QueryResultFlags &p ) {
  if( j.is_array() ) {
    p = QueryResultFlags ( 0 );
    for( auto &e:  j ) {
      QueryResultFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for QueryResultFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BufferCreateFlagBits &p ) {
  if( BufferCreateFlagBits :: eSparseBinding == p ) {
    j = "SparseBinding";
    return;
  }
  if( BufferCreateFlagBits :: eSparseResidency == p ) {
    j = "SparseResidency";
    return;
  }
  if( BufferCreateFlagBits :: eSparseAliased == p ) {
    j = "SparseAliased";
    return;
  }
  if( BufferCreateFlagBits :: eProtected == p ) {
    j = "Protected";
    return;
  }
  if( BufferCreateFlagBits :: eDeviceAddressCaptureReplay == p ) {
    j = "DeviceAddressCaptureReplay";
    return;
  }
  if( BufferCreateFlagBits :: eDeviceAddressCaptureReplayEXT == p ) {
    j = "DeviceAddressCaptureReplayEXT";
    return;
  }
}
void from_json( const nlohmann::json &j, BufferCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "SparseBinding" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseBinding ;
      return;
    }
    if( "eSparseBinding" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseBinding ;
      return;
    }
    if( "VK_BUFFER_CREATE_SPARSE_BINDING_BIT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseBinding ;
      return;
    }
    if( "SparseResidency" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseResidency ;
      return;
    }
    if( "eSparseResidency" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseResidency ;
      return;
    }
    if( "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseResidency ;
      return;
    }
    if( "SparseAliased" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseAliased ;
      return;
    }
    if( "eSparseAliased" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseAliased ;
      return;
    }
    if( "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseAliased ;
      return;
    }
    if( "Protected" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eProtected ;
      return;
    }
    if( "eProtected" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eProtected ;
      return;
    }
    if( "VK_BUFFER_CREATE_PROTECTED_BIT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eProtected ;
      return;
    }
    if( "DeviceAddressCaptureReplay" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eDeviceAddressCaptureReplay ;
      return;
    }
    if( "eDeviceAddressCaptureReplay" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eDeviceAddressCaptureReplay ;
      return;
    }
    if( "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eDeviceAddressCaptureReplay ;
      return;
    }
    if( "DeviceAddressCaptureReplayEXT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eDeviceAddressCaptureReplayEXT ;
      return;
    }
    if( "eDeviceAddressCaptureReplayEXT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eDeviceAddressCaptureReplayEXT ;
      return;
    }
    if( "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eDeviceAddressCaptureReplayEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BufferCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = BufferCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BufferCreateFlagBits" );
}
void to_json( nlohmann::json &j, const BufferCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( BufferCreateFlagBits ) * 8u; ++n ) {
    if( p & BufferCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, BufferCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, BufferCreateFlags &p ) {
  if( j.is_array() ) {
    p = BufferCreateFlags ( 0 );
    for( auto &e:  j ) {
      BufferCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for BufferCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageViewCreateFlagBits &p ) {
  if( ImageViewCreateFlagBits :: eFragmentDensityMapDynamicEXT == p ) {
    j = "FragmentDensityMapDynamicEXT";
    return;
  }
}
void from_json( const nlohmann::json &j, ImageViewCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "FragmentDensityMapDynamicEXT" == j.get< std::string >() ) {
      p = ImageViewCreateFlagBits :: eFragmentDensityMapDynamicEXT ;
      return;
    }
    if( "eFragmentDensityMapDynamicEXT" == j.get< std::string >() ) {
      p = ImageViewCreateFlagBits :: eFragmentDensityMapDynamicEXT ;
      return;
    }
    if( "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT" == j.get< std::string >() ) {
      p = ImageViewCreateFlagBits :: eFragmentDensityMapDynamicEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImageViewCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = ImageViewCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImageViewCreateFlagBits" );
}
void to_json( nlohmann::json &j, const ImageViewCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ImageViewCreateFlagBits ) * 8u; ++n ) {
    if( p & ImageViewCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ImageViewCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ImageViewCreateFlags &p ) {
  if( j.is_array() ) {
    p = ImageViewCreateFlags ( 0 );
    for( auto &e:  j ) {
      ImageViewCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ImageViewCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ShaderModuleCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, ShaderModuleCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for ShaderModuleCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = ShaderModuleCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ShaderModuleCreateFlagBits" );
}
void to_json( nlohmann::json &j, const ShaderModuleCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ShaderModuleCreateFlagBits ) * 8u; ++n ) {
    if( p & ShaderModuleCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ShaderModuleCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ShaderModuleCreateFlags &p ) {
  if( j.is_array() ) {
    p = ShaderModuleCreateFlags ( 0 );
    for( auto &e:  j ) {
      ShaderModuleCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ShaderModuleCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCacheCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, PipelineCacheCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCacheCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineCacheCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCacheCreateFlagBits" );
}
void to_json( nlohmann::json &j, const PipelineCacheCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineCacheCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineCacheCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineCacheCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineCacheCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineCacheCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineCacheCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineCacheCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ColorComponentFlagBits &p ) {
  if( ColorComponentFlagBits :: eR == p ) {
    j = "R";
    return;
  }
  if( ColorComponentFlagBits :: eG == p ) {
    j = "G";
    return;
  }
  if( ColorComponentFlagBits :: eB == p ) {
    j = "B";
    return;
  }
}
void from_json( const nlohmann::json &j, ColorComponentFlagBits &p ) {
  if( j.is_string() ) {
    if( "R" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eR ;
      return;
    }
    if( "eR" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eR ;
      return;
    }
    if( "VK_COLOR_COMPONENT_R_BIT" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eR ;
      return;
    }
    if( "G" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eG ;
      return;
    }
    if( "eG" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eG ;
      return;
    }
    if( "VK_COLOR_COMPONENT_G_BIT" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eG ;
      return;
    }
    if( "B" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eB ;
      return;
    }
    if( "eB" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eB ;
      return;
    }
    if( "VK_COLOR_COMPONENT_B_BIT" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eB ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ColorComponentFlagBits" );
  }
  if( j.is_number() ) {
    p = ColorComponentFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ColorComponentFlagBits" );
}
void to_json( nlohmann::json &j, const ColorComponentFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ColorComponentFlagBits ) * 8u; ++n ) {
    if( p & ColorComponentFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ColorComponentFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ColorComponentFlags &p ) {
  if( j.is_array() ) {
    p = ColorComponentFlags ( 0 );
    for( auto &e:  j ) {
      ColorComponentFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ColorComponentFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CullModeFlagBits &p ) {
  if( CullModeFlagBits :: eNone == p ) {
    j = "None";
    return;
  }
  if( CullModeFlagBits :: eFront == p ) {
    j = "Front";
    return;
  }
  if( CullModeFlagBits :: eBack == p ) {
    j = "Back";
    return;
  }
}
void from_json( const nlohmann::json &j, CullModeFlagBits &p ) {
  if( j.is_string() ) {
    if( "None" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eNone ;
      return;
    }
    if( "eNone" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eNone ;
      return;
    }
    if( "VK_CULL_MODE_NONE" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eNone ;
      return;
    }
    if( "Front" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eFront ;
      return;
    }
    if( "eFront" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eFront ;
      return;
    }
    if( "VK_CULL_MODE_FRONT_BIT" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eFront ;
      return;
    }
    if( "Back" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eBack ;
      return;
    }
    if( "eBack" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eBack ;
      return;
    }
    if( "VK_CULL_MODE_BACK_BIT" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eBack ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CullModeFlagBits" );
  }
  if( j.is_number() ) {
    p = CullModeFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CullModeFlagBits" );
}
void to_json( nlohmann::json &j, const CullModeFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( CullModeFlagBits ) * 8u; ++n ) {
    if( p & CullModeFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, CullModeFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, CullModeFlags &p ) {
  if( j.is_array() ) {
    p = CullModeFlags ( 0 );
    for( auto &e:  j ) {
      CullModeFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for CullModeFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCreateFlagBits &p ) {
  if( PipelineCreateFlagBits :: eDisableOptimization == p ) {
    j = "DisableOptimization";
    return;
  }
  if( PipelineCreateFlagBits :: eAllowDerivatives == p ) {
    j = "AllowDerivatives";
    return;
  }
  if( PipelineCreateFlagBits :: eDerivative == p ) {
    j = "Derivative";
    return;
  }
  if( PipelineCreateFlagBits :: eViewIndexFromDeviceIndex == p ) {
    j = "ViewIndexFromDeviceIndex";
    return;
  }
  if( PipelineCreateFlagBits :: eDispatchBase == p ) {
    j = "DispatchBase";
    return;
  }
  if( PipelineCreateFlagBits :: eRayTracingNoNullAnyHitShadersKHR == p ) {
    j = "RayTracingNoNullAnyHitShadersKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eRayTracingNoNullClosestHitShadersKHR == p ) {
    j = "RayTracingNoNullClosestHitShadersKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eRayTracingNoNullMissShadersKHR == p ) {
    j = "RayTracingNoNullMissShadersKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eRayTracingNoNullIntersectionShadersKHR == p ) {
    j = "RayTracingNoNullIntersectionShadersKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eRayTracingSkipTrianglesKHR == p ) {
    j = "RayTracingSkipTrianglesKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eRayTracingSkipAabbsKHR == p ) {
    j = "RayTracingSkipAabbsKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eDeferCompileNV == p ) {
    j = "DeferCompileNV";
    return;
  }
  if( PipelineCreateFlagBits :: eCaptureStatisticsKHR == p ) {
    j = "CaptureStatisticsKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eCaptureInternalRepresentationsKHR == p ) {
    j = "CaptureInternalRepresentationsKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eIndirectBindableNV == p ) {
    j = "IndirectBindableNV";
    return;
  }
  if( PipelineCreateFlagBits :: eLibraryKHR == p ) {
    j = "LibraryKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eFailOnPipelineCompileRequiredEXT == p ) {
    j = "FailOnPipelineCompileRequiredEXT";
    return;
  }
  if( PipelineCreateFlagBits :: eEarlyReturnOnFailureEXT == p ) {
    j = "EarlyReturnOnFailureEXT";
    return;
  }
  if( PipelineCreateFlagBits :: eRayTracingAllowMotionNV == p ) {
    j = "RayTracingAllowMotionNV";
    return;
  }
  if( PipelineCreateFlagBits :: eDispatchBaseKHR == p ) {
    j = "DispatchBaseKHR";
    return;
  }
}
void from_json( const nlohmann::json &j, PipelineCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "DisableOptimization" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDisableOptimization ;
      return;
    }
    if( "eDisableOptimization" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDisableOptimization ;
      return;
    }
    if( "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDisableOptimization ;
      return;
    }
    if( "AllowDerivatives" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eAllowDerivatives ;
      return;
    }
    if( "eAllowDerivatives" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eAllowDerivatives ;
      return;
    }
    if( "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eAllowDerivatives ;
      return;
    }
    if( "Derivative" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDerivative ;
      return;
    }
    if( "eDerivative" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDerivative ;
      return;
    }
    if( "VK_PIPELINE_CREATE_DERIVATIVE_BIT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDerivative ;
      return;
    }
    if( "ViewIndexFromDeviceIndex" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eViewIndexFromDeviceIndex ;
      return;
    }
    if( "eViewIndexFromDeviceIndex" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eViewIndexFromDeviceIndex ;
      return;
    }
    if( "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eViewIndexFromDeviceIndex ;
      return;
    }
    if( "DispatchBase" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDispatchBase ;
      return;
    }
    if( "eDispatchBase" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDispatchBase ;
      return;
    }
    if( "VK_PIPELINE_CREATE_DISPATCH_BASE_BIT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDispatchBase ;
      return;
    }
    if( "RayTracingNoNullAnyHitShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullAnyHitShadersKHR ;
      return;
    }
    if( "eRayTracingNoNullAnyHitShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullAnyHitShadersKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullAnyHitShadersKHR ;
      return;
    }
    if( "RayTracingNoNullClosestHitShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullClosestHitShadersKHR ;
      return;
    }
    if( "eRayTracingNoNullClosestHitShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullClosestHitShadersKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullClosestHitShadersKHR ;
      return;
    }
    if( "RayTracingNoNullMissShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullMissShadersKHR ;
      return;
    }
    if( "eRayTracingNoNullMissShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullMissShadersKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullMissShadersKHR ;
      return;
    }
    if( "RayTracingNoNullIntersectionShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullIntersectionShadersKHR ;
      return;
    }
    if( "eRayTracingNoNullIntersectionShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullIntersectionShadersKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullIntersectionShadersKHR ;
      return;
    }
    if( "RayTracingSkipTrianglesKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingSkipTrianglesKHR ;
      return;
    }
    if( "eRayTracingSkipTrianglesKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingSkipTrianglesKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingSkipTrianglesKHR ;
      return;
    }
    if( "RayTracingSkipAabbsKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingSkipAabbsKHR ;
      return;
    }
    if( "eRayTracingSkipAabbsKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingSkipAabbsKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingSkipAabbsKHR ;
      return;
    }
    if( "DeferCompileNV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDeferCompileNV ;
      return;
    }
    if( "eDeferCompileNV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDeferCompileNV ;
      return;
    }
    if( "VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDeferCompileNV ;
      return;
    }
    if( "CaptureStatisticsKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eCaptureStatisticsKHR ;
      return;
    }
    if( "eCaptureStatisticsKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eCaptureStatisticsKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eCaptureStatisticsKHR ;
      return;
    }
    if( "CaptureInternalRepresentationsKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eCaptureInternalRepresentationsKHR ;
      return;
    }
    if( "eCaptureInternalRepresentationsKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eCaptureInternalRepresentationsKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eCaptureInternalRepresentationsKHR ;
      return;
    }
    if( "IndirectBindableNV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eIndirectBindableNV ;
      return;
    }
    if( "eIndirectBindableNV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eIndirectBindableNV ;
      return;
    }
    if( "VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eIndirectBindableNV ;
      return;
    }
    if( "LibraryKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eLibraryKHR ;
      return;
    }
    if( "eLibraryKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eLibraryKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_LIBRARY_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eLibraryKHR ;
      return;
    }
    if( "FailOnPipelineCompileRequiredEXT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eFailOnPipelineCompileRequiredEXT ;
      return;
    }
    if( "eFailOnPipelineCompileRequiredEXT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eFailOnPipelineCompileRequiredEXT ;
      return;
    }
    if( "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eFailOnPipelineCompileRequiredEXT ;
      return;
    }
    if( "EarlyReturnOnFailureEXT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eEarlyReturnOnFailureEXT ;
      return;
    }
    if( "eEarlyReturnOnFailureEXT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eEarlyReturnOnFailureEXT ;
      return;
    }
    if( "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eEarlyReturnOnFailureEXT ;
      return;
    }
    if( "RayTracingAllowMotionNV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingAllowMotionNV ;
      return;
    }
    if( "eRayTracingAllowMotionNV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingAllowMotionNV ;
      return;
    }
    if( "VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingAllowMotionNV ;
      return;
    }
    if( "DispatchBaseKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDispatchBaseKHR ;
      return;
    }
    if( "eDispatchBaseKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDispatchBaseKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_DISPATCH_BASE_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDispatchBaseKHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCreateFlagBits" );
}
void to_json( nlohmann::json &j, const PipelineCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineShaderStageCreateFlagBits &p ) {
  if( PipelineShaderStageCreateFlagBits :: eAllowVaryingSubgroupSizeEXT == p ) {
    j = "AllowVaryingSubgroupSizeEXT";
    return;
  }
}
void from_json( const nlohmann::json &j, PipelineShaderStageCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "AllowVaryingSubgroupSizeEXT" == j.get< std::string >() ) {
      p = PipelineShaderStageCreateFlagBits :: eAllowVaryingSubgroupSizeEXT ;
      return;
    }
    if( "eAllowVaryingSubgroupSizeEXT" == j.get< std::string >() ) {
      p = PipelineShaderStageCreateFlagBits :: eAllowVaryingSubgroupSizeEXT ;
      return;
    }
    if( "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineShaderStageCreateFlagBits :: eAllowVaryingSubgroupSizeEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineShaderStageCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineShaderStageCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineShaderStageCreateFlagBits" );
}
void to_json( nlohmann::json &j, const PipelineShaderStageCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineShaderStageCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineShaderStageCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineShaderStageCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineShaderStageCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineShaderStageCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineShaderStageCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineShaderStageCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ShaderStageFlagBits &p ) {
  if( ShaderStageFlagBits :: eVertex == p ) {
    j = "Vertex";
    return;
  }
  if( ShaderStageFlagBits :: eTessellationControl == p ) {
    j = "TessellationControl";
    return;
  }
  if( ShaderStageFlagBits :: eTessellationEvaluation == p ) {
    j = "TessellationEvaluation";
    return;
  }
  if( ShaderStageFlagBits :: eGeometry == p ) {
    j = "Geometry";
    return;
  }
  if( ShaderStageFlagBits :: eFragment == p ) {
    j = "Fragment";
    return;
  }
  if( ShaderStageFlagBits :: eCompute == p ) {
    j = "Compute";
    return;
  }
  if( ShaderStageFlagBits :: eAllGraphics == p ) {
    j = "AllGraphics";
    return;
  }
  if( ShaderStageFlagBits :: eAll == p ) {
    j = "All";
    return;
  }
  if( ShaderStageFlagBits :: eRaygenKHR == p ) {
    j = "RaygenKHR";
    return;
  }
  if( ShaderStageFlagBits :: eAnyHitKHR == p ) {
    j = "AnyHitKHR";
    return;
  }
  if( ShaderStageFlagBits :: eClosestHitKHR == p ) {
    j = "ClosestHitKHR";
    return;
  }
  if( ShaderStageFlagBits :: eMissKHR == p ) {
    j = "MissKHR";
    return;
  }
  if( ShaderStageFlagBits :: eIntersectionKHR == p ) {
    j = "IntersectionKHR";
    return;
  }
  if( ShaderStageFlagBits :: eCallableKHR == p ) {
    j = "CallableKHR";
    return;
  }
  if( ShaderStageFlagBits :: eTaskNV == p ) {
    j = "TaskNV";
    return;
  }
  if( ShaderStageFlagBits :: eMeshNV == p ) {
    j = "MeshNV";
    return;
  }
  if( ShaderStageFlagBits :: eSubpassShadingHUAWEI == p ) {
    j = "SubpassShadingHUAWEI";
    return;
  }
  if( ShaderStageFlagBits :: eAnyHitNV == p ) {
    j = "AnyHitNV";
    return;
  }
  if( ShaderStageFlagBits :: eCallableNV == p ) {
    j = "CallableNV";
    return;
  }
  if( ShaderStageFlagBits :: eClosestHitNV == p ) {
    j = "ClosestHitNV";
    return;
  }
  if( ShaderStageFlagBits :: eIntersectionNV == p ) {
    j = "IntersectionNV";
    return;
  }
  if( ShaderStageFlagBits :: eMissNV == p ) {
    j = "MissNV";
    return;
  }
}
void from_json( const nlohmann::json &j, ShaderStageFlagBits &p ) {
  if( j.is_string() ) {
    if( "Vertex" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eVertex ;
      return;
    }
    if( "eVertex" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eVertex ;
      return;
    }
    if( "VK_SHADER_STAGE_VERTEX_BIT" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eVertex ;
      return;
    }
    if( "TessellationControl" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTessellationControl ;
      return;
    }
    if( "eTessellationControl" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTessellationControl ;
      return;
    }
    if( "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTessellationControl ;
      return;
    }
    if( "TessellationEvaluation" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTessellationEvaluation ;
      return;
    }
    if( "eTessellationEvaluation" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTessellationEvaluation ;
      return;
    }
    if( "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTessellationEvaluation ;
      return;
    }
    if( "Geometry" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eGeometry ;
      return;
    }
    if( "eGeometry" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eGeometry ;
      return;
    }
    if( "VK_SHADER_STAGE_GEOMETRY_BIT" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eGeometry ;
      return;
    }
    if( "Fragment" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eFragment ;
      return;
    }
    if( "eFragment" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eFragment ;
      return;
    }
    if( "VK_SHADER_STAGE_FRAGMENT_BIT" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eFragment ;
      return;
    }
    if( "Compute" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCompute ;
      return;
    }
    if( "eCompute" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCompute ;
      return;
    }
    if( "VK_SHADER_STAGE_COMPUTE_BIT" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCompute ;
      return;
    }
    if( "AllGraphics" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAllGraphics ;
      return;
    }
    if( "eAllGraphics" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAllGraphics ;
      return;
    }
    if( "VK_SHADER_STAGE_ALL_GRAPHICS" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAllGraphics ;
      return;
    }
    if( "All" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAll ;
      return;
    }
    if( "eAll" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAll ;
      return;
    }
    if( "VK_SHADER_STAGE_ALL" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAll ;
      return;
    }
    if( "RaygenKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eRaygenKHR ;
      return;
    }
    if( "eRaygenKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eRaygenKHR ;
      return;
    }
    if( "VK_SHADER_STAGE_RAYGEN_BIT_KHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eRaygenKHR ;
      return;
    }
    if( "AnyHitKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAnyHitKHR ;
      return;
    }
    if( "eAnyHitKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAnyHitKHR ;
      return;
    }
    if( "VK_SHADER_STAGE_ANY_HIT_BIT_KHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAnyHitKHR ;
      return;
    }
    if( "ClosestHitKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eClosestHitKHR ;
      return;
    }
    if( "eClosestHitKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eClosestHitKHR ;
      return;
    }
    if( "VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eClosestHitKHR ;
      return;
    }
    if( "MissKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMissKHR ;
      return;
    }
    if( "eMissKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMissKHR ;
      return;
    }
    if( "VK_SHADER_STAGE_MISS_BIT_KHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMissKHR ;
      return;
    }
    if( "IntersectionKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eIntersectionKHR ;
      return;
    }
    if( "eIntersectionKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eIntersectionKHR ;
      return;
    }
    if( "VK_SHADER_STAGE_INTERSECTION_BIT_KHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eIntersectionKHR ;
      return;
    }
    if( "CallableKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCallableKHR ;
      return;
    }
    if( "eCallableKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCallableKHR ;
      return;
    }
    if( "VK_SHADER_STAGE_CALLABLE_BIT_KHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCallableKHR ;
      return;
    }
    if( "TaskNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTaskNV ;
      return;
    }
    if( "eTaskNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTaskNV ;
      return;
    }
    if( "VK_SHADER_STAGE_TASK_BIT_NV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTaskNV ;
      return;
    }
    if( "MeshNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMeshNV ;
      return;
    }
    if( "eMeshNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMeshNV ;
      return;
    }
    if( "VK_SHADER_STAGE_MESH_BIT_NV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMeshNV ;
      return;
    }
    if( "SubpassShadingHUAWEI" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eSubpassShadingHUAWEI ;
      return;
    }
    if( "eSubpassShadingHUAWEI" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eSubpassShadingHUAWEI ;
      return;
    }
    if( "VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eSubpassShadingHUAWEI ;
      return;
    }
    if( "AnyHitNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAnyHitNV ;
      return;
    }
    if( "eAnyHitNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAnyHitNV ;
      return;
    }
    if( "VK_SHADER_STAGE_ANY_HIT_BIT_NV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAnyHitNV ;
      return;
    }
    if( "CallableNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCallableNV ;
      return;
    }
    if( "eCallableNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCallableNV ;
      return;
    }
    if( "VK_SHADER_STAGE_CALLABLE_BIT_NV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCallableNV ;
      return;
    }
    if( "ClosestHitNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eClosestHitNV ;
      return;
    }
    if( "eClosestHitNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eClosestHitNV ;
      return;
    }
    if( "VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eClosestHitNV ;
      return;
    }
    if( "IntersectionNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eIntersectionNV ;
      return;
    }
    if( "eIntersectionNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eIntersectionNV ;
      return;
    }
    if( "VK_SHADER_STAGE_INTERSECTION_BIT_NV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eIntersectionNV ;
      return;
    }
    if( "MissNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMissNV ;
      return;
    }
    if( "eMissNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMissNV ;
      return;
    }
    if( "VK_SHADER_STAGE_MISS_BIT_NV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMissNV ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ShaderStageFlagBits" );
  }
  if( j.is_number() ) {
    p = ShaderStageFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ShaderStageFlagBits" );
}
void to_json( nlohmann::json &j, const ShaderStageFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ShaderStageFlagBits ) * 8u; ++n ) {
    if( p & ShaderStageFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ShaderStageFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ShaderStageFlags &p ) {
  if( j.is_array() ) {
    p = ShaderStageFlags ( 0 );
    for( auto &e:  j ) {
      ShaderStageFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ShaderStageFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SamplerCreateFlagBits &p ) {
  if( SamplerCreateFlagBits :: eSubsampledEXT == p ) {
    j = "SubsampledEXT";
    return;
  }
}
void from_json( const nlohmann::json &j, SamplerCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "SubsampledEXT" == j.get< std::string >() ) {
      p = SamplerCreateFlagBits :: eSubsampledEXT ;
      return;
    }
    if( "eSubsampledEXT" == j.get< std::string >() ) {
      p = SamplerCreateFlagBits :: eSubsampledEXT ;
      return;
    }
    if( "VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT" == j.get< std::string >() ) {
      p = SamplerCreateFlagBits :: eSubsampledEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SamplerCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = SamplerCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SamplerCreateFlagBits" );
}
void to_json( nlohmann::json &j, const SamplerCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SamplerCreateFlagBits ) * 8u; ++n ) {
    if( p & SamplerCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SamplerCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, SamplerCreateFlags &p ) {
  if( j.is_array() ) {
    p = SamplerCreateFlags ( 0 );
    for( auto &e:  j ) {
      SamplerCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SamplerCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorPoolCreateFlagBits &p ) {
  if( DescriptorPoolCreateFlagBits :: eFreeDescriptorSet == p ) {
    j = "FreeDescriptorSet";
    return;
  }
  if( DescriptorPoolCreateFlagBits :: eUpdateAfterBind == p ) {
    j = "UpdateAfterBind";
    return;
  }
  if( DescriptorPoolCreateFlagBits :: eHostOnlyVALVE == p ) {
    j = "HostOnlyVALVE";
    return;
  }
}
void from_json( const nlohmann::json &j, DescriptorPoolCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "FreeDescriptorSet" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eFreeDescriptorSet ;
      return;
    }
    if( "eFreeDescriptorSet" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eFreeDescriptorSet ;
      return;
    }
    if( "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eFreeDescriptorSet ;
      return;
    }
    if( "UpdateAfterBind" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eUpdateAfterBind ;
      return;
    }
    if( "eUpdateAfterBind" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eUpdateAfterBind ;
      return;
    }
    if( "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eUpdateAfterBind ;
      return;
    }
    if( "HostOnlyVALVE" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eHostOnlyVALVE ;
      return;
    }
    if( "eHostOnlyVALVE" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eHostOnlyVALVE ;
      return;
    }
    if( "VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eHostOnlyVALVE ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DescriptorPoolCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = DescriptorPoolCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DescriptorPoolCreateFlagBits" );
}
void to_json( nlohmann::json &j, const DescriptorPoolCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DescriptorPoolCreateFlagBits ) * 8u; ++n ) {
    if( p & DescriptorPoolCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DescriptorPoolCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DescriptorPoolCreateFlags &p ) {
  if( j.is_array() ) {
    p = DescriptorPoolCreateFlags ( 0 );
    for( auto &e:  j ) {
      DescriptorPoolCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DescriptorPoolCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorSetLayoutCreateFlagBits &p ) {
  if( DescriptorSetLayoutCreateFlagBits :: eUpdateAfterBindPool == p ) {
    j = "UpdateAfterBindPool";
    return;
  }
  if( DescriptorSetLayoutCreateFlagBits :: ePushDescriptorKHR == p ) {
    j = "PushDescriptorKHR";
    return;
  }
  if( DescriptorSetLayoutCreateFlagBits :: eHostOnlyPoolVALVE == p ) {
    j = "HostOnlyPoolVALVE";
    return;
  }
}
void from_json( const nlohmann::json &j, DescriptorSetLayoutCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "UpdateAfterBindPool" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: eUpdateAfterBindPool ;
      return;
    }
    if( "eUpdateAfterBindPool" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: eUpdateAfterBindPool ;
      return;
    }
    if( "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: eUpdateAfterBindPool ;
      return;
    }
    if( "PushDescriptorKHR" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: ePushDescriptorKHR ;
      return;
    }
    if( "ePushDescriptorKHR" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: ePushDescriptorKHR ;
      return;
    }
    if( "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: ePushDescriptorKHR ;
      return;
    }
    if( "HostOnlyPoolVALVE" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: eHostOnlyPoolVALVE ;
      return;
    }
    if( "eHostOnlyPoolVALVE" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: eHostOnlyPoolVALVE ;
      return;
    }
    if( "VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: eHostOnlyPoolVALVE ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DescriptorSetLayoutCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = DescriptorSetLayoutCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DescriptorSetLayoutCreateFlagBits" );
}
void to_json( nlohmann::json &j, const DescriptorSetLayoutCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DescriptorSetLayoutCreateFlagBits ) * 8u; ++n ) {
    if( p & DescriptorSetLayoutCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DescriptorSetLayoutCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DescriptorSetLayoutCreateFlags &p ) {
  if( j.is_array() ) {
    p = DescriptorSetLayoutCreateFlags ( 0 );
    for( auto &e:  j ) {
      DescriptorSetLayoutCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DescriptorSetLayoutCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccessFlagBits &p ) {
  if( AccessFlagBits :: eIndirectCommandRead == p ) {
    j = "IndirectCommandRead";
    return;
  }
  if( AccessFlagBits :: eIndexRead == p ) {
    j = "IndexRead";
    return;
  }
  if( AccessFlagBits :: eVertexAttributeRead == p ) {
    j = "VertexAttributeRead";
    return;
  }
  if( AccessFlagBits :: eUniformRead == p ) {
    j = "UniformRead";
    return;
  }
  if( AccessFlagBits :: eInputAttachmentRead == p ) {
    j = "InputAttachmentRead";
    return;
  }
  if( AccessFlagBits :: eShaderRead == p ) {
    j = "ShaderRead";
    return;
  }
  if( AccessFlagBits :: eShaderWrite == p ) {
    j = "ShaderWrite";
    return;
  }
  if( AccessFlagBits :: eColorAttachmentRead == p ) {
    j = "ColorAttachmentRead";
    return;
  }
  if( AccessFlagBits :: eColorAttachmentWrite == p ) {
    j = "ColorAttachmentWrite";
    return;
  }
  if( AccessFlagBits :: eDepthStencilAttachmentRead == p ) {
    j = "DepthStencilAttachmentRead";
    return;
  }
  if( AccessFlagBits :: eDepthStencilAttachmentWrite == p ) {
    j = "DepthStencilAttachmentWrite";
    return;
  }
  if( AccessFlagBits :: eTransferRead == p ) {
    j = "TransferRead";
    return;
  }
  if( AccessFlagBits :: eTransferWrite == p ) {
    j = "TransferWrite";
    return;
  }
  if( AccessFlagBits :: eHostRead == p ) {
    j = "HostRead";
    return;
  }
  if( AccessFlagBits :: eHostWrite == p ) {
    j = "HostWrite";
    return;
  }
  if( AccessFlagBits :: eMemoryRead == p ) {
    j = "MemoryRead";
    return;
  }
  if( AccessFlagBits :: eMemoryWrite == p ) {
    j = "MemoryWrite";
    return;
  }
  if( AccessFlagBits :: eTransformFeedbackWriteEXT == p ) {
    j = "TransformFeedbackWriteEXT";
    return;
  }
  if( AccessFlagBits :: eTransformFeedbackCounterReadEXT == p ) {
    j = "TransformFeedbackCounterReadEXT";
    return;
  }
  if( AccessFlagBits :: eTransformFeedbackCounterWriteEXT == p ) {
    j = "TransformFeedbackCounterWriteEXT";
    return;
  }
  if( AccessFlagBits :: eConditionalRenderingReadEXT == p ) {
    j = "ConditionalRenderingReadEXT";
    return;
  }
  if( AccessFlagBits :: eColorAttachmentReadNoncoherentEXT == p ) {
    j = "ColorAttachmentReadNoncoherentEXT";
    return;
  }
  if( AccessFlagBits :: eAccelerationStructureReadKHR == p ) {
    j = "AccelerationStructureReadKHR";
    return;
  }
  if( AccessFlagBits :: eAccelerationStructureWriteKHR == p ) {
    j = "AccelerationStructureWriteKHR";
    return;
  }
  if( AccessFlagBits :: eFragmentDensityMapReadEXT == p ) {
    j = "FragmentDensityMapReadEXT";
    return;
  }
  if( AccessFlagBits :: eFragmentShadingRateAttachmentReadKHR == p ) {
    j = "FragmentShadingRateAttachmentReadKHR";
    return;
  }
  if( AccessFlagBits :: eCommandPreprocessReadNV == p ) {
    j = "CommandPreprocessReadNV";
    return;
  }
  if( AccessFlagBits :: eCommandPreprocessWriteNV == p ) {
    j = "CommandPreprocessWriteNV";
    return;
  }
  if( AccessFlagBits :: eNoneKHR == p ) {
    j = "NoneKHR";
    return;
  }
  if( AccessFlagBits :: eAccelerationStructureReadNV == p ) {
    j = "AccelerationStructureReadNV";
    return;
  }
  if( AccessFlagBits :: eAccelerationStructureWriteNV == p ) {
    j = "AccelerationStructureWriteNV";
    return;
  }
}
void from_json( const nlohmann::json &j, AccessFlagBits &p ) {
  if( j.is_string() ) {
    if( "IndirectCommandRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eIndirectCommandRead ;
      return;
    }
    if( "eIndirectCommandRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eIndirectCommandRead ;
      return;
    }
    if( "VK_ACCESS_INDIRECT_COMMAND_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eIndirectCommandRead ;
      return;
    }
    if( "IndexRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eIndexRead ;
      return;
    }
    if( "eIndexRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eIndexRead ;
      return;
    }
    if( "VK_ACCESS_INDEX_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eIndexRead ;
      return;
    }
    if( "VertexAttributeRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eVertexAttributeRead ;
      return;
    }
    if( "eVertexAttributeRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eVertexAttributeRead ;
      return;
    }
    if( "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eVertexAttributeRead ;
      return;
    }
    if( "UniformRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eUniformRead ;
      return;
    }
    if( "eUniformRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eUniformRead ;
      return;
    }
    if( "VK_ACCESS_UNIFORM_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eUniformRead ;
      return;
    }
    if( "InputAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eInputAttachmentRead ;
      return;
    }
    if( "eInputAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eInputAttachmentRead ;
      return;
    }
    if( "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eInputAttachmentRead ;
      return;
    }
    if( "ShaderRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eShaderRead ;
      return;
    }
    if( "eShaderRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eShaderRead ;
      return;
    }
    if( "VK_ACCESS_SHADER_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eShaderRead ;
      return;
    }
    if( "ShaderWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eShaderWrite ;
      return;
    }
    if( "eShaderWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eShaderWrite ;
      return;
    }
    if( "VK_ACCESS_SHADER_WRITE_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eShaderWrite ;
      return;
    }
    if( "ColorAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentRead ;
      return;
    }
    if( "eColorAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentRead ;
      return;
    }
    if( "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentRead ;
      return;
    }
    if( "ColorAttachmentWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentWrite ;
      return;
    }
    if( "eColorAttachmentWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentWrite ;
      return;
    }
    if( "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentWrite ;
      return;
    }
    if( "DepthStencilAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eDepthStencilAttachmentRead ;
      return;
    }
    if( "eDepthStencilAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eDepthStencilAttachmentRead ;
      return;
    }
    if( "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eDepthStencilAttachmentRead ;
      return;
    }
    if( "DepthStencilAttachmentWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eDepthStencilAttachmentWrite ;
      return;
    }
    if( "eDepthStencilAttachmentWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eDepthStencilAttachmentWrite ;
      return;
    }
    if( "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eDepthStencilAttachmentWrite ;
      return;
    }
    if( "TransferRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransferRead ;
      return;
    }
    if( "eTransferRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransferRead ;
      return;
    }
    if( "VK_ACCESS_TRANSFER_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransferRead ;
      return;
    }
    if( "TransferWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransferWrite ;
      return;
    }
    if( "eTransferWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransferWrite ;
      return;
    }
    if( "VK_ACCESS_TRANSFER_WRITE_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransferWrite ;
      return;
    }
    if( "HostRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eHostRead ;
      return;
    }
    if( "eHostRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eHostRead ;
      return;
    }
    if( "VK_ACCESS_HOST_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eHostRead ;
      return;
    }
    if( "HostWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eHostWrite ;
      return;
    }
    if( "eHostWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eHostWrite ;
      return;
    }
    if( "VK_ACCESS_HOST_WRITE_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eHostWrite ;
      return;
    }
    if( "MemoryRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eMemoryRead ;
      return;
    }
    if( "eMemoryRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eMemoryRead ;
      return;
    }
    if( "VK_ACCESS_MEMORY_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eMemoryRead ;
      return;
    }
    if( "MemoryWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eMemoryWrite ;
      return;
    }
    if( "eMemoryWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eMemoryWrite ;
      return;
    }
    if( "VK_ACCESS_MEMORY_WRITE_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eMemoryWrite ;
      return;
    }
    if( "TransformFeedbackWriteEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackWriteEXT ;
      return;
    }
    if( "eTransformFeedbackWriteEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackWriteEXT ;
      return;
    }
    if( "VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackWriteEXT ;
      return;
    }
    if( "TransformFeedbackCounterReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackCounterReadEXT ;
      return;
    }
    if( "eTransformFeedbackCounterReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackCounterReadEXT ;
      return;
    }
    if( "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackCounterReadEXT ;
      return;
    }
    if( "TransformFeedbackCounterWriteEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackCounterWriteEXT ;
      return;
    }
    if( "eTransformFeedbackCounterWriteEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackCounterWriteEXT ;
      return;
    }
    if( "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackCounterWriteEXT ;
      return;
    }
    if( "ConditionalRenderingReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eConditionalRenderingReadEXT ;
      return;
    }
    if( "eConditionalRenderingReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eConditionalRenderingReadEXT ;
      return;
    }
    if( "VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eConditionalRenderingReadEXT ;
      return;
    }
    if( "ColorAttachmentReadNoncoherentEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentReadNoncoherentEXT ;
      return;
    }
    if( "eColorAttachmentReadNoncoherentEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentReadNoncoherentEXT ;
      return;
    }
    if( "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentReadNoncoherentEXT ;
      return;
    }
    if( "AccelerationStructureReadKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureReadKHR ;
      return;
    }
    if( "eAccelerationStructureReadKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureReadKHR ;
      return;
    }
    if( "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureReadKHR ;
      return;
    }
    if( "AccelerationStructureWriteKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureWriteKHR ;
      return;
    }
    if( "eAccelerationStructureWriteKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureWriteKHR ;
      return;
    }
    if( "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureWriteKHR ;
      return;
    }
    if( "FragmentDensityMapReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eFragmentDensityMapReadEXT ;
      return;
    }
    if( "eFragmentDensityMapReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eFragmentDensityMapReadEXT ;
      return;
    }
    if( "VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eFragmentDensityMapReadEXT ;
      return;
    }
    if( "FragmentShadingRateAttachmentReadKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eFragmentShadingRateAttachmentReadKHR ;
      return;
    }
    if( "eFragmentShadingRateAttachmentReadKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eFragmentShadingRateAttachmentReadKHR ;
      return;
    }
    if( "VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eFragmentShadingRateAttachmentReadKHR ;
      return;
    }
    if( "CommandPreprocessReadNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eCommandPreprocessReadNV ;
      return;
    }
    if( "eCommandPreprocessReadNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eCommandPreprocessReadNV ;
      return;
    }
    if( "VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eCommandPreprocessReadNV ;
      return;
    }
    if( "CommandPreprocessWriteNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eCommandPreprocessWriteNV ;
      return;
    }
    if( "eCommandPreprocessWriteNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eCommandPreprocessWriteNV ;
      return;
    }
    if( "VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eCommandPreprocessWriteNV ;
      return;
    }
    if( "NoneKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eNoneKHR ;
      return;
    }
    if( "eNoneKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eNoneKHR ;
      return;
    }
    if( "VK_ACCESS_NONE_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eNoneKHR ;
      return;
    }
    if( "AccelerationStructureReadNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureReadNV ;
      return;
    }
    if( "eAccelerationStructureReadNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureReadNV ;
      return;
    }
    if( "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureReadNV ;
      return;
    }
    if( "AccelerationStructureWriteNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureWriteNV ;
      return;
    }
    if( "eAccelerationStructureWriteNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureWriteNV ;
      return;
    }
    if( "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureWriteNV ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccessFlagBits" );
  }
  if( j.is_number() ) {
    p = AccessFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccessFlagBits" );
}
void to_json( nlohmann::json &j, const AccessFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( AccessFlagBits ) * 8u; ++n ) {
    if( p & AccessFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, AccessFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, AccessFlags &p ) {
  if( j.is_array() ) {
    p = AccessFlags ( 0 );
    for( auto &e:  j ) {
      AccessFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for AccessFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AttachmentDescriptionFlagBits &p ) {
}
void from_json( const nlohmann::json &j, AttachmentDescriptionFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for AttachmentDescriptionFlagBits" );
  }
  if( j.is_number() ) {
    p = AttachmentDescriptionFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AttachmentDescriptionFlagBits" );
}
void to_json( nlohmann::json &j, const AttachmentDescriptionFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( AttachmentDescriptionFlagBits ) * 8u; ++n ) {
    if( p & AttachmentDescriptionFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, AttachmentDescriptionFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, AttachmentDescriptionFlags &p ) {
  if( j.is_array() ) {
    p = AttachmentDescriptionFlags ( 0 );
    for( auto &e:  j ) {
      AttachmentDescriptionFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for AttachmentDescriptionFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DependencyFlagBits &p ) {
  if( DependencyFlagBits :: eByRegion == p ) {
    j = "ByRegion";
    return;
  }
  if( DependencyFlagBits :: eDeviceGroup == p ) {
    j = "DeviceGroup";
    return;
  }
  if( DependencyFlagBits :: eViewLocal == p ) {
    j = "ViewLocal";
    return;
  }
  if( DependencyFlagBits :: eDeviceGroupKHR == p ) {
    j = "DeviceGroupKHR";
    return;
  }
}
void from_json( const nlohmann::json &j, DependencyFlagBits &p ) {
  if( j.is_string() ) {
    if( "ByRegion" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eByRegion ;
      return;
    }
    if( "eByRegion" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eByRegion ;
      return;
    }
    if( "VK_DEPENDENCY_BY_REGION_BIT" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eByRegion ;
      return;
    }
    if( "DeviceGroup" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eDeviceGroup ;
      return;
    }
    if( "eDeviceGroup" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eDeviceGroup ;
      return;
    }
    if( "VK_DEPENDENCY_DEVICE_GROUP_BIT" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eDeviceGroup ;
      return;
    }
    if( "ViewLocal" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eViewLocal ;
      return;
    }
    if( "eViewLocal" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eViewLocal ;
      return;
    }
    if( "VK_DEPENDENCY_VIEW_LOCAL_BIT" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eViewLocal ;
      return;
    }
    if( "DeviceGroupKHR" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eDeviceGroupKHR ;
      return;
    }
    if( "eDeviceGroupKHR" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eDeviceGroupKHR ;
      return;
    }
    if( "VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eDeviceGroupKHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DependencyFlagBits" );
  }
  if( j.is_number() ) {
    p = DependencyFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DependencyFlagBits" );
}
void to_json( nlohmann::json &j, const DependencyFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DependencyFlagBits ) * 8u; ++n ) {
    if( p & DependencyFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DependencyFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DependencyFlags &p ) {
  if( j.is_array() ) {
    p = DependencyFlags ( 0 );
    for( auto &e:  j ) {
      DependencyFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DependencyFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FramebufferCreateFlagBits &p ) {
  if( FramebufferCreateFlagBits :: eImageless == p ) {
    j = "Imageless";
    return;
  }
}
void from_json( const nlohmann::json &j, FramebufferCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "Imageless" == j.get< std::string >() ) {
      p = FramebufferCreateFlagBits :: eImageless ;
      return;
    }
    if( "eImageless" == j.get< std::string >() ) {
      p = FramebufferCreateFlagBits :: eImageless ;
      return;
    }
    if( "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT" == j.get< std::string >() ) {
      p = FramebufferCreateFlagBits :: eImageless ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for FramebufferCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = FramebufferCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FramebufferCreateFlagBits" );
}
void to_json( nlohmann::json &j, const FramebufferCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( FramebufferCreateFlagBits ) * 8u; ++n ) {
    if( p & FramebufferCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, FramebufferCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, FramebufferCreateFlags &p ) {
  if( j.is_array() ) {
    p = FramebufferCreateFlags ( 0 );
    for( auto &e:  j ) {
      FramebufferCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for FramebufferCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RenderPassCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, RenderPassCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for RenderPassCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = RenderPassCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for RenderPassCreateFlagBits" );
}
void to_json( nlohmann::json &j, const RenderPassCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( RenderPassCreateFlagBits ) * 8u; ++n ) {
    if( p & RenderPassCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, RenderPassCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, RenderPassCreateFlags &p ) {
  if( j.is_array() ) {
    p = RenderPassCreateFlags ( 0 );
    for( auto &e:  j ) {
      RenderPassCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for RenderPassCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubpassDescriptionFlagBits &p ) {
  if( SubpassDescriptionFlagBits :: ePerViewAttributesNVX == p ) {
    j = "PerViewAttributesNVX";
    return;
  }
  if( SubpassDescriptionFlagBits :: ePerViewPositionXOnlyNVX == p ) {
    j = "PerViewPositionXOnlyNVX";
    return;
  }
  if( SubpassDescriptionFlagBits :: eFragmentRegionQCOM == p ) {
    j = "FragmentRegionQCOM";
    return;
  }
}
void from_json( const nlohmann::json &j, SubpassDescriptionFlagBits &p ) {
  if( j.is_string() ) {
    if( "PerViewAttributesNVX" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: ePerViewAttributesNVX ;
      return;
    }
    if( "ePerViewAttributesNVX" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: ePerViewAttributesNVX ;
      return;
    }
    if( "VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: ePerViewAttributesNVX ;
      return;
    }
    if( "PerViewPositionXOnlyNVX" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: ePerViewPositionXOnlyNVX ;
      return;
    }
    if( "ePerViewPositionXOnlyNVX" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: ePerViewPositionXOnlyNVX ;
      return;
    }
    if( "VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: ePerViewPositionXOnlyNVX ;
      return;
    }
    if( "FragmentRegionQCOM" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: eFragmentRegionQCOM ;
      return;
    }
    if( "eFragmentRegionQCOM" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: eFragmentRegionQCOM ;
      return;
    }
    if( "VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: eFragmentRegionQCOM ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SubpassDescriptionFlagBits" );
  }
  if( j.is_number() ) {
    p = SubpassDescriptionFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SubpassDescriptionFlagBits" );
}
void to_json( nlohmann::json &j, const SubpassDescriptionFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SubpassDescriptionFlagBits ) * 8u; ++n ) {
    if( p & SubpassDescriptionFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SubpassDescriptionFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, SubpassDescriptionFlags &p ) {
  if( j.is_array() ) {
    p = SubpassDescriptionFlags ( 0 );
    for( auto &e:  j ) {
      SubpassDescriptionFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SubpassDescriptionFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CommandPoolCreateFlagBits &p ) {
  if( CommandPoolCreateFlagBits :: eTransient == p ) {
    j = "Transient";
    return;
  }
  if( CommandPoolCreateFlagBits :: eResetCommandBuffer == p ) {
    j = "ResetCommandBuffer";
    return;
  }
}
void from_json( const nlohmann::json &j, CommandPoolCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "Transient" == j.get< std::string >() ) {
      p = CommandPoolCreateFlagBits :: eTransient ;
      return;
    }
    if( "eTransient" == j.get< std::string >() ) {
      p = CommandPoolCreateFlagBits :: eTransient ;
      return;
    }
    if( "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT" == j.get< std::string >() ) {
      p = CommandPoolCreateFlagBits :: eTransient ;
      return;
    }
    if( "ResetCommandBuffer" == j.get< std::string >() ) {
      p = CommandPoolCreateFlagBits :: eResetCommandBuffer ;
      return;
    }
    if( "eResetCommandBuffer" == j.get< std::string >() ) {
      p = CommandPoolCreateFlagBits :: eResetCommandBuffer ;
      return;
    }
    if( "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT" == j.get< std::string >() ) {
      p = CommandPoolCreateFlagBits :: eResetCommandBuffer ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CommandPoolCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = CommandPoolCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CommandPoolCreateFlagBits" );
}
void to_json( nlohmann::json &j, const CommandPoolCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( CommandPoolCreateFlagBits ) * 8u; ++n ) {
    if( p & CommandPoolCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, CommandPoolCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, CommandPoolCreateFlags &p ) {
  if( j.is_array() ) {
    p = CommandPoolCreateFlags ( 0 );
    for( auto &e:  j ) {
      CommandPoolCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for CommandPoolCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CommandPoolResetFlagBits &p ) {
}
void from_json( const nlohmann::json &j, CommandPoolResetFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for CommandPoolResetFlagBits" );
  }
  if( j.is_number() ) {
    p = CommandPoolResetFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CommandPoolResetFlagBits" );
}
void to_json( nlohmann::json &j, const CommandPoolResetFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( CommandPoolResetFlagBits ) * 8u; ++n ) {
    if( p & CommandPoolResetFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, CommandPoolResetFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, CommandPoolResetFlags &p ) {
  if( j.is_array() ) {
    p = CommandPoolResetFlags ( 0 );
    for( auto &e:  j ) {
      CommandPoolResetFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for CommandPoolResetFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CommandBufferResetFlagBits &p ) {
}
void from_json( const nlohmann::json &j, CommandBufferResetFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for CommandBufferResetFlagBits" );
  }
  if( j.is_number() ) {
    p = CommandBufferResetFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CommandBufferResetFlagBits" );
}
void to_json( nlohmann::json &j, const CommandBufferResetFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( CommandBufferResetFlagBits ) * 8u; ++n ) {
    if( p & CommandBufferResetFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, CommandBufferResetFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, CommandBufferResetFlags &p ) {
  if( j.is_array() ) {
    p = CommandBufferResetFlags ( 0 );
    for( auto &e:  j ) {
      CommandBufferResetFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for CommandBufferResetFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CommandBufferUsageFlagBits &p ) {
  if( CommandBufferUsageFlagBits :: eOneTimeSubmit == p ) {
    j = "OneTimeSubmit";
    return;
  }
  if( CommandBufferUsageFlagBits :: eRenderPassContinue == p ) {
    j = "RenderPassContinue";
    return;
  }
}
void from_json( const nlohmann::json &j, CommandBufferUsageFlagBits &p ) {
  if( j.is_string() ) {
    if( "OneTimeSubmit" == j.get< std::string >() ) {
      p = CommandBufferUsageFlagBits :: eOneTimeSubmit ;
      return;
    }
    if( "eOneTimeSubmit" == j.get< std::string >() ) {
      p = CommandBufferUsageFlagBits :: eOneTimeSubmit ;
      return;
    }
    if( "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT" == j.get< std::string >() ) {
      p = CommandBufferUsageFlagBits :: eOneTimeSubmit ;
      return;
    }
    if( "RenderPassContinue" == j.get< std::string >() ) {
      p = CommandBufferUsageFlagBits :: eRenderPassContinue ;
      return;
    }
    if( "eRenderPassContinue" == j.get< std::string >() ) {
      p = CommandBufferUsageFlagBits :: eRenderPassContinue ;
      return;
    }
    if( "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT" == j.get< std::string >() ) {
      p = CommandBufferUsageFlagBits :: eRenderPassContinue ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CommandBufferUsageFlagBits" );
  }
  if( j.is_number() ) {
    p = CommandBufferUsageFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CommandBufferUsageFlagBits" );
}
void to_json( nlohmann::json &j, const CommandBufferUsageFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( CommandBufferUsageFlagBits ) * 8u; ++n ) {
    if( p & CommandBufferUsageFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, CommandBufferUsageFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, CommandBufferUsageFlags &p ) {
  if( j.is_array() ) {
    p = CommandBufferUsageFlags ( 0 );
    for( auto &e:  j ) {
      CommandBufferUsageFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for CommandBufferUsageFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const QueryControlFlagBits &p ) {
}
void from_json( const nlohmann::json &j, QueryControlFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueryControlFlagBits" );
  }
  if( j.is_number() ) {
    p = QueryControlFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueryControlFlagBits" );
}
void to_json( nlohmann::json &j, const QueryControlFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( QueryControlFlagBits ) * 8u; ++n ) {
    if( p & QueryControlFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, QueryControlFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, QueryControlFlags &p ) {
  if( j.is_array() ) {
    p = QueryControlFlags ( 0 );
    for( auto &e:  j ) {
      QueryControlFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for QueryControlFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const StencilFaceFlagBits &p ) {
  if( StencilFaceFlagBits :: eFront == p ) {
    j = "Front";
    return;
  }
  if( StencilFaceFlagBits :: eBack == p ) {
    j = "Back";
    return;
  }
  if( StencilFaceFlagBits :: eFrontAndBack == p ) {
    j = "FrontAndBack";
    return;
  }
}
void from_json( const nlohmann::json &j, StencilFaceFlagBits &p ) {
  if( j.is_string() ) {
    if( "Front" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eFront ;
      return;
    }
    if( "eFront" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eFront ;
      return;
    }
    if( "VK_STENCIL_FACE_FRONT_BIT" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eFront ;
      return;
    }
    if( "Back" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eBack ;
      return;
    }
    if( "eBack" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eBack ;
      return;
    }
    if( "VK_STENCIL_FACE_BACK_BIT" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eBack ;
      return;
    }
    if( "FrontAndBack" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eFrontAndBack ;
      return;
    }
    if( "eFrontAndBack" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eFrontAndBack ;
      return;
    }
    if( "VK_STENCIL_FACE_FRONT_AND_BACK" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eFrontAndBack ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for StencilFaceFlagBits" );
  }
  if( j.is_number() ) {
    p = StencilFaceFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for StencilFaceFlagBits" );
}
void to_json( nlohmann::json &j, const StencilFaceFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( StencilFaceFlagBits ) * 8u; ++n ) {
    if( p & StencilFaceFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, StencilFaceFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, StencilFaceFlags &p ) {
  if( j.is_array() ) {
    p = StencilFaceFlags ( 0 );
    for( auto &e:  j ) {
      StencilFaceFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for StencilFaceFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const InstanceCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, InstanceCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for InstanceCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = InstanceCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for InstanceCreateFlagBits" );
}
void to_json( nlohmann::json &j, const InstanceCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( InstanceCreateFlagBits ) * 8u; ++n ) {
    if( p & InstanceCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, InstanceCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, InstanceCreateFlags &p ) {
  if( j.is_array() ) {
    p = InstanceCreateFlags ( 0 );
    for( auto &e:  j ) {
      InstanceCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for InstanceCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, DeviceCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DeviceCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = DeviceCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DeviceCreateFlagBits" );
}
void to_json( nlohmann::json &j, const DeviceCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DeviceCreateFlagBits ) * 8u; ++n ) {
    if( p & DeviceCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DeviceCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DeviceCreateFlags &p ) {
  if( j.is_array() ) {
    p = DeviceCreateFlags ( 0 );
    for( auto &e:  j ) {
      DeviceCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DeviceCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryMapFlagBits &p ) {
}
void from_json( const nlohmann::json &j, MemoryMapFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for MemoryMapFlagBits" );
  }
  if( j.is_number() ) {
    p = MemoryMapFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for MemoryMapFlagBits" );
}
void to_json( nlohmann::json &j, const MemoryMapFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( MemoryMapFlagBits ) * 8u; ++n ) {
    if( p & MemoryMapFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, MemoryMapFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, MemoryMapFlags &p ) {
  if( j.is_array() ) {
    p = MemoryMapFlags ( 0 );
    for( auto &e:  j ) {
      MemoryMapFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for MemoryMapFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SemaphoreCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, SemaphoreCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for SemaphoreCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = SemaphoreCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SemaphoreCreateFlagBits" );
}
void to_json( nlohmann::json &j, const SemaphoreCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SemaphoreCreateFlagBits ) * 8u; ++n ) {
    if( p & SemaphoreCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SemaphoreCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, SemaphoreCreateFlags &p ) {
  if( j.is_array() ) {
    p = SemaphoreCreateFlags ( 0 );
    for( auto &e:  j ) {
      SemaphoreCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SemaphoreCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const QueryPoolCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, QueryPoolCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueryPoolCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = QueryPoolCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueryPoolCreateFlagBits" );
}
void to_json( nlohmann::json &j, const QueryPoolCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( QueryPoolCreateFlagBits ) * 8u; ++n ) {
    if( p & QueryPoolCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, QueryPoolCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, QueryPoolCreateFlags &p ) {
  if( j.is_array() ) {
    p = QueryPoolCreateFlags ( 0 );
    for( auto &e:  j ) {
      QueryPoolCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for QueryPoolCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BufferViewCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, BufferViewCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for BufferViewCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = BufferViewCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BufferViewCreateFlagBits" );
}
void to_json( nlohmann::json &j, const BufferViewCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( BufferViewCreateFlagBits ) * 8u; ++n ) {
    if( p & BufferViewCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, BufferViewCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, BufferViewCreateFlags &p ) {
  if( j.is_array() ) {
    p = BufferViewCreateFlags ( 0 );
    for( auto &e:  j ) {
      BufferViewCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for BufferViewCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineColorBlendStateCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, PipelineColorBlendStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineColorBlendStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineColorBlendStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineColorBlendStateCreateFlagBits" );
}
void to_json( nlohmann::json &j, const PipelineColorBlendStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineColorBlendStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineColorBlendStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineColorBlendStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineColorBlendStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineColorBlendStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineColorBlendStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineColorBlendStateCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineDepthStencilStateCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, PipelineDepthStencilStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineDepthStencilStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineDepthStencilStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineDepthStencilStateCreateFlagBits" );
}
void to_json( nlohmann::json &j, const PipelineDepthStencilStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineDepthStencilStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineDepthStencilStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineDepthStencilStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineDepthStencilStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineDepthStencilStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineDepthStencilStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineDepthStencilStateCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineDynamicStateCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, PipelineDynamicStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineDynamicStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineDynamicStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineDynamicStateCreateFlagBits" );
}
void to_json( nlohmann::json &j, const PipelineDynamicStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineDynamicStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineDynamicStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineDynamicStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineDynamicStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineDynamicStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineDynamicStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineDynamicStateCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineInputAssemblyStateCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, PipelineInputAssemblyStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineInputAssemblyStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineInputAssemblyStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineInputAssemblyStateCreateFlagBits" );
}
void to_json( nlohmann::json &j, const PipelineInputAssemblyStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineInputAssemblyStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineInputAssemblyStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineInputAssemblyStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineInputAssemblyStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineInputAssemblyStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineInputAssemblyStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineInputAssemblyStateCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineLayoutCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, PipelineLayoutCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineLayoutCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineLayoutCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineLayoutCreateFlagBits" );
}
void to_json( nlohmann::json &j, const PipelineLayoutCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineLayoutCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineLayoutCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineLayoutCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineLayoutCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineLayoutCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineLayoutCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineLayoutCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineMultisampleStateCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, PipelineMultisampleStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineMultisampleStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineMultisampleStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineMultisampleStateCreateFlagBits" );
}
void to_json( nlohmann::json &j, const PipelineMultisampleStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineMultisampleStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineMultisampleStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineMultisampleStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineMultisampleStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineMultisampleStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineMultisampleStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineMultisampleStateCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineRasterizationStateCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, PipelineRasterizationStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineRasterizationStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineRasterizationStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineRasterizationStateCreateFlagBits" );
}
void to_json( nlohmann::json &j, const PipelineRasterizationStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineRasterizationStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineRasterizationStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineRasterizationStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineRasterizationStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineRasterizationStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineRasterizationStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineRasterizationStateCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineTessellationStateCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, PipelineTessellationStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineTessellationStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineTessellationStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineTessellationStateCreateFlagBits" );
}
void to_json( nlohmann::json &j, const PipelineTessellationStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineTessellationStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineTessellationStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineTessellationStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineTessellationStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineTessellationStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineTessellationStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineTessellationStateCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineVertexInputStateCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, PipelineVertexInputStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineVertexInputStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineVertexInputStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineVertexInputStateCreateFlagBits" );
}
void to_json( nlohmann::json &j, const PipelineVertexInputStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineVertexInputStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineVertexInputStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineVertexInputStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineVertexInputStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineVertexInputStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineVertexInputStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineVertexInputStateCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineViewportStateCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, PipelineViewportStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineViewportStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineViewportStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineViewportStateCreateFlagBits" );
}
void to_json( nlohmann::json &j, const PipelineViewportStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineViewportStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineViewportStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineViewportStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineViewportStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineViewportStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineViewportStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineViewportStateCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorPoolResetFlagBits &p ) {
}
void from_json( const nlohmann::json &j, DescriptorPoolResetFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DescriptorPoolResetFlagBits" );
  }
  if( j.is_number() ) {
    p = DescriptorPoolResetFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DescriptorPoolResetFlagBits" );
}
void to_json( nlohmann::json &j, const DescriptorPoolResetFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DescriptorPoolResetFlagBits ) * 8u; ++n ) {
    if( p & DescriptorPoolResetFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DescriptorPoolResetFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DescriptorPoolResetFlags &p ) {
  if( j.is_array() ) {
    p = DescriptorPoolResetFlags ( 0 );
    for( auto &e:  j ) {
      DescriptorPoolResetFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DescriptorPoolResetFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubgroupFeatureFlagBits &p ) {
  if( SubgroupFeatureFlagBits :: eBasic == p ) {
    j = "Basic";
    return;
  }
  if( SubgroupFeatureFlagBits :: eVote == p ) {
    j = "Vote";
    return;
  }
  if( SubgroupFeatureFlagBits :: eArithmetic == p ) {
    j = "Arithmetic";
    return;
  }
  if( SubgroupFeatureFlagBits :: eBallot == p ) {
    j = "Ballot";
    return;
  }
  if( SubgroupFeatureFlagBits :: eShuffle == p ) {
    j = "Shuffle";
    return;
  }
  if( SubgroupFeatureFlagBits :: eShuffleRelative == p ) {
    j = "ShuffleRelative";
    return;
  }
  if( SubgroupFeatureFlagBits :: eClustered == p ) {
    j = "Clustered";
    return;
  }
  if( SubgroupFeatureFlagBits :: eQuad == p ) {
    j = "Quad";
    return;
  }
}
void from_json( const nlohmann::json &j, SubgroupFeatureFlagBits &p ) {
  if( j.is_string() ) {
    if( "Basic" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eBasic ;
      return;
    }
    if( "eBasic" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eBasic ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_BASIC_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eBasic ;
      return;
    }
    if( "Vote" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eVote ;
      return;
    }
    if( "eVote" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eVote ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_VOTE_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eVote ;
      return;
    }
    if( "Arithmetic" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eArithmetic ;
      return;
    }
    if( "eArithmetic" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eArithmetic ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_ARITHMETIC_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eArithmetic ;
      return;
    }
    if( "Ballot" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eBallot ;
      return;
    }
    if( "eBallot" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eBallot ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_BALLOT_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eBallot ;
      return;
    }
    if( "Shuffle" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eShuffle ;
      return;
    }
    if( "eShuffle" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eShuffle ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_SHUFFLE_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eShuffle ;
      return;
    }
    if( "ShuffleRelative" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eShuffleRelative ;
      return;
    }
    if( "eShuffleRelative" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eShuffleRelative ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eShuffleRelative ;
      return;
    }
    if( "Clustered" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eClustered ;
      return;
    }
    if( "eClustered" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eClustered ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_CLUSTERED_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eClustered ;
      return;
    }
    if( "Quad" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eQuad ;
      return;
    }
    if( "eQuad" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eQuad ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_QUAD_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eQuad ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SubgroupFeatureFlagBits" );
  }
  if( j.is_number() ) {
    p = SubgroupFeatureFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SubgroupFeatureFlagBits" );
}
void to_json( nlohmann::json &j, const SubgroupFeatureFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SubgroupFeatureFlagBits ) * 8u; ++n ) {
    if( p & SubgroupFeatureFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SubgroupFeatureFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, SubgroupFeatureFlags &p ) {
  if( j.is_array() ) {
    p = SubgroupFeatureFlags ( 0 );
    for( auto &e:  j ) {
      SubgroupFeatureFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SubgroupFeatureFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PeerMemoryFeatureFlagBits &p ) {
  if( PeerMemoryFeatureFlagBits :: eCopySrc == p ) {
    j = "CopySrc";
    return;
  }
  if( PeerMemoryFeatureFlagBits :: eCopyDst == p ) {
    j = "CopyDst";
    return;
  }
  if( PeerMemoryFeatureFlagBits :: eGenericSrc == p ) {
    j = "GenericSrc";
    return;
  }
}
void from_json( const nlohmann::json &j, PeerMemoryFeatureFlagBits &p ) {
  if( j.is_string() ) {
    if( "CopySrc" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eCopySrc ;
      return;
    }
    if( "eCopySrc" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eCopySrc ;
      return;
    }
    if( "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eCopySrc ;
      return;
    }
    if( "CopyDst" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eCopyDst ;
      return;
    }
    if( "eCopyDst" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eCopyDst ;
      return;
    }
    if( "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eCopyDst ;
      return;
    }
    if( "GenericSrc" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eGenericSrc ;
      return;
    }
    if( "eGenericSrc" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eGenericSrc ;
      return;
    }
    if( "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eGenericSrc ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PeerMemoryFeatureFlagBits" );
  }
  if( j.is_number() ) {
    p = PeerMemoryFeatureFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PeerMemoryFeatureFlagBits" );
}
void to_json( nlohmann::json &j, const PeerMemoryFeatureFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PeerMemoryFeatureFlagBits ) * 8u; ++n ) {
    if( p & PeerMemoryFeatureFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PeerMemoryFeatureFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PeerMemoryFeatureFlags &p ) {
  if( j.is_array() ) {
    p = PeerMemoryFeatureFlags ( 0 );
    for( auto &e:  j ) {
      PeerMemoryFeatureFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PeerMemoryFeatureFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryAllocateFlagBits &p ) {
  if( MemoryAllocateFlagBits :: eDeviceMask == p ) {
    j = "DeviceMask";
    return;
  }
  if( MemoryAllocateFlagBits :: eDeviceAddress == p ) {
    j = "DeviceAddress";
    return;
  }
}
void from_json( const nlohmann::json &j, MemoryAllocateFlagBits &p ) {
  if( j.is_string() ) {
    if( "DeviceMask" == j.get< std::string >() ) {
      p = MemoryAllocateFlagBits :: eDeviceMask ;
      return;
    }
    if( "eDeviceMask" == j.get< std::string >() ) {
      p = MemoryAllocateFlagBits :: eDeviceMask ;
      return;
    }
    if( "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT" == j.get< std::string >() ) {
      p = MemoryAllocateFlagBits :: eDeviceMask ;
      return;
    }
    if( "DeviceAddress" == j.get< std::string >() ) {
      p = MemoryAllocateFlagBits :: eDeviceAddress ;
      return;
    }
    if( "eDeviceAddress" == j.get< std::string >() ) {
      p = MemoryAllocateFlagBits :: eDeviceAddress ;
      return;
    }
    if( "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT" == j.get< std::string >() ) {
      p = MemoryAllocateFlagBits :: eDeviceAddress ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for MemoryAllocateFlagBits" );
  }
  if( j.is_number() ) {
    p = MemoryAllocateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for MemoryAllocateFlagBits" );
}
void to_json( nlohmann::json &j, const MemoryAllocateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( MemoryAllocateFlagBits ) * 8u; ++n ) {
    if( p & MemoryAllocateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, MemoryAllocateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, MemoryAllocateFlags &p ) {
  if( j.is_array() ) {
    p = MemoryAllocateFlags ( 0 );
    for( auto &e:  j ) {
      MemoryAllocateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for MemoryAllocateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalMemoryFeatureFlagBits &p ) {
  if( ExternalMemoryFeatureFlagBits :: eDedicatedOnly == p ) {
    j = "DedicatedOnly";
    return;
  }
  if( ExternalMemoryFeatureFlagBits :: eExportable == p ) {
    j = "Exportable";
    return;
  }
}
void from_json( const nlohmann::json &j, ExternalMemoryFeatureFlagBits &p ) {
  if( j.is_string() ) {
    if( "DedicatedOnly" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBits :: eDedicatedOnly ;
      return;
    }
    if( "eDedicatedOnly" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBits :: eDedicatedOnly ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBits :: eDedicatedOnly ;
      return;
    }
    if( "Exportable" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBits :: eExportable ;
      return;
    }
    if( "eExportable" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBits :: eExportable ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBits :: eExportable ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ExternalMemoryFeatureFlagBits" );
  }
  if( j.is_number() ) {
    p = ExternalMemoryFeatureFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ExternalMemoryFeatureFlagBits" );
}
void to_json( nlohmann::json &j, const ExternalMemoryFeatureFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ExternalMemoryFeatureFlagBits ) * 8u; ++n ) {
    if( p & ExternalMemoryFeatureFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ExternalMemoryFeatureFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ExternalMemoryFeatureFlags &p ) {
  if( j.is_array() ) {
    p = ExternalMemoryFeatureFlags ( 0 );
    for( auto &e:  j ) {
      ExternalMemoryFeatureFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ExternalMemoryFeatureFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalFenceHandleTypeFlagBits &p ) {
  if( ExternalFenceHandleTypeFlagBits :: eOpaqueFd == p ) {
    j = "OpaqueFd";
    return;
  }
  if( ExternalFenceHandleTypeFlagBits :: eOpaqueWin32 == p ) {
    j = "OpaqueWin32";
    return;
  }
  if( ExternalFenceHandleTypeFlagBits :: eOpaqueWin32Kmt == p ) {
    j = "OpaqueWin32Kmt";
    return;
  }
}
void from_json( const nlohmann::json &j, ExternalFenceHandleTypeFlagBits &p ) {
  if( j.is_string() ) {
    if( "OpaqueFd" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueFd ;
      return;
    }
    if( "eOpaqueFd" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueFd ;
      return;
    }
    if( "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueFd ;
      return;
    }
    if( "OpaqueWin32" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueWin32 ;
      return;
    }
    if( "eOpaqueWin32" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueWin32 ;
      return;
    }
    if( "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueWin32 ;
      return;
    }
    if( "OpaqueWin32Kmt" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueWin32Kmt ;
      return;
    }
    if( "eOpaqueWin32Kmt" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueWin32Kmt ;
      return;
    }
    if( "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueWin32Kmt ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ExternalFenceHandleTypeFlagBits" );
  }
  if( j.is_number() ) {
    p = ExternalFenceHandleTypeFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ExternalFenceHandleTypeFlagBits" );
}
void to_json( nlohmann::json &j, const ExternalFenceHandleTypeFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ExternalFenceHandleTypeFlagBits ) * 8u; ++n ) {
    if( p & ExternalFenceHandleTypeFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ExternalFenceHandleTypeFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ExternalFenceHandleTypeFlags &p ) {
  if( j.is_array() ) {
    p = ExternalFenceHandleTypeFlags ( 0 );
    for( auto &e:  j ) {
      ExternalFenceHandleTypeFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ExternalFenceHandleTypeFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalFenceFeatureFlagBits &p ) {
  if( ExternalFenceFeatureFlagBits :: eExportable == p ) {
    j = "Exportable";
    return;
  }
}
void from_json( const nlohmann::json &j, ExternalFenceFeatureFlagBits &p ) {
  if( j.is_string() ) {
    if( "Exportable" == j.get< std::string >() ) {
      p = ExternalFenceFeatureFlagBits :: eExportable ;
      return;
    }
    if( "eExportable" == j.get< std::string >() ) {
      p = ExternalFenceFeatureFlagBits :: eExportable ;
      return;
    }
    if( "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT" == j.get< std::string >() ) {
      p = ExternalFenceFeatureFlagBits :: eExportable ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ExternalFenceFeatureFlagBits" );
  }
  if( j.is_number() ) {
    p = ExternalFenceFeatureFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ExternalFenceFeatureFlagBits" );
}
void to_json( nlohmann::json &j, const ExternalFenceFeatureFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ExternalFenceFeatureFlagBits ) * 8u; ++n ) {
    if( p & ExternalFenceFeatureFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ExternalFenceFeatureFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ExternalFenceFeatureFlags &p ) {
  if( j.is_array() ) {
    p = ExternalFenceFeatureFlags ( 0 );
    for( auto &e:  j ) {
      ExternalFenceFeatureFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ExternalFenceFeatureFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FenceImportFlagBits &p ) {
}
void from_json( const nlohmann::json &j, FenceImportFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for FenceImportFlagBits" );
  }
  if( j.is_number() ) {
    p = FenceImportFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FenceImportFlagBits" );
}
void to_json( nlohmann::json &j, const FenceImportFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( FenceImportFlagBits ) * 8u; ++n ) {
    if( p & FenceImportFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, FenceImportFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, FenceImportFlags &p ) {
  if( j.is_array() ) {
    p = FenceImportFlags ( 0 );
    for( auto &e:  j ) {
      FenceImportFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for FenceImportFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SemaphoreImportFlagBits &p ) {
}
void from_json( const nlohmann::json &j, SemaphoreImportFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for SemaphoreImportFlagBits" );
  }
  if( j.is_number() ) {
    p = SemaphoreImportFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SemaphoreImportFlagBits" );
}
void to_json( nlohmann::json &j, const SemaphoreImportFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SemaphoreImportFlagBits ) * 8u; ++n ) {
    if( p & SemaphoreImportFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SemaphoreImportFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, SemaphoreImportFlags &p ) {
  if( j.is_array() ) {
    p = SemaphoreImportFlags ( 0 );
    for( auto &e:  j ) {
      SemaphoreImportFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SemaphoreImportFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalSemaphoreFeatureFlagBits &p ) {
  if( ExternalSemaphoreFeatureFlagBits :: eExportable == p ) {
    j = "Exportable";
    return;
  }
}
void from_json( const nlohmann::json &j, ExternalSemaphoreFeatureFlagBits &p ) {
  if( j.is_string() ) {
    if( "Exportable" == j.get< std::string >() ) {
      p = ExternalSemaphoreFeatureFlagBits :: eExportable ;
      return;
    }
    if( "eExportable" == j.get< std::string >() ) {
      p = ExternalSemaphoreFeatureFlagBits :: eExportable ;
      return;
    }
    if( "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT" == j.get< std::string >() ) {
      p = ExternalSemaphoreFeatureFlagBits :: eExportable ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ExternalSemaphoreFeatureFlagBits" );
  }
  if( j.is_number() ) {
    p = ExternalSemaphoreFeatureFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ExternalSemaphoreFeatureFlagBits" );
}
void to_json( nlohmann::json &j, const ExternalSemaphoreFeatureFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ExternalSemaphoreFeatureFlagBits ) * 8u; ++n ) {
    if( p & ExternalSemaphoreFeatureFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ExternalSemaphoreFeatureFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ExternalSemaphoreFeatureFlags &p ) {
  if( j.is_array() ) {
    p = ExternalSemaphoreFeatureFlags ( 0 );
    for( auto &e:  j ) {
      ExternalSemaphoreFeatureFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ExternalSemaphoreFeatureFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CommandPoolTrimFlagBits &p ) {
}
void from_json( const nlohmann::json &j, CommandPoolTrimFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for CommandPoolTrimFlagBits" );
  }
  if( j.is_number() ) {
    p = CommandPoolTrimFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CommandPoolTrimFlagBits" );
}
void to_json( nlohmann::json &j, const CommandPoolTrimFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( CommandPoolTrimFlagBits ) * 8u; ++n ) {
    if( p & CommandPoolTrimFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, CommandPoolTrimFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, CommandPoolTrimFlags &p ) {
  if( j.is_array() ) {
    p = CommandPoolTrimFlags ( 0 );
    for( auto &e:  j ) {
      CommandPoolTrimFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for CommandPoolTrimFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorUpdateTemplateCreateFlagBits &p ) {
}
void from_json( const nlohmann::json &j, DescriptorUpdateTemplateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DescriptorUpdateTemplateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = DescriptorUpdateTemplateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DescriptorUpdateTemplateCreateFlagBits" );
}
void to_json( nlohmann::json &j, const DescriptorUpdateTemplateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DescriptorUpdateTemplateCreateFlagBits ) * 8u; ++n ) {
    if( p & DescriptorUpdateTemplateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DescriptorUpdateTemplateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DescriptorUpdateTemplateCreateFlags &p ) {
  if( j.is_array() ) {
    p = DescriptorUpdateTemplateCreateFlags ( 0 );
    for( auto &e:  j ) {
      DescriptorUpdateTemplateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DescriptorUpdateTemplateCreateFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorBindingFlagBits &p ) {
  if( DescriptorBindingFlagBits :: eUpdateAfterBind == p ) {
    j = "UpdateAfterBind";
    return;
  }
  if( DescriptorBindingFlagBits :: eUpdateUnusedWhilePending == p ) {
    j = "UpdateUnusedWhilePending";
    return;
  }
  if( DescriptorBindingFlagBits :: ePartiallyBound == p ) {
    j = "PartiallyBound";
    return;
  }
}
void from_json( const nlohmann::json &j, DescriptorBindingFlagBits &p ) {
  if( j.is_string() ) {
    if( "UpdateAfterBind" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: eUpdateAfterBind ;
      return;
    }
    if( "eUpdateAfterBind" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: eUpdateAfterBind ;
      return;
    }
    if( "VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: eUpdateAfterBind ;
      return;
    }
    if( "UpdateUnusedWhilePending" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: eUpdateUnusedWhilePending ;
      return;
    }
    if( "eUpdateUnusedWhilePending" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: eUpdateUnusedWhilePending ;
      return;
    }
    if( "VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: eUpdateUnusedWhilePending ;
      return;
    }
    if( "PartiallyBound" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: ePartiallyBound ;
      return;
    }
    if( "ePartiallyBound" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: ePartiallyBound ;
      return;
    }
    if( "VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: ePartiallyBound ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DescriptorBindingFlagBits" );
  }
  if( j.is_number() ) {
    p = DescriptorBindingFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DescriptorBindingFlagBits" );
}
void to_json( nlohmann::json &j, const DescriptorBindingFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DescriptorBindingFlagBits ) * 8u; ++n ) {
    if( p & DescriptorBindingFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DescriptorBindingFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DescriptorBindingFlags &p ) {
  if( j.is_array() ) {
    p = DescriptorBindingFlags ( 0 );
    for( auto &e:  j ) {
      DescriptorBindingFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DescriptorBindingFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ResolveModeFlagBits &p ) {
  if( ResolveModeFlagBits :: eNone == p ) {
    j = "None";
    return;
  }
  if( ResolveModeFlagBits :: eSampleZero == p ) {
    j = "SampleZero";
    return;
  }
  if( ResolveModeFlagBits :: eAverage == p ) {
    j = "Average";
    return;
  }
  if( ResolveModeFlagBits :: eMin == p ) {
    j = "Min";
    return;
  }
}
void from_json( const nlohmann::json &j, ResolveModeFlagBits &p ) {
  if( j.is_string() ) {
    if( "None" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eNone ;
      return;
    }
    if( "eNone" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eNone ;
      return;
    }
    if( "VK_RESOLVE_MODE_NONE" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eNone ;
      return;
    }
    if( "SampleZero" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eSampleZero ;
      return;
    }
    if( "eSampleZero" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eSampleZero ;
      return;
    }
    if( "VK_RESOLVE_MODE_SAMPLE_ZERO_BIT" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eSampleZero ;
      return;
    }
    if( "Average" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eAverage ;
      return;
    }
    if( "eAverage" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eAverage ;
      return;
    }
    if( "VK_RESOLVE_MODE_AVERAGE_BIT" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eAverage ;
      return;
    }
    if( "Min" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eMin ;
      return;
    }
    if( "eMin" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eMin ;
      return;
    }
    if( "VK_RESOLVE_MODE_MIN_BIT" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eMin ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ResolveModeFlagBits" );
  }
  if( j.is_number() ) {
    p = ResolveModeFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ResolveModeFlagBits" );
}
void to_json( nlohmann::json &j, const ResolveModeFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ResolveModeFlagBits ) * 8u; ++n ) {
    if( p & ResolveModeFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ResolveModeFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ResolveModeFlags &p ) {
  if( j.is_array() ) {
    p = ResolveModeFlags ( 0 );
    for( auto &e:  j ) {
      ResolveModeFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ResolveModeFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SemaphoreWaitFlagBits &p ) {
}
void from_json( const nlohmann::json &j, SemaphoreWaitFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for SemaphoreWaitFlagBits" );
  }
  if( j.is_number() ) {
    p = SemaphoreWaitFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SemaphoreWaitFlagBits" );
}
void to_json( nlohmann::json &j, const SemaphoreWaitFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SemaphoreWaitFlagBits ) * 8u; ++n ) {
    if( p & SemaphoreWaitFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SemaphoreWaitFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, SemaphoreWaitFlags &p ) {
  if( j.is_array() ) {
    p = SemaphoreWaitFlags ( 0 );
    for( auto &e:  j ) {
      SemaphoreWaitFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SemaphoreWaitFlags" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SurfaceTransformFlagBitsKHR &p ) {
  if( SurfaceTransformFlagBitsKHR :: eIdentity == p ) {
    j = "Identity";
    return;
  }
  if( SurfaceTransformFlagBitsKHR :: eRotate90 == p ) {
    j = "Rotate90";
    return;
  }
  if( SurfaceTransformFlagBitsKHR :: eRotate180 == p ) {
    j = "Rotate180";
    return;
  }
  if( SurfaceTransformFlagBitsKHR :: eRotate270 == p ) {
    j = "Rotate270";
    return;
  }
  if( SurfaceTransformFlagBitsKHR :: eHorizontalMirror == p ) {
    j = "HorizontalMirror";
    return;
  }
  if( SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate90 == p ) {
    j = "HorizontalMirrorRotate90";
    return;
  }
  if( SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate180 == p ) {
    j = "HorizontalMirrorRotate180";
    return;
  }
  if( SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate270 == p ) {
    j = "HorizontalMirrorRotate270";
    return;
  }
}
void from_json( const nlohmann::json &j, SurfaceTransformFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "Identity" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eIdentity ;
      return;
    }
    if( "eIdentity" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eIdentity ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eIdentity ;
      return;
    }
    if( "Rotate90" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate90 ;
      return;
    }
    if( "eRotate90" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate90 ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate90 ;
      return;
    }
    if( "Rotate180" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate180 ;
      return;
    }
    if( "eRotate180" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate180 ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate180 ;
      return;
    }
    if( "Rotate270" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate270 ;
      return;
    }
    if( "eRotate270" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate270 ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate270 ;
      return;
    }
    if( "HorizontalMirror" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirror ;
      return;
    }
    if( "eHorizontalMirror" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirror ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirror ;
      return;
    }
    if( "HorizontalMirrorRotate90" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate90 ;
      return;
    }
    if( "eHorizontalMirrorRotate90" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate90 ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate90 ;
      return;
    }
    if( "HorizontalMirrorRotate180" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate180 ;
      return;
    }
    if( "eHorizontalMirrorRotate180" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate180 ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate180 ;
      return;
    }
    if( "HorizontalMirrorRotate270" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate270 ;
      return;
    }
    if( "eHorizontalMirrorRotate270" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate270 ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate270 ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SurfaceTransformFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = SurfaceTransformFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SurfaceTransformFlagBitsKHR" );
}
void to_json( nlohmann::json &j, const SurfaceTransformFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SurfaceTransformFlagBitsKHR ) * 8u; ++n ) {
    if( p & SurfaceTransformFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SurfaceTransformFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, SurfaceTransformFlagsKHR &p ) {
  if( j.is_array() ) {
    p = SurfaceTransformFlagsKHR ( 0 );
    for( auto &e:  j ) {
      SurfaceTransformFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SurfaceTransformFlagsKHR" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CompositeAlphaFlagBitsKHR &p ) {
  if( CompositeAlphaFlagBitsKHR :: eOpaque == p ) {
    j = "Opaque";
    return;
  }
  if( CompositeAlphaFlagBitsKHR :: ePreMultiplied == p ) {
    j = "PreMultiplied";
    return;
  }
  if( CompositeAlphaFlagBitsKHR :: ePostMultiplied == p ) {
    j = "PostMultiplied";
    return;
  }
}
void from_json( const nlohmann::json &j, CompositeAlphaFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "Opaque" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "eOpaque" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "PreMultiplied" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: ePreMultiplied ;
      return;
    }
    if( "ePreMultiplied" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: ePreMultiplied ;
      return;
    }
    if( "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: ePreMultiplied ;
      return;
    }
    if( "PostMultiplied" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: ePostMultiplied ;
      return;
    }
    if( "ePostMultiplied" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: ePostMultiplied ;
      return;
    }
    if( "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: ePostMultiplied ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CompositeAlphaFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = CompositeAlphaFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CompositeAlphaFlagBitsKHR" );
}
void to_json( nlohmann::json &j, const CompositeAlphaFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( CompositeAlphaFlagBitsKHR ) * 8u; ++n ) {
    if( p & CompositeAlphaFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, CompositeAlphaFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, CompositeAlphaFlagsKHR &p ) {
  if( j.is_array() ) {
    p = CompositeAlphaFlagsKHR ( 0 );
    for( auto &e:  j ) {
      CompositeAlphaFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for CompositeAlphaFlagsKHR" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SwapchainCreateFlagBitsKHR &p ) {
  if( SwapchainCreateFlagBitsKHR :: eSplitInstanceBindRegions == p ) {
    j = "SplitInstanceBindRegions";
    return;
  }
  if( SwapchainCreateFlagBitsKHR :: eProtected == p ) {
    j = "Protected";
    return;
  }
}
void from_json( const nlohmann::json &j, SwapchainCreateFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "SplitInstanceBindRegions" == j.get< std::string >() ) {
      p = SwapchainCreateFlagBitsKHR :: eSplitInstanceBindRegions ;
      return;
    }
    if( "eSplitInstanceBindRegions" == j.get< std::string >() ) {
      p = SwapchainCreateFlagBitsKHR :: eSplitInstanceBindRegions ;
      return;
    }
    if( "VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR" == j.get< std::string >() ) {
      p = SwapchainCreateFlagBitsKHR :: eSplitInstanceBindRegions ;
      return;
    }
    if( "Protected" == j.get< std::string >() ) {
      p = SwapchainCreateFlagBitsKHR :: eProtected ;
      return;
    }
    if( "eProtected" == j.get< std::string >() ) {
      p = SwapchainCreateFlagBitsKHR :: eProtected ;
      return;
    }
    if( "VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR" == j.get< std::string >() ) {
      p = SwapchainCreateFlagBitsKHR :: eProtected ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SwapchainCreateFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = SwapchainCreateFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SwapchainCreateFlagBitsKHR" );
}
void to_json( nlohmann::json &j, const SwapchainCreateFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SwapchainCreateFlagBitsKHR ) * 8u; ++n ) {
    if( p & SwapchainCreateFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SwapchainCreateFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, SwapchainCreateFlagsKHR &p ) {
  if( j.is_array() ) {
    p = SwapchainCreateFlagsKHR ( 0 );
    for( auto &e:  j ) {
      SwapchainCreateFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SwapchainCreateFlagsKHR" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceGroupPresentModeFlagBitsKHR &p ) {
  if( DeviceGroupPresentModeFlagBitsKHR :: eLocal == p ) {
    j = "Local";
    return;
  }
  if( DeviceGroupPresentModeFlagBitsKHR :: eRemote == p ) {
    j = "Remote";
    return;
  }
  if( DeviceGroupPresentModeFlagBitsKHR :: eSum == p ) {
    j = "Sum";
    return;
  }
}
void from_json( const nlohmann::json &j, DeviceGroupPresentModeFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "Local" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eLocal ;
      return;
    }
    if( "eLocal" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eLocal ;
      return;
    }
    if( "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eLocal ;
      return;
    }
    if( "Remote" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eRemote ;
      return;
    }
    if( "eRemote" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eRemote ;
      return;
    }
    if( "VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eRemote ;
      return;
    }
    if( "Sum" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eSum ;
      return;
    }
    if( "eSum" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eSum ;
      return;
    }
    if( "VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eSum ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DeviceGroupPresentModeFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = DeviceGroupPresentModeFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DeviceGroupPresentModeFlagBitsKHR" );
}
void to_json( nlohmann::json &j, const DeviceGroupPresentModeFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DeviceGroupPresentModeFlagBitsKHR ) * 8u; ++n ) {
    if( p & DeviceGroupPresentModeFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DeviceGroupPresentModeFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DeviceGroupPresentModeFlagsKHR &p ) {
  if( j.is_array() ) {
    p = DeviceGroupPresentModeFlagsKHR ( 0 );
    for( auto &e:  j ) {
      DeviceGroupPresentModeFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DeviceGroupPresentModeFlagsKHR" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayPlaneAlphaFlagBitsKHR &p ) {
  if( DisplayPlaneAlphaFlagBitsKHR :: eOpaque == p ) {
    j = "Opaque";
    return;
  }
  if( DisplayPlaneAlphaFlagBitsKHR :: eGlobal == p ) {
    j = "Global";
    return;
  }
  if( DisplayPlaneAlphaFlagBitsKHR :: ePerPixel == p ) {
    j = "PerPixel";
    return;
  }
}
void from_json( const nlohmann::json &j, DisplayPlaneAlphaFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "Opaque" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "eOpaque" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "Global" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: eGlobal ;
      return;
    }
    if( "eGlobal" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: eGlobal ;
      return;
    }
    if( "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: eGlobal ;
      return;
    }
    if( "PerPixel" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: ePerPixel ;
      return;
    }
    if( "ePerPixel" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: ePerPixel ;
      return;
    }
    if( "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: ePerPixel ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DisplayPlaneAlphaFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = DisplayPlaneAlphaFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DisplayPlaneAlphaFlagBitsKHR" );
}
void to_json( nlohmann::json &j, const DisplayPlaneAlphaFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DisplayPlaneAlphaFlagBitsKHR ) * 8u; ++n ) {
    if( p & DisplayPlaneAlphaFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DisplayPlaneAlphaFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DisplayPlaneAlphaFlagsKHR &p ) {
  if( j.is_array() ) {
    p = DisplayPlaneAlphaFlagsKHR ( 0 );
    for( auto &e:  j ) {
      DisplayPlaneAlphaFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DisplayPlaneAlphaFlagsKHR" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayModeCreateFlagBitsKHR &p ) {
}
void from_json( const nlohmann::json &j, DisplayModeCreateFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DisplayModeCreateFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = DisplayModeCreateFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DisplayModeCreateFlagBitsKHR" );
}
void to_json( nlohmann::json &j, const DisplayModeCreateFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DisplayModeCreateFlagBitsKHR ) * 8u; ++n ) {
    if( p & DisplayModeCreateFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DisplayModeCreateFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DisplayModeCreateFlagsKHR &p ) {
  if( j.is_array() ) {
    p = DisplayModeCreateFlagsKHR ( 0 );
    for( auto &e:  j ) {
      DisplayModeCreateFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DisplayModeCreateFlagsKHR" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplaySurfaceCreateFlagBitsKHR &p ) {
}
void from_json( const nlohmann::json &j, DisplaySurfaceCreateFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DisplaySurfaceCreateFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = DisplaySurfaceCreateFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DisplaySurfaceCreateFlagBitsKHR" );
}
void to_json( nlohmann::json &j, const DisplaySurfaceCreateFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DisplaySurfaceCreateFlagBitsKHR ) * 8u; ++n ) {
    if( p & DisplaySurfaceCreateFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DisplaySurfaceCreateFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DisplaySurfaceCreateFlagsKHR &p ) {
  if( j.is_array() ) {
    p = DisplaySurfaceCreateFlagsKHR ( 0 );
    for( auto &e:  j ) {
      DisplaySurfaceCreateFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DisplaySurfaceCreateFlagsKHR" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugReportFlagBitsEXT &p ) {
  if( DebugReportFlagBitsEXT :: eInformation == p ) {
    j = "Information";
    return;
  }
  if( DebugReportFlagBitsEXT :: eWarning == p ) {
    j = "Warning";
    return;
  }
  if( DebugReportFlagBitsEXT :: ePerformanceWarning == p ) {
    j = "PerformanceWarning";
    return;
  }
  if( DebugReportFlagBitsEXT :: eError == p ) {
    j = "Error";
    return;
  }
}
void from_json( const nlohmann::json &j, DebugReportFlagBitsEXT &p ) {
  if( j.is_string() ) {
    if( "Information" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eInformation ;
      return;
    }
    if( "eInformation" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eInformation ;
      return;
    }
    if( "VK_DEBUG_REPORT_INFORMATION_BIT_EXT" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eInformation ;
      return;
    }
    if( "Warning" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eWarning ;
      return;
    }
    if( "eWarning" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eWarning ;
      return;
    }
    if( "VK_DEBUG_REPORT_WARNING_BIT_EXT" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eWarning ;
      return;
    }
    if( "PerformanceWarning" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: ePerformanceWarning ;
      return;
    }
    if( "ePerformanceWarning" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: ePerformanceWarning ;
      return;
    }
    if( "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: ePerformanceWarning ;
      return;
    }
    if( "Error" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eError ;
      return;
    }
    if( "eError" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eError ;
      return;
    }
    if( "VK_DEBUG_REPORT_ERROR_BIT_EXT" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eError ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DebugReportFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = DebugReportFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DebugReportFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const DebugReportFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DebugReportFlagBitsEXT ) * 8u; ++n ) {
    if( p & DebugReportFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DebugReportFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DebugReportFlagsEXT &p ) {
  if( j.is_array() ) {
    p = DebugReportFlagsEXT ( 0 );
    for( auto &e:  j ) {
      DebugReportFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DebugReportFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineRasterizationStateStreamCreateFlagBitsEXT &p ) {
}
void from_json( const nlohmann::json &j, PipelineRasterizationStateStreamCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineRasterizationStateStreamCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = PipelineRasterizationStateStreamCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineRasterizationStateStreamCreateFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const PipelineRasterizationStateStreamCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineRasterizationStateStreamCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & PipelineRasterizationStateStreamCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineRasterizationStateStreamCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineRasterizationStateStreamCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = PipelineRasterizationStateStreamCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      PipelineRasterizationStateStreamCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineRasterizationStateStreamCreateFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalMemoryHandleTypeFlagBitsNV &p ) {
  if( ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32 == p ) {
    j = "OpaqueWin32";
    return;
  }
  if( ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32Kmt == p ) {
    j = "OpaqueWin32Kmt";
    return;
  }
  if( ExternalMemoryHandleTypeFlagBitsNV :: eD3D11Image == p ) {
    j = "D3D11Image";
    return;
  }
}
void from_json( const nlohmann::json &j, ExternalMemoryHandleTypeFlagBitsNV &p ) {
  if( j.is_string() ) {
    if( "OpaqueWin32" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32 ;
      return;
    }
    if( "eOpaqueWin32" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32 ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32 ;
      return;
    }
    if( "OpaqueWin32Kmt" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32Kmt ;
      return;
    }
    if( "eOpaqueWin32Kmt" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32Kmt ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32Kmt ;
      return;
    }
    if( "D3D11Image" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eD3D11Image ;
      return;
    }
    if( "eD3D11Image" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eD3D11Image ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eD3D11Image ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ExternalMemoryHandleTypeFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = ExternalMemoryHandleTypeFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ExternalMemoryHandleTypeFlagBitsNV" );
}
void to_json( nlohmann::json &j, const ExternalMemoryHandleTypeFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ExternalMemoryHandleTypeFlagBitsNV ) * 8u; ++n ) {
    if( p & ExternalMemoryHandleTypeFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ExternalMemoryHandleTypeFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ExternalMemoryHandleTypeFlagsNV &p ) {
  if( j.is_array() ) {
    p = ExternalMemoryHandleTypeFlagsNV ( 0 );
    for( auto &e:  j ) {
      ExternalMemoryHandleTypeFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ExternalMemoryHandleTypeFlagsNV" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalMemoryFeatureFlagBitsNV &p ) {
  if( ExternalMemoryFeatureFlagBitsNV :: eDedicatedOnly == p ) {
    j = "DedicatedOnly";
    return;
  }
  if( ExternalMemoryFeatureFlagBitsNV :: eExportable == p ) {
    j = "Exportable";
    return;
  }
}
void from_json( const nlohmann::json &j, ExternalMemoryFeatureFlagBitsNV &p ) {
  if( j.is_string() ) {
    if( "DedicatedOnly" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBitsNV :: eDedicatedOnly ;
      return;
    }
    if( "eDedicatedOnly" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBitsNV :: eDedicatedOnly ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBitsNV :: eDedicatedOnly ;
      return;
    }
    if( "Exportable" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBitsNV :: eExportable ;
      return;
    }
    if( "eExportable" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBitsNV :: eExportable ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBitsNV :: eExportable ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ExternalMemoryFeatureFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = ExternalMemoryFeatureFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ExternalMemoryFeatureFlagBitsNV" );
}
void to_json( nlohmann::json &j, const ExternalMemoryFeatureFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ExternalMemoryFeatureFlagBitsNV ) * 8u; ++n ) {
    if( p & ExternalMemoryFeatureFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ExternalMemoryFeatureFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ExternalMemoryFeatureFlagsNV &p ) {
  if( j.is_array() ) {
    p = ExternalMemoryFeatureFlagsNV ( 0 );
    for( auto &e:  j ) {
      ExternalMemoryFeatureFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ExternalMemoryFeatureFlagsNV" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ConditionalRenderingFlagBitsEXT &p ) {
}
void from_json( const nlohmann::json &j, ConditionalRenderingFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for ConditionalRenderingFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = ConditionalRenderingFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ConditionalRenderingFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const ConditionalRenderingFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ConditionalRenderingFlagBitsEXT ) * 8u; ++n ) {
    if( p & ConditionalRenderingFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ConditionalRenderingFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ConditionalRenderingFlagsEXT &p ) {
  if( j.is_array() ) {
    p = ConditionalRenderingFlagsEXT ( 0 );
    for( auto &e:  j ) {
      ConditionalRenderingFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ConditionalRenderingFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SurfaceCounterFlagBitsEXT &p ) {
}
void from_json( const nlohmann::json &j, SurfaceCounterFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for SurfaceCounterFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = SurfaceCounterFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SurfaceCounterFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const SurfaceCounterFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SurfaceCounterFlagBitsEXT ) * 8u; ++n ) {
    if( p & SurfaceCounterFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SurfaceCounterFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, SurfaceCounterFlagsEXT &p ) {
  if( j.is_array() ) {
    p = SurfaceCounterFlagsEXT ( 0 );
    for( auto &e:  j ) {
      SurfaceCounterFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SurfaceCounterFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineViewportSwizzleStateCreateFlagBitsNV &p ) {
}
void from_json( const nlohmann::json &j, PipelineViewportSwizzleStateCreateFlagBitsNV &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineViewportSwizzleStateCreateFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = PipelineViewportSwizzleStateCreateFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineViewportSwizzleStateCreateFlagBitsNV" );
}
void to_json( nlohmann::json &j, const PipelineViewportSwizzleStateCreateFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineViewportSwizzleStateCreateFlagBitsNV ) * 8u; ++n ) {
    if( p & PipelineViewportSwizzleStateCreateFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineViewportSwizzleStateCreateFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineViewportSwizzleStateCreateFlagsNV &p ) {
  if( j.is_array() ) {
    p = PipelineViewportSwizzleStateCreateFlagsNV ( 0 );
    for( auto &e:  j ) {
      PipelineViewportSwizzleStateCreateFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineViewportSwizzleStateCreateFlagsNV" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineDiscardRectangleStateCreateFlagBitsEXT &p ) {
}
void from_json( const nlohmann::json &j, PipelineDiscardRectangleStateCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineDiscardRectangleStateCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = PipelineDiscardRectangleStateCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineDiscardRectangleStateCreateFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const PipelineDiscardRectangleStateCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineDiscardRectangleStateCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & PipelineDiscardRectangleStateCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineDiscardRectangleStateCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineDiscardRectangleStateCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = PipelineDiscardRectangleStateCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      PipelineDiscardRectangleStateCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineDiscardRectangleStateCreateFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineRasterizationConservativeStateCreateFlagBitsEXT &p ) {
}
void from_json( const nlohmann::json &j, PipelineRasterizationConservativeStateCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineRasterizationConservativeStateCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = PipelineRasterizationConservativeStateCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineRasterizationConservativeStateCreateFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const PipelineRasterizationConservativeStateCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineRasterizationConservativeStateCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & PipelineRasterizationConservativeStateCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineRasterizationConservativeStateCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineRasterizationConservativeStateCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = PipelineRasterizationConservativeStateCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      PipelineRasterizationConservativeStateCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineRasterizationConservativeStateCreateFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineRasterizationDepthClipStateCreateFlagBitsEXT &p ) {
}
void from_json( const nlohmann::json &j, PipelineRasterizationDepthClipStateCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineRasterizationDepthClipStateCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = PipelineRasterizationDepthClipStateCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineRasterizationDepthClipStateCreateFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const PipelineRasterizationDepthClipStateCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineRasterizationDepthClipStateCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & PipelineRasterizationDepthClipStateCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineRasterizationDepthClipStateCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineRasterizationDepthClipStateCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = PipelineRasterizationDepthClipStateCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      PipelineRasterizationDepthClipStateCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineRasterizationDepthClipStateCreateFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceCounterDescriptionFlagBitsKHR &p ) {
  if( PerformanceCounterDescriptionFlagBitsKHR :: ePerformanceImpacting == p ) {
    j = "PerformanceImpacting";
    return;
  }
}
void from_json( const nlohmann::json &j, PerformanceCounterDescriptionFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "PerformanceImpacting" == j.get< std::string >() ) {
      p = PerformanceCounterDescriptionFlagBitsKHR :: ePerformanceImpacting ;
      return;
    }
    if( "ePerformanceImpacting" == j.get< std::string >() ) {
      p = PerformanceCounterDescriptionFlagBitsKHR :: ePerformanceImpacting ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterDescriptionFlagBitsKHR :: ePerformanceImpacting ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceCounterDescriptionFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = PerformanceCounterDescriptionFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceCounterDescriptionFlagBitsKHR" );
}
void to_json( nlohmann::json &j, const PerformanceCounterDescriptionFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PerformanceCounterDescriptionFlagBitsKHR ) * 8u; ++n ) {
    if( p & PerformanceCounterDescriptionFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PerformanceCounterDescriptionFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PerformanceCounterDescriptionFlagsKHR &p ) {
  if( j.is_array() ) {
    p = PerformanceCounterDescriptionFlagsKHR ( 0 );
    for( auto &e:  j ) {
      PerformanceCounterDescriptionFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PerformanceCounterDescriptionFlagsKHR" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AcquireProfilingLockFlagBitsKHR &p ) {
}
void from_json( const nlohmann::json &j, AcquireProfilingLockFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for AcquireProfilingLockFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = AcquireProfilingLockFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AcquireProfilingLockFlagBitsKHR" );
}
void to_json( nlohmann::json &j, const AcquireProfilingLockFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( AcquireProfilingLockFlagBitsKHR ) * 8u; ++n ) {
    if( p & AcquireProfilingLockFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, AcquireProfilingLockFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, AcquireProfilingLockFlagsKHR &p ) {
  if( j.is_array() ) {
    p = AcquireProfilingLockFlagsKHR ( 0 );
    for( auto &e:  j ) {
      AcquireProfilingLockFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for AcquireProfilingLockFlagsKHR" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugUtilsMessageSeverityFlagBitsEXT &p ) {
  if( DebugUtilsMessageSeverityFlagBitsEXT :: eVerbose == p ) {
    j = "Verbose";
    return;
  }
  if( DebugUtilsMessageSeverityFlagBitsEXT :: eInfo == p ) {
    j = "Info";
    return;
  }
  if( DebugUtilsMessageSeverityFlagBitsEXT :: eWarning == p ) {
    j = "Warning";
    return;
  }
}
void from_json( const nlohmann::json &j, DebugUtilsMessageSeverityFlagBitsEXT &p ) {
  if( j.is_string() ) {
    if( "Verbose" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eVerbose ;
      return;
    }
    if( "eVerbose" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eVerbose ;
      return;
    }
    if( "VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eVerbose ;
      return;
    }
    if( "Info" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eInfo ;
      return;
    }
    if( "eInfo" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eInfo ;
      return;
    }
    if( "VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eInfo ;
      return;
    }
    if( "Warning" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eWarning ;
      return;
    }
    if( "eWarning" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eWarning ;
      return;
    }
    if( "VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eWarning ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DebugUtilsMessageSeverityFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = DebugUtilsMessageSeverityFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DebugUtilsMessageSeverityFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const DebugUtilsMessageSeverityFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DebugUtilsMessageSeverityFlagBitsEXT ) * 8u; ++n ) {
    if( p & DebugUtilsMessageSeverityFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DebugUtilsMessageSeverityFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DebugUtilsMessageSeverityFlagsEXT &p ) {
  if( j.is_array() ) {
    p = DebugUtilsMessageSeverityFlagsEXT ( 0 );
    for( auto &e:  j ) {
      DebugUtilsMessageSeverityFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DebugUtilsMessageSeverityFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugUtilsMessageTypeFlagBitsEXT &p ) {
  if( DebugUtilsMessageTypeFlagBitsEXT :: eGeneral == p ) {
    j = "General";
    return;
  }
  if( DebugUtilsMessageTypeFlagBitsEXT :: eValidation == p ) {
    j = "Validation";
    return;
  }
}
void from_json( const nlohmann::json &j, DebugUtilsMessageTypeFlagBitsEXT &p ) {
  if( j.is_string() ) {
    if( "General" == j.get< std::string >() ) {
      p = DebugUtilsMessageTypeFlagBitsEXT :: eGeneral ;
      return;
    }
    if( "eGeneral" == j.get< std::string >() ) {
      p = DebugUtilsMessageTypeFlagBitsEXT :: eGeneral ;
      return;
    }
    if( "VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT" == j.get< std::string >() ) {
      p = DebugUtilsMessageTypeFlagBitsEXT :: eGeneral ;
      return;
    }
    if( "Validation" == j.get< std::string >() ) {
      p = DebugUtilsMessageTypeFlagBitsEXT :: eValidation ;
      return;
    }
    if( "eValidation" == j.get< std::string >() ) {
      p = DebugUtilsMessageTypeFlagBitsEXT :: eValidation ;
      return;
    }
    if( "VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT" == j.get< std::string >() ) {
      p = DebugUtilsMessageTypeFlagBitsEXT :: eValidation ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DebugUtilsMessageTypeFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = DebugUtilsMessageTypeFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DebugUtilsMessageTypeFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const DebugUtilsMessageTypeFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DebugUtilsMessageTypeFlagBitsEXT ) * 8u; ++n ) {
    if( p & DebugUtilsMessageTypeFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DebugUtilsMessageTypeFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DebugUtilsMessageTypeFlagsEXT &p ) {
  if( j.is_array() ) {
    p = DebugUtilsMessageTypeFlagsEXT ( 0 );
    for( auto &e:  j ) {
      DebugUtilsMessageTypeFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DebugUtilsMessageTypeFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugUtilsMessengerCallbackDataFlagBitsEXT &p ) {
}
void from_json( const nlohmann::json &j, DebugUtilsMessengerCallbackDataFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DebugUtilsMessengerCallbackDataFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = DebugUtilsMessengerCallbackDataFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DebugUtilsMessengerCallbackDataFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const DebugUtilsMessengerCallbackDataFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DebugUtilsMessengerCallbackDataFlagBitsEXT ) * 8u; ++n ) {
    if( p & DebugUtilsMessengerCallbackDataFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DebugUtilsMessengerCallbackDataFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DebugUtilsMessengerCallbackDataFlagsEXT &p ) {
  if( j.is_array() ) {
    p = DebugUtilsMessengerCallbackDataFlagsEXT ( 0 );
    for( auto &e:  j ) {
      DebugUtilsMessengerCallbackDataFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DebugUtilsMessengerCallbackDataFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugUtilsMessengerCreateFlagBitsEXT &p ) {
}
void from_json( const nlohmann::json &j, DebugUtilsMessengerCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DebugUtilsMessengerCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = DebugUtilsMessengerCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DebugUtilsMessengerCreateFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const DebugUtilsMessengerCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DebugUtilsMessengerCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & DebugUtilsMessengerCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DebugUtilsMessengerCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DebugUtilsMessengerCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = DebugUtilsMessengerCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      DebugUtilsMessengerCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DebugUtilsMessengerCreateFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCoverageToColorStateCreateFlagBitsNV &p ) {
}
void from_json( const nlohmann::json &j, PipelineCoverageToColorStateCreateFlagBitsNV &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCoverageToColorStateCreateFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = PipelineCoverageToColorStateCreateFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCoverageToColorStateCreateFlagBitsNV" );
}
void to_json( nlohmann::json &j, const PipelineCoverageToColorStateCreateFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineCoverageToColorStateCreateFlagBitsNV ) * 8u; ++n ) {
    if( p & PipelineCoverageToColorStateCreateFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineCoverageToColorStateCreateFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineCoverageToColorStateCreateFlagsNV &p ) {
  if( j.is_array() ) {
    p = PipelineCoverageToColorStateCreateFlagsNV ( 0 );
    for( auto &e:  j ) {
      PipelineCoverageToColorStateCreateFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineCoverageToColorStateCreateFlagsNV" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const GeometryFlagBitsKHR &p ) {
  if( GeometryFlagBitsKHR :: eOpaque == p ) {
    j = "Opaque";
    return;
  }
}
void from_json( const nlohmann::json &j, GeometryFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "Opaque" == j.get< std::string >() ) {
      p = GeometryFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "eOpaque" == j.get< std::string >() ) {
      p = GeometryFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "VK_GEOMETRY_OPAQUE_BIT_KHR" == j.get< std::string >() ) {
      p = GeometryFlagBitsKHR :: eOpaque ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for GeometryFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = GeometryFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for GeometryFlagBitsKHR" );
}
void to_json( nlohmann::json &j, const GeometryFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( GeometryFlagBitsKHR ) * 8u; ++n ) {
    if( p & GeometryFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, GeometryFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, GeometryFlagsKHR &p ) {
  if( j.is_array() ) {
    p = GeometryFlagsKHR ( 0 );
    for( auto &e:  j ) {
      GeometryFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for GeometryFlagsKHR" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const GeometryInstanceFlagBitsKHR &p ) {
  if( GeometryInstanceFlagBitsKHR :: eTriangleFacingCullDisable == p ) {
    j = "TriangleFacingCullDisable";
    return;
  }
  if( GeometryInstanceFlagBitsKHR :: eTriangleFrontCounterclockwise == p ) {
    j = "TriangleFrontCounterclockwise";
    return;
  }
  if( GeometryInstanceFlagBitsKHR :: eForceOpaque == p ) {
    j = "ForceOpaque";
    return;
  }
  if( GeometryInstanceFlagBitsKHR :: eForceNoOpaque == p ) {
    j = "ForceNoOpaque";
    return;
  }
}
void from_json( const nlohmann::json &j, GeometryInstanceFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "TriangleFacingCullDisable" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eTriangleFacingCullDisable ;
      return;
    }
    if( "eTriangleFacingCullDisable" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eTriangleFacingCullDisable ;
      return;
    }
    if( "VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eTriangleFacingCullDisable ;
      return;
    }
    if( "TriangleFrontCounterclockwise" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eTriangleFrontCounterclockwise ;
      return;
    }
    if( "eTriangleFrontCounterclockwise" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eTriangleFrontCounterclockwise ;
      return;
    }
    if( "VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eTriangleFrontCounterclockwise ;
      return;
    }
    if( "ForceOpaque" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eForceOpaque ;
      return;
    }
    if( "eForceOpaque" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eForceOpaque ;
      return;
    }
    if( "VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eForceOpaque ;
      return;
    }
    if( "ForceNoOpaque" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eForceNoOpaque ;
      return;
    }
    if( "eForceNoOpaque" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eForceNoOpaque ;
      return;
    }
    if( "VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eForceNoOpaque ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for GeometryInstanceFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = GeometryInstanceFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for GeometryInstanceFlagBitsKHR" );
}
void to_json( nlohmann::json &j, const GeometryInstanceFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( GeometryInstanceFlagBitsKHR ) * 8u; ++n ) {
    if( p & GeometryInstanceFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, GeometryInstanceFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, GeometryInstanceFlagsKHR &p ) {
  if( j.is_array() ) {
    p = GeometryInstanceFlagsKHR ( 0 );
    for( auto &e:  j ) {
      GeometryInstanceFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for GeometryInstanceFlagsKHR" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BuildAccelerationStructureFlagBitsKHR &p ) {
  if( BuildAccelerationStructureFlagBitsKHR :: eAllowUpdate == p ) {
    j = "AllowUpdate";
    return;
  }
  if( BuildAccelerationStructureFlagBitsKHR :: eAllowCompaction == p ) {
    j = "AllowCompaction";
    return;
  }
  if( BuildAccelerationStructureFlagBitsKHR :: ePreferFastTrace == p ) {
    j = "PreferFastTrace";
    return;
  }
  if( BuildAccelerationStructureFlagBitsKHR :: ePreferFastBuild == p ) {
    j = "PreferFastBuild";
    return;
  }
  if( BuildAccelerationStructureFlagBitsKHR :: eLowMemory == p ) {
    j = "LowMemory";
    return;
  }
}
void from_json( const nlohmann::json &j, BuildAccelerationStructureFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "AllowUpdate" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eAllowUpdate ;
      return;
    }
    if( "eAllowUpdate" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eAllowUpdate ;
      return;
    }
    if( "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eAllowUpdate ;
      return;
    }
    if( "AllowCompaction" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eAllowCompaction ;
      return;
    }
    if( "eAllowCompaction" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eAllowCompaction ;
      return;
    }
    if( "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eAllowCompaction ;
      return;
    }
    if( "PreferFastTrace" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: ePreferFastTrace ;
      return;
    }
    if( "ePreferFastTrace" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: ePreferFastTrace ;
      return;
    }
    if( "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: ePreferFastTrace ;
      return;
    }
    if( "PreferFastBuild" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: ePreferFastBuild ;
      return;
    }
    if( "ePreferFastBuild" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: ePreferFastBuild ;
      return;
    }
    if( "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: ePreferFastBuild ;
      return;
    }
    if( "LowMemory" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eLowMemory ;
      return;
    }
    if( "eLowMemory" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eLowMemory ;
      return;
    }
    if( "VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eLowMemory ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BuildAccelerationStructureFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = BuildAccelerationStructureFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BuildAccelerationStructureFlagBitsKHR" );
}
void to_json( nlohmann::json &j, const BuildAccelerationStructureFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( BuildAccelerationStructureFlagBitsKHR ) * 8u; ++n ) {
    if( p & BuildAccelerationStructureFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, BuildAccelerationStructureFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, BuildAccelerationStructureFlagsKHR &p ) {
  if( j.is_array() ) {
    p = BuildAccelerationStructureFlagsKHR ( 0 );
    for( auto &e:  j ) {
      BuildAccelerationStructureFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for BuildAccelerationStructureFlagsKHR" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureCreateFlagBitsKHR &p ) {
  if( AccelerationStructureCreateFlagBitsKHR :: eDeviceAddressCaptureReplay == p ) {
    j = "DeviceAddressCaptureReplay";
    return;
  }
}
void from_json( const nlohmann::json &j, AccelerationStructureCreateFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "DeviceAddressCaptureReplay" == j.get< std::string >() ) {
      p = AccelerationStructureCreateFlagBitsKHR :: eDeviceAddressCaptureReplay ;
      return;
    }
    if( "eDeviceAddressCaptureReplay" == j.get< std::string >() ) {
      p = AccelerationStructureCreateFlagBitsKHR :: eDeviceAddressCaptureReplay ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR" == j.get< std::string >() ) {
      p = AccelerationStructureCreateFlagBitsKHR :: eDeviceAddressCaptureReplay ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureCreateFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureCreateFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureCreateFlagBitsKHR" );
}
void to_json( nlohmann::json &j, const AccelerationStructureCreateFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( AccelerationStructureCreateFlagBitsKHR ) * 8u; ++n ) {
    if( p & AccelerationStructureCreateFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, AccelerationStructureCreateFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, AccelerationStructureCreateFlagsKHR &p ) {
  if( j.is_array() ) {
    p = AccelerationStructureCreateFlagsKHR ( 0 );
    for( auto &e:  j ) {
      AccelerationStructureCreateFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for AccelerationStructureCreateFlagsKHR" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCoverageModulationStateCreateFlagBitsNV &p ) {
}
void from_json( const nlohmann::json &j, PipelineCoverageModulationStateCreateFlagBitsNV &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCoverageModulationStateCreateFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = PipelineCoverageModulationStateCreateFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCoverageModulationStateCreateFlagBitsNV" );
}
void to_json( nlohmann::json &j, const PipelineCoverageModulationStateCreateFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineCoverageModulationStateCreateFlagBitsNV ) * 8u; ++n ) {
    if( p & PipelineCoverageModulationStateCreateFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineCoverageModulationStateCreateFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineCoverageModulationStateCreateFlagsNV &p ) {
  if( j.is_array() ) {
    p = PipelineCoverageModulationStateCreateFlagsNV ( 0 );
    for( auto &e:  j ) {
      PipelineCoverageModulationStateCreateFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineCoverageModulationStateCreateFlagsNV" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ValidationCacheCreateFlagBitsEXT &p ) {
}
void from_json( const nlohmann::json &j, ValidationCacheCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for ValidationCacheCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = ValidationCacheCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ValidationCacheCreateFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const ValidationCacheCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ValidationCacheCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & ValidationCacheCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ValidationCacheCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ValidationCacheCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = ValidationCacheCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      ValidationCacheCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ValidationCacheCreateFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCompilerControlFlagBitsAMD &p ) {
}
void from_json( const nlohmann::json &j, PipelineCompilerControlFlagBitsAMD &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCompilerControlFlagBitsAMD" );
  }
  if( j.is_number() ) {
    p = PipelineCompilerControlFlagBitsAMD ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCompilerControlFlagBitsAMD" );
}
void to_json( nlohmann::json &j, const PipelineCompilerControlFlagsAMD &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineCompilerControlFlagBitsAMD ) * 8u; ++n ) {
    if( p & PipelineCompilerControlFlagsAMD ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineCompilerControlFlagBitsAMD ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineCompilerControlFlagsAMD &p ) {
  if( j.is_array() ) {
    p = PipelineCompilerControlFlagsAMD ( 0 );
    for( auto &e:  j ) {
      PipelineCompilerControlFlagBitsAMD temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineCompilerControlFlagsAMD" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCreationFeedbackFlagBitsEXT &p ) {
  if( PipelineCreationFeedbackFlagBitsEXT :: eValid == p ) {
    j = "Valid";
    return;
  }
  if( PipelineCreationFeedbackFlagBitsEXT :: eApplicationPipelineCacheHit == p ) {
    j = "ApplicationPipelineCacheHit";
    return;
  }
}
void from_json( const nlohmann::json &j, PipelineCreationFeedbackFlagBitsEXT &p ) {
  if( j.is_string() ) {
    if( "Valid" == j.get< std::string >() ) {
      p = PipelineCreationFeedbackFlagBitsEXT :: eValid ;
      return;
    }
    if( "eValid" == j.get< std::string >() ) {
      p = PipelineCreationFeedbackFlagBitsEXT :: eValid ;
      return;
    }
    if( "VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineCreationFeedbackFlagBitsEXT :: eValid ;
      return;
    }
    if( "ApplicationPipelineCacheHit" == j.get< std::string >() ) {
      p = PipelineCreationFeedbackFlagBitsEXT :: eApplicationPipelineCacheHit ;
      return;
    }
    if( "eApplicationPipelineCacheHit" == j.get< std::string >() ) {
      p = PipelineCreationFeedbackFlagBitsEXT :: eApplicationPipelineCacheHit ;
      return;
    }
    if( "VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineCreationFeedbackFlagBitsEXT :: eApplicationPipelineCacheHit ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCreationFeedbackFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = PipelineCreationFeedbackFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCreationFeedbackFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const PipelineCreationFeedbackFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineCreationFeedbackFlagBitsEXT ) * 8u; ++n ) {
    if( p & PipelineCreationFeedbackFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineCreationFeedbackFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineCreationFeedbackFlagsEXT &p ) {
  if( j.is_array() ) {
    p = PipelineCreationFeedbackFlagsEXT ( 0 );
    for( auto &e:  j ) {
      PipelineCreationFeedbackFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineCreationFeedbackFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ShaderCorePropertiesFlagBitsAMD &p ) {
}
void from_json( const nlohmann::json &j, ShaderCorePropertiesFlagBitsAMD &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for ShaderCorePropertiesFlagBitsAMD" );
  }
  if( j.is_number() ) {
    p = ShaderCorePropertiesFlagBitsAMD ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ShaderCorePropertiesFlagBitsAMD" );
}
void to_json( nlohmann::json &j, const ShaderCorePropertiesFlagsAMD &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ShaderCorePropertiesFlagBitsAMD ) * 8u; ++n ) {
    if( p & ShaderCorePropertiesFlagsAMD ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ShaderCorePropertiesFlagBitsAMD ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ShaderCorePropertiesFlagsAMD &p ) {
  if( j.is_array() ) {
    p = ShaderCorePropertiesFlagsAMD ( 0 );
    for( auto &e:  j ) {
      ShaderCorePropertiesFlagBitsAMD temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ShaderCorePropertiesFlagsAMD" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ToolPurposeFlagBitsEXT &p ) {
  if( ToolPurposeFlagBitsEXT :: eValidation == p ) {
    j = "Validation";
    return;
  }
  if( ToolPurposeFlagBitsEXT :: eProfiling == p ) {
    j = "Profiling";
    return;
  }
  if( ToolPurposeFlagBitsEXT :: eTracing == p ) {
    j = "Tracing";
    return;
  }
  if( ToolPurposeFlagBitsEXT :: eAdditionalFeatures == p ) {
    j = "AdditionalFeatures";
    return;
  }
  if( ToolPurposeFlagBitsEXT :: eModifyingFeatures == p ) {
    j = "ModifyingFeatures";
    return;
  }
  if( ToolPurposeFlagBitsEXT :: eDebugReporting == p ) {
    j = "DebugReporting";
    return;
  }
}
void from_json( const nlohmann::json &j, ToolPurposeFlagBitsEXT &p ) {
  if( j.is_string() ) {
    if( "Validation" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eValidation ;
      return;
    }
    if( "eValidation" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eValidation ;
      return;
    }
    if( "VK_TOOL_PURPOSE_VALIDATION_BIT_EXT" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eValidation ;
      return;
    }
    if( "Profiling" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eProfiling ;
      return;
    }
    if( "eProfiling" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eProfiling ;
      return;
    }
    if( "VK_TOOL_PURPOSE_PROFILING_BIT_EXT" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eProfiling ;
      return;
    }
    if( "Tracing" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eTracing ;
      return;
    }
    if( "eTracing" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eTracing ;
      return;
    }
    if( "VK_TOOL_PURPOSE_TRACING_BIT_EXT" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eTracing ;
      return;
    }
    if( "AdditionalFeatures" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eAdditionalFeatures ;
      return;
    }
    if( "eAdditionalFeatures" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eAdditionalFeatures ;
      return;
    }
    if( "VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eAdditionalFeatures ;
      return;
    }
    if( "ModifyingFeatures" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eModifyingFeatures ;
      return;
    }
    if( "eModifyingFeatures" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eModifyingFeatures ;
      return;
    }
    if( "VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eModifyingFeatures ;
      return;
    }
    if( "DebugReporting" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eDebugReporting ;
      return;
    }
    if( "eDebugReporting" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eDebugReporting ;
      return;
    }
    if( "VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eDebugReporting ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ToolPurposeFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = ToolPurposeFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ToolPurposeFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const ToolPurposeFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ToolPurposeFlagBitsEXT ) * 8u; ++n ) {
    if( p & ToolPurposeFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ToolPurposeFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, ToolPurposeFlagsEXT &p ) {
  if( j.is_array() ) {
    p = ToolPurposeFlagsEXT ( 0 );
    for( auto &e:  j ) {
      ToolPurposeFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ToolPurposeFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCoverageReductionStateCreateFlagBitsNV &p ) {
}
void from_json( const nlohmann::json &j, PipelineCoverageReductionStateCreateFlagBitsNV &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCoverageReductionStateCreateFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = PipelineCoverageReductionStateCreateFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCoverageReductionStateCreateFlagBitsNV" );
}
void to_json( nlohmann::json &j, const PipelineCoverageReductionStateCreateFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineCoverageReductionStateCreateFlagBitsNV ) * 8u; ++n ) {
    if( p & PipelineCoverageReductionStateCreateFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineCoverageReductionStateCreateFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PipelineCoverageReductionStateCreateFlagsNV &p ) {
  if( j.is_array() ) {
    p = PipelineCoverageReductionStateCreateFlagsNV ( 0 );
    for( auto &e:  j ) {
      PipelineCoverageReductionStateCreateFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineCoverageReductionStateCreateFlagsNV" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const HeadlessSurfaceCreateFlagBitsEXT &p ) {
}
void from_json( const nlohmann::json &j, HeadlessSurfaceCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for HeadlessSurfaceCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = HeadlessSurfaceCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for HeadlessSurfaceCreateFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const HeadlessSurfaceCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( HeadlessSurfaceCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & HeadlessSurfaceCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, HeadlessSurfaceCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, HeadlessSurfaceCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = HeadlessSurfaceCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      HeadlessSurfaceCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for HeadlessSurfaceCreateFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const IndirectStateFlagBitsNV &p ) {
}
void from_json( const nlohmann::json &j, IndirectStateFlagBitsNV &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for IndirectStateFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = IndirectStateFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for IndirectStateFlagBitsNV" );
}
void to_json( nlohmann::json &j, const IndirectStateFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( IndirectStateFlagBitsNV ) * 8u; ++n ) {
    if( p & IndirectStateFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, IndirectStateFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, IndirectStateFlagsNV &p ) {
  if( j.is_array() ) {
    p = IndirectStateFlagsNV ( 0 );
    for( auto &e:  j ) {
      IndirectStateFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for IndirectStateFlagsNV" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const IndirectCommandsLayoutUsageFlagBitsNV &p ) {
  if( IndirectCommandsLayoutUsageFlagBitsNV :: eExplicitPreprocess == p ) {
    j = "ExplicitPreprocess";
    return;
  }
  if( IndirectCommandsLayoutUsageFlagBitsNV :: eIndexedSequences == p ) {
    j = "IndexedSequences";
    return;
  }
}
void from_json( const nlohmann::json &j, IndirectCommandsLayoutUsageFlagBitsNV &p ) {
  if( j.is_string() ) {
    if( "ExplicitPreprocess" == j.get< std::string >() ) {
      p = IndirectCommandsLayoutUsageFlagBitsNV :: eExplicitPreprocess ;
      return;
    }
    if( "eExplicitPreprocess" == j.get< std::string >() ) {
      p = IndirectCommandsLayoutUsageFlagBitsNV :: eExplicitPreprocess ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV" == j.get< std::string >() ) {
      p = IndirectCommandsLayoutUsageFlagBitsNV :: eExplicitPreprocess ;
      return;
    }
    if( "IndexedSequences" == j.get< std::string >() ) {
      p = IndirectCommandsLayoutUsageFlagBitsNV :: eIndexedSequences ;
      return;
    }
    if( "eIndexedSequences" == j.get< std::string >() ) {
      p = IndirectCommandsLayoutUsageFlagBitsNV :: eIndexedSequences ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV" == j.get< std::string >() ) {
      p = IndirectCommandsLayoutUsageFlagBitsNV :: eIndexedSequences ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for IndirectCommandsLayoutUsageFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = IndirectCommandsLayoutUsageFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for IndirectCommandsLayoutUsageFlagBitsNV" );
}
void to_json( nlohmann::json &j, const IndirectCommandsLayoutUsageFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( IndirectCommandsLayoutUsageFlagBitsNV ) * 8u; ++n ) {
    if( p & IndirectCommandsLayoutUsageFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, IndirectCommandsLayoutUsageFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, IndirectCommandsLayoutUsageFlagsNV &p ) {
  if( j.is_array() ) {
    p = IndirectCommandsLayoutUsageFlagsNV ( 0 );
    for( auto &e:  j ) {
      IndirectCommandsLayoutUsageFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for IndirectCommandsLayoutUsageFlagsNV" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceMemoryReportFlagBitsEXT &p ) {
}
void from_json( const nlohmann::json &j, DeviceMemoryReportFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DeviceMemoryReportFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = DeviceMemoryReportFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DeviceMemoryReportFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const DeviceMemoryReportFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DeviceMemoryReportFlagBitsEXT ) * 8u; ++n ) {
    if( p & DeviceMemoryReportFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DeviceMemoryReportFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DeviceMemoryReportFlagsEXT &p ) {
  if( j.is_array() ) {
    p = DeviceMemoryReportFlagsEXT ( 0 );
    for( auto &e:  j ) {
      DeviceMemoryReportFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DeviceMemoryReportFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PrivateDataSlotCreateFlagBitsEXT &p ) {
}
void from_json( const nlohmann::json &j, PrivateDataSlotCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PrivateDataSlotCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = PrivateDataSlotCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PrivateDataSlotCreateFlagBitsEXT" );
}
void to_json( nlohmann::json &j, const PrivateDataSlotCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PrivateDataSlotCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & PrivateDataSlotCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PrivateDataSlotCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, PrivateDataSlotCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = PrivateDataSlotCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      PrivateDataSlotCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PrivateDataSlotCreateFlagsEXT" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceDiagnosticsConfigFlagBitsNV &p ) {
  if( DeviceDiagnosticsConfigFlagBitsNV :: eEnableShaderDebugInfo == p ) {
    j = "EnableShaderDebugInfo";
    return;
  }
  if( DeviceDiagnosticsConfigFlagBitsNV :: eEnableResourceTracking == p ) {
    j = "EnableResourceTracking";
    return;
  }
}
void from_json( const nlohmann::json &j, DeviceDiagnosticsConfigFlagBitsNV &p ) {
  if( j.is_string() ) {
    if( "EnableShaderDebugInfo" == j.get< std::string >() ) {
      p = DeviceDiagnosticsConfigFlagBitsNV :: eEnableShaderDebugInfo ;
      return;
    }
    if( "eEnableShaderDebugInfo" == j.get< std::string >() ) {
      p = DeviceDiagnosticsConfigFlagBitsNV :: eEnableShaderDebugInfo ;
      return;
    }
    if( "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV" == j.get< std::string >() ) {
      p = DeviceDiagnosticsConfigFlagBitsNV :: eEnableShaderDebugInfo ;
      return;
    }
    if( "EnableResourceTracking" == j.get< std::string >() ) {
      p = DeviceDiagnosticsConfigFlagBitsNV :: eEnableResourceTracking ;
      return;
    }
    if( "eEnableResourceTracking" == j.get< std::string >() ) {
      p = DeviceDiagnosticsConfigFlagBitsNV :: eEnableResourceTracking ;
      return;
    }
    if( "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV" == j.get< std::string >() ) {
      p = DeviceDiagnosticsConfigFlagBitsNV :: eEnableResourceTracking ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DeviceDiagnosticsConfigFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = DeviceDiagnosticsConfigFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DeviceDiagnosticsConfigFlagBitsNV" );
}
void to_json( nlohmann::json &j, const DeviceDiagnosticsConfigFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DeviceDiagnosticsConfigFlagBitsNV ) * 8u; ++n ) {
    if( p & DeviceDiagnosticsConfigFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DeviceDiagnosticsConfigFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, DeviceDiagnosticsConfigFlagsNV &p ) {
  if( j.is_array() ) {
    p = DeviceDiagnosticsConfigFlagsNV ( 0 );
    for( auto &e:  j ) {
      DeviceDiagnosticsConfigFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DeviceDiagnosticsConfigFlagsNV" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubmitFlagBitsKHR &p ) {
}
void from_json( const nlohmann::json &j, SubmitFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for SubmitFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = SubmitFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SubmitFlagBitsKHR" );
}
void to_json( nlohmann::json &j, const SubmitFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SubmitFlagBitsKHR ) * 8u; ++n ) {
    if( p & SubmitFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SubmitFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, SubmitFlagsKHR &p ) {
  if( j.is_array() ) {
    p = SubmitFlagsKHR ( 0 );
    for( auto &e:  j ) {
      SubmitFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SubmitFlagsKHR" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureMotionInfoFlagBitsNV &p ) {
}
void from_json( const nlohmann::json &j, AccelerationStructureMotionInfoFlagBitsNV &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureMotionInfoFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureMotionInfoFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureMotionInfoFlagBitsNV" );
}
void to_json( nlohmann::json &j, const AccelerationStructureMotionInfoFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( AccelerationStructureMotionInfoFlagBitsNV ) * 8u; ++n ) {
    if( p & AccelerationStructureMotionInfoFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, AccelerationStructureMotionInfoFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, AccelerationStructureMotionInfoFlagsNV &p ) {
  if( j.is_array() ) {
    p = AccelerationStructureMotionInfoFlagsNV ( 0 );
    for( auto &e:  j ) {
      AccelerationStructureMotionInfoFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for AccelerationStructureMotionInfoFlagsNV" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureMotionInstanceFlagBitsNV &p ) {
}
void from_json( const nlohmann::json &j, AccelerationStructureMotionInstanceFlagBitsNV &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureMotionInstanceFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureMotionInstanceFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureMotionInstanceFlagBitsNV" );
}
void to_json( nlohmann::json &j, const AccelerationStructureMotionInstanceFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( AccelerationStructureMotionInstanceFlagBitsNV ) * 8u; ++n ) {
    if( p & AccelerationStructureMotionInstanceFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, AccelerationStructureMotionInstanceFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
void from_json( const nlohmann::json &j, AccelerationStructureMotionInstanceFlagsNV &p ) {
  if( j.is_array() ) {
    p = AccelerationStructureMotionInstanceFlagsNV ( 0 );
    for( auto &e:  j ) {
      AccelerationStructureMotionInstanceFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for AccelerationStructureMotionInstanceFlagsNV" );
}
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AabbPositionsKHR &p ) {
  j = nlohmann::json::object();
  j[ "minX" ] = p.minX;
  j[ "minY" ] = p.minY;
  j[ "minZ" ] = p.minZ;
  j[ "maxX" ] = p.maxX;
  j[ "maxY" ] = p.maxY;
  j[ "maxZ" ] = p.maxZ;
}
}
void to_json( nlohmann::json &j, const VkAabbPositionsKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AabbPositionsKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AabbPositionsKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AabbPositionsKHR" );
  if( j.find( "minX" ) != j.end() ) {
    p.minX = j[ "minX" ];
  }
  if( j.find( "minY" ) != j.end() ) {
    p.minY = j[ "minY" ];
  }
  if( j.find( "minZ" ) != j.end() ) {
    p.minZ = j[ "minZ" ];
  }
  if( j.find( "maxX" ) != j.end() ) {
    p.maxX = j[ "maxX" ];
  }
  if( j.find( "maxY" ) != j.end() ) {
    p.maxY = j[ "maxY" ];
  }
  if( j.find( "maxZ" ) != j.end() ) {
    p.maxZ = j[ "maxZ" ];
  }
}
}
void from_json( const nlohmann::json &j, VkAabbPositionsKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AabbPositionsKHR temp;
  from_json( j, temp );
  p = VkAabbPositionsKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Format.hpp>
#include <vulkan2json/IndexType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureGeometryTrianglesDataKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "vertexFormat" ] = p.vertexFormat;
  j[ "vertexStride" ] = p.vertexStride;
  j[ "maxVertex" ] = p.maxVertex;
  j[ "indexType" ] = p.indexType;
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureGeometryTrianglesDataKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureGeometryTrianglesDataKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureGeometryTrianglesDataKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureGeometryTrianglesDataKHR" );
  if( j.find( "vertexFormat" ) != j.end() ) {
    p.vertexFormat = Format ( j[ "vertexFormat" ] );
  }
  if( j.find( "vertexStride" ) != j.end() ) {
    p.vertexStride = j[ "vertexStride" ];
  }
  if( j.find( "maxVertex" ) != j.end() ) {
    p.maxVertex = j[ "maxVertex" ];
  }
  if( j.find( "indexType" ) != j.end() ) {
    p.indexType = IndexType ( j[ "indexType" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureGeometryTrianglesDataKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureGeometryTrianglesDataKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureGeometryTrianglesDataKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureGeometryAabbsDataKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stride" ] = p.stride;
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureGeometryAabbsDataKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureGeometryAabbsDataKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureGeometryAabbsDataKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureGeometryAabbsDataKHR" );
  if( j.find( "stride" ) != j.end() ) {
    p.stride = j[ "stride" ];
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureGeometryAabbsDataKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureGeometryAabbsDataKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureGeometryAabbsDataKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureGeometryInstancesDataKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "arrayOfPointers" ] = bool( p.arrayOfPointers );
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureGeometryInstancesDataKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureGeometryInstancesDataKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureGeometryInstancesDataKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureGeometryInstancesDataKHR" );
  if( j.find( "arrayOfPointers" ) != j.end() ) {
    p.arrayOfPointers = j[ "arrayOfPointers" ];
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureGeometryInstancesDataKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureGeometryInstancesDataKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureGeometryInstancesDataKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/GeometryTypeKHR.hpp>
#include <vulkan2json/GeometryFlagsKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureGeometryKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "geometryType" ] = p.geometryType;
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureGeometryKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureGeometryKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureGeometryKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureGeometryKHR" );
  if( j.find( "geometryType" ) != j.end() ) {
    p.geometryType = GeometryTypeKHR ( j[ "geometryType" ] );
  }
  if( j.find( "flags" ) != j.end() ) {
    p.flags = GeometryFlagsKHR ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureGeometryKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureGeometryKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureGeometryKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/AccelerationStructureTypeKHR.hpp>
#include <vulkan2json/BuildAccelerationStructureFlagsKHR.hpp>
#include <vulkan2json/BuildAccelerationStructureModeKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureBuildGeometryInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "type" ] = p.type;
  j[ "flags" ] = p.flags;
  j[ "mode" ] = p.mode;
  j[ "geometryCount" ] = p.geometryCount;
  j[ "pGeometries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pGeometries ) );
  j[ "ppGeometries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.ppGeometries ) );
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureBuildGeometryInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureBuildGeometryInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureBuildGeometryInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureBuildGeometryInfoKHR" );
  if( j.find( "type" ) != j.end() ) {
    p.type = AccelerationStructureTypeKHR ( j[ "type" ] );
  }
  if( j.find( "flags" ) != j.end() ) {
    p.flags = BuildAccelerationStructureFlagsKHR ( j[ "flags" ] );
  }
  if( j.find( "mode" ) != j.end() ) {
    p.mode = BuildAccelerationStructureModeKHR ( j[ "mode" ] );
  }
  if( j.find( "geometryCount" ) != j.end() ) {
    p.geometryCount = j[ "geometryCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureBuildGeometryInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureBuildGeometryInfoKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureBuildGeometryInfoKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureBuildRangeInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "primitiveCount" ] = p.primitiveCount;
  j[ "primitiveOffset" ] = p.primitiveOffset;
  j[ "firstVertex" ] = p.firstVertex;
  j[ "transformOffset" ] = p.transformOffset;
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureBuildRangeInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureBuildRangeInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureBuildRangeInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureBuildRangeInfoKHR" );
  if( j.find( "primitiveCount" ) != j.end() ) {
    p.primitiveCount = j[ "primitiveCount" ];
  }
  if( j.find( "primitiveOffset" ) != j.end() ) {
    p.primitiveOffset = j[ "primitiveOffset" ];
  }
  if( j.find( "firstVertex" ) != j.end() ) {
    p.firstVertex = j[ "firstVertex" ];
  }
  if( j.find( "transformOffset" ) != j.end() ) {
    p.transformOffset = j[ "transformOffset" ];
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureBuildRangeInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureBuildRangeInfoKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureBuildRangeInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureBuildSizesInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "accelerationStructureSize" ] = p.accelerationStructureSize;
  j[ "updateScratchSize" ] = p.updateScratchSize;
  j[ "buildScratchSize" ] = p.buildScratchSize;
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureBuildSizesInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureBuildSizesInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureBuildSizesInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureBuildSizesInfoKHR" );
  if( j.find( "accelerationStructureSize" ) != j.end() ) {
    p.accelerationStructureSize = j[ "accelerationStructureSize" ];
  }
  if( j.find( "updateScratchSize" ) != j.end() ) {
    p.updateScratchSize = j[ "updateScratchSize" ];
  }
  if( j.find( "buildScratchSize" ) != j.end() ) {
    p.buildScratchSize = j[ "buildScratchSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureBuildSizesInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureBuildSizesInfoKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureBuildSizesInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/AccelerationStructureCreateFlagsKHR.hpp>
#include <vulkan2json/AccelerationStructureTypeKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "createFlags" ] = p.createFlags;
  j[ "offset" ] = p.offset;
  j[ "size" ] = p.size;
  j[ "type" ] = p.type;
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureCreateInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureCreateInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureCreateInfoKHR" );
  if( j.find( "createFlags" ) != j.end() ) {
    p.createFlags = AccelerationStructureCreateFlagsKHR ( j[ "createFlags" ] );
  }
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
  if( j.find( "type" ) != j.end() ) {
    p.type = AccelerationStructureTypeKHR ( j[ "type" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureCreateInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureCreateInfoKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureCreateInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Format.hpp>
#include <vulkan2json/IndexType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const GeometryTrianglesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "vertexOffset" ] = p.vertexOffset;
  j[ "vertexCount" ] = p.vertexCount;
  j[ "vertexStride" ] = p.vertexStride;
  j[ "vertexFormat" ] = p.vertexFormat;
  j[ "indexOffset" ] = p.indexOffset;
  j[ "indexCount" ] = p.indexCount;
  j[ "indexType" ] = p.indexType;
  j[ "transformOffset" ] = p.transformOffset;
}
}
void to_json( nlohmann::json &j, const VkGeometryTrianglesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: GeometryTrianglesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, GeometryTrianglesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GeometryTrianglesNV" );
  if( j.find( "vertexOffset" ) != j.end() ) {
    p.vertexOffset = j[ "vertexOffset" ];
  }
  if( j.find( "vertexCount" ) != j.end() ) {
    p.vertexCount = j[ "vertexCount" ];
  }
  if( j.find( "vertexStride" ) != j.end() ) {
    p.vertexStride = j[ "vertexStride" ];
  }
  if( j.find( "vertexFormat" ) != j.end() ) {
    p.vertexFormat = Format ( j[ "vertexFormat" ] );
  }
  if( j.find( "indexOffset" ) != j.end() ) {
    p.indexOffset = j[ "indexOffset" ];
  }
  if( j.find( "indexCount" ) != j.end() ) {
    p.indexCount = j[ "indexCount" ];
  }
  if( j.find( "indexType" ) != j.end() ) {
    p.indexType = IndexType ( j[ "indexType" ] );
  }
  if( j.find( "transformOffset" ) != j.end() ) {
    p.transformOffset = j[ "transformOffset" ];
  }
}
}
void from_json( const nlohmann::json &j, VkGeometryTrianglesNV &p ) {
  VULKAN_HPP_NAMESPACE :: GeometryTrianglesNV temp;
  from_json( j, temp );
  p = VkGeometryTrianglesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const GeometryAABBNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "numAABBs" ] = p.numAABBs;
  j[ "stride" ] = p.stride;
  j[ "offset" ] = p.offset;
}
}
void to_json( nlohmann::json &j, const VkGeometryAABBNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: GeometryAABBNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, GeometryAABBNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GeometryAABBNV" );
  if( j.find( "numAABBs" ) != j.end() ) {
    p.numAABBs = j[ "numAABBs" ];
  }
  if( j.find( "stride" ) != j.end() ) {
    p.stride = j[ "stride" ];
  }
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
}
}
void from_json( const nlohmann::json &j, VkGeometryAABBNV &p ) {
  VULKAN_HPP_NAMESPACE :: GeometryAABBNV temp;
  from_json( j, temp );
  p = VkGeometryAABBNV ( temp );
}
#include <vulkan2json/GeometryTrianglesNV.hpp>
#include <vulkan2json/GeometryAABBNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const GeometryDataNV &p ) {
  j = nlohmann::json::object();
  j[ "triangles" ] = p.triangles;
  j[ "aabbs" ] = p.aabbs;
}
}
void to_json( nlohmann::json &j, const VkGeometryDataNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: GeometryDataNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, GeometryDataNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GeometryDataNV" );
  if( j.find( "triangles" ) != j.end() ) {
    p.triangles = GeometryTrianglesNV ( j[ "triangles" ] );
  }
  if( j.find( "aabbs" ) != j.end() ) {
    p.aabbs = GeometryAABBNV ( j[ "aabbs" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkGeometryDataNV &p ) {
  VULKAN_HPP_NAMESPACE :: GeometryDataNV temp;
  from_json( j, temp );
  p = VkGeometryDataNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/GeometryTypeKHR.hpp>
#include <vulkan2json/GeometryDataNV.hpp>
#include <vulkan2json/GeometryFlagsKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const GeometryNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "geometryType" ] = p.geometryType;
  j[ "geometry" ] = p.geometry;
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkGeometryNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: GeometryNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, GeometryNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GeometryNV" );
  if( j.find( "geometryType" ) != j.end() ) {
    p.geometryType = GeometryTypeKHR ( j[ "geometryType" ] );
  }
  if( j.find( "geometry" ) != j.end() ) {
    p.geometry = GeometryDataNV ( j[ "geometry" ] );
  }
  if( j.find( "flags" ) != j.end() ) {
    p.flags = GeometryFlagsKHR ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkGeometryNV &p ) {
  VULKAN_HPP_NAMESPACE :: GeometryNV temp;
  from_json( j, temp );
  p = VkGeometryNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/AccelerationStructureTypeKHR.hpp>
#include <vulkan2json/BuildAccelerationStructureFlagsKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "type" ] = p.type;
  j[ "flags" ] = p.flags;
  j[ "instanceCount" ] = p.instanceCount;
  j[ "geometryCount" ] = p.geometryCount;
  j[ "pGeometries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pGeometries ) );
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureInfoNV" );
  if( j.find( "type" ) != j.end() ) {
    p.type = AccelerationStructureTypeNV ( j[ "type" ] );
  }
  if( j.find( "flags" ) != j.end() ) {
    p.flags = BuildAccelerationStructureFlagsNV ( j[ "flags" ] );
  }
  if( j.find( "instanceCount" ) != j.end() ) {
    p.instanceCount = j[ "instanceCount" ];
  }
  if( j.find( "geometryCount" ) != j.end() ) {
    p.geometryCount = j[ "geometryCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureInfoNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/AccelerationStructureInfoNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "compactedSize" ] = p.compactedSize;
  j[ "info" ] = p.info;
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureCreateInfoNV" );
  if( j.find( "compactedSize" ) != j.end() ) {
    p.compactedSize = j[ "compactedSize" ];
  }
  if( j.find( "info" ) != j.end() ) {
    p.info = AccelerationStructureInfoNV ( j[ "info" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureCreateInfoNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureCreateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureDeviceAddressInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureDeviceAddressInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureDeviceAddressInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureDeviceAddressInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureDeviceAddressInfoKHR" );
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureDeviceAddressInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureDeviceAddressInfoKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureDeviceAddressInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureGeometryMotionTrianglesDataNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureGeometryMotionTrianglesDataNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureGeometryMotionTrianglesDataNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureGeometryMotionTrianglesDataNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureGeometryMotionTrianglesDataNV" );
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureGeometryMotionTrianglesDataNV &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureGeometryMotionTrianglesDataNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureGeometryMotionTrianglesDataNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const TransformMatrixKHR &p ) {
  j = nlohmann::json::object();
  j[ "matrix" ] = nlohmann::json::array();
  for( auto &e: p.matrix ) {
    auto temp = nlohmann::json::array();
    std::copy( e.begin(), e.end(), std::back_inserter( temp ) );
    j[ "matrix" ].push_back( std::move( temp ) );
  }
}
}
void to_json( nlohmann::json &j, const VkTransformMatrixKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: TransformMatrixKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, TransformMatrixKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for TransformMatrixKHR" );
  if( j.find( "matrix" ) != j.end() ) {
    if( !j[ "matrix" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for TransformMatrixKHR.matrix" );
    if( !j[ "matrix" ].size() > p.matrix.size() ) throw vulkan2json::invalid_array_value( "too many values in array for TransformMatrixKHR.matrix" );
    for( std::size_t i = 0u; i != j[ "matrix" ].size(); ++i ) {
      if( !j[ "matrix" ][ i ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for TransformMatrixKHR.matrix" );
      if( !j[ "matrix" ][ i ].size() > p.matrix[ i ].size() ) throw vulkan2json::invalid_array_value( "too many values in array for TransformMatrixKHR.matrix" );
      std::fill( p.matrix[ i ].begin(), p.matrix[ i ].end(), 0 );
      std::copy( j[ "matrix" ][ i ].begin(), j[ "matrix" ][ i ].end(), p.matrix[ i ].begin() );
    }
    for( std::size_t i = j[ "matrix" ].size(); i != p.matrix.size(); ++i ) {
      std::fill( p.matrix[ i ].begin(), p.matrix[ i ].end(), 0 );
    }
  }
}
}
void from_json( const nlohmann::json &j, VkTransformMatrixKHR &p ) {
  VULKAN_HPP_NAMESPACE :: TransformMatrixKHR temp;
  from_json( j, temp );
  p = VkTransformMatrixKHR ( temp );
}
#include <vulkan2json/TransformMatrixKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureInstanceKHR &p ) {
  j = nlohmann::json::object();
  j[ "transform" ] = p.transform;
  j[ "instanceCustomIndex" ] = p.instanceCustomIndex;
  j[ "mask" ] = p.mask;
  j[ "instanceShaderBindingTableRecordOffset" ] = p.instanceShaderBindingTableRecordOffset;
  j[ "accelerationStructureReference" ] = p.accelerationStructureReference;
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureInstanceKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureInstanceKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureInstanceKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureInstanceKHR" );
  if( j.find( "transform" ) != j.end() ) {
    p.transform = TransformMatrixKHR ( j[ "transform" ] );
  }
  if( j.find( "instanceCustomIndex" ) != j.end() ) {
    p.instanceCustomIndex = j[ "instanceCustomIndex" ];
  }
  if( j.find( "mask" ) != j.end() ) {
    p.mask = j[ "mask" ];
  }
  if( j.find( "instanceShaderBindingTableRecordOffset" ) != j.end() ) {
    p.instanceShaderBindingTableRecordOffset = j[ "instanceShaderBindingTableRecordOffset" ];
  }
  if( j.find( "accelerationStructureReference" ) != j.end() ) {
    p.accelerationStructureReference = j[ "accelerationStructureReference" ];
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureInstanceKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureInstanceKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureInstanceKHR ( temp );
}
#include <vulkan2json/TransformMatrixKHR.hpp>
#include <vulkan2json/TransformMatrixKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureMatrixMotionInstanceNV &p ) {
  j = nlohmann::json::object();
  j[ "transformT0" ] = p.transformT0;
  j[ "transformT1" ] = p.transformT1;
  j[ "instanceCustomIndex" ] = p.instanceCustomIndex;
  j[ "mask" ] = p.mask;
  j[ "instanceShaderBindingTableRecordOffset" ] = p.instanceShaderBindingTableRecordOffset;
  j[ "accelerationStructureReference" ] = p.accelerationStructureReference;
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureMatrixMotionInstanceNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureMatrixMotionInstanceNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureMatrixMotionInstanceNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureMatrixMotionInstanceNV" );
  if( j.find( "transformT0" ) != j.end() ) {
    p.transformT0 = TransformMatrixKHR ( j[ "transformT0" ] );
  }
  if( j.find( "transformT1" ) != j.end() ) {
    p.transformT1 = TransformMatrixKHR ( j[ "transformT1" ] );
  }
  if( j.find( "instanceCustomIndex" ) != j.end() ) {
    p.instanceCustomIndex = j[ "instanceCustomIndex" ];
  }
  if( j.find( "mask" ) != j.end() ) {
    p.mask = j[ "mask" ];
  }
  if( j.find( "instanceShaderBindingTableRecordOffset" ) != j.end() ) {
    p.instanceShaderBindingTableRecordOffset = j[ "instanceShaderBindingTableRecordOffset" ];
  }
  if( j.find( "accelerationStructureReference" ) != j.end() ) {
    p.accelerationStructureReference = j[ "accelerationStructureReference" ];
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureMatrixMotionInstanceNV &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureMatrixMotionInstanceNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureMatrixMotionInstanceNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/AccelerationStructureMemoryRequirementsTypeNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureMemoryRequirementsInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "type" ] = p.type;
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureMemoryRequirementsInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureMemoryRequirementsInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureMemoryRequirementsInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureMemoryRequirementsInfoNV" );
  if( j.find( "type" ) != j.end() ) {
    p.type = AccelerationStructureMemoryRequirementsTypeNV ( j[ "type" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureMemoryRequirementsInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureMemoryRequirementsInfoNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureMemoryRequirementsInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/AccelerationStructureMotionInfoFlagsNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureMotionInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxInstances" ] = p.maxInstances;
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureMotionInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureMotionInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureMotionInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureMotionInfoNV" );
  if( j.find( "maxInstances" ) != j.end() ) {
    p.maxInstances = j[ "maxInstances" ];
  }
  if( j.find( "flags" ) != j.end() ) {
    p.flags = AccelerationStructureMotionInfoFlagsNV ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureMotionInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureMotionInfoNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureMotionInfoNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SRTDataNV &p ) {
  j = nlohmann::json::object();
  j[ "sx" ] = p.sx;
  j[ "a" ] = p.a;
  j[ "b" ] = p.b;
  j[ "pvx" ] = p.pvx;
  j[ "sy" ] = p.sy;
  j[ "c" ] = p.c;
  j[ "pvy" ] = p.pvy;
  j[ "sz" ] = p.sz;
  j[ "pvz" ] = p.pvz;
  j[ "qx" ] = p.qx;
  j[ "qy" ] = p.qy;
  j[ "qz" ] = p.qz;
  j[ "qw" ] = p.qw;
  j[ "tx" ] = p.tx;
  j[ "ty" ] = p.ty;
  j[ "tz" ] = p.tz;
}
}
void to_json( nlohmann::json &j, const VkSRTDataNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SRTDataNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SRTDataNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SRTDataNV" );
  if( j.find( "sx" ) != j.end() ) {
    p.sx = j[ "sx" ];
  }
  if( j.find( "a" ) != j.end() ) {
    p.a = j[ "a" ];
  }
  if( j.find( "b" ) != j.end() ) {
    p.b = j[ "b" ];
  }
  if( j.find( "pvx" ) != j.end() ) {
    p.pvx = j[ "pvx" ];
  }
  if( j.find( "sy" ) != j.end() ) {
    p.sy = j[ "sy" ];
  }
  if( j.find( "c" ) != j.end() ) {
    p.c = j[ "c" ];
  }
  if( j.find( "pvy" ) != j.end() ) {
    p.pvy = j[ "pvy" ];
  }
  if( j.find( "sz" ) != j.end() ) {
    p.sz = j[ "sz" ];
  }
  if( j.find( "pvz" ) != j.end() ) {
    p.pvz = j[ "pvz" ];
  }
  if( j.find( "qx" ) != j.end() ) {
    p.qx = j[ "qx" ];
  }
  if( j.find( "qy" ) != j.end() ) {
    p.qy = j[ "qy" ];
  }
  if( j.find( "qz" ) != j.end() ) {
    p.qz = j[ "qz" ];
  }
  if( j.find( "qw" ) != j.end() ) {
    p.qw = j[ "qw" ];
  }
  if( j.find( "tx" ) != j.end() ) {
    p.tx = j[ "tx" ];
  }
  if( j.find( "ty" ) != j.end() ) {
    p.ty = j[ "ty" ];
  }
  if( j.find( "tz" ) != j.end() ) {
    p.tz = j[ "tz" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSRTDataNV &p ) {
  VULKAN_HPP_NAMESPACE :: SRTDataNV temp;
  from_json( j, temp );
  p = VkSRTDataNV ( temp );
}
#include <vulkan2json/SRTDataNV.hpp>
#include <vulkan2json/SRTDataNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureSRTMotionInstanceNV &p ) {
  j = nlohmann::json::object();
  j[ "transformT0" ] = p.transformT0;
  j[ "transformT1" ] = p.transformT1;
  j[ "instanceCustomIndex" ] = p.instanceCustomIndex;
  j[ "mask" ] = p.mask;
  j[ "instanceShaderBindingTableRecordOffset" ] = p.instanceShaderBindingTableRecordOffset;
  j[ "accelerationStructureReference" ] = p.accelerationStructureReference;
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureSRTMotionInstanceNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureSRTMotionInstanceNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureSRTMotionInstanceNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureSRTMotionInstanceNV" );
  if( j.find( "transformT0" ) != j.end() ) {
    p.transformT0 = SRTDataNV ( j[ "transformT0" ] );
  }
  if( j.find( "transformT1" ) != j.end() ) {
    p.transformT1 = SRTDataNV ( j[ "transformT1" ] );
  }
  if( j.find( "instanceCustomIndex" ) != j.end() ) {
    p.instanceCustomIndex = j[ "instanceCustomIndex" ];
  }
  if( j.find( "mask" ) != j.end() ) {
    p.mask = j[ "mask" ];
  }
  if( j.find( "instanceShaderBindingTableRecordOffset" ) != j.end() ) {
    p.instanceShaderBindingTableRecordOffset = j[ "instanceShaderBindingTableRecordOffset" ];
  }
  if( j.find( "accelerationStructureReference" ) != j.end() ) {
    p.accelerationStructureReference = j[ "accelerationStructureReference" ];
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureSRTMotionInstanceNV &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureSRTMotionInstanceNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureSRTMotionInstanceNV ( temp );
}
#include <vulkan2json/AccelerationStructureMotionInstanceTypeNV.hpp>
#include <vulkan2json/AccelerationStructureMotionInstanceFlagsNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureMotionInstanceNV &p ) {
  j = nlohmann::json::object();
  j[ "type" ] = p.type;
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureMotionInstanceNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureMotionInstanceNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureMotionInstanceNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureMotionInstanceNV" );
  if( j.find( "type" ) != j.end() ) {
    p.type = AccelerationStructureMotionInstanceTypeNV ( j[ "type" ] );
  }
  if( j.find( "flags" ) != j.end() ) {
    p.flags = AccelerationStructureMotionInstanceFlagsNV ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureMotionInstanceNV &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureMotionInstanceNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureMotionInstanceNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AccelerationStructureVersionInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pVersionData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pVersionData ) );
}
}
void to_json( nlohmann::json &j, const VkAccelerationStructureVersionInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AccelerationStructureVersionInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AccelerationStructureVersionInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureVersionInfoKHR" );
}
}
void from_json( const nlohmann::json &j, VkAccelerationStructureVersionInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AccelerationStructureVersionInfoKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureVersionInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AcquireNextImageInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "timeout" ] = p.timeout;
  j[ "deviceMask" ] = p.deviceMask;
}
}
void to_json( nlohmann::json &j, const VkAcquireNextImageInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AcquireNextImageInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AcquireNextImageInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AcquireNextImageInfoKHR" );
  if( j.find( "timeout" ) != j.end() ) {
    p.timeout = j[ "timeout" ];
  }
  if( j.find( "deviceMask" ) != j.end() ) {
    p.deviceMask = j[ "deviceMask" ];
  }
}
}
void from_json( const nlohmann::json &j, VkAcquireNextImageInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AcquireNextImageInfoKHR temp;
  from_json( j, temp );
  p = VkAcquireNextImageInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/AcquireProfilingLockFlagsKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AcquireProfilingLockInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "timeout" ] = p.timeout;
}
}
void to_json( nlohmann::json &j, const VkAcquireProfilingLockInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AcquireProfilingLockInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AcquireProfilingLockInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AcquireProfilingLockInfoKHR" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = AcquireProfilingLockFlagsKHR ( j[ "flags" ] );
  }
  if( j.find( "timeout" ) != j.end() ) {
    p.timeout = j[ "timeout" ];
  }
}
}
void from_json( const nlohmann::json &j, VkAcquireProfilingLockInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: AcquireProfilingLockInfoKHR temp;
  from_json( j, temp );
  p = VkAcquireProfilingLockInfoKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AllocationCallbacks &p ) {
  j = nlohmann::json::object();
  j[ "pUserData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pUserData ) );
  j[ "pfnAllocation" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnAllocation ) );
  j[ "pfnReallocation" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnReallocation ) );
  j[ "pfnFree" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnFree ) );
  j[ "pfnInternalAllocation" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnInternalAllocation ) );
  j[ "pfnInternalFree" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnInternalFree ) );
}
}
void to_json( nlohmann::json &j, const VkAllocationCallbacks &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AllocationCallbacks ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AllocationCallbacks &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AllocationCallbacks" );
}
}
void from_json( const nlohmann::json &j, VkAllocationCallbacks &p ) {
  VULKAN_HPP_NAMESPACE :: AllocationCallbacks temp;
  from_json( j, temp );
  p = VkAllocationCallbacks ( temp );
}
#include <vulkan2json/ComponentSwizzle.hpp>
#include <vulkan2json/ComponentSwizzle.hpp>
#include <vulkan2json/ComponentSwizzle.hpp>
#include <vulkan2json/ComponentSwizzle.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ComponentMapping &p ) {
  j = nlohmann::json::object();
  j[ "r" ] = p.r;
  j[ "g" ] = p.g;
  j[ "b" ] = p.b;
  j[ "a" ] = p.a;
}
}
void to_json( nlohmann::json &j, const VkComponentMapping &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ComponentMapping ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ComponentMapping &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ComponentMapping" );
  if( j.find( "r" ) != j.end() ) {
    p.r = ComponentSwizzle ( j[ "r" ] );
  }
  if( j.find( "g" ) != j.end() ) {
    p.g = ComponentSwizzle ( j[ "g" ] );
  }
  if( j.find( "b" ) != j.end() ) {
    p.b = ComponentSwizzle ( j[ "b" ] );
  }
  if( j.find( "a" ) != j.end() ) {
    p.a = ComponentSwizzle ( j[ "a" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkComponentMapping &p ) {
  VULKAN_HPP_NAMESPACE :: ComponentMapping temp;
  from_json( j, temp );
  p = VkComponentMapping ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ApplicationInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  if( p.pApplicationName ) j[ "pApplicationName" ] = std::string( p.pApplicationName );
  j[ "applicationVersion" ] = p.applicationVersion;
  if( p.pEngineName ) j[ "pEngineName" ] = std::string( p.pEngineName );
  j[ "engineVersion" ] = p.engineVersion;
  j[ "apiVersion" ] = p.apiVersion;
}
}
void to_json( nlohmann::json &j, const VkApplicationInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ApplicationInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ApplicationInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ApplicationInfo" );
  if( j.find( "applicationVersion" ) != j.end() ) {
    p.applicationVersion = j[ "applicationVersion" ];
  }
  if( j.find( "engineVersion" ) != j.end() ) {
    p.engineVersion = j[ "engineVersion" ];
  }
  if( j.find( "apiVersion" ) != j.end() ) {
    p.apiVersion = j[ "apiVersion" ];
  }
}
}
void from_json( const nlohmann::json &j, VkApplicationInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ApplicationInfo temp;
  from_json( j, temp );
  p = VkApplicationInfo ( temp );
}
#include <vulkan2json/AttachmentDescriptionFlags.hpp>
#include <vulkan2json/Format.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/AttachmentLoadOp.hpp>
#include <vulkan2json/AttachmentStoreOp.hpp>
#include <vulkan2json/AttachmentLoadOp.hpp>
#include <vulkan2json/AttachmentStoreOp.hpp>
#include <vulkan2json/ImageLayout.hpp>
#include <vulkan2json/ImageLayout.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AttachmentDescription &p ) {
  j = nlohmann::json::object();
  j[ "flags" ] = p.flags;
  j[ "format" ] = p.format;
  j[ "samples" ] = p.samples;
  j[ "loadOp" ] = p.loadOp;
  j[ "storeOp" ] = p.storeOp;
  j[ "stencilLoadOp" ] = p.stencilLoadOp;
  j[ "stencilStoreOp" ] = p.stencilStoreOp;
  j[ "initialLayout" ] = p.initialLayout;
  j[ "finalLayout" ] = p.finalLayout;
}
}
void to_json( nlohmann::json &j, const VkAttachmentDescription &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AttachmentDescription ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AttachmentDescription &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AttachmentDescription" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = AttachmentDescriptionFlags ( j[ "flags" ] );
  }
  if( j.find( "format" ) != j.end() ) {
    p.format = Format ( j[ "format" ] );
  }
  if( j.find( "samples" ) != j.end() ) {
    p.samples = SampleCountFlagBits ( j[ "samples" ] );
  }
  if( j.find( "loadOp" ) != j.end() ) {
    p.loadOp = AttachmentLoadOp ( j[ "loadOp" ] );
  }
  if( j.find( "storeOp" ) != j.end() ) {
    p.storeOp = AttachmentStoreOp ( j[ "storeOp" ] );
  }
  if( j.find( "stencilLoadOp" ) != j.end() ) {
    p.stencilLoadOp = AttachmentLoadOp ( j[ "stencilLoadOp" ] );
  }
  if( j.find( "stencilStoreOp" ) != j.end() ) {
    p.stencilStoreOp = AttachmentStoreOp ( j[ "stencilStoreOp" ] );
  }
  if( j.find( "initialLayout" ) != j.end() ) {
    p.initialLayout = ImageLayout ( j[ "initialLayout" ] );
  }
  if( j.find( "finalLayout" ) != j.end() ) {
    p.finalLayout = ImageLayout ( j[ "finalLayout" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkAttachmentDescription &p ) {
  VULKAN_HPP_NAMESPACE :: AttachmentDescription temp;
  from_json( j, temp );
  p = VkAttachmentDescription ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/AttachmentDescriptionFlags.hpp>
#include <vulkan2json/Format.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/AttachmentLoadOp.hpp>
#include <vulkan2json/AttachmentStoreOp.hpp>
#include <vulkan2json/AttachmentLoadOp.hpp>
#include <vulkan2json/AttachmentStoreOp.hpp>
#include <vulkan2json/ImageLayout.hpp>
#include <vulkan2json/ImageLayout.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AttachmentDescription2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "format" ] = p.format;
  j[ "samples" ] = p.samples;
  j[ "loadOp" ] = p.loadOp;
  j[ "storeOp" ] = p.storeOp;
  j[ "stencilLoadOp" ] = p.stencilLoadOp;
  j[ "stencilStoreOp" ] = p.stencilStoreOp;
  j[ "initialLayout" ] = p.initialLayout;
  j[ "finalLayout" ] = p.finalLayout;
}
}
void to_json( nlohmann::json &j, const VkAttachmentDescription2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AttachmentDescription2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AttachmentDescription2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AttachmentDescription2" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = AttachmentDescriptionFlags ( j[ "flags" ] );
  }
  if( j.find( "format" ) != j.end() ) {
    p.format = Format ( j[ "format" ] );
  }
  if( j.find( "samples" ) != j.end() ) {
    p.samples = SampleCountFlagBits ( j[ "samples" ] );
  }
  if( j.find( "loadOp" ) != j.end() ) {
    p.loadOp = AttachmentLoadOp ( j[ "loadOp" ] );
  }
  if( j.find( "storeOp" ) != j.end() ) {
    p.storeOp = AttachmentStoreOp ( j[ "storeOp" ] );
  }
  if( j.find( "stencilLoadOp" ) != j.end() ) {
    p.stencilLoadOp = AttachmentLoadOp ( j[ "stencilLoadOp" ] );
  }
  if( j.find( "stencilStoreOp" ) != j.end() ) {
    p.stencilStoreOp = AttachmentStoreOp ( j[ "stencilStoreOp" ] );
  }
  if( j.find( "initialLayout" ) != j.end() ) {
    p.initialLayout = ImageLayout ( j[ "initialLayout" ] );
  }
  if( j.find( "finalLayout" ) != j.end() ) {
    p.finalLayout = ImageLayout ( j[ "finalLayout" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkAttachmentDescription2 &p ) {
  VULKAN_HPP_NAMESPACE :: AttachmentDescription2 temp;
  from_json( j, temp );
  p = VkAttachmentDescription2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageLayout.hpp>
#include <vulkan2json/ImageLayout.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AttachmentDescriptionStencilLayout &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stencilInitialLayout" ] = p.stencilInitialLayout;
  j[ "stencilFinalLayout" ] = p.stencilFinalLayout;
}
}
void to_json( nlohmann::json &j, const VkAttachmentDescriptionStencilLayout &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AttachmentDescriptionStencilLayout ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AttachmentDescriptionStencilLayout &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AttachmentDescriptionStencilLayout" );
  if( j.find( "stencilInitialLayout" ) != j.end() ) {
    p.stencilInitialLayout = ImageLayout ( j[ "stencilInitialLayout" ] );
  }
  if( j.find( "stencilFinalLayout" ) != j.end() ) {
    p.stencilFinalLayout = ImageLayout ( j[ "stencilFinalLayout" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkAttachmentDescriptionStencilLayout &p ) {
  VULKAN_HPP_NAMESPACE :: AttachmentDescriptionStencilLayout temp;
  from_json( j, temp );
  p = VkAttachmentDescriptionStencilLayout ( temp );
}
#include <vulkan2json/ImageLayout.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AttachmentReference &p ) {
  j = nlohmann::json::object();
  j[ "attachment" ] = p.attachment;
  j[ "layout" ] = p.layout;
}
}
void to_json( nlohmann::json &j, const VkAttachmentReference &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AttachmentReference ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AttachmentReference &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AttachmentReference" );
  if( j.find( "attachment" ) != j.end() ) {
    p.attachment = j[ "attachment" ];
  }
  if( j.find( "layout" ) != j.end() ) {
    p.layout = ImageLayout ( j[ "layout" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkAttachmentReference &p ) {
  VULKAN_HPP_NAMESPACE :: AttachmentReference temp;
  from_json( j, temp );
  p = VkAttachmentReference ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageLayout.hpp>
#include <vulkan2json/ImageAspectFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AttachmentReference2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "attachment" ] = p.attachment;
  j[ "layout" ] = p.layout;
  j[ "aspectMask" ] = p.aspectMask;
}
}
void to_json( nlohmann::json &j, const VkAttachmentReference2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AttachmentReference2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AttachmentReference2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AttachmentReference2" );
  if( j.find( "attachment" ) != j.end() ) {
    p.attachment = j[ "attachment" ];
  }
  if( j.find( "layout" ) != j.end() ) {
    p.layout = ImageLayout ( j[ "layout" ] );
  }
  if( j.find( "aspectMask" ) != j.end() ) {
    p.aspectMask = ImageAspectFlags ( j[ "aspectMask" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkAttachmentReference2 &p ) {
  VULKAN_HPP_NAMESPACE :: AttachmentReference2 temp;
  from_json( j, temp );
  p = VkAttachmentReference2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageLayout.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AttachmentReferenceStencilLayout &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stencilLayout" ] = p.stencilLayout;
}
}
void to_json( nlohmann::json &j, const VkAttachmentReferenceStencilLayout &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AttachmentReferenceStencilLayout ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AttachmentReferenceStencilLayout &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AttachmentReferenceStencilLayout" );
  if( j.find( "stencilLayout" ) != j.end() ) {
    p.stencilLayout = ImageLayout ( j[ "stencilLayout" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkAttachmentReferenceStencilLayout &p ) {
  VULKAN_HPP_NAMESPACE :: AttachmentReferenceStencilLayout temp;
  from_json( j, temp );
  p = VkAttachmentReferenceStencilLayout ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const Extent2D &p ) {
  j = nlohmann::json::object();
  j[ "width" ] = p.width;
  j[ "height" ] = p.height;
}
}
void to_json( nlohmann::json &j, const VkExtent2D &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: Extent2D ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, Extent2D &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Extent2D" );
  if( j.find( "width" ) != j.end() ) {
    p.width = j[ "width" ];
  }
  if( j.find( "height" ) != j.end() ) {
    p.height = j[ "height" ];
  }
}
}
void from_json( const nlohmann::json &j, VkExtent2D &p ) {
  VULKAN_HPP_NAMESPACE :: Extent2D temp;
  from_json( j, temp );
  p = VkExtent2D ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SampleLocationEXT &p ) {
  j = nlohmann::json::object();
  j[ "x" ] = p.x;
  j[ "y" ] = p.y;
}
}
void to_json( nlohmann::json &j, const VkSampleLocationEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SampleLocationEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SampleLocationEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SampleLocationEXT" );
  if( j.find( "x" ) != j.end() ) {
    p.x = j[ "x" ];
  }
  if( j.find( "y" ) != j.end() ) {
    p.y = j[ "y" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSampleLocationEXT &p ) {
  VULKAN_HPP_NAMESPACE :: SampleLocationEXT temp;
  from_json( j, temp );
  p = VkSampleLocationEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/Extent2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SampleLocationsInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "sampleLocationsPerPixel" ] = p.sampleLocationsPerPixel;
  j[ "sampleLocationGridSize" ] = p.sampleLocationGridSize;
  j[ "sampleLocationsCount" ] = p.sampleLocationsCount;
  j[ "pSampleLocations" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSampleLocations ) );
}
}
void to_json( nlohmann::json &j, const VkSampleLocationsInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SampleLocationsInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SampleLocationsInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SampleLocationsInfoEXT" );
  if( j.find( "sampleLocationsPerPixel" ) != j.end() ) {
    p.sampleLocationsPerPixel = SampleCountFlagBits ( j[ "sampleLocationsPerPixel" ] );
  }
  if( j.find( "sampleLocationGridSize" ) != j.end() ) {
    p.sampleLocationGridSize = Extent2D ( j[ "sampleLocationGridSize" ] );
  }
  if( j.find( "sampleLocationsCount" ) != j.end() ) {
    p.sampleLocationsCount = j[ "sampleLocationsCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSampleLocationsInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: SampleLocationsInfoEXT temp;
  from_json( j, temp );
  p = VkSampleLocationsInfoEXT ( temp );
}
#include <vulkan2json/SampleLocationsInfoEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const AttachmentSampleLocationsEXT &p ) {
  j = nlohmann::json::object();
  j[ "attachmentIndex" ] = p.attachmentIndex;
  j[ "sampleLocationsInfo" ] = p.sampleLocationsInfo;
}
}
void to_json( nlohmann::json &j, const VkAttachmentSampleLocationsEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: AttachmentSampleLocationsEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, AttachmentSampleLocationsEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AttachmentSampleLocationsEXT" );
  if( j.find( "attachmentIndex" ) != j.end() ) {
    p.attachmentIndex = j[ "attachmentIndex" ];
  }
  if( j.find( "sampleLocationsInfo" ) != j.end() ) {
    p.sampleLocationsInfo = SampleLocationsInfoEXT ( j[ "sampleLocationsInfo" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkAttachmentSampleLocationsEXT &p ) {
  VULKAN_HPP_NAMESPACE :: AttachmentSampleLocationsEXT temp;
  from_json( j, temp );
  p = VkAttachmentSampleLocationsEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BaseInStructure &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkBaseInStructure &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BaseInStructure ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BaseInStructure &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BaseInStructure" );
}
}
void from_json( const nlohmann::json &j, VkBaseInStructure &p ) {
  VULKAN_HPP_NAMESPACE :: BaseInStructure temp;
  from_json( j, temp );
  p = VkBaseInStructure ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BaseOutStructure &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkBaseOutStructure &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BaseOutStructure ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BaseOutStructure &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BaseOutStructure" );
}
}
void from_json( const nlohmann::json &j, VkBaseOutStructure &p ) {
  VULKAN_HPP_NAMESPACE :: BaseOutStructure temp;
  from_json( j, temp );
  p = VkBaseOutStructure ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BindAccelerationStructureMemoryInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryOffset" ] = p.memoryOffset;
  j[ "deviceIndexCount" ] = p.deviceIndexCount;
  j[ "pDeviceIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDeviceIndices ) );
}
}
void to_json( nlohmann::json &j, const VkBindAccelerationStructureMemoryInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BindAccelerationStructureMemoryInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BindAccelerationStructureMemoryInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindAccelerationStructureMemoryInfoNV" );
  if( j.find( "memoryOffset" ) != j.end() ) {
    p.memoryOffset = j[ "memoryOffset" ];
  }
  if( j.find( "deviceIndexCount" ) != j.end() ) {
    p.deviceIndexCount = j[ "deviceIndexCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBindAccelerationStructureMemoryInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: BindAccelerationStructureMemoryInfoNV temp;
  from_json( j, temp );
  p = VkBindAccelerationStructureMemoryInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BindBufferMemoryDeviceGroupInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceIndexCount" ] = p.deviceIndexCount;
  j[ "pDeviceIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDeviceIndices ) );
}
}
void to_json( nlohmann::json &j, const VkBindBufferMemoryDeviceGroupInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BindBufferMemoryDeviceGroupInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BindBufferMemoryDeviceGroupInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindBufferMemoryDeviceGroupInfo" );
  if( j.find( "deviceIndexCount" ) != j.end() ) {
    p.deviceIndexCount = j[ "deviceIndexCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBindBufferMemoryDeviceGroupInfo &p ) {
  VULKAN_HPP_NAMESPACE :: BindBufferMemoryDeviceGroupInfo temp;
  from_json( j, temp );
  p = VkBindBufferMemoryDeviceGroupInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BindBufferMemoryInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryOffset" ] = p.memoryOffset;
}
}
void to_json( nlohmann::json &j, const VkBindBufferMemoryInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BindBufferMemoryInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BindBufferMemoryInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindBufferMemoryInfo" );
  if( j.find( "memoryOffset" ) != j.end() ) {
    p.memoryOffset = j[ "memoryOffset" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBindBufferMemoryInfo &p ) {
  VULKAN_HPP_NAMESPACE :: BindBufferMemoryInfo temp;
  from_json( j, temp );
  p = VkBindBufferMemoryInfo ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const Offset2D &p ) {
  j = nlohmann::json::object();
  j[ "x" ] = p.x;
  j[ "y" ] = p.y;
}
}
void to_json( nlohmann::json &j, const VkOffset2D &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: Offset2D ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, Offset2D &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Offset2D" );
  if( j.find( "x" ) != j.end() ) {
    p.x = j[ "x" ];
  }
  if( j.find( "y" ) != j.end() ) {
    p.y = j[ "y" ];
  }
}
}
void from_json( const nlohmann::json &j, VkOffset2D &p ) {
  VULKAN_HPP_NAMESPACE :: Offset2D temp;
  from_json( j, temp );
  p = VkOffset2D ( temp );
}
#include <vulkan2json/Offset2D.hpp>
#include <vulkan2json/Extent2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const Rect2D &p ) {
  j = nlohmann::json::object();
  j[ "offset" ] = p.offset;
  j[ "extent" ] = p.extent;
}
}
void to_json( nlohmann::json &j, const VkRect2D &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: Rect2D ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, Rect2D &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Rect2D" );
  if( j.find( "offset" ) != j.end() ) {
    p.offset = Offset2D ( j[ "offset" ] );
  }
  if( j.find( "extent" ) != j.end() ) {
    p.extent = Extent2D ( j[ "extent" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkRect2D &p ) {
  VULKAN_HPP_NAMESPACE :: Rect2D temp;
  from_json( j, temp );
  p = VkRect2D ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BindImageMemoryDeviceGroupInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceIndexCount" ] = p.deviceIndexCount;
  j[ "pDeviceIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDeviceIndices ) );
  j[ "splitInstanceBindRegionCount" ] = p.splitInstanceBindRegionCount;
  j[ "pSplitInstanceBindRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSplitInstanceBindRegions ) );
}
}
void to_json( nlohmann::json &j, const VkBindImageMemoryDeviceGroupInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BindImageMemoryDeviceGroupInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BindImageMemoryDeviceGroupInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindImageMemoryDeviceGroupInfo" );
  if( j.find( "deviceIndexCount" ) != j.end() ) {
    p.deviceIndexCount = j[ "deviceIndexCount" ];
  }
  if( j.find( "splitInstanceBindRegionCount" ) != j.end() ) {
    p.splitInstanceBindRegionCount = j[ "splitInstanceBindRegionCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBindImageMemoryDeviceGroupInfo &p ) {
  VULKAN_HPP_NAMESPACE :: BindImageMemoryDeviceGroupInfo temp;
  from_json( j, temp );
  p = VkBindImageMemoryDeviceGroupInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BindImageMemoryInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryOffset" ] = p.memoryOffset;
}
}
void to_json( nlohmann::json &j, const VkBindImageMemoryInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BindImageMemoryInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BindImageMemoryInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindImageMemoryInfo" );
  if( j.find( "memoryOffset" ) != j.end() ) {
    p.memoryOffset = j[ "memoryOffset" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBindImageMemoryInfo &p ) {
  VULKAN_HPP_NAMESPACE :: BindImageMemoryInfo temp;
  from_json( j, temp );
  p = VkBindImageMemoryInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BindImageMemorySwapchainInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "imageIndex" ] = p.imageIndex;
}
}
void to_json( nlohmann::json &j, const VkBindImageMemorySwapchainInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BindImageMemorySwapchainInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BindImageMemorySwapchainInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindImageMemorySwapchainInfoKHR" );
  if( j.find( "imageIndex" ) != j.end() ) {
    p.imageIndex = j[ "imageIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBindImageMemorySwapchainInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: BindImageMemorySwapchainInfoKHR temp;
  from_json( j, temp );
  p = VkBindImageMemorySwapchainInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageAspectFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BindImagePlaneMemoryInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "planeAspect" ] = p.planeAspect;
}
}
void to_json( nlohmann::json &j, const VkBindImagePlaneMemoryInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BindImagePlaneMemoryInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BindImagePlaneMemoryInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindImagePlaneMemoryInfo" );
  if( j.find( "planeAspect" ) != j.end() ) {
    p.planeAspect = ImageAspectFlagBits ( j[ "planeAspect" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkBindImagePlaneMemoryInfo &p ) {
  VULKAN_HPP_NAMESPACE :: BindImagePlaneMemoryInfo temp;
  from_json( j, temp );
  p = VkBindImagePlaneMemoryInfo ( temp );
}
#include <vulkan2json/IndexType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BindIndexBufferIndirectCommandNV &p ) {
  j = nlohmann::json::object();
  j[ "size" ] = p.size;
  j[ "indexType" ] = p.indexType;
}
}
void to_json( nlohmann::json &j, const VkBindIndexBufferIndirectCommandNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BindIndexBufferIndirectCommandNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BindIndexBufferIndirectCommandNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindIndexBufferIndirectCommandNV" );
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
  if( j.find( "indexType" ) != j.end() ) {
    p.indexType = IndexType ( j[ "indexType" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkBindIndexBufferIndirectCommandNV &p ) {
  VULKAN_HPP_NAMESPACE :: BindIndexBufferIndirectCommandNV temp;
  from_json( j, temp );
  p = VkBindIndexBufferIndirectCommandNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BindShaderGroupIndirectCommandNV &p ) {
  j = nlohmann::json::object();
  j[ "groupIndex" ] = p.groupIndex;
}
}
void to_json( nlohmann::json &j, const VkBindShaderGroupIndirectCommandNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BindShaderGroupIndirectCommandNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BindShaderGroupIndirectCommandNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindShaderGroupIndirectCommandNV" );
  if( j.find( "groupIndex" ) != j.end() ) {
    p.groupIndex = j[ "groupIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBindShaderGroupIndirectCommandNV &p ) {
  VULKAN_HPP_NAMESPACE :: BindShaderGroupIndirectCommandNV temp;
  from_json( j, temp );
  p = VkBindShaderGroupIndirectCommandNV ( temp );
}
#include <vulkan2json/SparseMemoryBindFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SparseMemoryBind &p ) {
  j = nlohmann::json::object();
  j[ "resourceOffset" ] = p.resourceOffset;
  j[ "size" ] = p.size;
  j[ "memoryOffset" ] = p.memoryOffset;
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkSparseMemoryBind &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SparseMemoryBind ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SparseMemoryBind &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseMemoryBind" );
  if( j.find( "resourceOffset" ) != j.end() ) {
    p.resourceOffset = j[ "resourceOffset" ];
  }
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
  if( j.find( "memoryOffset" ) != j.end() ) {
    p.memoryOffset = j[ "memoryOffset" ];
  }
  if( j.find( "flags" ) != j.end() ) {
    p.flags = SparseMemoryBindFlags ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSparseMemoryBind &p ) {
  VULKAN_HPP_NAMESPACE :: SparseMemoryBind temp;
  from_json( j, temp );
  p = VkSparseMemoryBind ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SparseBufferMemoryBindInfo &p ) {
  j = nlohmann::json::object();
  j[ "bindCount" ] = p.bindCount;
  j[ "pBinds" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBinds ) );
}
}
void to_json( nlohmann::json &j, const VkSparseBufferMemoryBindInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SparseBufferMemoryBindInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SparseBufferMemoryBindInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseBufferMemoryBindInfo" );
  if( j.find( "bindCount" ) != j.end() ) {
    p.bindCount = j[ "bindCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSparseBufferMemoryBindInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SparseBufferMemoryBindInfo temp;
  from_json( j, temp );
  p = VkSparseBufferMemoryBindInfo ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SparseImageOpaqueMemoryBindInfo &p ) {
  j = nlohmann::json::object();
  j[ "bindCount" ] = p.bindCount;
  j[ "pBinds" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBinds ) );
}
}
void to_json( nlohmann::json &j, const VkSparseImageOpaqueMemoryBindInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SparseImageOpaqueMemoryBindInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SparseImageOpaqueMemoryBindInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseImageOpaqueMemoryBindInfo" );
  if( j.find( "bindCount" ) != j.end() ) {
    p.bindCount = j[ "bindCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSparseImageOpaqueMemoryBindInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SparseImageOpaqueMemoryBindInfo temp;
  from_json( j, temp );
  p = VkSparseImageOpaqueMemoryBindInfo ( temp );
}
#include <vulkan2json/ImageAspectFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageSubresource &p ) {
  j = nlohmann::json::object();
  j[ "aspectMask" ] = p.aspectMask;
  j[ "mipLevel" ] = p.mipLevel;
  j[ "arrayLayer" ] = p.arrayLayer;
}
}
void to_json( nlohmann::json &j, const VkImageSubresource &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageSubresource ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageSubresource &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageSubresource" );
  if( j.find( "aspectMask" ) != j.end() ) {
    p.aspectMask = ImageAspectFlags ( j[ "aspectMask" ] );
  }
  if( j.find( "mipLevel" ) != j.end() ) {
    p.mipLevel = j[ "mipLevel" ];
  }
  if( j.find( "arrayLayer" ) != j.end() ) {
    p.arrayLayer = j[ "arrayLayer" ];
  }
}
}
void from_json( const nlohmann::json &j, VkImageSubresource &p ) {
  VULKAN_HPP_NAMESPACE :: ImageSubresource temp;
  from_json( j, temp );
  p = VkImageSubresource ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const Offset3D &p ) {
  j = nlohmann::json::object();
  j[ "x" ] = p.x;
  j[ "y" ] = p.y;
  j[ "z" ] = p.z;
}
}
void to_json( nlohmann::json &j, const VkOffset3D &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: Offset3D ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, Offset3D &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Offset3D" );
  if( j.find( "x" ) != j.end() ) {
    p.x = j[ "x" ];
  }
  if( j.find( "y" ) != j.end() ) {
    p.y = j[ "y" ];
  }
  if( j.find( "z" ) != j.end() ) {
    p.z = j[ "z" ];
  }
}
}
void from_json( const nlohmann::json &j, VkOffset3D &p ) {
  VULKAN_HPP_NAMESPACE :: Offset3D temp;
  from_json( j, temp );
  p = VkOffset3D ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const Extent3D &p ) {
  j = nlohmann::json::object();
  j[ "width" ] = p.width;
  j[ "height" ] = p.height;
  j[ "depth" ] = p.depth;
}
}
void to_json( nlohmann::json &j, const VkExtent3D &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: Extent3D ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, Extent3D &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Extent3D" );
  if( j.find( "width" ) != j.end() ) {
    p.width = j[ "width" ];
  }
  if( j.find( "height" ) != j.end() ) {
    p.height = j[ "height" ];
  }
  if( j.find( "depth" ) != j.end() ) {
    p.depth = j[ "depth" ];
  }
}
}
void from_json( const nlohmann::json &j, VkExtent3D &p ) {
  VULKAN_HPP_NAMESPACE :: Extent3D temp;
  from_json( j, temp );
  p = VkExtent3D ( temp );
}
#include <vulkan2json/ImageSubresource.hpp>
#include <vulkan2json/Offset3D.hpp>
#include <vulkan2json/Extent3D.hpp>
#include <vulkan2json/SparseMemoryBindFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SparseImageMemoryBind &p ) {
  j = nlohmann::json::object();
  j[ "subresource" ] = p.subresource;
  j[ "offset" ] = p.offset;
  j[ "extent" ] = p.extent;
  j[ "memoryOffset" ] = p.memoryOffset;
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkSparseImageMemoryBind &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SparseImageMemoryBind ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SparseImageMemoryBind &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseImageMemoryBind" );
  if( j.find( "subresource" ) != j.end() ) {
    p.subresource = ImageSubresource ( j[ "subresource" ] );
  }
  if( j.find( "offset" ) != j.end() ) {
    p.offset = Offset3D ( j[ "offset" ] );
  }
  if( j.find( "extent" ) != j.end() ) {
    p.extent = Extent3D ( j[ "extent" ] );
  }
  if( j.find( "memoryOffset" ) != j.end() ) {
    p.memoryOffset = j[ "memoryOffset" ];
  }
  if( j.find( "flags" ) != j.end() ) {
    p.flags = SparseMemoryBindFlags ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSparseImageMemoryBind &p ) {
  VULKAN_HPP_NAMESPACE :: SparseImageMemoryBind temp;
  from_json( j, temp );
  p = VkSparseImageMemoryBind ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SparseImageMemoryBindInfo &p ) {
  j = nlohmann::json::object();
  j[ "bindCount" ] = p.bindCount;
  j[ "pBinds" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBinds ) );
}
}
void to_json( nlohmann::json &j, const VkSparseImageMemoryBindInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SparseImageMemoryBindInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SparseImageMemoryBindInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseImageMemoryBindInfo" );
  if( j.find( "bindCount" ) != j.end() ) {
    p.bindCount = j[ "bindCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSparseImageMemoryBindInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SparseImageMemoryBindInfo temp;
  from_json( j, temp );
  p = VkSparseImageMemoryBindInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BindSparseInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "waitSemaphoreCount" ] = p.waitSemaphoreCount;
  j[ "pWaitSemaphores" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitSemaphores ) );
  j[ "bufferBindCount" ] = p.bufferBindCount;
  j[ "pBufferBinds" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBufferBinds ) );
  j[ "imageOpaqueBindCount" ] = p.imageOpaqueBindCount;
  j[ "pImageOpaqueBinds" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pImageOpaqueBinds ) );
  j[ "imageBindCount" ] = p.imageBindCount;
  j[ "pImageBinds" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pImageBinds ) );
  j[ "signalSemaphoreCount" ] = p.signalSemaphoreCount;
  j[ "pSignalSemaphores" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSignalSemaphores ) );
}
}
void to_json( nlohmann::json &j, const VkBindSparseInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BindSparseInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BindSparseInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindSparseInfo" );
  if( j.find( "waitSemaphoreCount" ) != j.end() ) {
    p.waitSemaphoreCount = j[ "waitSemaphoreCount" ];
  }
  if( j.find( "bufferBindCount" ) != j.end() ) {
    p.bufferBindCount = j[ "bufferBindCount" ];
  }
  if( j.find( "imageOpaqueBindCount" ) != j.end() ) {
    p.imageOpaqueBindCount = j[ "imageOpaqueBindCount" ];
  }
  if( j.find( "imageBindCount" ) != j.end() ) {
    p.imageBindCount = j[ "imageBindCount" ];
  }
  if( j.find( "signalSemaphoreCount" ) != j.end() ) {
    p.signalSemaphoreCount = j[ "signalSemaphoreCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBindSparseInfo &p ) {
  VULKAN_HPP_NAMESPACE :: BindSparseInfo temp;
  from_json( j, temp );
  p = VkBindSparseInfo ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BindVertexBufferIndirectCommandNV &p ) {
  j = nlohmann::json::object();
  j[ "size" ] = p.size;
  j[ "stride" ] = p.stride;
}
}
void to_json( nlohmann::json &j, const VkBindVertexBufferIndirectCommandNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BindVertexBufferIndirectCommandNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BindVertexBufferIndirectCommandNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindVertexBufferIndirectCommandNV" );
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
  if( j.find( "stride" ) != j.end() ) {
    p.stride = j[ "stride" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBindVertexBufferIndirectCommandNV &p ) {
  VULKAN_HPP_NAMESPACE :: BindVertexBufferIndirectCommandNV temp;
  from_json( j, temp );
  p = VkBindVertexBufferIndirectCommandNV ( temp );
}
#include <vulkan2json/ImageAspectFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageSubresourceLayers &p ) {
  j = nlohmann::json::object();
  j[ "aspectMask" ] = p.aspectMask;
  j[ "mipLevel" ] = p.mipLevel;
  j[ "baseArrayLayer" ] = p.baseArrayLayer;
  j[ "layerCount" ] = p.layerCount;
}
}
void to_json( nlohmann::json &j, const VkImageSubresourceLayers &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageSubresourceLayers ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageSubresourceLayers &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageSubresourceLayers" );
  if( j.find( "aspectMask" ) != j.end() ) {
    p.aspectMask = ImageAspectFlags ( j[ "aspectMask" ] );
  }
  if( j.find( "mipLevel" ) != j.end() ) {
    p.mipLevel = j[ "mipLevel" ];
  }
  if( j.find( "baseArrayLayer" ) != j.end() ) {
    p.baseArrayLayer = j[ "baseArrayLayer" ];
  }
  if( j.find( "layerCount" ) != j.end() ) {
    p.layerCount = j[ "layerCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkImageSubresourceLayers &p ) {
  VULKAN_HPP_NAMESPACE :: ImageSubresourceLayers temp;
  from_json( j, temp );
  p = VkImageSubresourceLayers ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageSubresourceLayers.hpp>
#include <vulkan2json/Offset3D.hpp>
#include <vulkan2json/ImageSubresourceLayers.hpp>
#include <vulkan2json/Offset3D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageBlit2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcSubresource" ] = p.srcSubresource;
  j[ "srcOffsets" ] = nlohmann::json::array();
  std::copy( p.srcOffsets.begin(), p.srcOffsets.end(), std::back_inserter( j[ "srcOffsets" ] ) );
  j[ "dstSubresource" ] = p.dstSubresource;
  j[ "dstOffsets" ] = nlohmann::json::array();
  std::copy( p.dstOffsets.begin(), p.dstOffsets.end(), std::back_inserter( j[ "dstOffsets" ] ) );
}
}
void to_json( nlohmann::json &j, const VkImageBlit2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageBlit2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageBlit2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageBlit2KHR" );
  if( j.find( "srcSubresource" ) != j.end() ) {
    p.srcSubresource = ImageSubresourceLayers ( j[ "srcSubresource" ] );
  }
  if( j.find( "srcOffsets" ) != j.end() ) {
    if( !j[ "srcOffsets" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for ImageBlit2KHR.srcOffsets" );
    if( !j[ "srcOffsets" ].size() > p.srcOffsets.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for ImageBlit2KHR.srcOffsets" );
    std::fill( p.srcOffsets.begin(), p.srcOffsets.end(), Offset3D () );
    std::transform( j[ "srcOffsets" ].begin(), j[ "srcOffsets" ].end(), p.srcOffsets.begin(), []( const auto &v ) { return Offset3D ( v ); } );
  }
  if( j.find( "dstSubresource" ) != j.end() ) {
    p.dstSubresource = ImageSubresourceLayers ( j[ "dstSubresource" ] );
  }
  if( j.find( "dstOffsets" ) != j.end() ) {
    if( !j[ "dstOffsets" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for ImageBlit2KHR.dstOffsets" );
    if( !j[ "dstOffsets" ].size() > p.dstOffsets.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for ImageBlit2KHR.dstOffsets" );
    std::fill( p.dstOffsets.begin(), p.dstOffsets.end(), Offset3D () );
    std::transform( j[ "dstOffsets" ].begin(), j[ "dstOffsets" ].end(), p.dstOffsets.begin(), []( const auto &v ) { return Offset3D ( v ); } );
  }
}
}
void from_json( const nlohmann::json &j, VkImageBlit2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: ImageBlit2KHR temp;
  from_json( j, temp );
  p = VkImageBlit2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageLayout.hpp>
#include <vulkan2json/ImageLayout.hpp>
#include <vulkan2json/Filter.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BlitImageInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcImageLayout" ] = p.srcImageLayout;
  j[ "dstImageLayout" ] = p.dstImageLayout;
  j[ "regionCount" ] = p.regionCount;
  j[ "pRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRegions ) );
  j[ "filter" ] = p.filter;
}
}
void to_json( nlohmann::json &j, const VkBlitImageInfo2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BlitImageInfo2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BlitImageInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BlitImageInfo2KHR" );
  if( j.find( "srcImageLayout" ) != j.end() ) {
    p.srcImageLayout = ImageLayout ( j[ "srcImageLayout" ] );
  }
  if( j.find( "dstImageLayout" ) != j.end() ) {
    p.dstImageLayout = ImageLayout ( j[ "dstImageLayout" ] );
  }
  if( j.find( "regionCount" ) != j.end() ) {
    p.regionCount = j[ "regionCount" ];
  }
  if( j.find( "filter" ) != j.end() ) {
    p.filter = Filter ( j[ "filter" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkBlitImageInfo2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: BlitImageInfo2KHR temp;
  from_json( j, temp );
  p = VkBlitImageInfo2KHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BufferCopy &p ) {
  j = nlohmann::json::object();
  j[ "srcOffset" ] = p.srcOffset;
  j[ "dstOffset" ] = p.dstOffset;
  j[ "size" ] = p.size;
}
}
void to_json( nlohmann::json &j, const VkBufferCopy &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BufferCopy ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BufferCopy &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferCopy" );
  if( j.find( "srcOffset" ) != j.end() ) {
    p.srcOffset = j[ "srcOffset" ];
  }
  if( j.find( "dstOffset" ) != j.end() ) {
    p.dstOffset = j[ "dstOffset" ];
  }
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBufferCopy &p ) {
  VULKAN_HPP_NAMESPACE :: BufferCopy temp;
  from_json( j, temp );
  p = VkBufferCopy ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BufferCopy2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcOffset" ] = p.srcOffset;
  j[ "dstOffset" ] = p.dstOffset;
  j[ "size" ] = p.size;
}
}
void to_json( nlohmann::json &j, const VkBufferCopy2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BufferCopy2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BufferCopy2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferCopy2KHR" );
  if( j.find( "srcOffset" ) != j.end() ) {
    p.srcOffset = j[ "srcOffset" ];
  }
  if( j.find( "dstOffset" ) != j.end() ) {
    p.dstOffset = j[ "dstOffset" ];
  }
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBufferCopy2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: BufferCopy2KHR temp;
  from_json( j, temp );
  p = VkBufferCopy2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/BufferCreateFlags.hpp>
#include <vulkan2json/BufferUsageFlags.hpp>
#include <vulkan2json/SharingMode.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BufferCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "size" ] = p.size;
  j[ "usage" ] = p.usage;
  j[ "sharingMode" ] = p.sharingMode;
  j[ "queueFamilyIndexCount" ] = p.queueFamilyIndexCount;
  j[ "pQueueFamilyIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pQueueFamilyIndices ) );
}
}
void to_json( nlohmann::json &j, const VkBufferCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BufferCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BufferCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = BufferCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
  if( j.find( "usage" ) != j.end() ) {
    p.usage = BufferUsageFlags ( j[ "usage" ] );
  }
  if( j.find( "sharingMode" ) != j.end() ) {
    p.sharingMode = SharingMode ( j[ "sharingMode" ] );
  }
  if( j.find( "queueFamilyIndexCount" ) != j.end() ) {
    p.queueFamilyIndexCount = j[ "queueFamilyIndexCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBufferCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: BufferCreateInfo temp;
  from_json( j, temp );
  p = VkBufferCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BufferDeviceAddressCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkBufferDeviceAddressCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BufferDeviceAddressCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BufferDeviceAddressCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferDeviceAddressCreateInfoEXT" );
}
}
void from_json( const nlohmann::json &j, VkBufferDeviceAddressCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: BufferDeviceAddressCreateInfoEXT temp;
  from_json( j, temp );
  p = VkBufferDeviceAddressCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BufferDeviceAddressInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkBufferDeviceAddressInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BufferDeviceAddressInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BufferDeviceAddressInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferDeviceAddressInfo" );
}
}
void from_json( const nlohmann::json &j, VkBufferDeviceAddressInfo &p ) {
  VULKAN_HPP_NAMESPACE :: BufferDeviceAddressInfo temp;
  from_json( j, temp );
  p = VkBufferDeviceAddressInfo ( temp );
}
#include <vulkan2json/ImageSubresourceLayers.hpp>
#include <vulkan2json/Offset3D.hpp>
#include <vulkan2json/Extent3D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BufferImageCopy &p ) {
  j = nlohmann::json::object();
  j[ "bufferOffset" ] = p.bufferOffset;
  j[ "bufferRowLength" ] = p.bufferRowLength;
  j[ "bufferImageHeight" ] = p.bufferImageHeight;
  j[ "imageSubresource" ] = p.imageSubresource;
  j[ "imageOffset" ] = p.imageOffset;
  j[ "imageExtent" ] = p.imageExtent;
}
}
void to_json( nlohmann::json &j, const VkBufferImageCopy &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BufferImageCopy ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BufferImageCopy &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferImageCopy" );
  if( j.find( "bufferOffset" ) != j.end() ) {
    p.bufferOffset = j[ "bufferOffset" ];
  }
  if( j.find( "bufferRowLength" ) != j.end() ) {
    p.bufferRowLength = j[ "bufferRowLength" ];
  }
  if( j.find( "bufferImageHeight" ) != j.end() ) {
    p.bufferImageHeight = j[ "bufferImageHeight" ];
  }
  if( j.find( "imageSubresource" ) != j.end() ) {
    p.imageSubresource = ImageSubresourceLayers ( j[ "imageSubresource" ] );
  }
  if( j.find( "imageOffset" ) != j.end() ) {
    p.imageOffset = Offset3D ( j[ "imageOffset" ] );
  }
  if( j.find( "imageExtent" ) != j.end() ) {
    p.imageExtent = Extent3D ( j[ "imageExtent" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkBufferImageCopy &p ) {
  VULKAN_HPP_NAMESPACE :: BufferImageCopy temp;
  from_json( j, temp );
  p = VkBufferImageCopy ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageSubresourceLayers.hpp>
#include <vulkan2json/Offset3D.hpp>
#include <vulkan2json/Extent3D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BufferImageCopy2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "bufferOffset" ] = p.bufferOffset;
  j[ "bufferRowLength" ] = p.bufferRowLength;
  j[ "bufferImageHeight" ] = p.bufferImageHeight;
  j[ "imageSubresource" ] = p.imageSubresource;
  j[ "imageOffset" ] = p.imageOffset;
  j[ "imageExtent" ] = p.imageExtent;
}
}
void to_json( nlohmann::json &j, const VkBufferImageCopy2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BufferImageCopy2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BufferImageCopy2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferImageCopy2KHR" );
  if( j.find( "bufferOffset" ) != j.end() ) {
    p.bufferOffset = j[ "bufferOffset" ];
  }
  if( j.find( "bufferRowLength" ) != j.end() ) {
    p.bufferRowLength = j[ "bufferRowLength" ];
  }
  if( j.find( "bufferImageHeight" ) != j.end() ) {
    p.bufferImageHeight = j[ "bufferImageHeight" ];
  }
  if( j.find( "imageSubresource" ) != j.end() ) {
    p.imageSubresource = ImageSubresourceLayers ( j[ "imageSubresource" ] );
  }
  if( j.find( "imageOffset" ) != j.end() ) {
    p.imageOffset = Offset3D ( j[ "imageOffset" ] );
  }
  if( j.find( "imageExtent" ) != j.end() ) {
    p.imageExtent = Extent3D ( j[ "imageExtent" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkBufferImageCopy2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: BufferImageCopy2KHR temp;
  from_json( j, temp );
  p = VkBufferImageCopy2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/AccessFlags.hpp>
#include <vulkan2json/AccessFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BufferMemoryBarrier &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
  j[ "srcQueueFamilyIndex" ] = p.srcQueueFamilyIndex;
  j[ "dstQueueFamilyIndex" ] = p.dstQueueFamilyIndex;
  j[ "offset" ] = p.offset;
  j[ "size" ] = p.size;
}
}
void to_json( nlohmann::json &j, const VkBufferMemoryBarrier &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BufferMemoryBarrier ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BufferMemoryBarrier &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferMemoryBarrier" );
  if( j.find( "srcAccessMask" ) != j.end() ) {
    p.srcAccessMask = AccessFlags ( j[ "srcAccessMask" ] );
  }
  if( j.find( "dstAccessMask" ) != j.end() ) {
    p.dstAccessMask = AccessFlags ( j[ "dstAccessMask" ] );
  }
  if( j.find( "srcQueueFamilyIndex" ) != j.end() ) {
    p.srcQueueFamilyIndex = j[ "srcQueueFamilyIndex" ];
  }
  if( j.find( "dstQueueFamilyIndex" ) != j.end() ) {
    p.dstQueueFamilyIndex = j[ "dstQueueFamilyIndex" ];
  }
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBufferMemoryBarrier &p ) {
  VULKAN_HPP_NAMESPACE :: BufferMemoryBarrier temp;
  from_json( j, temp );
  p = VkBufferMemoryBarrier ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineStageFlags2KHR.hpp>
#include <vulkan2json/AccessFlags2KHR.hpp>
#include <vulkan2json/PipelineStageFlags2KHR.hpp>
#include <vulkan2json/AccessFlags2KHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BufferMemoryBarrier2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcStageMask" ] = p.srcStageMask;
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstStageMask" ] = p.dstStageMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
  j[ "srcQueueFamilyIndex" ] = p.srcQueueFamilyIndex;
  j[ "dstQueueFamilyIndex" ] = p.dstQueueFamilyIndex;
  j[ "offset" ] = p.offset;
  j[ "size" ] = p.size;
}
}
void to_json( nlohmann::json &j, const VkBufferMemoryBarrier2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BufferMemoryBarrier2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BufferMemoryBarrier2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferMemoryBarrier2KHR" );
  if( j.find( "srcStageMask" ) != j.end() ) {
    p.srcStageMask = PipelineStageFlags2KHR ( j[ "srcStageMask" ] );
  }
  if( j.find( "srcAccessMask" ) != j.end() ) {
    p.srcAccessMask = AccessFlags2KHR ( j[ "srcAccessMask" ] );
  }
  if( j.find( "dstStageMask" ) != j.end() ) {
    p.dstStageMask = PipelineStageFlags2KHR ( j[ "dstStageMask" ] );
  }
  if( j.find( "dstAccessMask" ) != j.end() ) {
    p.dstAccessMask = AccessFlags2KHR ( j[ "dstAccessMask" ] );
  }
  if( j.find( "srcQueueFamilyIndex" ) != j.end() ) {
    p.srcQueueFamilyIndex = j[ "srcQueueFamilyIndex" ];
  }
  if( j.find( "dstQueueFamilyIndex" ) != j.end() ) {
    p.dstQueueFamilyIndex = j[ "dstQueueFamilyIndex" ];
  }
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBufferMemoryBarrier2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: BufferMemoryBarrier2KHR temp;
  from_json( j, temp );
  p = VkBufferMemoryBarrier2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BufferMemoryRequirementsInfo2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkBufferMemoryRequirementsInfo2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BufferMemoryRequirementsInfo2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BufferMemoryRequirementsInfo2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferMemoryRequirementsInfo2" );
}
}
void from_json( const nlohmann::json &j, VkBufferMemoryRequirementsInfo2 &p ) {
  VULKAN_HPP_NAMESPACE :: BufferMemoryRequirementsInfo2 temp;
  from_json( j, temp );
  p = VkBufferMemoryRequirementsInfo2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BufferOpaqueCaptureAddressCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "opaqueCaptureAddress" ] = p.opaqueCaptureAddress;
}
}
void to_json( nlohmann::json &j, const VkBufferOpaqueCaptureAddressCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BufferOpaqueCaptureAddressCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BufferOpaqueCaptureAddressCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferOpaqueCaptureAddressCreateInfo" );
  if( j.find( "opaqueCaptureAddress" ) != j.end() ) {
    p.opaqueCaptureAddress = j[ "opaqueCaptureAddress" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBufferOpaqueCaptureAddressCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: BufferOpaqueCaptureAddressCreateInfo temp;
  from_json( j, temp );
  p = VkBufferOpaqueCaptureAddressCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/BufferViewCreateFlags.hpp>
#include <vulkan2json/Format.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const BufferViewCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "format" ] = p.format;
  j[ "offset" ] = p.offset;
  j[ "range" ] = p.range;
}
}
void to_json( nlohmann::json &j, const VkBufferViewCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: BufferViewCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, BufferViewCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferViewCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = BufferViewCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "format" ) != j.end() ) {
    p.format = Format ( j[ "format" ] );
  }
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
  if( j.find( "range" ) != j.end() ) {
    p.range = j[ "range" ];
  }
}
}
void from_json( const nlohmann::json &j, VkBufferViewCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: BufferViewCreateInfo temp;
  from_json( j, temp );
  p = VkBufferViewCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/TimeDomainEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CalibratedTimestampInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "timeDomain" ] = p.timeDomain;
}
}
void to_json( nlohmann::json &j, const VkCalibratedTimestampInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CalibratedTimestampInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CalibratedTimestampInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CalibratedTimestampInfoEXT" );
  if( j.find( "timeDomain" ) != j.end() ) {
    p.timeDomain = TimeDomainEXT ( j[ "timeDomain" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkCalibratedTimestampInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: CalibratedTimestampInfoEXT temp;
  from_json( j, temp );
  p = VkCalibratedTimestampInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineStageFlags2KHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CheckpointData2NV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stage" ] = p.stage;
  j[ "pCheckpointMarker" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCheckpointMarker ) );
}
}
void to_json( nlohmann::json &j, const VkCheckpointData2NV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CheckpointData2NV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CheckpointData2NV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CheckpointData2NV" );
  if( j.find( "stage" ) != j.end() ) {
    p.stage = PipelineStageFlags2KHR ( j[ "stage" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkCheckpointData2NV &p ) {
  VULKAN_HPP_NAMESPACE :: CheckpointData2NV temp;
  from_json( j, temp );
  p = VkCheckpointData2NV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineStageFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CheckpointDataNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stage" ] = p.stage;
  j[ "pCheckpointMarker" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCheckpointMarker ) );
}
}
void to_json( nlohmann::json &j, const VkCheckpointDataNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CheckpointDataNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CheckpointDataNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CheckpointDataNV" );
  if( j.find( "stage" ) != j.end() ) {
    p.stage = PipelineStageFlagBits ( j[ "stage" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkCheckpointDataNV &p ) {
  VULKAN_HPP_NAMESPACE :: CheckpointDataNV temp;
  from_json( j, temp );
  p = VkCheckpointDataNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ClearDepthStencilValue &p ) {
  j = nlohmann::json::object();
  j[ "depth" ] = p.depth;
  j[ "stencil" ] = p.stencil;
}
}
void to_json( nlohmann::json &j, const VkClearDepthStencilValue &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ClearDepthStencilValue ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ClearDepthStencilValue &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ClearDepthStencilValue" );
  if( j.find( "depth" ) != j.end() ) {
    p.depth = j[ "depth" ];
  }
  if( j.find( "stencil" ) != j.end() ) {
    p.stencil = j[ "stencil" ];
  }
}
}
void from_json( const nlohmann::json &j, VkClearDepthStencilValue &p ) {
  VULKAN_HPP_NAMESPACE :: ClearDepthStencilValue temp;
  from_json( j, temp );
  p = VkClearDepthStencilValue ( temp );
}
#include <vulkan2json/ImageAspectFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ClearAttachment &p ) {
  j = nlohmann::json::object();
  j[ "aspectMask" ] = p.aspectMask;
  j[ "colorAttachment" ] = p.colorAttachment;
}
}
void to_json( nlohmann::json &j, const VkClearAttachment &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ClearAttachment ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ClearAttachment &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ClearAttachment" );
  if( j.find( "aspectMask" ) != j.end() ) {
    p.aspectMask = ImageAspectFlags ( j[ "aspectMask" ] );
  }
  if( j.find( "colorAttachment" ) != j.end() ) {
    p.colorAttachment = j[ "colorAttachment" ];
  }
}
}
void from_json( const nlohmann::json &j, VkClearAttachment &p ) {
  VULKAN_HPP_NAMESPACE :: ClearAttachment temp;
  from_json( j, temp );
  p = VkClearAttachment ( temp );
}
#include <vulkan2json/Rect2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ClearRect &p ) {
  j = nlohmann::json::object();
  j[ "rect" ] = p.rect;
  j[ "baseArrayLayer" ] = p.baseArrayLayer;
  j[ "layerCount" ] = p.layerCount;
}
}
void to_json( nlohmann::json &j, const VkClearRect &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ClearRect ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ClearRect &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ClearRect" );
  if( j.find( "rect" ) != j.end() ) {
    p.rect = Rect2D ( j[ "rect" ] );
  }
  if( j.find( "baseArrayLayer" ) != j.end() ) {
    p.baseArrayLayer = j[ "baseArrayLayer" ];
  }
  if( j.find( "layerCount" ) != j.end() ) {
    p.layerCount = j[ "layerCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkClearRect &p ) {
  VULKAN_HPP_NAMESPACE :: ClearRect temp;
  from_json( j, temp );
  p = VkClearRect ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CoarseSampleLocationNV &p ) {
  j = nlohmann::json::object();
  j[ "pixelX" ] = p.pixelX;
  j[ "pixelY" ] = p.pixelY;
  j[ "sample" ] = p.sample;
}
}
void to_json( nlohmann::json &j, const VkCoarseSampleLocationNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CoarseSampleLocationNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CoarseSampleLocationNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CoarseSampleLocationNV" );
  if( j.find( "pixelX" ) != j.end() ) {
    p.pixelX = j[ "pixelX" ];
  }
  if( j.find( "pixelY" ) != j.end() ) {
    p.pixelY = j[ "pixelY" ];
  }
  if( j.find( "sample" ) != j.end() ) {
    p.sample = j[ "sample" ];
  }
}
}
void from_json( const nlohmann::json &j, VkCoarseSampleLocationNV &p ) {
  VULKAN_HPP_NAMESPACE :: CoarseSampleLocationNV temp;
  from_json( j, temp );
  p = VkCoarseSampleLocationNV ( temp );
}
#include <vulkan2json/ShadingRatePaletteEntryNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CoarseSampleOrderCustomNV &p ) {
  j = nlohmann::json::object();
  j[ "shadingRate" ] = p.shadingRate;
  j[ "sampleCount" ] = p.sampleCount;
  j[ "sampleLocationCount" ] = p.sampleLocationCount;
  j[ "pSampleLocations" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSampleLocations ) );
}
}
void to_json( nlohmann::json &j, const VkCoarseSampleOrderCustomNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CoarseSampleOrderCustomNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CoarseSampleOrderCustomNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CoarseSampleOrderCustomNV" );
  if( j.find( "shadingRate" ) != j.end() ) {
    p.shadingRate = ShadingRatePaletteEntryNV ( j[ "shadingRate" ] );
  }
  if( j.find( "sampleCount" ) != j.end() ) {
    p.sampleCount = j[ "sampleCount" ];
  }
  if( j.find( "sampleLocationCount" ) != j.end() ) {
    p.sampleLocationCount = j[ "sampleLocationCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkCoarseSampleOrderCustomNV &p ) {
  VULKAN_HPP_NAMESPACE :: CoarseSampleOrderCustomNV temp;
  from_json( j, temp );
  p = VkCoarseSampleOrderCustomNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/CommandBufferLevel.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CommandBufferAllocateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "level" ] = p.level;
  j[ "commandBufferCount" ] = p.commandBufferCount;
}
}
void to_json( nlohmann::json &j, const VkCommandBufferAllocateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CommandBufferAllocateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CommandBufferAllocateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandBufferAllocateInfo" );
  if( j.find( "level" ) != j.end() ) {
    p.level = CommandBufferLevel ( j[ "level" ] );
  }
  if( j.find( "commandBufferCount" ) != j.end() ) {
    p.commandBufferCount = j[ "commandBufferCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkCommandBufferAllocateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: CommandBufferAllocateInfo temp;
  from_json( j, temp );
  p = VkCommandBufferAllocateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/QueryControlFlags.hpp>
#include <vulkan2json/QueryPipelineStatisticFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CommandBufferInheritanceInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "subpass" ] = p.subpass;
  j[ "occlusionQueryEnable" ] = bool( p.occlusionQueryEnable );
  j[ "queryFlags" ] = p.queryFlags;
  j[ "pipelineStatistics" ] = p.pipelineStatistics;
}
}
void to_json( nlohmann::json &j, const VkCommandBufferInheritanceInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CommandBufferInheritanceInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CommandBufferInheritanceInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandBufferInheritanceInfo" );
  if( j.find( "subpass" ) != j.end() ) {
    p.subpass = j[ "subpass" ];
  }
  if( j.find( "occlusionQueryEnable" ) != j.end() ) {
    p.occlusionQueryEnable = j[ "occlusionQueryEnable" ];
  }
  if( j.find( "queryFlags" ) != j.end() ) {
    p.queryFlags = QueryControlFlags ( j[ "queryFlags" ] );
  }
  if( j.find( "pipelineStatistics" ) != j.end() ) {
    p.pipelineStatistics = QueryPipelineStatisticFlags ( j[ "pipelineStatistics" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkCommandBufferInheritanceInfo &p ) {
  VULKAN_HPP_NAMESPACE :: CommandBufferInheritanceInfo temp;
  from_json( j, temp );
  p = VkCommandBufferInheritanceInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/CommandBufferUsageFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CommandBufferBeginInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pInheritanceInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pInheritanceInfo ) );
}
}
void to_json( nlohmann::json &j, const VkCommandBufferBeginInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CommandBufferBeginInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CommandBufferBeginInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandBufferBeginInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = CommandBufferUsageFlags ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkCommandBufferBeginInfo &p ) {
  VULKAN_HPP_NAMESPACE :: CommandBufferBeginInfo temp;
  from_json( j, temp );
  p = VkCommandBufferBeginInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CommandBufferInheritanceConditionalRenderingInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "conditionalRenderingEnable" ] = bool( p.conditionalRenderingEnable );
}
}
void to_json( nlohmann::json &j, const VkCommandBufferInheritanceConditionalRenderingInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CommandBufferInheritanceConditionalRenderingInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CommandBufferInheritanceConditionalRenderingInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandBufferInheritanceConditionalRenderingInfoEXT" );
  if( j.find( "conditionalRenderingEnable" ) != j.end() ) {
    p.conditionalRenderingEnable = j[ "conditionalRenderingEnable" ];
  }
}
}
void from_json( const nlohmann::json &j, VkCommandBufferInheritanceConditionalRenderingInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: CommandBufferInheritanceConditionalRenderingInfoEXT temp;
  from_json( j, temp );
  p = VkCommandBufferInheritanceConditionalRenderingInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SurfaceTransformFlagsKHR.hpp>
#include <vulkan2json/Rect2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CommandBufferInheritanceRenderPassTransformInfoQCOM &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "transform" ] = p.transform;
  j[ "renderArea" ] = p.renderArea;
}
}
void to_json( nlohmann::json &j, const VkCommandBufferInheritanceRenderPassTransformInfoQCOM &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CommandBufferInheritanceRenderPassTransformInfoQCOM ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CommandBufferInheritanceRenderPassTransformInfoQCOM &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandBufferInheritanceRenderPassTransformInfoQCOM" );
  if( j.find( "transform" ) != j.end() ) {
    p.transform = SurfaceTransformFlagBitsKHR ( j[ "transform" ] );
  }
  if( j.find( "renderArea" ) != j.end() ) {
    p.renderArea = Rect2D ( j[ "renderArea" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkCommandBufferInheritanceRenderPassTransformInfoQCOM &p ) {
  VULKAN_HPP_NAMESPACE :: CommandBufferInheritanceRenderPassTransformInfoQCOM temp;
  from_json( j, temp );
  p = VkCommandBufferInheritanceRenderPassTransformInfoQCOM ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const Viewport &p ) {
  j = nlohmann::json::object();
  j[ "x" ] = p.x;
  j[ "y" ] = p.y;
  j[ "width" ] = p.width;
  j[ "height" ] = p.height;
  j[ "minDepth" ] = p.minDepth;
  j[ "maxDepth" ] = p.maxDepth;
}
}
void to_json( nlohmann::json &j, const VkViewport &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: Viewport ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, Viewport &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Viewport" );
  if( j.find( "x" ) != j.end() ) {
    p.x = j[ "x" ];
  }
  if( j.find( "y" ) != j.end() ) {
    p.y = j[ "y" ];
  }
  if( j.find( "width" ) != j.end() ) {
    p.width = j[ "width" ];
  }
  if( j.find( "height" ) != j.end() ) {
    p.height = j[ "height" ];
  }
  if( j.find( "minDepth" ) != j.end() ) {
    p.minDepth = j[ "minDepth" ];
  }
  if( j.find( "maxDepth" ) != j.end() ) {
    p.maxDepth = j[ "maxDepth" ];
  }
}
}
void from_json( const nlohmann::json &j, VkViewport &p ) {
  VULKAN_HPP_NAMESPACE :: Viewport temp;
  from_json( j, temp );
  p = VkViewport ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CommandBufferInheritanceViewportScissorInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "viewportScissor2D" ] = bool( p.viewportScissor2D );
  j[ "viewportDepthCount" ] = p.viewportDepthCount;
  j[ "pViewportDepths" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewportDepths ) );
}
}
void to_json( nlohmann::json &j, const VkCommandBufferInheritanceViewportScissorInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CommandBufferInheritanceViewportScissorInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CommandBufferInheritanceViewportScissorInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandBufferInheritanceViewportScissorInfoNV" );
  if( j.find( "viewportScissor2D" ) != j.end() ) {
    p.viewportScissor2D = j[ "viewportScissor2D" ];
  }
  if( j.find( "viewportDepthCount" ) != j.end() ) {
    p.viewportDepthCount = j[ "viewportDepthCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkCommandBufferInheritanceViewportScissorInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: CommandBufferInheritanceViewportScissorInfoNV temp;
  from_json( j, temp );
  p = VkCommandBufferInheritanceViewportScissorInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CommandBufferSubmitInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceMask" ] = p.deviceMask;
}
}
void to_json( nlohmann::json &j, const VkCommandBufferSubmitInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CommandBufferSubmitInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CommandBufferSubmitInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandBufferSubmitInfoKHR" );
  if( j.find( "deviceMask" ) != j.end() ) {
    p.deviceMask = j[ "deviceMask" ];
  }
}
}
void from_json( const nlohmann::json &j, VkCommandBufferSubmitInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: CommandBufferSubmitInfoKHR temp;
  from_json( j, temp );
  p = VkCommandBufferSubmitInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/CommandPoolCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CommandPoolCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "queueFamilyIndex" ] = p.queueFamilyIndex;
}
}
void to_json( nlohmann::json &j, const VkCommandPoolCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CommandPoolCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CommandPoolCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandPoolCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = CommandPoolCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "queueFamilyIndex" ) != j.end() ) {
    p.queueFamilyIndex = j[ "queueFamilyIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkCommandPoolCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: CommandPoolCreateInfo temp;
  from_json( j, temp );
  p = VkCommandPoolCreateInfo ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SpecializationMapEntry &p ) {
  j = nlohmann::json::object();
  j[ "constantID" ] = p.constantID;
  j[ "offset" ] = p.offset;
  j[ "size" ] = p.size;
}
}
void to_json( nlohmann::json &j, const VkSpecializationMapEntry &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SpecializationMapEntry ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SpecializationMapEntry &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SpecializationMapEntry" );
  if( j.find( "constantID" ) != j.end() ) {
    p.constantID = j[ "constantID" ];
  }
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSpecializationMapEntry &p ) {
  VULKAN_HPP_NAMESPACE :: SpecializationMapEntry temp;
  from_json( j, temp );
  p = VkSpecializationMapEntry ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SpecializationInfo &p ) {
  j = nlohmann::json::object();
  j[ "mapEntryCount" ] = p.mapEntryCount;
  j[ "pMapEntries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pMapEntries ) );
  j[ "dataSize" ] = p.dataSize;
  j[ "pData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pData ) );
}
}
void to_json( nlohmann::json &j, const VkSpecializationInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SpecializationInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SpecializationInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SpecializationInfo" );
  if( j.find( "mapEntryCount" ) != j.end() ) {
    p.mapEntryCount = j[ "mapEntryCount" ];
  }
  if( j.find( "dataSize" ) != j.end() ) {
    p.dataSize = j[ "dataSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSpecializationInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SpecializationInfo temp;
  from_json( j, temp );
  p = VkSpecializationInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineShaderStageCreateFlags.hpp>
#include <vulkan2json/ShaderStageFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineShaderStageCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "stage" ] = p.stage;
  if( p.pName ) j[ "pName" ] = std::string( p.pName );
  j[ "pSpecializationInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSpecializationInfo ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineShaderStageCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineShaderStageCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineShaderStageCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineShaderStageCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineShaderStageCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "stage" ) != j.end() ) {
    p.stage = ShaderStageFlagBits ( j[ "stage" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineShaderStageCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineShaderStageCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineShaderStageCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineCreateFlags.hpp>
#include <vulkan2json/PipelineShaderStageCreateInfo.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ComputePipelineCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "stage" ] = p.stage;
  j[ "basePipelineIndex" ] = p.basePipelineIndex;
}
}
void to_json( nlohmann::json &j, const VkComputePipelineCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ComputePipelineCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ComputePipelineCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ComputePipelineCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "stage" ) != j.end() ) {
    p.stage = PipelineShaderStageCreateInfo ( j[ "stage" ] );
  }
  if( j.find( "basePipelineIndex" ) != j.end() ) {
    p.basePipelineIndex = j[ "basePipelineIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkComputePipelineCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ComputePipelineCreateInfo temp;
  from_json( j, temp );
  p = VkComputePipelineCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ConditionalRenderingFlagsEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ConditionalRenderingBeginInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "offset" ] = p.offset;
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkConditionalRenderingBeginInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ConditionalRenderingBeginInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ConditionalRenderingBeginInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ConditionalRenderingBeginInfoEXT" );
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
  if( j.find( "flags" ) != j.end() ) {
    p.flags = ConditionalRenderingFlagsEXT ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkConditionalRenderingBeginInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ConditionalRenderingBeginInfoEXT temp;
  from_json( j, temp );
  p = VkConditionalRenderingBeginInfoEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ConformanceVersion &p ) {
  j = nlohmann::json::object();
  j[ "major" ] = p.major;
  j[ "minor" ] = p.minor;
  j[ "subminor" ] = p.subminor;
  j[ "patch" ] = p.patch;
}
}
void to_json( nlohmann::json &j, const VkConformanceVersion &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ConformanceVersion ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ConformanceVersion &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ConformanceVersion" );
  if( j.find( "major" ) != j.end() ) {
    p.major = j[ "major" ];
  }
  if( j.find( "minor" ) != j.end() ) {
    p.minor = j[ "minor" ];
  }
  if( j.find( "subminor" ) != j.end() ) {
    p.subminor = j[ "subminor" ];
  }
  if( j.find( "patch" ) != j.end() ) {
    p.patch = j[ "patch" ];
  }
}
}
void from_json( const nlohmann::json &j, VkConformanceVersion &p ) {
  VULKAN_HPP_NAMESPACE :: ConformanceVersion temp;
  from_json( j, temp );
  p = VkConformanceVersion ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ComponentTypeNV.hpp>
#include <vulkan2json/ComponentTypeNV.hpp>
#include <vulkan2json/ComponentTypeNV.hpp>
#include <vulkan2json/ComponentTypeNV.hpp>
#include <vulkan2json/ScopeNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CooperativeMatrixPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "MSize" ] = p.MSize;
  j[ "NSize" ] = p.NSize;
  j[ "KSize" ] = p.KSize;
  j[ "AType" ] = p.AType;
  j[ "BType" ] = p.BType;
  j[ "CType" ] = p.CType;
  j[ "DType" ] = p.DType;
  j[ "scope" ] = p.scope;
}
}
void to_json( nlohmann::json &j, const VkCooperativeMatrixPropertiesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CooperativeMatrixPropertiesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CooperativeMatrixPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CooperativeMatrixPropertiesNV" );
  if( j.find( "MSize" ) != j.end() ) {
    p.MSize = j[ "MSize" ];
  }
  if( j.find( "NSize" ) != j.end() ) {
    p.NSize = j[ "NSize" ];
  }
  if( j.find( "KSize" ) != j.end() ) {
    p.KSize = j[ "KSize" ];
  }
  if( j.find( "AType" ) != j.end() ) {
    p.AType = ComponentTypeNV ( j[ "AType" ] );
  }
  if( j.find( "BType" ) != j.end() ) {
    p.BType = ComponentTypeNV ( j[ "BType" ] );
  }
  if( j.find( "CType" ) != j.end() ) {
    p.CType = ComponentTypeNV ( j[ "CType" ] );
  }
  if( j.find( "DType" ) != j.end() ) {
    p.DType = ComponentTypeNV ( j[ "DType" ] );
  }
  if( j.find( "scope" ) != j.end() ) {
    p.scope = ScopeNV ( j[ "scope" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkCooperativeMatrixPropertiesNV &p ) {
  VULKAN_HPP_NAMESPACE :: CooperativeMatrixPropertiesNV temp;
  from_json( j, temp );
  p = VkCooperativeMatrixPropertiesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/CopyAccelerationStructureModeKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CopyAccelerationStructureInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "mode" ] = p.mode;
}
}
void to_json( nlohmann::json &j, const VkCopyAccelerationStructureInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CopyAccelerationStructureInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CopyAccelerationStructureInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyAccelerationStructureInfoKHR" );
  if( j.find( "mode" ) != j.end() ) {
    p.mode = CopyAccelerationStructureModeKHR ( j[ "mode" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkCopyAccelerationStructureInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: CopyAccelerationStructureInfoKHR temp;
  from_json( j, temp );
  p = VkCopyAccelerationStructureInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/CopyAccelerationStructureModeKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CopyAccelerationStructureToMemoryInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "mode" ] = p.mode;
}
}
void to_json( nlohmann::json &j, const VkCopyAccelerationStructureToMemoryInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CopyAccelerationStructureToMemoryInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CopyAccelerationStructureToMemoryInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyAccelerationStructureToMemoryInfoKHR" );
  if( j.find( "mode" ) != j.end() ) {
    p.mode = CopyAccelerationStructureModeKHR ( j[ "mode" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkCopyAccelerationStructureToMemoryInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: CopyAccelerationStructureToMemoryInfoKHR temp;
  from_json( j, temp );
  p = VkCopyAccelerationStructureToMemoryInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CopyBufferInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "regionCount" ] = p.regionCount;
  j[ "pRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRegions ) );
}
}
void to_json( nlohmann::json &j, const VkCopyBufferInfo2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CopyBufferInfo2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CopyBufferInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyBufferInfo2KHR" );
  if( j.find( "regionCount" ) != j.end() ) {
    p.regionCount = j[ "regionCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkCopyBufferInfo2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: CopyBufferInfo2KHR temp;
  from_json( j, temp );
  p = VkCopyBufferInfo2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageLayout.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CopyBufferToImageInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dstImageLayout" ] = p.dstImageLayout;
  j[ "regionCount" ] = p.regionCount;
  j[ "pRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRegions ) );
}
}
void to_json( nlohmann::json &j, const VkCopyBufferToImageInfo2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CopyBufferToImageInfo2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CopyBufferToImageInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyBufferToImageInfo2KHR" );
  if( j.find( "dstImageLayout" ) != j.end() ) {
    p.dstImageLayout = ImageLayout ( j[ "dstImageLayout" ] );
  }
  if( j.find( "regionCount" ) != j.end() ) {
    p.regionCount = j[ "regionCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkCopyBufferToImageInfo2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: CopyBufferToImageInfo2KHR temp;
  from_json( j, temp );
  p = VkCopyBufferToImageInfo2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SurfaceTransformFlagsKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CopyCommandTransformInfoQCOM &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "transform" ] = p.transform;
}
}
void to_json( nlohmann::json &j, const VkCopyCommandTransformInfoQCOM &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CopyCommandTransformInfoQCOM ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CopyCommandTransformInfoQCOM &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyCommandTransformInfoQCOM" );
  if( j.find( "transform" ) != j.end() ) {
    p.transform = SurfaceTransformFlagBitsKHR ( j[ "transform" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkCopyCommandTransformInfoQCOM &p ) {
  VULKAN_HPP_NAMESPACE :: CopyCommandTransformInfoQCOM temp;
  from_json( j, temp );
  p = VkCopyCommandTransformInfoQCOM ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CopyDescriptorSet &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcBinding" ] = p.srcBinding;
  j[ "srcArrayElement" ] = p.srcArrayElement;
  j[ "dstBinding" ] = p.dstBinding;
  j[ "dstArrayElement" ] = p.dstArrayElement;
  j[ "descriptorCount" ] = p.descriptorCount;
}
}
void to_json( nlohmann::json &j, const VkCopyDescriptorSet &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CopyDescriptorSet ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CopyDescriptorSet &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyDescriptorSet" );
  if( j.find( "srcBinding" ) != j.end() ) {
    p.srcBinding = j[ "srcBinding" ];
  }
  if( j.find( "srcArrayElement" ) != j.end() ) {
    p.srcArrayElement = j[ "srcArrayElement" ];
  }
  if( j.find( "dstBinding" ) != j.end() ) {
    p.dstBinding = j[ "dstBinding" ];
  }
  if( j.find( "dstArrayElement" ) != j.end() ) {
    p.dstArrayElement = j[ "dstArrayElement" ];
  }
  if( j.find( "descriptorCount" ) != j.end() ) {
    p.descriptorCount = j[ "descriptorCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkCopyDescriptorSet &p ) {
  VULKAN_HPP_NAMESPACE :: CopyDescriptorSet temp;
  from_json( j, temp );
  p = VkCopyDescriptorSet ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageSubresourceLayers.hpp>
#include <vulkan2json/Offset3D.hpp>
#include <vulkan2json/ImageSubresourceLayers.hpp>
#include <vulkan2json/Offset3D.hpp>
#include <vulkan2json/Extent3D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageCopy2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcSubresource" ] = p.srcSubresource;
  j[ "srcOffset" ] = p.srcOffset;
  j[ "dstSubresource" ] = p.dstSubresource;
  j[ "dstOffset" ] = p.dstOffset;
  j[ "extent" ] = p.extent;
}
}
void to_json( nlohmann::json &j, const VkImageCopy2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageCopy2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageCopy2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageCopy2KHR" );
  if( j.find( "srcSubresource" ) != j.end() ) {
    p.srcSubresource = ImageSubresourceLayers ( j[ "srcSubresource" ] );
  }
  if( j.find( "srcOffset" ) != j.end() ) {
    p.srcOffset = Offset3D ( j[ "srcOffset" ] );
  }
  if( j.find( "dstSubresource" ) != j.end() ) {
    p.dstSubresource = ImageSubresourceLayers ( j[ "dstSubresource" ] );
  }
  if( j.find( "dstOffset" ) != j.end() ) {
    p.dstOffset = Offset3D ( j[ "dstOffset" ] );
  }
  if( j.find( "extent" ) != j.end() ) {
    p.extent = Extent3D ( j[ "extent" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImageCopy2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: ImageCopy2KHR temp;
  from_json( j, temp );
  p = VkImageCopy2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageLayout.hpp>
#include <vulkan2json/ImageLayout.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CopyImageInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcImageLayout" ] = p.srcImageLayout;
  j[ "dstImageLayout" ] = p.dstImageLayout;
  j[ "regionCount" ] = p.regionCount;
  j[ "pRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRegions ) );
}
}
void to_json( nlohmann::json &j, const VkCopyImageInfo2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CopyImageInfo2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CopyImageInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyImageInfo2KHR" );
  if( j.find( "srcImageLayout" ) != j.end() ) {
    p.srcImageLayout = ImageLayout ( j[ "srcImageLayout" ] );
  }
  if( j.find( "dstImageLayout" ) != j.end() ) {
    p.dstImageLayout = ImageLayout ( j[ "dstImageLayout" ] );
  }
  if( j.find( "regionCount" ) != j.end() ) {
    p.regionCount = j[ "regionCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkCopyImageInfo2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: CopyImageInfo2KHR temp;
  from_json( j, temp );
  p = VkCopyImageInfo2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageLayout.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CopyImageToBufferInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcImageLayout" ] = p.srcImageLayout;
  j[ "regionCount" ] = p.regionCount;
  j[ "pRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRegions ) );
}
}
void to_json( nlohmann::json &j, const VkCopyImageToBufferInfo2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CopyImageToBufferInfo2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CopyImageToBufferInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyImageToBufferInfo2KHR" );
  if( j.find( "srcImageLayout" ) != j.end() ) {
    p.srcImageLayout = ImageLayout ( j[ "srcImageLayout" ] );
  }
  if( j.find( "regionCount" ) != j.end() ) {
    p.regionCount = j[ "regionCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkCopyImageToBufferInfo2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: CopyImageToBufferInfo2KHR temp;
  from_json( j, temp );
  p = VkCopyImageToBufferInfo2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/CopyAccelerationStructureModeKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CopyMemoryToAccelerationStructureInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "mode" ] = p.mode;
}
}
void to_json( nlohmann::json &j, const VkCopyMemoryToAccelerationStructureInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CopyMemoryToAccelerationStructureInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CopyMemoryToAccelerationStructureInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyMemoryToAccelerationStructureInfoKHR" );
  if( j.find( "mode" ) != j.end() ) {
    p.mode = CopyAccelerationStructureModeKHR ( j[ "mode" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkCopyMemoryToAccelerationStructureInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: CopyMemoryToAccelerationStructureInfoKHR temp;
  from_json( j, temp );
  p = VkCopyMemoryToAccelerationStructureInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CuFunctionCreateInfoNVX &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  if( p.pName ) j[ "pName" ] = std::string( p.pName );
}
}
void to_json( nlohmann::json &j, const VkCuFunctionCreateInfoNVX &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CuFunctionCreateInfoNVX ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CuFunctionCreateInfoNVX &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CuFunctionCreateInfoNVX" );
}
}
void from_json( const nlohmann::json &j, VkCuFunctionCreateInfoNVX &p ) {
  VULKAN_HPP_NAMESPACE :: CuFunctionCreateInfoNVX temp;
  from_json( j, temp );
  p = VkCuFunctionCreateInfoNVX ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CuLaunchInfoNVX &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "gridDimX" ] = p.gridDimX;
  j[ "gridDimY" ] = p.gridDimY;
  j[ "gridDimZ" ] = p.gridDimZ;
  j[ "blockDimX" ] = p.blockDimX;
  j[ "blockDimY" ] = p.blockDimY;
  j[ "blockDimZ" ] = p.blockDimZ;
  j[ "sharedMemBytes" ] = p.sharedMemBytes;
  j[ "paramCount" ] = p.paramCount;
  j[ "pParams" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pParams ) );
  j[ "extraCount" ] = p.extraCount;
  j[ "pExtras" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pExtras ) );
}
}
void to_json( nlohmann::json &j, const VkCuLaunchInfoNVX &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CuLaunchInfoNVX ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CuLaunchInfoNVX &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CuLaunchInfoNVX" );
  if( j.find( "gridDimX" ) != j.end() ) {
    p.gridDimX = j[ "gridDimX" ];
  }
  if( j.find( "gridDimY" ) != j.end() ) {
    p.gridDimY = j[ "gridDimY" ];
  }
  if( j.find( "gridDimZ" ) != j.end() ) {
    p.gridDimZ = j[ "gridDimZ" ];
  }
  if( j.find( "blockDimX" ) != j.end() ) {
    p.blockDimX = j[ "blockDimX" ];
  }
  if( j.find( "blockDimY" ) != j.end() ) {
    p.blockDimY = j[ "blockDimY" ];
  }
  if( j.find( "blockDimZ" ) != j.end() ) {
    p.blockDimZ = j[ "blockDimZ" ];
  }
  if( j.find( "sharedMemBytes" ) != j.end() ) {
    p.sharedMemBytes = j[ "sharedMemBytes" ];
  }
  if( j.find( "paramCount" ) != j.end() ) {
    p.paramCount = j[ "paramCount" ];
  }
  if( j.find( "extraCount" ) != j.end() ) {
    p.extraCount = j[ "extraCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkCuLaunchInfoNVX &p ) {
  VULKAN_HPP_NAMESPACE :: CuLaunchInfoNVX temp;
  from_json( j, temp );
  p = VkCuLaunchInfoNVX ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const CuModuleCreateInfoNVX &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dataSize" ] = p.dataSize;
  j[ "pData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pData ) );
}
}
void to_json( nlohmann::json &j, const VkCuModuleCreateInfoNVX &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: CuModuleCreateInfoNVX ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, CuModuleCreateInfoNVX &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CuModuleCreateInfoNVX" );
  if( j.find( "dataSize" ) != j.end() ) {
    p.dataSize = j[ "dataSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkCuModuleCreateInfoNVX &p ) {
  VULKAN_HPP_NAMESPACE :: CuModuleCreateInfoNVX temp;
  from_json( j, temp );
  p = VkCuModuleCreateInfoNVX ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugMarkerMarkerInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  if( p.pMarkerName ) j[ "pMarkerName" ] = std::string( p.pMarkerName );
  j[ "color" ] = nlohmann::json::array();
  std::copy( p.color.begin(), p.color.end(), std::back_inserter( j[ "color" ] ) );
}
}
void to_json( nlohmann::json &j, const VkDebugMarkerMarkerInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DebugMarkerMarkerInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DebugMarkerMarkerInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugMarkerMarkerInfoEXT" );
  if( j.find( "color" ) != j.end() ) {
    if( !j[ "color" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for DebugMarkerMarkerInfoEXT.color" );
    if( !j[ "color" ].size() > p.color.size() ) throw vulkan2json::invalid_array_value( "too many values in array for DebugMarkerMarkerInfoEXT.color" );
    std::fill( p.color.begin(), p.color.end(), 0 );
    std::copy( j[ "color" ].begin(), j[ "color" ].end(), p.color.begin() );
  }
}
}
void from_json( const nlohmann::json &j, VkDebugMarkerMarkerInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DebugMarkerMarkerInfoEXT temp;
  from_json( j, temp );
  p = VkDebugMarkerMarkerInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DebugReportObjectTypeEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugMarkerObjectNameInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "objectType" ] = p.objectType;
  j[ "object" ] = p.object;
  if( p.pObjectName ) j[ "pObjectName" ] = std::string( p.pObjectName );
}
}
void to_json( nlohmann::json &j, const VkDebugMarkerObjectNameInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DebugMarkerObjectNameInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DebugMarkerObjectNameInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugMarkerObjectNameInfoEXT" );
  if( j.find( "objectType" ) != j.end() ) {
    p.objectType = DebugReportObjectTypeEXT ( j[ "objectType" ] );
  }
  if( j.find( "object" ) != j.end() ) {
    p.object = j[ "object" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDebugMarkerObjectNameInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DebugMarkerObjectNameInfoEXT temp;
  from_json( j, temp );
  p = VkDebugMarkerObjectNameInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DebugReportObjectTypeEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugMarkerObjectTagInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "objectType" ] = p.objectType;
  j[ "object" ] = p.object;
  j[ "tagName" ] = p.tagName;
  j[ "tagSize" ] = p.tagSize;
  j[ "pTag" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pTag ) );
}
}
void to_json( nlohmann::json &j, const VkDebugMarkerObjectTagInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DebugMarkerObjectTagInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DebugMarkerObjectTagInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugMarkerObjectTagInfoEXT" );
  if( j.find( "objectType" ) != j.end() ) {
    p.objectType = DebugReportObjectTypeEXT ( j[ "objectType" ] );
  }
  if( j.find( "object" ) != j.end() ) {
    p.object = j[ "object" ];
  }
  if( j.find( "tagName" ) != j.end() ) {
    p.tagName = j[ "tagName" ];
  }
  if( j.find( "tagSize" ) != j.end() ) {
    p.tagSize = j[ "tagSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDebugMarkerObjectTagInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DebugMarkerObjectTagInfoEXT temp;
  from_json( j, temp );
  p = VkDebugMarkerObjectTagInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DebugReportFlagsEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugReportCallbackCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pfnCallback" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnCallback ) );
  j[ "pUserData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pUserData ) );
}
}
void to_json( nlohmann::json &j, const VkDebugReportCallbackCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DebugReportCallbackCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DebugReportCallbackCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugReportCallbackCreateInfoEXT" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = DebugReportFlagsEXT ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDebugReportCallbackCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DebugReportCallbackCreateInfoEXT temp;
  from_json( j, temp );
  p = VkDebugReportCallbackCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugUtilsLabelEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  if( p.pLabelName ) j[ "pLabelName" ] = std::string( p.pLabelName );
  j[ "color" ] = nlohmann::json::array();
  std::copy( p.color.begin(), p.color.end(), std::back_inserter( j[ "color" ] ) );
}
}
void to_json( nlohmann::json &j, const VkDebugUtilsLabelEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DebugUtilsLabelEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DebugUtilsLabelEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugUtilsLabelEXT" );
  if( j.find( "color" ) != j.end() ) {
    if( !j[ "color" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for DebugUtilsLabelEXT.color" );
    if( !j[ "color" ].size() > p.color.size() ) throw vulkan2json::invalid_array_value( "too many values in array for DebugUtilsLabelEXT.color" );
    std::fill( p.color.begin(), p.color.end(), 0 );
    std::copy( j[ "color" ].begin(), j[ "color" ].end(), p.color.begin() );
  }
}
}
void from_json( const nlohmann::json &j, VkDebugUtilsLabelEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DebugUtilsLabelEXT temp;
  from_json( j, temp );
  p = VkDebugUtilsLabelEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ObjectType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugUtilsObjectNameInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "objectType" ] = p.objectType;
  j[ "objectHandle" ] = p.objectHandle;
  if( p.pObjectName ) j[ "pObjectName" ] = std::string( p.pObjectName );
}
}
void to_json( nlohmann::json &j, const VkDebugUtilsObjectNameInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DebugUtilsObjectNameInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DebugUtilsObjectNameInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugUtilsObjectNameInfoEXT" );
  if( j.find( "objectType" ) != j.end() ) {
    p.objectType = ObjectType ( j[ "objectType" ] );
  }
  if( j.find( "objectHandle" ) != j.end() ) {
    p.objectHandle = j[ "objectHandle" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDebugUtilsObjectNameInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DebugUtilsObjectNameInfoEXT temp;
  from_json( j, temp );
  p = VkDebugUtilsObjectNameInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DebugUtilsMessengerCallbackDataFlagsEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugUtilsMessengerCallbackDataEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  if( p.pMessageIdName ) j[ "pMessageIdName" ] = std::string( p.pMessageIdName );
  j[ "messageIdNumber" ] = p.messageIdNumber;
  if( p.pMessage ) j[ "pMessage" ] = std::string( p.pMessage );
  j[ "queueLabelCount" ] = p.queueLabelCount;
  j[ "pQueueLabels" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pQueueLabels ) );
  j[ "cmdBufLabelCount" ] = p.cmdBufLabelCount;
  j[ "pCmdBufLabels" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCmdBufLabels ) );
  j[ "objectCount" ] = p.objectCount;
  j[ "pObjects" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pObjects ) );
}
}
void to_json( nlohmann::json &j, const VkDebugUtilsMessengerCallbackDataEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DebugUtilsMessengerCallbackDataEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DebugUtilsMessengerCallbackDataEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugUtilsMessengerCallbackDataEXT" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = DebugUtilsMessengerCallbackDataFlagsEXT ( j[ "flags" ] );
  }
  if( j.find( "messageIdNumber" ) != j.end() ) {
    p.messageIdNumber = j[ "messageIdNumber" ];
  }
  if( j.find( "queueLabelCount" ) != j.end() ) {
    p.queueLabelCount = j[ "queueLabelCount" ];
  }
  if( j.find( "cmdBufLabelCount" ) != j.end() ) {
    p.cmdBufLabelCount = j[ "cmdBufLabelCount" ];
  }
  if( j.find( "objectCount" ) != j.end() ) {
    p.objectCount = j[ "objectCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDebugUtilsMessengerCallbackDataEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DebugUtilsMessengerCallbackDataEXT temp;
  from_json( j, temp );
  p = VkDebugUtilsMessengerCallbackDataEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DebugUtilsMessengerCreateFlagsEXT.hpp>
#include <vulkan2json/DebugUtilsMessageSeverityFlagsEXT.hpp>
#include <vulkan2json/DebugUtilsMessageTypeFlagsEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugUtilsMessengerCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "messageSeverity" ] = p.messageSeverity;
  j[ "messageType" ] = p.messageType;
  j[ "pfnUserCallback" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnUserCallback ) );
  j[ "pUserData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pUserData ) );
}
}
void to_json( nlohmann::json &j, const VkDebugUtilsMessengerCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DebugUtilsMessengerCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DebugUtilsMessengerCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugUtilsMessengerCreateInfoEXT" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = DebugUtilsMessengerCreateFlagsEXT ( j[ "flags" ] );
  }
  if( j.find( "messageSeverity" ) != j.end() ) {
    p.messageSeverity = DebugUtilsMessageSeverityFlagsEXT ( j[ "messageSeverity" ] );
  }
  if( j.find( "messageType" ) != j.end() ) {
    p.messageType = DebugUtilsMessageTypeFlagsEXT ( j[ "messageType" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDebugUtilsMessengerCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DebugUtilsMessengerCreateInfoEXT temp;
  from_json( j, temp );
  p = VkDebugUtilsMessengerCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ObjectType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DebugUtilsObjectTagInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "objectType" ] = p.objectType;
  j[ "objectHandle" ] = p.objectHandle;
  j[ "tagName" ] = p.tagName;
  j[ "tagSize" ] = p.tagSize;
  j[ "pTag" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pTag ) );
}
}
void to_json( nlohmann::json &j, const VkDebugUtilsObjectTagInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DebugUtilsObjectTagInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DebugUtilsObjectTagInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugUtilsObjectTagInfoEXT" );
  if( j.find( "objectType" ) != j.end() ) {
    p.objectType = ObjectType ( j[ "objectType" ] );
  }
  if( j.find( "objectHandle" ) != j.end() ) {
    p.objectHandle = j[ "objectHandle" ];
  }
  if( j.find( "tagName" ) != j.end() ) {
    p.tagName = j[ "tagName" ];
  }
  if( j.find( "tagSize" ) != j.end() ) {
    p.tagSize = j[ "tagSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDebugUtilsObjectTagInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DebugUtilsObjectTagInfoEXT temp;
  from_json( j, temp );
  p = VkDebugUtilsObjectTagInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DedicatedAllocationBufferCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dedicatedAllocation" ] = bool( p.dedicatedAllocation );
}
}
void to_json( nlohmann::json &j, const VkDedicatedAllocationBufferCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DedicatedAllocationBufferCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DedicatedAllocationBufferCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DedicatedAllocationBufferCreateInfoNV" );
  if( j.find( "dedicatedAllocation" ) != j.end() ) {
    p.dedicatedAllocation = j[ "dedicatedAllocation" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDedicatedAllocationBufferCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: DedicatedAllocationBufferCreateInfoNV temp;
  from_json( j, temp );
  p = VkDedicatedAllocationBufferCreateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DedicatedAllocationImageCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dedicatedAllocation" ] = bool( p.dedicatedAllocation );
}
}
void to_json( nlohmann::json &j, const VkDedicatedAllocationImageCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DedicatedAllocationImageCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DedicatedAllocationImageCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DedicatedAllocationImageCreateInfoNV" );
  if( j.find( "dedicatedAllocation" ) != j.end() ) {
    p.dedicatedAllocation = j[ "dedicatedAllocation" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDedicatedAllocationImageCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: DedicatedAllocationImageCreateInfoNV temp;
  from_json( j, temp );
  p = VkDedicatedAllocationImageCreateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DedicatedAllocationMemoryAllocateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkDedicatedAllocationMemoryAllocateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DedicatedAllocationMemoryAllocateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DedicatedAllocationMemoryAllocateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DedicatedAllocationMemoryAllocateInfoNV" );
}
}
void from_json( const nlohmann::json &j, VkDedicatedAllocationMemoryAllocateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: DedicatedAllocationMemoryAllocateInfoNV temp;
  from_json( j, temp );
  p = VkDedicatedAllocationMemoryAllocateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineStageFlags2KHR.hpp>
#include <vulkan2json/AccessFlags2KHR.hpp>
#include <vulkan2json/PipelineStageFlags2KHR.hpp>
#include <vulkan2json/AccessFlags2KHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryBarrier2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcStageMask" ] = p.srcStageMask;
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstStageMask" ] = p.dstStageMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
}
}
void to_json( nlohmann::json &j, const VkMemoryBarrier2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryBarrier2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryBarrier2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryBarrier2KHR" );
  if( j.find( "srcStageMask" ) != j.end() ) {
    p.srcStageMask = PipelineStageFlags2KHR ( j[ "srcStageMask" ] );
  }
  if( j.find( "srcAccessMask" ) != j.end() ) {
    p.srcAccessMask = AccessFlags2KHR ( j[ "srcAccessMask" ] );
  }
  if( j.find( "dstStageMask" ) != j.end() ) {
    p.dstStageMask = PipelineStageFlags2KHR ( j[ "dstStageMask" ] );
  }
  if( j.find( "dstAccessMask" ) != j.end() ) {
    p.dstAccessMask = AccessFlags2KHR ( j[ "dstAccessMask" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkMemoryBarrier2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryBarrier2KHR temp;
  from_json( j, temp );
  p = VkMemoryBarrier2KHR ( temp );
}
#include <vulkan2json/ImageAspectFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageSubresourceRange &p ) {
  j = nlohmann::json::object();
  j[ "aspectMask" ] = p.aspectMask;
  j[ "baseMipLevel" ] = p.baseMipLevel;
  j[ "levelCount" ] = p.levelCount;
  j[ "baseArrayLayer" ] = p.baseArrayLayer;
  j[ "layerCount" ] = p.layerCount;
}
}
void to_json( nlohmann::json &j, const VkImageSubresourceRange &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageSubresourceRange ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageSubresourceRange &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageSubresourceRange" );
  if( j.find( "aspectMask" ) != j.end() ) {
    p.aspectMask = ImageAspectFlags ( j[ "aspectMask" ] );
  }
  if( j.find( "baseMipLevel" ) != j.end() ) {
    p.baseMipLevel = j[ "baseMipLevel" ];
  }
  if( j.find( "levelCount" ) != j.end() ) {
    p.levelCount = j[ "levelCount" ];
  }
  if( j.find( "baseArrayLayer" ) != j.end() ) {
    p.baseArrayLayer = j[ "baseArrayLayer" ];
  }
  if( j.find( "layerCount" ) != j.end() ) {
    p.layerCount = j[ "layerCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkImageSubresourceRange &p ) {
  VULKAN_HPP_NAMESPACE :: ImageSubresourceRange temp;
  from_json( j, temp );
  p = VkImageSubresourceRange ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineStageFlags2KHR.hpp>
#include <vulkan2json/AccessFlags2KHR.hpp>
#include <vulkan2json/PipelineStageFlags2KHR.hpp>
#include <vulkan2json/AccessFlags2KHR.hpp>
#include <vulkan2json/ImageLayout.hpp>
#include <vulkan2json/ImageLayout.hpp>
#include <vulkan2json/ImageSubresourceRange.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageMemoryBarrier2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcStageMask" ] = p.srcStageMask;
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstStageMask" ] = p.dstStageMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
  j[ "oldLayout" ] = p.oldLayout;
  j[ "newLayout" ] = p.newLayout;
  j[ "srcQueueFamilyIndex" ] = p.srcQueueFamilyIndex;
  j[ "dstQueueFamilyIndex" ] = p.dstQueueFamilyIndex;
  j[ "subresourceRange" ] = p.subresourceRange;
}
}
void to_json( nlohmann::json &j, const VkImageMemoryBarrier2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageMemoryBarrier2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageMemoryBarrier2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageMemoryBarrier2KHR" );
  if( j.find( "srcStageMask" ) != j.end() ) {
    p.srcStageMask = PipelineStageFlags2KHR ( j[ "srcStageMask" ] );
  }
  if( j.find( "srcAccessMask" ) != j.end() ) {
    p.srcAccessMask = AccessFlags2KHR ( j[ "srcAccessMask" ] );
  }
  if( j.find( "dstStageMask" ) != j.end() ) {
    p.dstStageMask = PipelineStageFlags2KHR ( j[ "dstStageMask" ] );
  }
  if( j.find( "dstAccessMask" ) != j.end() ) {
    p.dstAccessMask = AccessFlags2KHR ( j[ "dstAccessMask" ] );
  }
  if( j.find( "oldLayout" ) != j.end() ) {
    p.oldLayout = ImageLayout ( j[ "oldLayout" ] );
  }
  if( j.find( "newLayout" ) != j.end() ) {
    p.newLayout = ImageLayout ( j[ "newLayout" ] );
  }
  if( j.find( "srcQueueFamilyIndex" ) != j.end() ) {
    p.srcQueueFamilyIndex = j[ "srcQueueFamilyIndex" ];
  }
  if( j.find( "dstQueueFamilyIndex" ) != j.end() ) {
    p.dstQueueFamilyIndex = j[ "dstQueueFamilyIndex" ];
  }
  if( j.find( "subresourceRange" ) != j.end() ) {
    p.subresourceRange = ImageSubresourceRange ( j[ "subresourceRange" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImageMemoryBarrier2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: ImageMemoryBarrier2KHR temp;
  from_json( j, temp );
  p = VkImageMemoryBarrier2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DependencyFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DependencyInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dependencyFlags" ] = p.dependencyFlags;
  j[ "memoryBarrierCount" ] = p.memoryBarrierCount;
  j[ "pMemoryBarriers" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pMemoryBarriers ) );
  j[ "bufferMemoryBarrierCount" ] = p.bufferMemoryBarrierCount;
  j[ "pBufferMemoryBarriers" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBufferMemoryBarriers ) );
  j[ "imageMemoryBarrierCount" ] = p.imageMemoryBarrierCount;
  j[ "pImageMemoryBarriers" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pImageMemoryBarriers ) );
}
}
void to_json( nlohmann::json &j, const VkDependencyInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DependencyInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DependencyInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DependencyInfoKHR" );
  if( j.find( "dependencyFlags" ) != j.end() ) {
    p.dependencyFlags = DependencyFlags ( j[ "dependencyFlags" ] );
  }
  if( j.find( "memoryBarrierCount" ) != j.end() ) {
    p.memoryBarrierCount = j[ "memoryBarrierCount" ];
  }
  if( j.find( "bufferMemoryBarrierCount" ) != j.end() ) {
    p.bufferMemoryBarrierCount = j[ "bufferMemoryBarrierCount" ];
  }
  if( j.find( "imageMemoryBarrierCount" ) != j.end() ) {
    p.imageMemoryBarrierCount = j[ "imageMemoryBarrierCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDependencyInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: DependencyInfoKHR temp;
  from_json( j, temp );
  p = VkDependencyInfoKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorBufferInfo &p ) {
  j = nlohmann::json::object();
  j[ "offset" ] = p.offset;
  j[ "range" ] = p.range;
}
}
void to_json( nlohmann::json &j, const VkDescriptorBufferInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorBufferInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorBufferInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorBufferInfo" );
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
  if( j.find( "range" ) != j.end() ) {
    p.range = j[ "range" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDescriptorBufferInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorBufferInfo temp;
  from_json( j, temp );
  p = VkDescriptorBufferInfo ( temp );
}
#include <vulkan2json/ImageLayout.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorImageInfo &p ) {
  j = nlohmann::json::object();
  j[ "imageLayout" ] = p.imageLayout;
}
}
void to_json( nlohmann::json &j, const VkDescriptorImageInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorImageInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorImageInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorImageInfo" );
  if( j.find( "imageLayout" ) != j.end() ) {
    p.imageLayout = ImageLayout ( j[ "imageLayout" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDescriptorImageInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorImageInfo temp;
  from_json( j, temp );
  p = VkDescriptorImageInfo ( temp );
}
#include <vulkan2json/DescriptorType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorPoolSize &p ) {
  j = nlohmann::json::object();
  j[ "type" ] = p.type;
  j[ "descriptorCount" ] = p.descriptorCount;
}
}
void to_json( nlohmann::json &j, const VkDescriptorPoolSize &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorPoolSize ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorPoolSize &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorPoolSize" );
  if( j.find( "type" ) != j.end() ) {
    p.type = DescriptorType ( j[ "type" ] );
  }
  if( j.find( "descriptorCount" ) != j.end() ) {
    p.descriptorCount = j[ "descriptorCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDescriptorPoolSize &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorPoolSize temp;
  from_json( j, temp );
  p = VkDescriptorPoolSize ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DescriptorPoolCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorPoolCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "maxSets" ] = p.maxSets;
  j[ "poolSizeCount" ] = p.poolSizeCount;
  j[ "pPoolSizes" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPoolSizes ) );
}
}
void to_json( nlohmann::json &j, const VkDescriptorPoolCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorPoolCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorPoolCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorPoolCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = DescriptorPoolCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "maxSets" ) != j.end() ) {
    p.maxSets = j[ "maxSets" ];
  }
  if( j.find( "poolSizeCount" ) != j.end() ) {
    p.poolSizeCount = j[ "poolSizeCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDescriptorPoolCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorPoolCreateInfo temp;
  from_json( j, temp );
  p = VkDescriptorPoolCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorPoolInlineUniformBlockCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxInlineUniformBlockBindings" ] = p.maxInlineUniformBlockBindings;
}
}
void to_json( nlohmann::json &j, const VkDescriptorPoolInlineUniformBlockCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorPoolInlineUniformBlockCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorPoolInlineUniformBlockCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorPoolInlineUniformBlockCreateInfoEXT" );
  if( j.find( "maxInlineUniformBlockBindings" ) != j.end() ) {
    p.maxInlineUniformBlockBindings = j[ "maxInlineUniformBlockBindings" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDescriptorPoolInlineUniformBlockCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorPoolInlineUniformBlockCreateInfoEXT temp;
  from_json( j, temp );
  p = VkDescriptorPoolInlineUniformBlockCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorSetAllocateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "descriptorSetCount" ] = p.descriptorSetCount;
  j[ "pSetLayouts" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSetLayouts ) );
}
}
void to_json( nlohmann::json &j, const VkDescriptorSetAllocateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorSetAllocateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorSetAllocateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorSetAllocateInfo" );
  if( j.find( "descriptorSetCount" ) != j.end() ) {
    p.descriptorSetCount = j[ "descriptorSetCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDescriptorSetAllocateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorSetAllocateInfo temp;
  from_json( j, temp );
  p = VkDescriptorSetAllocateInfo ( temp );
}
#include <vulkan2json/DescriptorType.hpp>
#include <vulkan2json/ShaderStageFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorSetLayoutBinding &p ) {
  j = nlohmann::json::object();
  j[ "binding" ] = p.binding;
  j[ "descriptorType" ] = p.descriptorType;
  j[ "descriptorCount" ] = p.descriptorCount;
  j[ "stageFlags" ] = p.stageFlags;
  j[ "pImmutableSamplers" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pImmutableSamplers ) );
}
}
void to_json( nlohmann::json &j, const VkDescriptorSetLayoutBinding &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorSetLayoutBinding ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorSetLayoutBinding &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorSetLayoutBinding" );
  if( j.find( "binding" ) != j.end() ) {
    p.binding = j[ "binding" ];
  }
  if( j.find( "descriptorType" ) != j.end() ) {
    p.descriptorType = DescriptorType ( j[ "descriptorType" ] );
  }
  if( j.find( "descriptorCount" ) != j.end() ) {
    p.descriptorCount = j[ "descriptorCount" ];
  }
  if( j.find( "stageFlags" ) != j.end() ) {
    p.stageFlags = ShaderStageFlags ( j[ "stageFlags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDescriptorSetLayoutBinding &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorSetLayoutBinding temp;
  from_json( j, temp );
  p = VkDescriptorSetLayoutBinding ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorSetLayoutBindingFlagsCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "bindingCount" ] = p.bindingCount;
  j[ "pBindingFlags" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBindingFlags ) );
}
}
void to_json( nlohmann::json &j, const VkDescriptorSetLayoutBindingFlagsCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorSetLayoutBindingFlagsCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorSetLayoutBindingFlagsCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorSetLayoutBindingFlagsCreateInfo" );
  if( j.find( "bindingCount" ) != j.end() ) {
    p.bindingCount = j[ "bindingCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDescriptorSetLayoutBindingFlagsCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorSetLayoutBindingFlagsCreateInfo temp;
  from_json( j, temp );
  p = VkDescriptorSetLayoutBindingFlagsCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DescriptorSetLayoutCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorSetLayoutCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "bindingCount" ] = p.bindingCount;
  j[ "pBindings" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBindings ) );
}
}
void to_json( nlohmann::json &j, const VkDescriptorSetLayoutCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorSetLayoutCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorSetLayoutCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorSetLayoutCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = DescriptorSetLayoutCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "bindingCount" ) != j.end() ) {
    p.bindingCount = j[ "bindingCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDescriptorSetLayoutCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorSetLayoutCreateInfo temp;
  from_json( j, temp );
  p = VkDescriptorSetLayoutCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorSetLayoutSupport &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "supported" ] = bool( p.supported );
}
}
void to_json( nlohmann::json &j, const VkDescriptorSetLayoutSupport &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorSetLayoutSupport ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorSetLayoutSupport &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorSetLayoutSupport" );
  if( j.find( "supported" ) != j.end() ) {
    p.supported = j[ "supported" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDescriptorSetLayoutSupport &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorSetLayoutSupport temp;
  from_json( j, temp );
  p = VkDescriptorSetLayoutSupport ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorSetVariableDescriptorCountAllocateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "descriptorSetCount" ] = p.descriptorSetCount;
  j[ "pDescriptorCounts" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDescriptorCounts ) );
}
}
void to_json( nlohmann::json &j, const VkDescriptorSetVariableDescriptorCountAllocateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorSetVariableDescriptorCountAllocateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorSetVariableDescriptorCountAllocateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorSetVariableDescriptorCountAllocateInfo" );
  if( j.find( "descriptorSetCount" ) != j.end() ) {
    p.descriptorSetCount = j[ "descriptorSetCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDescriptorSetVariableDescriptorCountAllocateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorSetVariableDescriptorCountAllocateInfo temp;
  from_json( j, temp );
  p = VkDescriptorSetVariableDescriptorCountAllocateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorSetVariableDescriptorCountLayoutSupport &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxVariableDescriptorCount" ] = p.maxVariableDescriptorCount;
}
}
void to_json( nlohmann::json &j, const VkDescriptorSetVariableDescriptorCountLayoutSupport &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorSetVariableDescriptorCountLayoutSupport ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorSetVariableDescriptorCountLayoutSupport &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorSetVariableDescriptorCountLayoutSupport" );
  if( j.find( "maxVariableDescriptorCount" ) != j.end() ) {
    p.maxVariableDescriptorCount = j[ "maxVariableDescriptorCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDescriptorSetVariableDescriptorCountLayoutSupport &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorSetVariableDescriptorCountLayoutSupport temp;
  from_json( j, temp );
  p = VkDescriptorSetVariableDescriptorCountLayoutSupport ( temp );
}
#include <vulkan2json/DescriptorType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorUpdateTemplateEntry &p ) {
  j = nlohmann::json::object();
  j[ "dstBinding" ] = p.dstBinding;
  j[ "dstArrayElement" ] = p.dstArrayElement;
  j[ "descriptorCount" ] = p.descriptorCount;
  j[ "descriptorType" ] = p.descriptorType;
  j[ "offset" ] = p.offset;
  j[ "stride" ] = p.stride;
}
}
void to_json( nlohmann::json &j, const VkDescriptorUpdateTemplateEntry &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorUpdateTemplateEntry ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorUpdateTemplateEntry &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorUpdateTemplateEntry" );
  if( j.find( "dstBinding" ) != j.end() ) {
    p.dstBinding = j[ "dstBinding" ];
  }
  if( j.find( "dstArrayElement" ) != j.end() ) {
    p.dstArrayElement = j[ "dstArrayElement" ];
  }
  if( j.find( "descriptorCount" ) != j.end() ) {
    p.descriptorCount = j[ "descriptorCount" ];
  }
  if( j.find( "descriptorType" ) != j.end() ) {
    p.descriptorType = DescriptorType ( j[ "descriptorType" ] );
  }
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
  if( j.find( "stride" ) != j.end() ) {
    p.stride = j[ "stride" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDescriptorUpdateTemplateEntry &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorUpdateTemplateEntry temp;
  from_json( j, temp );
  p = VkDescriptorUpdateTemplateEntry ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DescriptorUpdateTemplateCreateFlags.hpp>
#include <vulkan2json/DescriptorUpdateTemplateType.hpp>
#include <vulkan2json/PipelineBindPoint.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DescriptorUpdateTemplateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "descriptorUpdateEntryCount" ] = p.descriptorUpdateEntryCount;
  j[ "pDescriptorUpdateEntries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDescriptorUpdateEntries ) );
  j[ "templateType" ] = p.templateType;
  j[ "pipelineBindPoint" ] = p.pipelineBindPoint;
  j[ "set" ] = p.set;
}
}
void to_json( nlohmann::json &j, const VkDescriptorUpdateTemplateCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DescriptorUpdateTemplateCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DescriptorUpdateTemplateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorUpdateTemplateCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = DescriptorUpdateTemplateCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "descriptorUpdateEntryCount" ) != j.end() ) {
    p.descriptorUpdateEntryCount = j[ "descriptorUpdateEntryCount" ];
  }
  if( j.find( "templateType" ) != j.end() ) {
    p.templateType = DescriptorUpdateTemplateType ( j[ "templateType" ] );
  }
  if( j.find( "pipelineBindPoint" ) != j.end() ) {
    p.pipelineBindPoint = PipelineBindPoint ( j[ "pipelineBindPoint" ] );
  }
  if( j.find( "set" ) != j.end() ) {
    p.set = j[ "set" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDescriptorUpdateTemplateCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DescriptorUpdateTemplateCreateInfo temp;
  from_json( j, temp );
  p = VkDescriptorUpdateTemplateCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DeviceQueueCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceQueueCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "queueFamilyIndex" ] = p.queueFamilyIndex;
  j[ "queueCount" ] = p.queueCount;
  j[ "pQueuePriorities" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pQueuePriorities ) );
}
}
void to_json( nlohmann::json &j, const VkDeviceQueueCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceQueueCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceQueueCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceQueueCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = DeviceQueueCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "queueFamilyIndex" ) != j.end() ) {
    p.queueFamilyIndex = j[ "queueFamilyIndex" ];
  }
  if( j.find( "queueCount" ) != j.end() ) {
    p.queueCount = j[ "queueCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceQueueCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceQueueCreateInfo temp;
  from_json( j, temp );
  p = VkDeviceQueueCreateInfo ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceFeatures &p ) {
  j = nlohmann::json::object();
  j[ "robustBufferAccess" ] = bool( p.robustBufferAccess );
  j[ "fullDrawIndexUint32" ] = bool( p.fullDrawIndexUint32 );
  j[ "imageCubeArray" ] = bool( p.imageCubeArray );
  j[ "independentBlend" ] = bool( p.independentBlend );
  j[ "geometryShader" ] = bool( p.geometryShader );
  j[ "tessellationShader" ] = bool( p.tessellationShader );
  j[ "sampleRateShading" ] = bool( p.sampleRateShading );
  j[ "dualSrcBlend" ] = bool( p.dualSrcBlend );
  j[ "logicOp" ] = bool( p.logicOp );
  j[ "multiDrawIndirect" ] = bool( p.multiDrawIndirect );
  j[ "drawIndirectFirstInstance" ] = bool( p.drawIndirectFirstInstance );
  j[ "depthClamp" ] = bool( p.depthClamp );
  j[ "depthBiasClamp" ] = bool( p.depthBiasClamp );
  j[ "fillModeNonSolid" ] = bool( p.fillModeNonSolid );
  j[ "depthBounds" ] = bool( p.depthBounds );
  j[ "wideLines" ] = bool( p.wideLines );
  j[ "largePoints" ] = bool( p.largePoints );
  j[ "alphaToOne" ] = bool( p.alphaToOne );
  j[ "multiViewport" ] = bool( p.multiViewport );
  j[ "samplerAnisotropy" ] = bool( p.samplerAnisotropy );
  j[ "textureCompressionETC2" ] = bool( p.textureCompressionETC2 );
  j[ "textureCompressionASTC_LDR" ] = bool( p.textureCompressionASTC_LDR );
  j[ "textureCompressionBC" ] = bool( p.textureCompressionBC );
  j[ "occlusionQueryPrecise" ] = bool( p.occlusionQueryPrecise );
  j[ "pipelineStatisticsQuery" ] = bool( p.pipelineStatisticsQuery );
  j[ "vertexPipelineStoresAndAtomics" ] = bool( p.vertexPipelineStoresAndAtomics );
  j[ "fragmentStoresAndAtomics" ] = bool( p.fragmentStoresAndAtomics );
  j[ "shaderTessellationAndGeometryPointSize" ] = bool( p.shaderTessellationAndGeometryPointSize );
  j[ "shaderImageGatherExtended" ] = bool( p.shaderImageGatherExtended );
  j[ "shaderStorageImageExtendedFormats" ] = bool( p.shaderStorageImageExtendedFormats );
  j[ "shaderStorageImageMultisample" ] = bool( p.shaderStorageImageMultisample );
  j[ "shaderStorageImageReadWithoutFormat" ] = bool( p.shaderStorageImageReadWithoutFormat );
  j[ "shaderStorageImageWriteWithoutFormat" ] = bool( p.shaderStorageImageWriteWithoutFormat );
  j[ "shaderUniformBufferArrayDynamicIndexing" ] = bool( p.shaderUniformBufferArrayDynamicIndexing );
  j[ "shaderSampledImageArrayDynamicIndexing" ] = bool( p.shaderSampledImageArrayDynamicIndexing );
  j[ "shaderStorageBufferArrayDynamicIndexing" ] = bool( p.shaderStorageBufferArrayDynamicIndexing );
  j[ "shaderStorageImageArrayDynamicIndexing" ] = bool( p.shaderStorageImageArrayDynamicIndexing );
  j[ "shaderClipDistance" ] = bool( p.shaderClipDistance );
  j[ "shaderCullDistance" ] = bool( p.shaderCullDistance );
  j[ "shaderFloat64" ] = bool( p.shaderFloat64 );
  j[ "shaderInt64" ] = bool( p.shaderInt64 );
  j[ "shaderInt16" ] = bool( p.shaderInt16 );
  j[ "shaderResourceResidency" ] = bool( p.shaderResourceResidency );
  j[ "shaderResourceMinLod" ] = bool( p.shaderResourceMinLod );
  j[ "sparseBinding" ] = bool( p.sparseBinding );
  j[ "sparseResidencyBuffer" ] = bool( p.sparseResidencyBuffer );
  j[ "sparseResidencyImage2D" ] = bool( p.sparseResidencyImage2D );
  j[ "sparseResidencyImage3D" ] = bool( p.sparseResidencyImage3D );
  j[ "sparseResidency2Samples" ] = bool( p.sparseResidency2Samples );
  j[ "sparseResidency4Samples" ] = bool( p.sparseResidency4Samples );
  j[ "sparseResidency8Samples" ] = bool( p.sparseResidency8Samples );
  j[ "sparseResidency16Samples" ] = bool( p.sparseResidency16Samples );
  j[ "sparseResidencyAliased" ] = bool( p.sparseResidencyAliased );
  j[ "variableMultisampleRate" ] = bool( p.variableMultisampleRate );
  j[ "inheritedQueries" ] = bool( p.inheritedQueries );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFeatures" );
  if( j.find( "robustBufferAccess" ) != j.end() ) {
    p.robustBufferAccess = j[ "robustBufferAccess" ];
  }
  if( j.find( "fullDrawIndexUint32" ) != j.end() ) {
    p.fullDrawIndexUint32 = j[ "fullDrawIndexUint32" ];
  }
  if( j.find( "imageCubeArray" ) != j.end() ) {
    p.imageCubeArray = j[ "imageCubeArray" ];
  }
  if( j.find( "independentBlend" ) != j.end() ) {
    p.independentBlend = j[ "independentBlend" ];
  }
  if( j.find( "geometryShader" ) != j.end() ) {
    p.geometryShader = j[ "geometryShader" ];
  }
  if( j.find( "tessellationShader" ) != j.end() ) {
    p.tessellationShader = j[ "tessellationShader" ];
  }
  if( j.find( "sampleRateShading" ) != j.end() ) {
    p.sampleRateShading = j[ "sampleRateShading" ];
  }
  if( j.find( "dualSrcBlend" ) != j.end() ) {
    p.dualSrcBlend = j[ "dualSrcBlend" ];
  }
  if( j.find( "logicOp" ) != j.end() ) {
    p.logicOp = j[ "logicOp" ];
  }
  if( j.find( "multiDrawIndirect" ) != j.end() ) {
    p.multiDrawIndirect = j[ "multiDrawIndirect" ];
  }
  if( j.find( "drawIndirectFirstInstance" ) != j.end() ) {
    p.drawIndirectFirstInstance = j[ "drawIndirectFirstInstance" ];
  }
  if( j.find( "depthClamp" ) != j.end() ) {
    p.depthClamp = j[ "depthClamp" ];
  }
  if( j.find( "depthBiasClamp" ) != j.end() ) {
    p.depthBiasClamp = j[ "depthBiasClamp" ];
  }
  if( j.find( "fillModeNonSolid" ) != j.end() ) {
    p.fillModeNonSolid = j[ "fillModeNonSolid" ];
  }
  if( j.find( "depthBounds" ) != j.end() ) {
    p.depthBounds = j[ "depthBounds" ];
  }
  if( j.find( "wideLines" ) != j.end() ) {
    p.wideLines = j[ "wideLines" ];
  }
  if( j.find( "largePoints" ) != j.end() ) {
    p.largePoints = j[ "largePoints" ];
  }
  if( j.find( "alphaToOne" ) != j.end() ) {
    p.alphaToOne = j[ "alphaToOne" ];
  }
  if( j.find( "multiViewport" ) != j.end() ) {
    p.multiViewport = j[ "multiViewport" ];
  }
  if( j.find( "samplerAnisotropy" ) != j.end() ) {
    p.samplerAnisotropy = j[ "samplerAnisotropy" ];
  }
  if( j.find( "textureCompressionETC2" ) != j.end() ) {
    p.textureCompressionETC2 = j[ "textureCompressionETC2" ];
  }
  if( j.find( "textureCompressionASTC_LDR" ) != j.end() ) {
    p.textureCompressionASTC_LDR = j[ "textureCompressionASTC_LDR" ];
  }
  if( j.find( "textureCompressionBC" ) != j.end() ) {
    p.textureCompressionBC = j[ "textureCompressionBC" ];
  }
  if( j.find( "occlusionQueryPrecise" ) != j.end() ) {
    p.occlusionQueryPrecise = j[ "occlusionQueryPrecise" ];
  }
  if( j.find( "pipelineStatisticsQuery" ) != j.end() ) {
    p.pipelineStatisticsQuery = j[ "pipelineStatisticsQuery" ];
  }
  if( j.find( "vertexPipelineStoresAndAtomics" ) != j.end() ) {
    p.vertexPipelineStoresAndAtomics = j[ "vertexPipelineStoresAndAtomics" ];
  }
  if( j.find( "fragmentStoresAndAtomics" ) != j.end() ) {
    p.fragmentStoresAndAtomics = j[ "fragmentStoresAndAtomics" ];
  }
  if( j.find( "shaderTessellationAndGeometryPointSize" ) != j.end() ) {
    p.shaderTessellationAndGeometryPointSize = j[ "shaderTessellationAndGeometryPointSize" ];
  }
  if( j.find( "shaderImageGatherExtended" ) != j.end() ) {
    p.shaderImageGatherExtended = j[ "shaderImageGatherExtended" ];
  }
  if( j.find( "shaderStorageImageExtendedFormats" ) != j.end() ) {
    p.shaderStorageImageExtendedFormats = j[ "shaderStorageImageExtendedFormats" ];
  }
  if( j.find( "shaderStorageImageMultisample" ) != j.end() ) {
    p.shaderStorageImageMultisample = j[ "shaderStorageImageMultisample" ];
  }
  if( j.find( "shaderStorageImageReadWithoutFormat" ) != j.end() ) {
    p.shaderStorageImageReadWithoutFormat = j[ "shaderStorageImageReadWithoutFormat" ];
  }
  if( j.find( "shaderStorageImageWriteWithoutFormat" ) != j.end() ) {
    p.shaderStorageImageWriteWithoutFormat = j[ "shaderStorageImageWriteWithoutFormat" ];
  }
  if( j.find( "shaderUniformBufferArrayDynamicIndexing" ) != j.end() ) {
    p.shaderUniformBufferArrayDynamicIndexing = j[ "shaderUniformBufferArrayDynamicIndexing" ];
  }
  if( j.find( "shaderSampledImageArrayDynamicIndexing" ) != j.end() ) {
    p.shaderSampledImageArrayDynamicIndexing = j[ "shaderSampledImageArrayDynamicIndexing" ];
  }
  if( j.find( "shaderStorageBufferArrayDynamicIndexing" ) != j.end() ) {
    p.shaderStorageBufferArrayDynamicIndexing = j[ "shaderStorageBufferArrayDynamicIndexing" ];
  }
  if( j.find( "shaderStorageImageArrayDynamicIndexing" ) != j.end() ) {
    p.shaderStorageImageArrayDynamicIndexing = j[ "shaderStorageImageArrayDynamicIndexing" ];
  }
  if( j.find( "shaderClipDistance" ) != j.end() ) {
    p.shaderClipDistance = j[ "shaderClipDistance" ];
  }
  if( j.find( "shaderCullDistance" ) != j.end() ) {
    p.shaderCullDistance = j[ "shaderCullDistance" ];
  }
  if( j.find( "shaderFloat64" ) != j.end() ) {
    p.shaderFloat64 = j[ "shaderFloat64" ];
  }
  if( j.find( "shaderInt64" ) != j.end() ) {
    p.shaderInt64 = j[ "shaderInt64" ];
  }
  if( j.find( "shaderInt16" ) != j.end() ) {
    p.shaderInt16 = j[ "shaderInt16" ];
  }
  if( j.find( "shaderResourceResidency" ) != j.end() ) {
    p.shaderResourceResidency = j[ "shaderResourceResidency" ];
  }
  if( j.find( "shaderResourceMinLod" ) != j.end() ) {
    p.shaderResourceMinLod = j[ "shaderResourceMinLod" ];
  }
  if( j.find( "sparseBinding" ) != j.end() ) {
    p.sparseBinding = j[ "sparseBinding" ];
  }
  if( j.find( "sparseResidencyBuffer" ) != j.end() ) {
    p.sparseResidencyBuffer = j[ "sparseResidencyBuffer" ];
  }
  if( j.find( "sparseResidencyImage2D" ) != j.end() ) {
    p.sparseResidencyImage2D = j[ "sparseResidencyImage2D" ];
  }
  if( j.find( "sparseResidencyImage3D" ) != j.end() ) {
    p.sparseResidencyImage3D = j[ "sparseResidencyImage3D" ];
  }
  if( j.find( "sparseResidency2Samples" ) != j.end() ) {
    p.sparseResidency2Samples = j[ "sparseResidency2Samples" ];
  }
  if( j.find( "sparseResidency4Samples" ) != j.end() ) {
    p.sparseResidency4Samples = j[ "sparseResidency4Samples" ];
  }
  if( j.find( "sparseResidency8Samples" ) != j.end() ) {
    p.sparseResidency8Samples = j[ "sparseResidency8Samples" ];
  }
  if( j.find( "sparseResidency16Samples" ) != j.end() ) {
    p.sparseResidency16Samples = j[ "sparseResidency16Samples" ];
  }
  if( j.find( "sparseResidencyAliased" ) != j.end() ) {
    p.sparseResidencyAliased = j[ "sparseResidencyAliased" ];
  }
  if( j.find( "variableMultisampleRate" ) != j.end() ) {
    p.variableMultisampleRate = j[ "variableMultisampleRate" ];
  }
  if( j.find( "inheritedQueries" ) != j.end() ) {
    p.inheritedQueries = j[ "inheritedQueries" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DeviceCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "queueCreateInfoCount" ] = p.queueCreateInfoCount;
  j[ "pQueueCreateInfos" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pQueueCreateInfos ) );
  j[ "enabledLayerCount" ] = p.enabledLayerCount;
  j[ "ppEnabledLayerNames" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.ppEnabledLayerNames ) );
  j[ "enabledExtensionCount" ] = p.enabledExtensionCount;
  j[ "ppEnabledExtensionNames" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.ppEnabledExtensionNames ) );
  j[ "pEnabledFeatures" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pEnabledFeatures ) );
}
}
void to_json( nlohmann::json &j, const VkDeviceCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = DeviceCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "queueCreateInfoCount" ) != j.end() ) {
    p.queueCreateInfoCount = j[ "queueCreateInfoCount" ];
  }
  if( j.find( "enabledLayerCount" ) != j.end() ) {
    p.enabledLayerCount = j[ "enabledLayerCount" ];
  }
  if( j.find( "enabledExtensionCount" ) != j.end() ) {
    p.enabledExtensionCount = j[ "enabledExtensionCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceCreateInfo temp;
  from_json( j, temp );
  p = VkDeviceCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DeviceMemoryReportFlagsEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceDeviceMemoryReportCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pfnUserCallback" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnUserCallback ) );
  j[ "pUserData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pUserData ) );
}
}
void to_json( nlohmann::json &j, const VkDeviceDeviceMemoryReportCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceDeviceMemoryReportCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceDeviceMemoryReportCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceDeviceMemoryReportCreateInfoEXT" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = DeviceMemoryReportFlagsEXT ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceDeviceMemoryReportCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceDeviceMemoryReportCreateInfoEXT temp;
  from_json( j, temp );
  p = VkDeviceDeviceMemoryReportCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DeviceDiagnosticsConfigFlagsNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceDiagnosticsConfigCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkDeviceDiagnosticsConfigCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceDiagnosticsConfigCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceDiagnosticsConfigCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceDiagnosticsConfigCreateInfoNV" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = DeviceDiagnosticsConfigFlagsNV ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceDiagnosticsConfigCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceDiagnosticsConfigCreateInfoNV temp;
  from_json( j, temp );
  p = VkDeviceDiagnosticsConfigCreateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DeviceEventTypeEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceEventInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceEvent" ] = p.deviceEvent;
}
}
void to_json( nlohmann::json &j, const VkDeviceEventInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceEventInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceEventInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceEventInfoEXT" );
  if( j.find( "deviceEvent" ) != j.end() ) {
    p.deviceEvent = DeviceEventTypeEXT ( j[ "deviceEvent" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceEventInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceEventInfoEXT temp;
  from_json( j, temp );
  p = VkDeviceEventInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceGroupBindSparseInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "resourceDeviceIndex" ] = p.resourceDeviceIndex;
  j[ "memoryDeviceIndex" ] = p.memoryDeviceIndex;
}
}
void to_json( nlohmann::json &j, const VkDeviceGroupBindSparseInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceGroupBindSparseInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceGroupBindSparseInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupBindSparseInfo" );
  if( j.find( "resourceDeviceIndex" ) != j.end() ) {
    p.resourceDeviceIndex = j[ "resourceDeviceIndex" ];
  }
  if( j.find( "memoryDeviceIndex" ) != j.end() ) {
    p.memoryDeviceIndex = j[ "memoryDeviceIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceGroupBindSparseInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceGroupBindSparseInfo temp;
  from_json( j, temp );
  p = VkDeviceGroupBindSparseInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceGroupCommandBufferBeginInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceMask" ] = p.deviceMask;
}
}
void to_json( nlohmann::json &j, const VkDeviceGroupCommandBufferBeginInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceGroupCommandBufferBeginInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceGroupCommandBufferBeginInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupCommandBufferBeginInfo" );
  if( j.find( "deviceMask" ) != j.end() ) {
    p.deviceMask = j[ "deviceMask" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceGroupCommandBufferBeginInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceGroupCommandBufferBeginInfo temp;
  from_json( j, temp );
  p = VkDeviceGroupCommandBufferBeginInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceGroupDeviceCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "physicalDeviceCount" ] = p.physicalDeviceCount;
  j[ "pPhysicalDevices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPhysicalDevices ) );
}
}
void to_json( nlohmann::json &j, const VkDeviceGroupDeviceCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceGroupDeviceCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceGroupDeviceCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupDeviceCreateInfo" );
  if( j.find( "physicalDeviceCount" ) != j.end() ) {
    p.physicalDeviceCount = j[ "physicalDeviceCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceGroupDeviceCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceGroupDeviceCreateInfo temp;
  from_json( j, temp );
  p = VkDeviceGroupDeviceCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DeviceGroupPresentModeFlagsKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceGroupPresentCapabilitiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "presentMask" ] = nlohmann::json::array();
  std::copy( p.presentMask.begin(), p.presentMask.end(), std::back_inserter( j[ "presentMask" ] ) );
  j[ "modes" ] = p.modes;
}
}
void to_json( nlohmann::json &j, const VkDeviceGroupPresentCapabilitiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceGroupPresentCapabilitiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceGroupPresentCapabilitiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupPresentCapabilitiesKHR" );
  if( j.find( "presentMask" ) != j.end() ) {
    if( !j[ "presentMask" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for DeviceGroupPresentCapabilitiesKHR.presentMask" );
    if( !j[ "presentMask" ].size() > p.presentMask.size() ) throw vulkan2json::invalid_array_value( "too many values in array for DeviceGroupPresentCapabilitiesKHR.presentMask" );
    std::fill( p.presentMask.begin(), p.presentMask.end(), 0 );
    std::copy( j[ "presentMask" ].begin(), j[ "presentMask" ].end(), p.presentMask.begin() );
  }
  if( j.find( "modes" ) != j.end() ) {
    p.modes = DeviceGroupPresentModeFlagsKHR ( j[ "modes" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceGroupPresentCapabilitiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceGroupPresentCapabilitiesKHR temp;
  from_json( j, temp );
  p = VkDeviceGroupPresentCapabilitiesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DeviceGroupPresentModeFlagsKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceGroupPresentInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "swapchainCount" ] = p.swapchainCount;
  j[ "pDeviceMasks" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDeviceMasks ) );
  j[ "mode" ] = p.mode;
}
}
void to_json( nlohmann::json &j, const VkDeviceGroupPresentInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceGroupPresentInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceGroupPresentInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupPresentInfoKHR" );
  if( j.find( "swapchainCount" ) != j.end() ) {
    p.swapchainCount = j[ "swapchainCount" ];
  }
  if( j.find( "mode" ) != j.end() ) {
    p.mode = DeviceGroupPresentModeFlagBitsKHR ( j[ "mode" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceGroupPresentInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceGroupPresentInfoKHR temp;
  from_json( j, temp );
  p = VkDeviceGroupPresentInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceGroupRenderPassBeginInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceMask" ] = p.deviceMask;
  j[ "deviceRenderAreaCount" ] = p.deviceRenderAreaCount;
  j[ "pDeviceRenderAreas" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDeviceRenderAreas ) );
}
}
void to_json( nlohmann::json &j, const VkDeviceGroupRenderPassBeginInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceGroupRenderPassBeginInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceGroupRenderPassBeginInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupRenderPassBeginInfo" );
  if( j.find( "deviceMask" ) != j.end() ) {
    p.deviceMask = j[ "deviceMask" ];
  }
  if( j.find( "deviceRenderAreaCount" ) != j.end() ) {
    p.deviceRenderAreaCount = j[ "deviceRenderAreaCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceGroupRenderPassBeginInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceGroupRenderPassBeginInfo temp;
  from_json( j, temp );
  p = VkDeviceGroupRenderPassBeginInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceGroupSubmitInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "waitSemaphoreCount" ] = p.waitSemaphoreCount;
  j[ "pWaitSemaphoreDeviceIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitSemaphoreDeviceIndices ) );
  j[ "commandBufferCount" ] = p.commandBufferCount;
  j[ "pCommandBufferDeviceMasks" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCommandBufferDeviceMasks ) );
  j[ "signalSemaphoreCount" ] = p.signalSemaphoreCount;
  j[ "pSignalSemaphoreDeviceIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSignalSemaphoreDeviceIndices ) );
}
}
void to_json( nlohmann::json &j, const VkDeviceGroupSubmitInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceGroupSubmitInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceGroupSubmitInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupSubmitInfo" );
  if( j.find( "waitSemaphoreCount" ) != j.end() ) {
    p.waitSemaphoreCount = j[ "waitSemaphoreCount" ];
  }
  if( j.find( "commandBufferCount" ) != j.end() ) {
    p.commandBufferCount = j[ "commandBufferCount" ];
  }
  if( j.find( "signalSemaphoreCount" ) != j.end() ) {
    p.signalSemaphoreCount = j[ "signalSemaphoreCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceGroupSubmitInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceGroupSubmitInfo temp;
  from_json( j, temp );
  p = VkDeviceGroupSubmitInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DeviceGroupPresentModeFlagsKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceGroupSwapchainCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "modes" ] = p.modes;
}
}
void to_json( nlohmann::json &j, const VkDeviceGroupSwapchainCreateInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceGroupSwapchainCreateInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceGroupSwapchainCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupSwapchainCreateInfoKHR" );
  if( j.find( "modes" ) != j.end() ) {
    p.modes = DeviceGroupPresentModeFlagsKHR ( j[ "modes" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceGroupSwapchainCreateInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceGroupSwapchainCreateInfoKHR temp;
  from_json( j, temp );
  p = VkDeviceGroupSwapchainCreateInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceMemoryOpaqueCaptureAddressInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkDeviceMemoryOpaqueCaptureAddressInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceMemoryOpaqueCaptureAddressInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceMemoryOpaqueCaptureAddressInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceMemoryOpaqueCaptureAddressInfo" );
}
}
void from_json( const nlohmann::json &j, VkDeviceMemoryOpaqueCaptureAddressInfo &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceMemoryOpaqueCaptureAddressInfo temp;
  from_json( j, temp );
  p = VkDeviceMemoryOpaqueCaptureAddressInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/MemoryOverallocationBehaviorAMD.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceMemoryOverallocationCreateInfoAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "overallocationBehavior" ] = p.overallocationBehavior;
}
}
void to_json( nlohmann::json &j, const VkDeviceMemoryOverallocationCreateInfoAMD &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceMemoryOverallocationCreateInfoAMD ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceMemoryOverallocationCreateInfoAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceMemoryOverallocationCreateInfoAMD" );
  if( j.find( "overallocationBehavior" ) != j.end() ) {
    p.overallocationBehavior = MemoryOverallocationBehaviorAMD ( j[ "overallocationBehavior" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceMemoryOverallocationCreateInfoAMD &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceMemoryOverallocationCreateInfoAMD temp;
  from_json( j, temp );
  p = VkDeviceMemoryOverallocationCreateInfoAMD ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DeviceMemoryReportFlagsEXT.hpp>
#include <vulkan2json/DeviceMemoryReportEventTypeEXT.hpp>
#include <vulkan2json/ObjectType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceMemoryReportCallbackDataEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "type" ] = p.type;
  j[ "memoryObjectId" ] = p.memoryObjectId;
  j[ "size" ] = p.size;
  j[ "objectType" ] = p.objectType;
  j[ "objectHandle" ] = p.objectHandle;
  j[ "heapIndex" ] = p.heapIndex;
}
}
void to_json( nlohmann::json &j, const VkDeviceMemoryReportCallbackDataEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceMemoryReportCallbackDataEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceMemoryReportCallbackDataEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceMemoryReportCallbackDataEXT" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = DeviceMemoryReportFlagsEXT ( j[ "flags" ] );
  }
  if( j.find( "type" ) != j.end() ) {
    p.type = DeviceMemoryReportEventTypeEXT ( j[ "type" ] );
  }
  if( j.find( "memoryObjectId" ) != j.end() ) {
    p.memoryObjectId = j[ "memoryObjectId" ];
  }
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
  if( j.find( "objectType" ) != j.end() ) {
    p.objectType = ObjectType ( j[ "objectType" ] );
  }
  if( j.find( "objectHandle" ) != j.end() ) {
    p.objectHandle = j[ "objectHandle" ];
  }
  if( j.find( "heapIndex" ) != j.end() ) {
    p.heapIndex = j[ "heapIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceMemoryReportCallbackDataEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceMemoryReportCallbackDataEXT temp;
  from_json( j, temp );
  p = VkDeviceMemoryReportCallbackDataEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DevicePrivateDataCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "privateDataSlotRequestCount" ] = p.privateDataSlotRequestCount;
}
}
void to_json( nlohmann::json &j, const VkDevicePrivateDataCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DevicePrivateDataCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DevicePrivateDataCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DevicePrivateDataCreateInfoEXT" );
  if( j.find( "privateDataSlotRequestCount" ) != j.end() ) {
    p.privateDataSlotRequestCount = j[ "privateDataSlotRequestCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDevicePrivateDataCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DevicePrivateDataCreateInfoEXT temp;
  from_json( j, temp );
  p = VkDevicePrivateDataCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/QueueGlobalPriorityEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceQueueGlobalPriorityCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "globalPriority" ] = p.globalPriority;
}
}
void to_json( nlohmann::json &j, const VkDeviceQueueGlobalPriorityCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceQueueGlobalPriorityCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceQueueGlobalPriorityCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceQueueGlobalPriorityCreateInfoEXT" );
  if( j.find( "globalPriority" ) != j.end() ) {
    p.globalPriority = QueueGlobalPriorityEXT ( j[ "globalPriority" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceQueueGlobalPriorityCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceQueueGlobalPriorityCreateInfoEXT temp;
  from_json( j, temp );
  p = VkDeviceQueueGlobalPriorityCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DeviceQueueCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DeviceQueueInfo2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "queueFamilyIndex" ] = p.queueFamilyIndex;
  j[ "queueIndex" ] = p.queueIndex;
}
}
void to_json( nlohmann::json &j, const VkDeviceQueueInfo2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DeviceQueueInfo2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DeviceQueueInfo2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceQueueInfo2" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = DeviceQueueCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "queueFamilyIndex" ) != j.end() ) {
    p.queueFamilyIndex = j[ "queueFamilyIndex" ];
  }
  if( j.find( "queueIndex" ) != j.end() ) {
    p.queueIndex = j[ "queueIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDeviceQueueInfo2 &p ) {
  VULKAN_HPP_NAMESPACE :: DeviceQueueInfo2 temp;
  from_json( j, temp );
  p = VkDeviceQueueInfo2 ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DispatchIndirectCommand &p ) {
  j = nlohmann::json::object();
  j[ "x" ] = p.x;
  j[ "y" ] = p.y;
  j[ "z" ] = p.z;
}
}
void to_json( nlohmann::json &j, const VkDispatchIndirectCommand &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DispatchIndirectCommand ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DispatchIndirectCommand &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DispatchIndirectCommand" );
  if( j.find( "x" ) != j.end() ) {
    p.x = j[ "x" ];
  }
  if( j.find( "y" ) != j.end() ) {
    p.y = j[ "y" ];
  }
  if( j.find( "z" ) != j.end() ) {
    p.z = j[ "z" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDispatchIndirectCommand &p ) {
  VULKAN_HPP_NAMESPACE :: DispatchIndirectCommand temp;
  from_json( j, temp );
  p = VkDispatchIndirectCommand ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DisplayEventTypeEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayEventInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "displayEvent" ] = p.displayEvent;
}
}
void to_json( nlohmann::json &j, const VkDisplayEventInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayEventInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayEventInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayEventInfoEXT" );
  if( j.find( "displayEvent" ) != j.end() ) {
    p.displayEvent = DisplayEventTypeEXT ( j[ "displayEvent" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayEventInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayEventInfoEXT temp;
  from_json( j, temp );
  p = VkDisplayEventInfoEXT ( temp );
}
#include <vulkan2json/Extent2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayModeParametersKHR &p ) {
  j = nlohmann::json::object();
  j[ "visibleRegion" ] = p.visibleRegion;
  j[ "refreshRate" ] = p.refreshRate;
}
}
void to_json( nlohmann::json &j, const VkDisplayModeParametersKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayModeParametersKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayModeParametersKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayModeParametersKHR" );
  if( j.find( "visibleRegion" ) != j.end() ) {
    p.visibleRegion = Extent2D ( j[ "visibleRegion" ] );
  }
  if( j.find( "refreshRate" ) != j.end() ) {
    p.refreshRate = j[ "refreshRate" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayModeParametersKHR &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayModeParametersKHR temp;
  from_json( j, temp );
  p = VkDisplayModeParametersKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DisplayModeCreateFlagsKHR.hpp>
#include <vulkan2json/DisplayModeParametersKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayModeCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "parameters" ] = p.parameters;
}
}
void to_json( nlohmann::json &j, const VkDisplayModeCreateInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayModeCreateInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayModeCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayModeCreateInfoKHR" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = DisplayModeCreateFlagsKHR ( j[ "flags" ] );
  }
  if( j.find( "parameters" ) != j.end() ) {
    p.parameters = DisplayModeParametersKHR ( j[ "parameters" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayModeCreateInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayModeCreateInfoKHR temp;
  from_json( j, temp );
  p = VkDisplayModeCreateInfoKHR ( temp );
}
#include <vulkan2json/DisplayModeParametersKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayModePropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "parameters" ] = p.parameters;
}
}
void to_json( nlohmann::json &j, const VkDisplayModePropertiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayModePropertiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayModePropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayModePropertiesKHR" );
  if( j.find( "parameters" ) != j.end() ) {
    p.parameters = DisplayModeParametersKHR ( j[ "parameters" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayModePropertiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayModePropertiesKHR temp;
  from_json( j, temp );
  p = VkDisplayModePropertiesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DisplayModePropertiesKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayModeProperties2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "displayModeProperties" ] = p.displayModeProperties;
}
}
void to_json( nlohmann::json &j, const VkDisplayModeProperties2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayModeProperties2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayModeProperties2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayModeProperties2KHR" );
  if( j.find( "displayModeProperties" ) != j.end() ) {
    p.displayModeProperties = DisplayModePropertiesKHR ( j[ "displayModeProperties" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayModeProperties2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayModeProperties2KHR temp;
  from_json( j, temp );
  p = VkDisplayModeProperties2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayNativeHdrSurfaceCapabilitiesAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "localDimmingSupport" ] = bool( p.localDimmingSupport );
}
}
void to_json( nlohmann::json &j, const VkDisplayNativeHdrSurfaceCapabilitiesAMD &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayNativeHdrSurfaceCapabilitiesAMD ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayNativeHdrSurfaceCapabilitiesAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayNativeHdrSurfaceCapabilitiesAMD" );
  if( j.find( "localDimmingSupport" ) != j.end() ) {
    p.localDimmingSupport = j[ "localDimmingSupport" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayNativeHdrSurfaceCapabilitiesAMD &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayNativeHdrSurfaceCapabilitiesAMD temp;
  from_json( j, temp );
  p = VkDisplayNativeHdrSurfaceCapabilitiesAMD ( temp );
}
#include <vulkan2json/DisplayPlaneAlphaFlagsKHR.hpp>
#include <vulkan2json/Offset2D.hpp>
#include <vulkan2json/Offset2D.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/Offset2D.hpp>
#include <vulkan2json/Offset2D.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/Extent2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayPlaneCapabilitiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "supportedAlpha" ] = p.supportedAlpha;
  j[ "minSrcPosition" ] = p.minSrcPosition;
  j[ "maxSrcPosition" ] = p.maxSrcPosition;
  j[ "minSrcExtent" ] = p.minSrcExtent;
  j[ "maxSrcExtent" ] = p.maxSrcExtent;
  j[ "minDstPosition" ] = p.minDstPosition;
  j[ "maxDstPosition" ] = p.maxDstPosition;
  j[ "minDstExtent" ] = p.minDstExtent;
  j[ "maxDstExtent" ] = p.maxDstExtent;
}
}
void to_json( nlohmann::json &j, const VkDisplayPlaneCapabilitiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayPlaneCapabilitiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayPlaneCapabilitiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPlaneCapabilitiesKHR" );
  if( j.find( "supportedAlpha" ) != j.end() ) {
    p.supportedAlpha = DisplayPlaneAlphaFlagsKHR ( j[ "supportedAlpha" ] );
  }
  if( j.find( "minSrcPosition" ) != j.end() ) {
    p.minSrcPosition = Offset2D ( j[ "minSrcPosition" ] );
  }
  if( j.find( "maxSrcPosition" ) != j.end() ) {
    p.maxSrcPosition = Offset2D ( j[ "maxSrcPosition" ] );
  }
  if( j.find( "minSrcExtent" ) != j.end() ) {
    p.minSrcExtent = Extent2D ( j[ "minSrcExtent" ] );
  }
  if( j.find( "maxSrcExtent" ) != j.end() ) {
    p.maxSrcExtent = Extent2D ( j[ "maxSrcExtent" ] );
  }
  if( j.find( "minDstPosition" ) != j.end() ) {
    p.minDstPosition = Offset2D ( j[ "minDstPosition" ] );
  }
  if( j.find( "maxDstPosition" ) != j.end() ) {
    p.maxDstPosition = Offset2D ( j[ "maxDstPosition" ] );
  }
  if( j.find( "minDstExtent" ) != j.end() ) {
    p.minDstExtent = Extent2D ( j[ "minDstExtent" ] );
  }
  if( j.find( "maxDstExtent" ) != j.end() ) {
    p.maxDstExtent = Extent2D ( j[ "maxDstExtent" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayPlaneCapabilitiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayPlaneCapabilitiesKHR temp;
  from_json( j, temp );
  p = VkDisplayPlaneCapabilitiesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DisplayPlaneCapabilitiesKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayPlaneCapabilities2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "capabilities" ] = p.capabilities;
}
}
void to_json( nlohmann::json &j, const VkDisplayPlaneCapabilities2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayPlaneCapabilities2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayPlaneCapabilities2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPlaneCapabilities2KHR" );
  if( j.find( "capabilities" ) != j.end() ) {
    p.capabilities = DisplayPlaneCapabilitiesKHR ( j[ "capabilities" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayPlaneCapabilities2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayPlaneCapabilities2KHR temp;
  from_json( j, temp );
  p = VkDisplayPlaneCapabilities2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayPlaneInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "planeIndex" ] = p.planeIndex;
}
}
void to_json( nlohmann::json &j, const VkDisplayPlaneInfo2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayPlaneInfo2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayPlaneInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPlaneInfo2KHR" );
  if( j.find( "planeIndex" ) != j.end() ) {
    p.planeIndex = j[ "planeIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayPlaneInfo2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayPlaneInfo2KHR temp;
  from_json( j, temp );
  p = VkDisplayPlaneInfo2KHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayPlanePropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "currentStackIndex" ] = p.currentStackIndex;
}
}
void to_json( nlohmann::json &j, const VkDisplayPlanePropertiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayPlanePropertiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayPlanePropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPlanePropertiesKHR" );
  if( j.find( "currentStackIndex" ) != j.end() ) {
    p.currentStackIndex = j[ "currentStackIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayPlanePropertiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayPlanePropertiesKHR temp;
  from_json( j, temp );
  p = VkDisplayPlanePropertiesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DisplayPlanePropertiesKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayPlaneProperties2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "displayPlaneProperties" ] = p.displayPlaneProperties;
}
}
void to_json( nlohmann::json &j, const VkDisplayPlaneProperties2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayPlaneProperties2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayPlaneProperties2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPlaneProperties2KHR" );
  if( j.find( "displayPlaneProperties" ) != j.end() ) {
    p.displayPlaneProperties = DisplayPlanePropertiesKHR ( j[ "displayPlaneProperties" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayPlaneProperties2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayPlaneProperties2KHR temp;
  from_json( j, temp );
  p = VkDisplayPlaneProperties2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DisplayPowerStateEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayPowerInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "powerState" ] = p.powerState;
}
}
void to_json( nlohmann::json &j, const VkDisplayPowerInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayPowerInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayPowerInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPowerInfoEXT" );
  if( j.find( "powerState" ) != j.end() ) {
    p.powerState = DisplayPowerStateEXT ( j[ "powerState" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayPowerInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayPowerInfoEXT temp;
  from_json( j, temp );
  p = VkDisplayPowerInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Rect2D.hpp>
#include <vulkan2json/Rect2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayPresentInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcRect" ] = p.srcRect;
  j[ "dstRect" ] = p.dstRect;
  j[ "persistent" ] = bool( p.persistent );
}
}
void to_json( nlohmann::json &j, const VkDisplayPresentInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayPresentInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayPresentInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPresentInfoKHR" );
  if( j.find( "srcRect" ) != j.end() ) {
    p.srcRect = Rect2D ( j[ "srcRect" ] );
  }
  if( j.find( "dstRect" ) != j.end() ) {
    p.dstRect = Rect2D ( j[ "dstRect" ] );
  }
  if( j.find( "persistent" ) != j.end() ) {
    p.persistent = j[ "persistent" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayPresentInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayPresentInfoKHR temp;
  from_json( j, temp );
  p = VkDisplayPresentInfoKHR ( temp );
}
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/SurfaceTransformFlagsKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayPropertiesKHR &p ) {
  j = nlohmann::json::object();
  if( p.displayName ) j[ "displayName" ] = std::string( p.displayName );
  j[ "physicalDimensions" ] = p.physicalDimensions;
  j[ "physicalResolution" ] = p.physicalResolution;
  j[ "supportedTransforms" ] = p.supportedTransforms;
  j[ "planeReorderPossible" ] = bool( p.planeReorderPossible );
  j[ "persistentContent" ] = bool( p.persistentContent );
}
}
void to_json( nlohmann::json &j, const VkDisplayPropertiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayPropertiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayPropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPropertiesKHR" );
  if( j.find( "physicalDimensions" ) != j.end() ) {
    p.physicalDimensions = Extent2D ( j[ "physicalDimensions" ] );
  }
  if( j.find( "physicalResolution" ) != j.end() ) {
    p.physicalResolution = Extent2D ( j[ "physicalResolution" ] );
  }
  if( j.find( "supportedTransforms" ) != j.end() ) {
    p.supportedTransforms = SurfaceTransformFlagsKHR ( j[ "supportedTransforms" ] );
  }
  if( j.find( "planeReorderPossible" ) != j.end() ) {
    p.planeReorderPossible = j[ "planeReorderPossible" ];
  }
  if( j.find( "persistentContent" ) != j.end() ) {
    p.persistentContent = j[ "persistentContent" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayPropertiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayPropertiesKHR temp;
  from_json( j, temp );
  p = VkDisplayPropertiesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DisplayPropertiesKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplayProperties2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "displayProperties" ] = p.displayProperties;
}
}
void to_json( nlohmann::json &j, const VkDisplayProperties2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplayProperties2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplayProperties2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayProperties2KHR" );
  if( j.find( "displayProperties" ) != j.end() ) {
    p.displayProperties = DisplayPropertiesKHR ( j[ "displayProperties" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDisplayProperties2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: DisplayProperties2KHR temp;
  from_json( j, temp );
  p = VkDisplayProperties2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DisplaySurfaceCreateFlagsKHR.hpp>
#include <vulkan2json/SurfaceTransformFlagsKHR.hpp>
#include <vulkan2json/DisplayPlaneAlphaFlagsKHR.hpp>
#include <vulkan2json/Extent2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DisplaySurfaceCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "planeIndex" ] = p.planeIndex;
  j[ "planeStackIndex" ] = p.planeStackIndex;
  j[ "transform" ] = p.transform;
  j[ "globalAlpha" ] = p.globalAlpha;
  j[ "alphaMode" ] = p.alphaMode;
  j[ "imageExtent" ] = p.imageExtent;
}
}
void to_json( nlohmann::json &j, const VkDisplaySurfaceCreateInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DisplaySurfaceCreateInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DisplaySurfaceCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplaySurfaceCreateInfoKHR" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = DisplaySurfaceCreateFlagsKHR ( j[ "flags" ] );
  }
  if( j.find( "planeIndex" ) != j.end() ) {
    p.planeIndex = j[ "planeIndex" ];
  }
  if( j.find( "planeStackIndex" ) != j.end() ) {
    p.planeStackIndex = j[ "planeStackIndex" ];
  }
  if( j.find( "transform" ) != j.end() ) {
    p.transform = SurfaceTransformFlagBitsKHR ( j[ "transform" ] );
  }
  if( j.find( "globalAlpha" ) != j.end() ) {
    p.globalAlpha = j[ "globalAlpha" ];
  }
  if( j.find( "alphaMode" ) != j.end() ) {
    p.alphaMode = DisplayPlaneAlphaFlagBitsKHR ( j[ "alphaMode" ] );
  }
  if( j.find( "imageExtent" ) != j.end() ) {
    p.imageExtent = Extent2D ( j[ "imageExtent" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDisplaySurfaceCreateInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: DisplaySurfaceCreateInfoKHR temp;
  from_json( j, temp );
  p = VkDisplaySurfaceCreateInfoKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DrawIndexedIndirectCommand &p ) {
  j = nlohmann::json::object();
  j[ "indexCount" ] = p.indexCount;
  j[ "instanceCount" ] = p.instanceCount;
  j[ "firstIndex" ] = p.firstIndex;
  j[ "vertexOffset" ] = p.vertexOffset;
  j[ "firstInstance" ] = p.firstInstance;
}
}
void to_json( nlohmann::json &j, const VkDrawIndexedIndirectCommand &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DrawIndexedIndirectCommand ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DrawIndexedIndirectCommand &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DrawIndexedIndirectCommand" );
  if( j.find( "indexCount" ) != j.end() ) {
    p.indexCount = j[ "indexCount" ];
  }
  if( j.find( "instanceCount" ) != j.end() ) {
    p.instanceCount = j[ "instanceCount" ];
  }
  if( j.find( "firstIndex" ) != j.end() ) {
    p.firstIndex = j[ "firstIndex" ];
  }
  if( j.find( "vertexOffset" ) != j.end() ) {
    p.vertexOffset = j[ "vertexOffset" ];
  }
  if( j.find( "firstInstance" ) != j.end() ) {
    p.firstInstance = j[ "firstInstance" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDrawIndexedIndirectCommand &p ) {
  VULKAN_HPP_NAMESPACE :: DrawIndexedIndirectCommand temp;
  from_json( j, temp );
  p = VkDrawIndexedIndirectCommand ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DrawIndirectCommand &p ) {
  j = nlohmann::json::object();
  j[ "vertexCount" ] = p.vertexCount;
  j[ "instanceCount" ] = p.instanceCount;
  j[ "firstVertex" ] = p.firstVertex;
  j[ "firstInstance" ] = p.firstInstance;
}
}
void to_json( nlohmann::json &j, const VkDrawIndirectCommand &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DrawIndirectCommand ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DrawIndirectCommand &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DrawIndirectCommand" );
  if( j.find( "vertexCount" ) != j.end() ) {
    p.vertexCount = j[ "vertexCount" ];
  }
  if( j.find( "instanceCount" ) != j.end() ) {
    p.instanceCount = j[ "instanceCount" ];
  }
  if( j.find( "firstVertex" ) != j.end() ) {
    p.firstVertex = j[ "firstVertex" ];
  }
  if( j.find( "firstInstance" ) != j.end() ) {
    p.firstInstance = j[ "firstInstance" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDrawIndirectCommand &p ) {
  VULKAN_HPP_NAMESPACE :: DrawIndirectCommand temp;
  from_json( j, temp );
  p = VkDrawIndirectCommand ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DrawMeshTasksIndirectCommandNV &p ) {
  j = nlohmann::json::object();
  j[ "taskCount" ] = p.taskCount;
  j[ "firstTask" ] = p.firstTask;
}
}
void to_json( nlohmann::json &j, const VkDrawMeshTasksIndirectCommandNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DrawMeshTasksIndirectCommandNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DrawMeshTasksIndirectCommandNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DrawMeshTasksIndirectCommandNV" );
  if( j.find( "taskCount" ) != j.end() ) {
    p.taskCount = j[ "taskCount" ];
  }
  if( j.find( "firstTask" ) != j.end() ) {
    p.firstTask = j[ "firstTask" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDrawMeshTasksIndirectCommandNV &p ) {
  VULKAN_HPP_NAMESPACE :: DrawMeshTasksIndirectCommandNV temp;
  from_json( j, temp );
  p = VkDrawMeshTasksIndirectCommandNV ( temp );
}
#include <vulkan2json/FormatFeatureFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DrmFormatModifierPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "drmFormatModifier" ] = p.drmFormatModifier;
  j[ "drmFormatModifierPlaneCount" ] = p.drmFormatModifierPlaneCount;
  j[ "drmFormatModifierTilingFeatures" ] = p.drmFormatModifierTilingFeatures;
}
}
void to_json( nlohmann::json &j, const VkDrmFormatModifierPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DrmFormatModifierPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DrmFormatModifierPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DrmFormatModifierPropertiesEXT" );
  if( j.find( "drmFormatModifier" ) != j.end() ) {
    p.drmFormatModifier = j[ "drmFormatModifier" ];
  }
  if( j.find( "drmFormatModifierPlaneCount" ) != j.end() ) {
    p.drmFormatModifierPlaneCount = j[ "drmFormatModifierPlaneCount" ];
  }
  if( j.find( "drmFormatModifierTilingFeatures" ) != j.end() ) {
    p.drmFormatModifierTilingFeatures = FormatFeatureFlags ( j[ "drmFormatModifierTilingFeatures" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkDrmFormatModifierPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DrmFormatModifierPropertiesEXT temp;
  from_json( j, temp );
  p = VkDrmFormatModifierPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const DrmFormatModifierPropertiesListEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "drmFormatModifierCount" ] = p.drmFormatModifierCount;
  j[ "pDrmFormatModifierProperties" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDrmFormatModifierProperties ) );
}
}
void to_json( nlohmann::json &j, const VkDrmFormatModifierPropertiesListEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: DrmFormatModifierPropertiesListEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, DrmFormatModifierPropertiesListEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DrmFormatModifierPropertiesListEXT" );
  if( j.find( "drmFormatModifierCount" ) != j.end() ) {
    p.drmFormatModifierCount = j[ "drmFormatModifierCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkDrmFormatModifierPropertiesListEXT &p ) {
  VULKAN_HPP_NAMESPACE :: DrmFormatModifierPropertiesListEXT temp;
  from_json( j, temp );
  p = VkDrmFormatModifierPropertiesListEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/EventCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const EventCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkEventCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: EventCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, EventCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for EventCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = EventCreateFlags ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkEventCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: EventCreateInfo temp;
  from_json( j, temp );
  p = VkEventCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalFenceHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExportFenceCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleTypes" ] = p.handleTypes;
}
}
void to_json( nlohmann::json &j, const VkExportFenceCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ExportFenceCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ExportFenceCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExportFenceCreateInfo" );
  if( j.find( "handleTypes" ) != j.end() ) {
    p.handleTypes = ExternalFenceHandleTypeFlags ( j[ "handleTypes" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkExportFenceCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ExportFenceCreateInfo temp;
  from_json( j, temp );
  p = VkExportFenceCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalMemoryHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExportMemoryAllocateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleTypes" ] = p.handleTypes;
}
}
void to_json( nlohmann::json &j, const VkExportMemoryAllocateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ExportMemoryAllocateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ExportMemoryAllocateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExportMemoryAllocateInfo" );
  if( j.find( "handleTypes" ) != j.end() ) {
    p.handleTypes = ExternalMemoryHandleTypeFlags ( j[ "handleTypes" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkExportMemoryAllocateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ExportMemoryAllocateInfo temp;
  from_json( j, temp );
  p = VkExportMemoryAllocateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalMemoryHandleTypeFlagsNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExportMemoryAllocateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleTypes" ] = p.handleTypes;
}
}
void to_json( nlohmann::json &j, const VkExportMemoryAllocateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ExportMemoryAllocateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ExportMemoryAllocateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExportMemoryAllocateInfoNV" );
  if( j.find( "handleTypes" ) != j.end() ) {
    p.handleTypes = ExternalMemoryHandleTypeFlagsNV ( j[ "handleTypes" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkExportMemoryAllocateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: ExportMemoryAllocateInfoNV temp;
  from_json( j, temp );
  p = VkExportMemoryAllocateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalSemaphoreHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExportSemaphoreCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleTypes" ] = p.handleTypes;
}
}
void to_json( nlohmann::json &j, const VkExportSemaphoreCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ExportSemaphoreCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ExportSemaphoreCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExportSemaphoreCreateInfo" );
  if( j.find( "handleTypes" ) != j.end() ) {
    p.handleTypes = ExternalSemaphoreHandleTypeFlags ( j[ "handleTypes" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkExportSemaphoreCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ExportSemaphoreCreateInfo temp;
  from_json( j, temp );
  p = VkExportSemaphoreCreateInfo ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExtensionProperties &p ) {
  j = nlohmann::json::object();
  j[ "extensionName" ] = std::string( p.extensionName.begin(), std::find( p.extensionName.begin(), p.extensionName.end(), '\0' ) );
  j[ "specVersion" ] = p.specVersion;
}
}
void to_json( nlohmann::json &j, const VkExtensionProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ExtensionProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ExtensionProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExtensionProperties" );
  if( j.find( "extensionName" ) != j.end() ) {
    {
      std::string s = j[ "extensionName" ];
      if( !p.extensionName.empty() ) {
        p.extensionName[ p.extensionName.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.extensionName.size() - 1u ) ), p.extensionName.begin() );
      }
    }
  }
  if( j.find( "specVersion" ) != j.end() ) {
    p.specVersion = j[ "specVersion" ];
  }
}
}
void from_json( const nlohmann::json &j, VkExtensionProperties &p ) {
  VULKAN_HPP_NAMESPACE :: ExtensionProperties temp;
  from_json( j, temp );
  p = VkExtensionProperties ( temp );
}
#include <vulkan2json/ExternalMemoryFeatureFlags.hpp>
#include <vulkan2json/ExternalMemoryHandleTypeFlags.hpp>
#include <vulkan2json/ExternalMemoryHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalMemoryProperties &p ) {
  j = nlohmann::json::object();
  j[ "externalMemoryFeatures" ] = p.externalMemoryFeatures;
  j[ "exportFromImportedHandleTypes" ] = p.exportFromImportedHandleTypes;
  j[ "compatibleHandleTypes" ] = p.compatibleHandleTypes;
}
}
void to_json( nlohmann::json &j, const VkExternalMemoryProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ExternalMemoryProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ExternalMemoryProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalMemoryProperties" );
  if( j.find( "externalMemoryFeatures" ) != j.end() ) {
    p.externalMemoryFeatures = ExternalMemoryFeatureFlags ( j[ "externalMemoryFeatures" ] );
  }
  if( j.find( "exportFromImportedHandleTypes" ) != j.end() ) {
    p.exportFromImportedHandleTypes = ExternalMemoryHandleTypeFlags ( j[ "exportFromImportedHandleTypes" ] );
  }
  if( j.find( "compatibleHandleTypes" ) != j.end() ) {
    p.compatibleHandleTypes = ExternalMemoryHandleTypeFlags ( j[ "compatibleHandleTypes" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkExternalMemoryProperties &p ) {
  VULKAN_HPP_NAMESPACE :: ExternalMemoryProperties temp;
  from_json( j, temp );
  p = VkExternalMemoryProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalMemoryProperties.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalBufferProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "externalMemoryProperties" ] = p.externalMemoryProperties;
}
}
void to_json( nlohmann::json &j, const VkExternalBufferProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ExternalBufferProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ExternalBufferProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalBufferProperties" );
  if( j.find( "externalMemoryProperties" ) != j.end() ) {
    p.externalMemoryProperties = ExternalMemoryProperties ( j[ "externalMemoryProperties" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkExternalBufferProperties &p ) {
  VULKAN_HPP_NAMESPACE :: ExternalBufferProperties temp;
  from_json( j, temp );
  p = VkExternalBufferProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalFenceHandleTypeFlags.hpp>
#include <vulkan2json/ExternalFenceHandleTypeFlags.hpp>
#include <vulkan2json/ExternalFenceFeatureFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalFenceProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "exportFromImportedHandleTypes" ] = p.exportFromImportedHandleTypes;
  j[ "compatibleHandleTypes" ] = p.compatibleHandleTypes;
  j[ "externalFenceFeatures" ] = p.externalFenceFeatures;
}
}
void to_json( nlohmann::json &j, const VkExternalFenceProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ExternalFenceProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ExternalFenceProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalFenceProperties" );
  if( j.find( "exportFromImportedHandleTypes" ) != j.end() ) {
    p.exportFromImportedHandleTypes = ExternalFenceHandleTypeFlags ( j[ "exportFromImportedHandleTypes" ] );
  }
  if( j.find( "compatibleHandleTypes" ) != j.end() ) {
    p.compatibleHandleTypes = ExternalFenceHandleTypeFlags ( j[ "compatibleHandleTypes" ] );
  }
  if( j.find( "externalFenceFeatures" ) != j.end() ) {
    p.externalFenceFeatures = ExternalFenceFeatureFlags ( j[ "externalFenceFeatures" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkExternalFenceProperties &p ) {
  VULKAN_HPP_NAMESPACE :: ExternalFenceProperties temp;
  from_json( j, temp );
  p = VkExternalFenceProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalMemoryProperties.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalImageFormatProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "externalMemoryProperties" ] = p.externalMemoryProperties;
}
}
void to_json( nlohmann::json &j, const VkExternalImageFormatProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ExternalImageFormatProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ExternalImageFormatProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalImageFormatProperties" );
  if( j.find( "externalMemoryProperties" ) != j.end() ) {
    p.externalMemoryProperties = ExternalMemoryProperties ( j[ "externalMemoryProperties" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkExternalImageFormatProperties &p ) {
  VULKAN_HPP_NAMESPACE :: ExternalImageFormatProperties temp;
  from_json( j, temp );
  p = VkExternalImageFormatProperties ( temp );
}
#include <vulkan2json/Extent3D.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageFormatProperties &p ) {
  j = nlohmann::json::object();
  j[ "maxExtent" ] = p.maxExtent;
  j[ "maxMipLevels" ] = p.maxMipLevels;
  j[ "maxArrayLayers" ] = p.maxArrayLayers;
  j[ "sampleCounts" ] = p.sampleCounts;
  j[ "maxResourceSize" ] = p.maxResourceSize;
}
}
void to_json( nlohmann::json &j, const VkImageFormatProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageFormatProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageFormatProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageFormatProperties" );
  if( j.find( "maxExtent" ) != j.end() ) {
    p.maxExtent = Extent3D ( j[ "maxExtent" ] );
  }
  if( j.find( "maxMipLevels" ) != j.end() ) {
    p.maxMipLevels = j[ "maxMipLevels" ];
  }
  if( j.find( "maxArrayLayers" ) != j.end() ) {
    p.maxArrayLayers = j[ "maxArrayLayers" ];
  }
  if( j.find( "sampleCounts" ) != j.end() ) {
    p.sampleCounts = SampleCountFlags ( j[ "sampleCounts" ] );
  }
  if( j.find( "maxResourceSize" ) != j.end() ) {
    p.maxResourceSize = j[ "maxResourceSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkImageFormatProperties &p ) {
  VULKAN_HPP_NAMESPACE :: ImageFormatProperties temp;
  from_json( j, temp );
  p = VkImageFormatProperties ( temp );
}
#include <vulkan2json/ImageFormatProperties.hpp>
#include <vulkan2json/ExternalMemoryFeatureFlagsNV.hpp>
#include <vulkan2json/ExternalMemoryHandleTypeFlagsNV.hpp>
#include <vulkan2json/ExternalMemoryHandleTypeFlagsNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalImageFormatPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "imageFormatProperties" ] = p.imageFormatProperties;
  j[ "externalMemoryFeatures" ] = p.externalMemoryFeatures;
  j[ "exportFromImportedHandleTypes" ] = p.exportFromImportedHandleTypes;
  j[ "compatibleHandleTypes" ] = p.compatibleHandleTypes;
}
}
void to_json( nlohmann::json &j, const VkExternalImageFormatPropertiesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ExternalImageFormatPropertiesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ExternalImageFormatPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalImageFormatPropertiesNV" );
  if( j.find( "imageFormatProperties" ) != j.end() ) {
    p.imageFormatProperties = ImageFormatProperties ( j[ "imageFormatProperties" ] );
  }
  if( j.find( "externalMemoryFeatures" ) != j.end() ) {
    p.externalMemoryFeatures = ExternalMemoryFeatureFlagsNV ( j[ "externalMemoryFeatures" ] );
  }
  if( j.find( "exportFromImportedHandleTypes" ) != j.end() ) {
    p.exportFromImportedHandleTypes = ExternalMemoryHandleTypeFlagsNV ( j[ "exportFromImportedHandleTypes" ] );
  }
  if( j.find( "compatibleHandleTypes" ) != j.end() ) {
    p.compatibleHandleTypes = ExternalMemoryHandleTypeFlagsNV ( j[ "compatibleHandleTypes" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkExternalImageFormatPropertiesNV &p ) {
  VULKAN_HPP_NAMESPACE :: ExternalImageFormatPropertiesNV temp;
  from_json( j, temp );
  p = VkExternalImageFormatPropertiesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalMemoryHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalMemoryBufferCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleTypes" ] = p.handleTypes;
}
}
void to_json( nlohmann::json &j, const VkExternalMemoryBufferCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ExternalMemoryBufferCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ExternalMemoryBufferCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalMemoryBufferCreateInfo" );
  if( j.find( "handleTypes" ) != j.end() ) {
    p.handleTypes = ExternalMemoryHandleTypeFlags ( j[ "handleTypes" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkExternalMemoryBufferCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ExternalMemoryBufferCreateInfo temp;
  from_json( j, temp );
  p = VkExternalMemoryBufferCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalMemoryHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalMemoryImageCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleTypes" ] = p.handleTypes;
}
}
void to_json( nlohmann::json &j, const VkExternalMemoryImageCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ExternalMemoryImageCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ExternalMemoryImageCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalMemoryImageCreateInfo" );
  if( j.find( "handleTypes" ) != j.end() ) {
    p.handleTypes = ExternalMemoryHandleTypeFlags ( j[ "handleTypes" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkExternalMemoryImageCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ExternalMemoryImageCreateInfo temp;
  from_json( j, temp );
  p = VkExternalMemoryImageCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalMemoryHandleTypeFlagsNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalMemoryImageCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleTypes" ] = p.handleTypes;
}
}
void to_json( nlohmann::json &j, const VkExternalMemoryImageCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ExternalMemoryImageCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ExternalMemoryImageCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalMemoryImageCreateInfoNV" );
  if( j.find( "handleTypes" ) != j.end() ) {
    p.handleTypes = ExternalMemoryHandleTypeFlagsNV ( j[ "handleTypes" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkExternalMemoryImageCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: ExternalMemoryImageCreateInfoNV temp;
  from_json( j, temp );
  p = VkExternalMemoryImageCreateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalSemaphoreHandleTypeFlags.hpp>
#include <vulkan2json/ExternalSemaphoreHandleTypeFlags.hpp>
#include <vulkan2json/ExternalSemaphoreFeatureFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ExternalSemaphoreProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "exportFromImportedHandleTypes" ] = p.exportFromImportedHandleTypes;
  j[ "compatibleHandleTypes" ] = p.compatibleHandleTypes;
  j[ "externalSemaphoreFeatures" ] = p.externalSemaphoreFeatures;
}
}
void to_json( nlohmann::json &j, const VkExternalSemaphoreProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ExternalSemaphoreProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ExternalSemaphoreProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalSemaphoreProperties" );
  if( j.find( "exportFromImportedHandleTypes" ) != j.end() ) {
    p.exportFromImportedHandleTypes = ExternalSemaphoreHandleTypeFlags ( j[ "exportFromImportedHandleTypes" ] );
  }
  if( j.find( "compatibleHandleTypes" ) != j.end() ) {
    p.compatibleHandleTypes = ExternalSemaphoreHandleTypeFlags ( j[ "compatibleHandleTypes" ] );
  }
  if( j.find( "externalSemaphoreFeatures" ) != j.end() ) {
    p.externalSemaphoreFeatures = ExternalSemaphoreFeatureFlags ( j[ "externalSemaphoreFeatures" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkExternalSemaphoreProperties &p ) {
  VULKAN_HPP_NAMESPACE :: ExternalSemaphoreProperties temp;
  from_json( j, temp );
  p = VkExternalSemaphoreProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/FenceCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FenceCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkFenceCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: FenceCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, FenceCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FenceCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = FenceCreateFlags ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkFenceCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: FenceCreateInfo temp;
  from_json( j, temp );
  p = VkFenceCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalFenceHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FenceGetFdInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
}
void to_json( nlohmann::json &j, const VkFenceGetFdInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: FenceGetFdInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, FenceGetFdInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FenceGetFdInfoKHR" );
  if( j.find( "handleType" ) != j.end() ) {
    p.handleType = ExternalFenceHandleTypeFlagBits ( j[ "handleType" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkFenceGetFdInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: FenceGetFdInfoKHR temp;
  from_json( j, temp );
  p = VkFenceGetFdInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FilterCubicImageViewImageFormatPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "filterCubic" ] = bool( p.filterCubic );
  j[ "filterCubicMinmax" ] = bool( p.filterCubicMinmax );
}
}
void to_json( nlohmann::json &j, const VkFilterCubicImageViewImageFormatPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: FilterCubicImageViewImageFormatPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, FilterCubicImageViewImageFormatPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FilterCubicImageViewImageFormatPropertiesEXT" );
  if( j.find( "filterCubic" ) != j.end() ) {
    p.filterCubic = j[ "filterCubic" ];
  }
  if( j.find( "filterCubicMinmax" ) != j.end() ) {
    p.filterCubicMinmax = j[ "filterCubicMinmax" ];
  }
}
}
void from_json( const nlohmann::json &j, VkFilterCubicImageViewImageFormatPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: FilterCubicImageViewImageFormatPropertiesEXT temp;
  from_json( j, temp );
  p = VkFilterCubicImageViewImageFormatPropertiesEXT ( temp );
}
#include <vulkan2json/FormatFeatureFlags.hpp>
#include <vulkan2json/FormatFeatureFlags.hpp>
#include <vulkan2json/FormatFeatureFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FormatProperties &p ) {
  j = nlohmann::json::object();
  j[ "linearTilingFeatures" ] = p.linearTilingFeatures;
  j[ "optimalTilingFeatures" ] = p.optimalTilingFeatures;
  j[ "bufferFeatures" ] = p.bufferFeatures;
}
}
void to_json( nlohmann::json &j, const VkFormatProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: FormatProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, FormatProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FormatProperties" );
  if( j.find( "linearTilingFeatures" ) != j.end() ) {
    p.linearTilingFeatures = FormatFeatureFlags ( j[ "linearTilingFeatures" ] );
  }
  if( j.find( "optimalTilingFeatures" ) != j.end() ) {
    p.optimalTilingFeatures = FormatFeatureFlags ( j[ "optimalTilingFeatures" ] );
  }
  if( j.find( "bufferFeatures" ) != j.end() ) {
    p.bufferFeatures = FormatFeatureFlags ( j[ "bufferFeatures" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkFormatProperties &p ) {
  VULKAN_HPP_NAMESPACE :: FormatProperties temp;
  from_json( j, temp );
  p = VkFormatProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/FormatProperties.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FormatProperties2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "formatProperties" ] = p.formatProperties;
}
}
void to_json( nlohmann::json &j, const VkFormatProperties2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: FormatProperties2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, FormatProperties2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FormatProperties2" );
  if( j.find( "formatProperties" ) != j.end() ) {
    p.formatProperties = FormatProperties ( j[ "formatProperties" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkFormatProperties2 &p ) {
  VULKAN_HPP_NAMESPACE :: FormatProperties2 temp;
  from_json( j, temp );
  p = VkFormatProperties2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Extent2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FragmentShadingRateAttachmentInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pFragmentShadingRateAttachment" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pFragmentShadingRateAttachment ) );
  j[ "shadingRateAttachmentTexelSize" ] = p.shadingRateAttachmentTexelSize;
}
}
void to_json( nlohmann::json &j, const VkFragmentShadingRateAttachmentInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: FragmentShadingRateAttachmentInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, FragmentShadingRateAttachmentInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FragmentShadingRateAttachmentInfoKHR" );
  if( j.find( "shadingRateAttachmentTexelSize" ) != j.end() ) {
    p.shadingRateAttachmentTexelSize = Extent2D ( j[ "shadingRateAttachmentTexelSize" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkFragmentShadingRateAttachmentInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: FragmentShadingRateAttachmentInfoKHR temp;
  from_json( j, temp );
  p = VkFragmentShadingRateAttachmentInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageCreateFlags.hpp>
#include <vulkan2json/ImageUsageFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FramebufferAttachmentImageInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "usage" ] = p.usage;
  j[ "width" ] = p.width;
  j[ "height" ] = p.height;
  j[ "layerCount" ] = p.layerCount;
  j[ "viewFormatCount" ] = p.viewFormatCount;
  j[ "pViewFormats" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewFormats ) );
}
}
void to_json( nlohmann::json &j, const VkFramebufferAttachmentImageInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: FramebufferAttachmentImageInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, FramebufferAttachmentImageInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FramebufferAttachmentImageInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = ImageCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "usage" ) != j.end() ) {
    p.usage = ImageUsageFlags ( j[ "usage" ] );
  }
  if( j.find( "width" ) != j.end() ) {
    p.width = j[ "width" ];
  }
  if( j.find( "height" ) != j.end() ) {
    p.height = j[ "height" ];
  }
  if( j.find( "layerCount" ) != j.end() ) {
    p.layerCount = j[ "layerCount" ];
  }
  if( j.find( "viewFormatCount" ) != j.end() ) {
    p.viewFormatCount = j[ "viewFormatCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkFramebufferAttachmentImageInfo &p ) {
  VULKAN_HPP_NAMESPACE :: FramebufferAttachmentImageInfo temp;
  from_json( j, temp );
  p = VkFramebufferAttachmentImageInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FramebufferAttachmentsCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "attachmentImageInfoCount" ] = p.attachmentImageInfoCount;
  j[ "pAttachmentImageInfos" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttachmentImageInfos ) );
}
}
void to_json( nlohmann::json &j, const VkFramebufferAttachmentsCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: FramebufferAttachmentsCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, FramebufferAttachmentsCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FramebufferAttachmentsCreateInfo" );
  if( j.find( "attachmentImageInfoCount" ) != j.end() ) {
    p.attachmentImageInfoCount = j[ "attachmentImageInfoCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkFramebufferAttachmentsCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: FramebufferAttachmentsCreateInfo temp;
  from_json( j, temp );
  p = VkFramebufferAttachmentsCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/FramebufferCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FramebufferCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "attachmentCount" ] = p.attachmentCount;
  j[ "pAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttachments ) );
  j[ "width" ] = p.width;
  j[ "height" ] = p.height;
  j[ "layers" ] = p.layers;
}
}
void to_json( nlohmann::json &j, const VkFramebufferCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: FramebufferCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, FramebufferCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FramebufferCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = FramebufferCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "attachmentCount" ) != j.end() ) {
    p.attachmentCount = j[ "attachmentCount" ];
  }
  if( j.find( "width" ) != j.end() ) {
    p.width = j[ "width" ];
  }
  if( j.find( "height" ) != j.end() ) {
    p.height = j[ "height" ];
  }
  if( j.find( "layers" ) != j.end() ) {
    p.layers = j[ "layers" ];
  }
}
}
void from_json( const nlohmann::json &j, VkFramebufferCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: FramebufferCreateInfo temp;
  from_json( j, temp );
  p = VkFramebufferCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/CoverageReductionModeNV.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const FramebufferMixedSamplesCombinationNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "coverageReductionMode" ] = p.coverageReductionMode;
  j[ "rasterizationSamples" ] = p.rasterizationSamples;
  j[ "depthStencilSamples" ] = p.depthStencilSamples;
  j[ "colorSamples" ] = p.colorSamples;
}
}
void to_json( nlohmann::json &j, const VkFramebufferMixedSamplesCombinationNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: FramebufferMixedSamplesCombinationNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, FramebufferMixedSamplesCombinationNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FramebufferMixedSamplesCombinationNV" );
  if( j.find( "coverageReductionMode" ) != j.end() ) {
    p.coverageReductionMode = CoverageReductionModeNV ( j[ "coverageReductionMode" ] );
  }
  if( j.find( "rasterizationSamples" ) != j.end() ) {
    p.rasterizationSamples = SampleCountFlagBits ( j[ "rasterizationSamples" ] );
  }
  if( j.find( "depthStencilSamples" ) != j.end() ) {
    p.depthStencilSamples = SampleCountFlags ( j[ "depthStencilSamples" ] );
  }
  if( j.find( "colorSamples" ) != j.end() ) {
    p.colorSamples = SampleCountFlags ( j[ "colorSamples" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkFramebufferMixedSamplesCombinationNV &p ) {
  VULKAN_HPP_NAMESPACE :: FramebufferMixedSamplesCombinationNV temp;
  from_json( j, temp );
  p = VkFramebufferMixedSamplesCombinationNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const IndirectCommandsStreamNV &p ) {
  j = nlohmann::json::object();
  j[ "offset" ] = p.offset;
}
}
void to_json( nlohmann::json &j, const VkIndirectCommandsStreamNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: IndirectCommandsStreamNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, IndirectCommandsStreamNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for IndirectCommandsStreamNV" );
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
}
}
void from_json( const nlohmann::json &j, VkIndirectCommandsStreamNV &p ) {
  VULKAN_HPP_NAMESPACE :: IndirectCommandsStreamNV temp;
  from_json( j, temp );
  p = VkIndirectCommandsStreamNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineBindPoint.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const GeneratedCommandsInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pipelineBindPoint" ] = p.pipelineBindPoint;
  j[ "streamCount" ] = p.streamCount;
  j[ "pStreams" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStreams ) );
  j[ "sequencesCount" ] = p.sequencesCount;
  j[ "preprocessOffset" ] = p.preprocessOffset;
  j[ "preprocessSize" ] = p.preprocessSize;
  j[ "sequencesCountOffset" ] = p.sequencesCountOffset;
  j[ "sequencesIndexOffset" ] = p.sequencesIndexOffset;
}
}
void to_json( nlohmann::json &j, const VkGeneratedCommandsInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: GeneratedCommandsInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, GeneratedCommandsInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GeneratedCommandsInfoNV" );
  if( j.find( "pipelineBindPoint" ) != j.end() ) {
    p.pipelineBindPoint = PipelineBindPoint ( j[ "pipelineBindPoint" ] );
  }
  if( j.find( "streamCount" ) != j.end() ) {
    p.streamCount = j[ "streamCount" ];
  }
  if( j.find( "sequencesCount" ) != j.end() ) {
    p.sequencesCount = j[ "sequencesCount" ];
  }
  if( j.find( "preprocessOffset" ) != j.end() ) {
    p.preprocessOffset = j[ "preprocessOffset" ];
  }
  if( j.find( "preprocessSize" ) != j.end() ) {
    p.preprocessSize = j[ "preprocessSize" ];
  }
  if( j.find( "sequencesCountOffset" ) != j.end() ) {
    p.sequencesCountOffset = j[ "sequencesCountOffset" ];
  }
  if( j.find( "sequencesIndexOffset" ) != j.end() ) {
    p.sequencesIndexOffset = j[ "sequencesIndexOffset" ];
  }
}
}
void from_json( const nlohmann::json &j, VkGeneratedCommandsInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: GeneratedCommandsInfoNV temp;
  from_json( j, temp );
  p = VkGeneratedCommandsInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineBindPoint.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const GeneratedCommandsMemoryRequirementsInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pipelineBindPoint" ] = p.pipelineBindPoint;
  j[ "maxSequencesCount" ] = p.maxSequencesCount;
}
}
void to_json( nlohmann::json &j, const VkGeneratedCommandsMemoryRequirementsInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: GeneratedCommandsMemoryRequirementsInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, GeneratedCommandsMemoryRequirementsInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GeneratedCommandsMemoryRequirementsInfoNV" );
  if( j.find( "pipelineBindPoint" ) != j.end() ) {
    p.pipelineBindPoint = PipelineBindPoint ( j[ "pipelineBindPoint" ] );
  }
  if( j.find( "maxSequencesCount" ) != j.end() ) {
    p.maxSequencesCount = j[ "maxSequencesCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkGeneratedCommandsMemoryRequirementsInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: GeneratedCommandsMemoryRequirementsInfoNV temp;
  from_json( j, temp );
  p = VkGeneratedCommandsMemoryRequirementsInfoNV ( temp );
}
#include <vulkan2json/VertexInputRate.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const VertexInputBindingDescription &p ) {
  j = nlohmann::json::object();
  j[ "binding" ] = p.binding;
  j[ "stride" ] = p.stride;
  j[ "inputRate" ] = p.inputRate;
}
}
void to_json( nlohmann::json &j, const VkVertexInputBindingDescription &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: VertexInputBindingDescription ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, VertexInputBindingDescription &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VertexInputBindingDescription" );
  if( j.find( "binding" ) != j.end() ) {
    p.binding = j[ "binding" ];
  }
  if( j.find( "stride" ) != j.end() ) {
    p.stride = j[ "stride" ];
  }
  if( j.find( "inputRate" ) != j.end() ) {
    p.inputRate = VertexInputRate ( j[ "inputRate" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkVertexInputBindingDescription &p ) {
  VULKAN_HPP_NAMESPACE :: VertexInputBindingDescription temp;
  from_json( j, temp );
  p = VkVertexInputBindingDescription ( temp );
}
#include <vulkan2json/Format.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const VertexInputAttributeDescription &p ) {
  j = nlohmann::json::object();
  j[ "location" ] = p.location;
  j[ "binding" ] = p.binding;
  j[ "format" ] = p.format;
  j[ "offset" ] = p.offset;
}
}
void to_json( nlohmann::json &j, const VkVertexInputAttributeDescription &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: VertexInputAttributeDescription ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, VertexInputAttributeDescription &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VertexInputAttributeDescription" );
  if( j.find( "location" ) != j.end() ) {
    p.location = j[ "location" ];
  }
  if( j.find( "binding" ) != j.end() ) {
    p.binding = j[ "binding" ];
  }
  if( j.find( "format" ) != j.end() ) {
    p.format = Format ( j[ "format" ] );
  }
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
}
}
void from_json( const nlohmann::json &j, VkVertexInputAttributeDescription &p ) {
  VULKAN_HPP_NAMESPACE :: VertexInputAttributeDescription temp;
  from_json( j, temp );
  p = VkVertexInputAttributeDescription ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineVertexInputStateCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineVertexInputStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "vertexBindingDescriptionCount" ] = p.vertexBindingDescriptionCount;
  j[ "pVertexBindingDescriptions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pVertexBindingDescriptions ) );
  j[ "vertexAttributeDescriptionCount" ] = p.vertexAttributeDescriptionCount;
  j[ "pVertexAttributeDescriptions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pVertexAttributeDescriptions ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineVertexInputStateCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineVertexInputStateCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineVertexInputStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineVertexInputStateCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineVertexInputStateCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "vertexBindingDescriptionCount" ) != j.end() ) {
    p.vertexBindingDescriptionCount = j[ "vertexBindingDescriptionCount" ];
  }
  if( j.find( "vertexAttributeDescriptionCount" ) != j.end() ) {
    p.vertexAttributeDescriptionCount = j[ "vertexAttributeDescriptionCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineVertexInputStateCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineVertexInputStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineVertexInputStateCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineInputAssemblyStateCreateFlags.hpp>
#include <vulkan2json/PrimitiveTopology.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineInputAssemblyStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "topology" ] = p.topology;
  j[ "primitiveRestartEnable" ] = bool( p.primitiveRestartEnable );
}
}
void to_json( nlohmann::json &j, const VkPipelineInputAssemblyStateCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineInputAssemblyStateCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineInputAssemblyStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineInputAssemblyStateCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineInputAssemblyStateCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "topology" ) != j.end() ) {
    p.topology = PrimitiveTopology ( j[ "topology" ] );
  }
  if( j.find( "primitiveRestartEnable" ) != j.end() ) {
    p.primitiveRestartEnable = j[ "primitiveRestartEnable" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineInputAssemblyStateCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineInputAssemblyStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineInputAssemblyStateCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineTessellationStateCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineTessellationStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "patchControlPoints" ] = p.patchControlPoints;
}
}
void to_json( nlohmann::json &j, const VkPipelineTessellationStateCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineTessellationStateCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineTessellationStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineTessellationStateCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineTessellationStateCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "patchControlPoints" ) != j.end() ) {
    p.patchControlPoints = j[ "patchControlPoints" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineTessellationStateCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineTessellationStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineTessellationStateCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineViewportStateCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineViewportStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "viewportCount" ] = p.viewportCount;
  j[ "pViewports" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewports ) );
  j[ "scissorCount" ] = p.scissorCount;
  j[ "pScissors" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pScissors ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineViewportStateCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineViewportStateCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineViewportStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineViewportStateCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineViewportStateCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "viewportCount" ) != j.end() ) {
    p.viewportCount = j[ "viewportCount" ];
  }
  if( j.find( "scissorCount" ) != j.end() ) {
    p.scissorCount = j[ "scissorCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineViewportStateCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineViewportStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineViewportStateCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineRasterizationStateCreateFlags.hpp>
#include <vulkan2json/PolygonMode.hpp>
#include <vulkan2json/CullModeFlags.hpp>
#include <vulkan2json/FrontFace.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineRasterizationStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "depthClampEnable" ] = bool( p.depthClampEnable );
  j[ "rasterizerDiscardEnable" ] = bool( p.rasterizerDiscardEnable );
  j[ "polygonMode" ] = p.polygonMode;
  j[ "cullMode" ] = p.cullMode;
  j[ "frontFace" ] = p.frontFace;
  j[ "depthBiasEnable" ] = bool( p.depthBiasEnable );
  j[ "depthBiasConstantFactor" ] = p.depthBiasConstantFactor;
  j[ "depthBiasClamp" ] = p.depthBiasClamp;
  j[ "depthBiasSlopeFactor" ] = p.depthBiasSlopeFactor;
  j[ "lineWidth" ] = p.lineWidth;
}
}
void to_json( nlohmann::json &j, const VkPipelineRasterizationStateCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineRasterizationStateCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineRasterizationStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRasterizationStateCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineRasterizationStateCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "depthClampEnable" ) != j.end() ) {
    p.depthClampEnable = j[ "depthClampEnable" ];
  }
  if( j.find( "rasterizerDiscardEnable" ) != j.end() ) {
    p.rasterizerDiscardEnable = j[ "rasterizerDiscardEnable" ];
  }
  if( j.find( "polygonMode" ) != j.end() ) {
    p.polygonMode = PolygonMode ( j[ "polygonMode" ] );
  }
  if( j.find( "cullMode" ) != j.end() ) {
    p.cullMode = CullModeFlags ( j[ "cullMode" ] );
  }
  if( j.find( "frontFace" ) != j.end() ) {
    p.frontFace = FrontFace ( j[ "frontFace" ] );
  }
  if( j.find( "depthBiasEnable" ) != j.end() ) {
    p.depthBiasEnable = j[ "depthBiasEnable" ];
  }
  if( j.find( "depthBiasConstantFactor" ) != j.end() ) {
    p.depthBiasConstantFactor = j[ "depthBiasConstantFactor" ];
  }
  if( j.find( "depthBiasClamp" ) != j.end() ) {
    p.depthBiasClamp = j[ "depthBiasClamp" ];
  }
  if( j.find( "depthBiasSlopeFactor" ) != j.end() ) {
    p.depthBiasSlopeFactor = j[ "depthBiasSlopeFactor" ];
  }
  if( j.find( "lineWidth" ) != j.end() ) {
    p.lineWidth = j[ "lineWidth" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineRasterizationStateCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineRasterizationStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineRasterizationStateCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineMultisampleStateCreateFlags.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineMultisampleStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "rasterizationSamples" ] = p.rasterizationSamples;
  j[ "sampleShadingEnable" ] = bool( p.sampleShadingEnable );
  j[ "minSampleShading" ] = p.minSampleShading;
  j[ "pSampleMask" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSampleMask ) );
  j[ "alphaToCoverageEnable" ] = bool( p.alphaToCoverageEnable );
  j[ "alphaToOneEnable" ] = bool( p.alphaToOneEnable );
}
}
void to_json( nlohmann::json &j, const VkPipelineMultisampleStateCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineMultisampleStateCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineMultisampleStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineMultisampleStateCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineMultisampleStateCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "rasterizationSamples" ) != j.end() ) {
    p.rasterizationSamples = SampleCountFlagBits ( j[ "rasterizationSamples" ] );
  }
  if( j.find( "sampleShadingEnable" ) != j.end() ) {
    p.sampleShadingEnable = j[ "sampleShadingEnable" ];
  }
  if( j.find( "minSampleShading" ) != j.end() ) {
    p.minSampleShading = j[ "minSampleShading" ];
  }
  if( j.find( "alphaToCoverageEnable" ) != j.end() ) {
    p.alphaToCoverageEnable = j[ "alphaToCoverageEnable" ];
  }
  if( j.find( "alphaToOneEnable" ) != j.end() ) {
    p.alphaToOneEnable = j[ "alphaToOneEnable" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineMultisampleStateCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineMultisampleStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineMultisampleStateCreateInfo ( temp );
}
#include <vulkan2json/StencilOp.hpp>
#include <vulkan2json/StencilOp.hpp>
#include <vulkan2json/StencilOp.hpp>
#include <vulkan2json/CompareOp.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const StencilOpState &p ) {
  j = nlohmann::json::object();
  j[ "failOp" ] = p.failOp;
  j[ "passOp" ] = p.passOp;
  j[ "depthFailOp" ] = p.depthFailOp;
  j[ "compareOp" ] = p.compareOp;
  j[ "compareMask" ] = p.compareMask;
  j[ "writeMask" ] = p.writeMask;
  j[ "reference" ] = p.reference;
}
}
void to_json( nlohmann::json &j, const VkStencilOpState &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: StencilOpState ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, StencilOpState &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for StencilOpState" );
  if( j.find( "failOp" ) != j.end() ) {
    p.failOp = StencilOp ( j[ "failOp" ] );
  }
  if( j.find( "passOp" ) != j.end() ) {
    p.passOp = StencilOp ( j[ "passOp" ] );
  }
  if( j.find( "depthFailOp" ) != j.end() ) {
    p.depthFailOp = StencilOp ( j[ "depthFailOp" ] );
  }
  if( j.find( "compareOp" ) != j.end() ) {
    p.compareOp = CompareOp ( j[ "compareOp" ] );
  }
  if( j.find( "compareMask" ) != j.end() ) {
    p.compareMask = j[ "compareMask" ];
  }
  if( j.find( "writeMask" ) != j.end() ) {
    p.writeMask = j[ "writeMask" ];
  }
  if( j.find( "reference" ) != j.end() ) {
    p.reference = j[ "reference" ];
  }
}
}
void from_json( const nlohmann::json &j, VkStencilOpState &p ) {
  VULKAN_HPP_NAMESPACE :: StencilOpState temp;
  from_json( j, temp );
  p = VkStencilOpState ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineDepthStencilStateCreateFlags.hpp>
#include <vulkan2json/CompareOp.hpp>
#include <vulkan2json/StencilOpState.hpp>
#include <vulkan2json/StencilOpState.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineDepthStencilStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "depthTestEnable" ] = bool( p.depthTestEnable );
  j[ "depthWriteEnable" ] = bool( p.depthWriteEnable );
  j[ "depthCompareOp" ] = p.depthCompareOp;
  j[ "depthBoundsTestEnable" ] = bool( p.depthBoundsTestEnable );
  j[ "stencilTestEnable" ] = bool( p.stencilTestEnable );
  j[ "front" ] = p.front;
  j[ "back" ] = p.back;
  j[ "minDepthBounds" ] = p.minDepthBounds;
  j[ "maxDepthBounds" ] = p.maxDepthBounds;
}
}
void to_json( nlohmann::json &j, const VkPipelineDepthStencilStateCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineDepthStencilStateCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineDepthStencilStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineDepthStencilStateCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineDepthStencilStateCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "depthTestEnable" ) != j.end() ) {
    p.depthTestEnable = j[ "depthTestEnable" ];
  }
  if( j.find( "depthWriteEnable" ) != j.end() ) {
    p.depthWriteEnable = j[ "depthWriteEnable" ];
  }
  if( j.find( "depthCompareOp" ) != j.end() ) {
    p.depthCompareOp = CompareOp ( j[ "depthCompareOp" ] );
  }
  if( j.find( "depthBoundsTestEnable" ) != j.end() ) {
    p.depthBoundsTestEnable = j[ "depthBoundsTestEnable" ];
  }
  if( j.find( "stencilTestEnable" ) != j.end() ) {
    p.stencilTestEnable = j[ "stencilTestEnable" ];
  }
  if( j.find( "front" ) != j.end() ) {
    p.front = StencilOpState ( j[ "front" ] );
  }
  if( j.find( "back" ) != j.end() ) {
    p.back = StencilOpState ( j[ "back" ] );
  }
  if( j.find( "minDepthBounds" ) != j.end() ) {
    p.minDepthBounds = j[ "minDepthBounds" ];
  }
  if( j.find( "maxDepthBounds" ) != j.end() ) {
    p.maxDepthBounds = j[ "maxDepthBounds" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineDepthStencilStateCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineDepthStencilStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineDepthStencilStateCreateInfo ( temp );
}
#include <vulkan2json/BlendFactor.hpp>
#include <vulkan2json/BlendFactor.hpp>
#include <vulkan2json/BlendOp.hpp>
#include <vulkan2json/BlendFactor.hpp>
#include <vulkan2json/BlendFactor.hpp>
#include <vulkan2json/BlendOp.hpp>
#include <vulkan2json/ColorComponentFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineColorBlendAttachmentState &p ) {
  j = nlohmann::json::object();
  j[ "blendEnable" ] = bool( p.blendEnable );
  j[ "srcColorBlendFactor" ] = p.srcColorBlendFactor;
  j[ "dstColorBlendFactor" ] = p.dstColorBlendFactor;
  j[ "colorBlendOp" ] = p.colorBlendOp;
  j[ "srcAlphaBlendFactor" ] = p.srcAlphaBlendFactor;
  j[ "dstAlphaBlendFactor" ] = p.dstAlphaBlendFactor;
  j[ "alphaBlendOp" ] = p.alphaBlendOp;
  j[ "colorWriteMask" ] = p.colorWriteMask;
}
}
void to_json( nlohmann::json &j, const VkPipelineColorBlendAttachmentState &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineColorBlendAttachmentState ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineColorBlendAttachmentState &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineColorBlendAttachmentState" );
  if( j.find( "blendEnable" ) != j.end() ) {
    p.blendEnable = j[ "blendEnable" ];
  }
  if( j.find( "srcColorBlendFactor" ) != j.end() ) {
    p.srcColorBlendFactor = BlendFactor ( j[ "srcColorBlendFactor" ] );
  }
  if( j.find( "dstColorBlendFactor" ) != j.end() ) {
    p.dstColorBlendFactor = BlendFactor ( j[ "dstColorBlendFactor" ] );
  }
  if( j.find( "colorBlendOp" ) != j.end() ) {
    p.colorBlendOp = BlendOp ( j[ "colorBlendOp" ] );
  }
  if( j.find( "srcAlphaBlendFactor" ) != j.end() ) {
    p.srcAlphaBlendFactor = BlendFactor ( j[ "srcAlphaBlendFactor" ] );
  }
  if( j.find( "dstAlphaBlendFactor" ) != j.end() ) {
    p.dstAlphaBlendFactor = BlendFactor ( j[ "dstAlphaBlendFactor" ] );
  }
  if( j.find( "alphaBlendOp" ) != j.end() ) {
    p.alphaBlendOp = BlendOp ( j[ "alphaBlendOp" ] );
  }
  if( j.find( "colorWriteMask" ) != j.end() ) {
    p.colorWriteMask = ColorComponentFlags ( j[ "colorWriteMask" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineColorBlendAttachmentState &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineColorBlendAttachmentState temp;
  from_json( j, temp );
  p = VkPipelineColorBlendAttachmentState ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineColorBlendStateCreateFlags.hpp>
#include <vulkan2json/LogicOp.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineColorBlendStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "logicOpEnable" ] = bool( p.logicOpEnable );
  j[ "logicOp" ] = p.logicOp;
  j[ "attachmentCount" ] = p.attachmentCount;
  j[ "pAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttachments ) );
  j[ "blendConstants" ] = nlohmann::json::array();
  std::copy( p.blendConstants.begin(), p.blendConstants.end(), std::back_inserter( j[ "blendConstants" ] ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineColorBlendStateCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineColorBlendStateCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineColorBlendStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineColorBlendStateCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineColorBlendStateCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "logicOpEnable" ) != j.end() ) {
    p.logicOpEnable = j[ "logicOpEnable" ];
  }
  if( j.find( "logicOp" ) != j.end() ) {
    p.logicOp = LogicOp ( j[ "logicOp" ] );
  }
  if( j.find( "attachmentCount" ) != j.end() ) {
    p.attachmentCount = j[ "attachmentCount" ];
  }
  if( j.find( "blendConstants" ) != j.end() ) {
    if( !j[ "blendConstants" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PipelineColorBlendStateCreateInfo.blendConstants" );
    if( !j[ "blendConstants" ].size() > p.blendConstants.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PipelineColorBlendStateCreateInfo.blendConstants" );
    std::fill( p.blendConstants.begin(), p.blendConstants.end(), 0 );
    std::copy( j[ "blendConstants" ].begin(), j[ "blendConstants" ].end(), p.blendConstants.begin() );
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineColorBlendStateCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineColorBlendStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineColorBlendStateCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineDynamicStateCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineDynamicStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "dynamicStateCount" ] = p.dynamicStateCount;
  j[ "pDynamicStates" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDynamicStates ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineDynamicStateCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineDynamicStateCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineDynamicStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineDynamicStateCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineDynamicStateCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "dynamicStateCount" ) != j.end() ) {
    p.dynamicStateCount = j[ "dynamicStateCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineDynamicStateCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineDynamicStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineDynamicStateCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const GraphicsPipelineCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "stageCount" ] = p.stageCount;
  j[ "pStages" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStages ) );
  j[ "pVertexInputState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pVertexInputState ) );
  j[ "pInputAssemblyState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pInputAssemblyState ) );
  j[ "pTessellationState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pTessellationState ) );
  j[ "pViewportState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewportState ) );
  j[ "pRasterizationState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRasterizationState ) );
  j[ "pMultisampleState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pMultisampleState ) );
  j[ "pDepthStencilState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDepthStencilState ) );
  j[ "pColorBlendState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pColorBlendState ) );
  j[ "pDynamicState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDynamicState ) );
  j[ "subpass" ] = p.subpass;
  j[ "basePipelineIndex" ] = p.basePipelineIndex;
}
}
void to_json( nlohmann::json &j, const VkGraphicsPipelineCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: GraphicsPipelineCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, GraphicsPipelineCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GraphicsPipelineCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "stageCount" ) != j.end() ) {
    p.stageCount = j[ "stageCount" ];
  }
  if( j.find( "subpass" ) != j.end() ) {
    p.subpass = j[ "subpass" ];
  }
  if( j.find( "basePipelineIndex" ) != j.end() ) {
    p.basePipelineIndex = j[ "basePipelineIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkGraphicsPipelineCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: GraphicsPipelineCreateInfo temp;
  from_json( j, temp );
  p = VkGraphicsPipelineCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const GraphicsShaderGroupCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stageCount" ] = p.stageCount;
  j[ "pStages" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStages ) );
  j[ "pVertexInputState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pVertexInputState ) );
  j[ "pTessellationState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pTessellationState ) );
}
}
void to_json( nlohmann::json &j, const VkGraphicsShaderGroupCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: GraphicsShaderGroupCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, GraphicsShaderGroupCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GraphicsShaderGroupCreateInfoNV" );
  if( j.find( "stageCount" ) != j.end() ) {
    p.stageCount = j[ "stageCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkGraphicsShaderGroupCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: GraphicsShaderGroupCreateInfoNV temp;
  from_json( j, temp );
  p = VkGraphicsShaderGroupCreateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const GraphicsPipelineShaderGroupsCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "groupCount" ] = p.groupCount;
  j[ "pGroups" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pGroups ) );
  j[ "pipelineCount" ] = p.pipelineCount;
  j[ "pPipelines" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPipelines ) );
}
}
void to_json( nlohmann::json &j, const VkGraphicsPipelineShaderGroupsCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: GraphicsPipelineShaderGroupsCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, GraphicsPipelineShaderGroupsCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GraphicsPipelineShaderGroupsCreateInfoNV" );
  if( j.find( "groupCount" ) != j.end() ) {
    p.groupCount = j[ "groupCount" ];
  }
  if( j.find( "pipelineCount" ) != j.end() ) {
    p.pipelineCount = j[ "pipelineCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkGraphicsPipelineShaderGroupsCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: GraphicsPipelineShaderGroupsCreateInfoNV temp;
  from_json( j, temp );
  p = VkGraphicsPipelineShaderGroupsCreateInfoNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const XYColorEXT &p ) {
  j = nlohmann::json::object();
  j[ "x" ] = p.x;
  j[ "y" ] = p.y;
}
}
void to_json( nlohmann::json &j, const VkXYColorEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: XYColorEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, XYColorEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for XYColorEXT" );
  if( j.find( "x" ) != j.end() ) {
    p.x = j[ "x" ];
  }
  if( j.find( "y" ) != j.end() ) {
    p.y = j[ "y" ];
  }
}
}
void from_json( const nlohmann::json &j, VkXYColorEXT &p ) {
  VULKAN_HPP_NAMESPACE :: XYColorEXT temp;
  from_json( j, temp );
  p = VkXYColorEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/XYColorEXT.hpp>
#include <vulkan2json/XYColorEXT.hpp>
#include <vulkan2json/XYColorEXT.hpp>
#include <vulkan2json/XYColorEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const HdrMetadataEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "displayPrimaryRed" ] = p.displayPrimaryRed;
  j[ "displayPrimaryGreen" ] = p.displayPrimaryGreen;
  j[ "displayPrimaryBlue" ] = p.displayPrimaryBlue;
  j[ "whitePoint" ] = p.whitePoint;
  j[ "maxLuminance" ] = p.maxLuminance;
  j[ "minLuminance" ] = p.minLuminance;
  j[ "maxContentLightLevel" ] = p.maxContentLightLevel;
  j[ "maxFrameAverageLightLevel" ] = p.maxFrameAverageLightLevel;
}
}
void to_json( nlohmann::json &j, const VkHdrMetadataEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: HdrMetadataEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, HdrMetadataEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for HdrMetadataEXT" );
  if( j.find( "displayPrimaryRed" ) != j.end() ) {
    p.displayPrimaryRed = XYColorEXT ( j[ "displayPrimaryRed" ] );
  }
  if( j.find( "displayPrimaryGreen" ) != j.end() ) {
    p.displayPrimaryGreen = XYColorEXT ( j[ "displayPrimaryGreen" ] );
  }
  if( j.find( "displayPrimaryBlue" ) != j.end() ) {
    p.displayPrimaryBlue = XYColorEXT ( j[ "displayPrimaryBlue" ] );
  }
  if( j.find( "whitePoint" ) != j.end() ) {
    p.whitePoint = XYColorEXT ( j[ "whitePoint" ] );
  }
  if( j.find( "maxLuminance" ) != j.end() ) {
    p.maxLuminance = j[ "maxLuminance" ];
  }
  if( j.find( "minLuminance" ) != j.end() ) {
    p.minLuminance = j[ "minLuminance" ];
  }
  if( j.find( "maxContentLightLevel" ) != j.end() ) {
    p.maxContentLightLevel = j[ "maxContentLightLevel" ];
  }
  if( j.find( "maxFrameAverageLightLevel" ) != j.end() ) {
    p.maxFrameAverageLightLevel = j[ "maxFrameAverageLightLevel" ];
  }
}
}
void from_json( const nlohmann::json &j, VkHdrMetadataEXT &p ) {
  VULKAN_HPP_NAMESPACE :: HdrMetadataEXT temp;
  from_json( j, temp );
  p = VkHdrMetadataEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/HeadlessSurfaceCreateFlagsEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const HeadlessSurfaceCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkHeadlessSurfaceCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: HeadlessSurfaceCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, HeadlessSurfaceCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for HeadlessSurfaceCreateInfoEXT" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = HeadlessSurfaceCreateFlagsEXT ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkHeadlessSurfaceCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: HeadlessSurfaceCreateInfoEXT temp;
  from_json( j, temp );
  p = VkHeadlessSurfaceCreateInfoEXT ( temp );
}
#include <vulkan2json/ImageSubresourceLayers.hpp>
#include <vulkan2json/Offset3D.hpp>
#include <vulkan2json/ImageSubresourceLayers.hpp>
#include <vulkan2json/Offset3D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageBlit &p ) {
  j = nlohmann::json::object();
  j[ "srcSubresource" ] = p.srcSubresource;
  j[ "srcOffsets" ] = nlohmann::json::array();
  std::copy( p.srcOffsets.begin(), p.srcOffsets.end(), std::back_inserter( j[ "srcOffsets" ] ) );
  j[ "dstSubresource" ] = p.dstSubresource;
  j[ "dstOffsets" ] = nlohmann::json::array();
  std::copy( p.dstOffsets.begin(), p.dstOffsets.end(), std::back_inserter( j[ "dstOffsets" ] ) );
}
}
void to_json( nlohmann::json &j, const VkImageBlit &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageBlit ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageBlit &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageBlit" );
  if( j.find( "srcSubresource" ) != j.end() ) {
    p.srcSubresource = ImageSubresourceLayers ( j[ "srcSubresource" ] );
  }
  if( j.find( "srcOffsets" ) != j.end() ) {
    if( !j[ "srcOffsets" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for ImageBlit.srcOffsets" );
    if( !j[ "srcOffsets" ].size() > p.srcOffsets.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for ImageBlit.srcOffsets" );
    std::fill( p.srcOffsets.begin(), p.srcOffsets.end(), Offset3D () );
    std::transform( j[ "srcOffsets" ].begin(), j[ "srcOffsets" ].end(), p.srcOffsets.begin(), []( const auto &v ) { return Offset3D ( v ); } );
  }
  if( j.find( "dstSubresource" ) != j.end() ) {
    p.dstSubresource = ImageSubresourceLayers ( j[ "dstSubresource" ] );
  }
  if( j.find( "dstOffsets" ) != j.end() ) {
    if( !j[ "dstOffsets" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for ImageBlit.dstOffsets" );
    if( !j[ "dstOffsets" ].size() > p.dstOffsets.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for ImageBlit.dstOffsets" );
    std::fill( p.dstOffsets.begin(), p.dstOffsets.end(), Offset3D () );
    std::transform( j[ "dstOffsets" ].begin(), j[ "dstOffsets" ].end(), p.dstOffsets.begin(), []( const auto &v ) { return Offset3D ( v ); } );
  }
}
}
void from_json( const nlohmann::json &j, VkImageBlit &p ) {
  VULKAN_HPP_NAMESPACE :: ImageBlit temp;
  from_json( j, temp );
  p = VkImageBlit ( temp );
}
#include <vulkan2json/ImageSubresourceLayers.hpp>
#include <vulkan2json/Offset3D.hpp>
#include <vulkan2json/ImageSubresourceLayers.hpp>
#include <vulkan2json/Offset3D.hpp>
#include <vulkan2json/Extent3D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageCopy &p ) {
  j = nlohmann::json::object();
  j[ "srcSubresource" ] = p.srcSubresource;
  j[ "srcOffset" ] = p.srcOffset;
  j[ "dstSubresource" ] = p.dstSubresource;
  j[ "dstOffset" ] = p.dstOffset;
  j[ "extent" ] = p.extent;
}
}
void to_json( nlohmann::json &j, const VkImageCopy &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageCopy ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageCopy &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageCopy" );
  if( j.find( "srcSubresource" ) != j.end() ) {
    p.srcSubresource = ImageSubresourceLayers ( j[ "srcSubresource" ] );
  }
  if( j.find( "srcOffset" ) != j.end() ) {
    p.srcOffset = Offset3D ( j[ "srcOffset" ] );
  }
  if( j.find( "dstSubresource" ) != j.end() ) {
    p.dstSubresource = ImageSubresourceLayers ( j[ "dstSubresource" ] );
  }
  if( j.find( "dstOffset" ) != j.end() ) {
    p.dstOffset = Offset3D ( j[ "dstOffset" ] );
  }
  if( j.find( "extent" ) != j.end() ) {
    p.extent = Extent3D ( j[ "extent" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImageCopy &p ) {
  VULKAN_HPP_NAMESPACE :: ImageCopy temp;
  from_json( j, temp );
  p = VkImageCopy ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageCreateFlags.hpp>
#include <vulkan2json/ImageType.hpp>
#include <vulkan2json/Format.hpp>
#include <vulkan2json/Extent3D.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/ImageTiling.hpp>
#include <vulkan2json/ImageUsageFlags.hpp>
#include <vulkan2json/SharingMode.hpp>
#include <vulkan2json/ImageLayout.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "imageType" ] = p.imageType;
  j[ "format" ] = p.format;
  j[ "extent" ] = p.extent;
  j[ "mipLevels" ] = p.mipLevels;
  j[ "arrayLayers" ] = p.arrayLayers;
  j[ "samples" ] = p.samples;
  j[ "tiling" ] = p.tiling;
  j[ "usage" ] = p.usage;
  j[ "sharingMode" ] = p.sharingMode;
  j[ "queueFamilyIndexCount" ] = p.queueFamilyIndexCount;
  j[ "pQueueFamilyIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pQueueFamilyIndices ) );
  j[ "initialLayout" ] = p.initialLayout;
}
}
void to_json( nlohmann::json &j, const VkImageCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = ImageCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "imageType" ) != j.end() ) {
    p.imageType = ImageType ( j[ "imageType" ] );
  }
  if( j.find( "format" ) != j.end() ) {
    p.format = Format ( j[ "format" ] );
  }
  if( j.find( "extent" ) != j.end() ) {
    p.extent = Extent3D ( j[ "extent" ] );
  }
  if( j.find( "mipLevels" ) != j.end() ) {
    p.mipLevels = j[ "mipLevels" ];
  }
  if( j.find( "arrayLayers" ) != j.end() ) {
    p.arrayLayers = j[ "arrayLayers" ];
  }
  if( j.find( "samples" ) != j.end() ) {
    p.samples = SampleCountFlagBits ( j[ "samples" ] );
  }
  if( j.find( "tiling" ) != j.end() ) {
    p.tiling = ImageTiling ( j[ "tiling" ] );
  }
  if( j.find( "usage" ) != j.end() ) {
    p.usage = ImageUsageFlags ( j[ "usage" ] );
  }
  if( j.find( "sharingMode" ) != j.end() ) {
    p.sharingMode = SharingMode ( j[ "sharingMode" ] );
  }
  if( j.find( "queueFamilyIndexCount" ) != j.end() ) {
    p.queueFamilyIndexCount = j[ "queueFamilyIndexCount" ];
  }
  if( j.find( "initialLayout" ) != j.end() ) {
    p.initialLayout = ImageLayout ( j[ "initialLayout" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImageCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ImageCreateInfo temp;
  from_json( j, temp );
  p = VkImageCreateInfo ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubresourceLayout &p ) {
  j = nlohmann::json::object();
  j[ "offset" ] = p.offset;
  j[ "size" ] = p.size;
  j[ "rowPitch" ] = p.rowPitch;
  j[ "arrayPitch" ] = p.arrayPitch;
  j[ "depthPitch" ] = p.depthPitch;
}
}
void to_json( nlohmann::json &j, const VkSubresourceLayout &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SubresourceLayout ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SubresourceLayout &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubresourceLayout" );
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
  if( j.find( "rowPitch" ) != j.end() ) {
    p.rowPitch = j[ "rowPitch" ];
  }
  if( j.find( "arrayPitch" ) != j.end() ) {
    p.arrayPitch = j[ "arrayPitch" ];
  }
  if( j.find( "depthPitch" ) != j.end() ) {
    p.depthPitch = j[ "depthPitch" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSubresourceLayout &p ) {
  VULKAN_HPP_NAMESPACE :: SubresourceLayout temp;
  from_json( j, temp );
  p = VkSubresourceLayout ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageDrmFormatModifierExplicitCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "drmFormatModifier" ] = p.drmFormatModifier;
  j[ "drmFormatModifierPlaneCount" ] = p.drmFormatModifierPlaneCount;
  j[ "pPlaneLayouts" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPlaneLayouts ) );
}
}
void to_json( nlohmann::json &j, const VkImageDrmFormatModifierExplicitCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageDrmFormatModifierExplicitCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageDrmFormatModifierExplicitCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageDrmFormatModifierExplicitCreateInfoEXT" );
  if( j.find( "drmFormatModifier" ) != j.end() ) {
    p.drmFormatModifier = j[ "drmFormatModifier" ];
  }
  if( j.find( "drmFormatModifierPlaneCount" ) != j.end() ) {
    p.drmFormatModifierPlaneCount = j[ "drmFormatModifierPlaneCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkImageDrmFormatModifierExplicitCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ImageDrmFormatModifierExplicitCreateInfoEXT temp;
  from_json( j, temp );
  p = VkImageDrmFormatModifierExplicitCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageDrmFormatModifierListCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "drmFormatModifierCount" ] = p.drmFormatModifierCount;
  j[ "pDrmFormatModifiers" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDrmFormatModifiers ) );
}
}
void to_json( nlohmann::json &j, const VkImageDrmFormatModifierListCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageDrmFormatModifierListCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageDrmFormatModifierListCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageDrmFormatModifierListCreateInfoEXT" );
  if( j.find( "drmFormatModifierCount" ) != j.end() ) {
    p.drmFormatModifierCount = j[ "drmFormatModifierCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkImageDrmFormatModifierListCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ImageDrmFormatModifierListCreateInfoEXT temp;
  from_json( j, temp );
  p = VkImageDrmFormatModifierListCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageDrmFormatModifierPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "drmFormatModifier" ] = p.drmFormatModifier;
}
}
void to_json( nlohmann::json &j, const VkImageDrmFormatModifierPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageDrmFormatModifierPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageDrmFormatModifierPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageDrmFormatModifierPropertiesEXT" );
  if( j.find( "drmFormatModifier" ) != j.end() ) {
    p.drmFormatModifier = j[ "drmFormatModifier" ];
  }
}
}
void from_json( const nlohmann::json &j, VkImageDrmFormatModifierPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ImageDrmFormatModifierPropertiesEXT temp;
  from_json( j, temp );
  p = VkImageDrmFormatModifierPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageFormatListCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "viewFormatCount" ] = p.viewFormatCount;
  j[ "pViewFormats" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewFormats ) );
}
}
void to_json( nlohmann::json &j, const VkImageFormatListCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageFormatListCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageFormatListCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageFormatListCreateInfo" );
  if( j.find( "viewFormatCount" ) != j.end() ) {
    p.viewFormatCount = j[ "viewFormatCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkImageFormatListCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ImageFormatListCreateInfo temp;
  from_json( j, temp );
  p = VkImageFormatListCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageFormatProperties.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageFormatProperties2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "imageFormatProperties" ] = p.imageFormatProperties;
}
}
void to_json( nlohmann::json &j, const VkImageFormatProperties2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageFormatProperties2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageFormatProperties2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageFormatProperties2" );
  if( j.find( "imageFormatProperties" ) != j.end() ) {
    p.imageFormatProperties = ImageFormatProperties ( j[ "imageFormatProperties" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImageFormatProperties2 &p ) {
  VULKAN_HPP_NAMESPACE :: ImageFormatProperties2 temp;
  from_json( j, temp );
  p = VkImageFormatProperties2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/AccessFlags.hpp>
#include <vulkan2json/AccessFlags.hpp>
#include <vulkan2json/ImageLayout.hpp>
#include <vulkan2json/ImageLayout.hpp>
#include <vulkan2json/ImageSubresourceRange.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageMemoryBarrier &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
  j[ "oldLayout" ] = p.oldLayout;
  j[ "newLayout" ] = p.newLayout;
  j[ "srcQueueFamilyIndex" ] = p.srcQueueFamilyIndex;
  j[ "dstQueueFamilyIndex" ] = p.dstQueueFamilyIndex;
  j[ "subresourceRange" ] = p.subresourceRange;
}
}
void to_json( nlohmann::json &j, const VkImageMemoryBarrier &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageMemoryBarrier ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageMemoryBarrier &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageMemoryBarrier" );
  if( j.find( "srcAccessMask" ) != j.end() ) {
    p.srcAccessMask = AccessFlags ( j[ "srcAccessMask" ] );
  }
  if( j.find( "dstAccessMask" ) != j.end() ) {
    p.dstAccessMask = AccessFlags ( j[ "dstAccessMask" ] );
  }
  if( j.find( "oldLayout" ) != j.end() ) {
    p.oldLayout = ImageLayout ( j[ "oldLayout" ] );
  }
  if( j.find( "newLayout" ) != j.end() ) {
    p.newLayout = ImageLayout ( j[ "newLayout" ] );
  }
  if( j.find( "srcQueueFamilyIndex" ) != j.end() ) {
    p.srcQueueFamilyIndex = j[ "srcQueueFamilyIndex" ];
  }
  if( j.find( "dstQueueFamilyIndex" ) != j.end() ) {
    p.dstQueueFamilyIndex = j[ "dstQueueFamilyIndex" ];
  }
  if( j.find( "subresourceRange" ) != j.end() ) {
    p.subresourceRange = ImageSubresourceRange ( j[ "subresourceRange" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImageMemoryBarrier &p ) {
  VULKAN_HPP_NAMESPACE :: ImageMemoryBarrier temp;
  from_json( j, temp );
  p = VkImageMemoryBarrier ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageMemoryRequirementsInfo2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkImageMemoryRequirementsInfo2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageMemoryRequirementsInfo2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageMemoryRequirementsInfo2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageMemoryRequirementsInfo2" );
}
}
void from_json( const nlohmann::json &j, VkImageMemoryRequirementsInfo2 &p ) {
  VULKAN_HPP_NAMESPACE :: ImageMemoryRequirementsInfo2 temp;
  from_json( j, temp );
  p = VkImageMemoryRequirementsInfo2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageAspectFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImagePlaneMemoryRequirementsInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "planeAspect" ] = p.planeAspect;
}
}
void to_json( nlohmann::json &j, const VkImagePlaneMemoryRequirementsInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImagePlaneMemoryRequirementsInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImagePlaneMemoryRequirementsInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImagePlaneMemoryRequirementsInfo" );
  if( j.find( "planeAspect" ) != j.end() ) {
    p.planeAspect = ImageAspectFlagBits ( j[ "planeAspect" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImagePlaneMemoryRequirementsInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ImagePlaneMemoryRequirementsInfo temp;
  from_json( j, temp );
  p = VkImagePlaneMemoryRequirementsInfo ( temp );
}
#include <vulkan2json/ImageSubresourceLayers.hpp>
#include <vulkan2json/Offset3D.hpp>
#include <vulkan2json/ImageSubresourceLayers.hpp>
#include <vulkan2json/Offset3D.hpp>
#include <vulkan2json/Extent3D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageResolve &p ) {
  j = nlohmann::json::object();
  j[ "srcSubresource" ] = p.srcSubresource;
  j[ "srcOffset" ] = p.srcOffset;
  j[ "dstSubresource" ] = p.dstSubresource;
  j[ "dstOffset" ] = p.dstOffset;
  j[ "extent" ] = p.extent;
}
}
void to_json( nlohmann::json &j, const VkImageResolve &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageResolve ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageResolve &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageResolve" );
  if( j.find( "srcSubresource" ) != j.end() ) {
    p.srcSubresource = ImageSubresourceLayers ( j[ "srcSubresource" ] );
  }
  if( j.find( "srcOffset" ) != j.end() ) {
    p.srcOffset = Offset3D ( j[ "srcOffset" ] );
  }
  if( j.find( "dstSubresource" ) != j.end() ) {
    p.dstSubresource = ImageSubresourceLayers ( j[ "dstSubresource" ] );
  }
  if( j.find( "dstOffset" ) != j.end() ) {
    p.dstOffset = Offset3D ( j[ "dstOffset" ] );
  }
  if( j.find( "extent" ) != j.end() ) {
    p.extent = Extent3D ( j[ "extent" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImageResolve &p ) {
  VULKAN_HPP_NAMESPACE :: ImageResolve temp;
  from_json( j, temp );
  p = VkImageResolve ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageSubresourceLayers.hpp>
#include <vulkan2json/Offset3D.hpp>
#include <vulkan2json/ImageSubresourceLayers.hpp>
#include <vulkan2json/Offset3D.hpp>
#include <vulkan2json/Extent3D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageResolve2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcSubresource" ] = p.srcSubresource;
  j[ "srcOffset" ] = p.srcOffset;
  j[ "dstSubresource" ] = p.dstSubresource;
  j[ "dstOffset" ] = p.dstOffset;
  j[ "extent" ] = p.extent;
}
}
void to_json( nlohmann::json &j, const VkImageResolve2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageResolve2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageResolve2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageResolve2KHR" );
  if( j.find( "srcSubresource" ) != j.end() ) {
    p.srcSubresource = ImageSubresourceLayers ( j[ "srcSubresource" ] );
  }
  if( j.find( "srcOffset" ) != j.end() ) {
    p.srcOffset = Offset3D ( j[ "srcOffset" ] );
  }
  if( j.find( "dstSubresource" ) != j.end() ) {
    p.dstSubresource = ImageSubresourceLayers ( j[ "dstSubresource" ] );
  }
  if( j.find( "dstOffset" ) != j.end() ) {
    p.dstOffset = Offset3D ( j[ "dstOffset" ] );
  }
  if( j.find( "extent" ) != j.end() ) {
    p.extent = Extent3D ( j[ "extent" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImageResolve2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: ImageResolve2KHR temp;
  from_json( j, temp );
  p = VkImageResolve2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageSparseMemoryRequirementsInfo2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkImageSparseMemoryRequirementsInfo2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageSparseMemoryRequirementsInfo2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageSparseMemoryRequirementsInfo2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageSparseMemoryRequirementsInfo2" );
}
}
void from_json( const nlohmann::json &j, VkImageSparseMemoryRequirementsInfo2 &p ) {
  VULKAN_HPP_NAMESPACE :: ImageSparseMemoryRequirementsInfo2 temp;
  from_json( j, temp );
  p = VkImageSparseMemoryRequirementsInfo2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageUsageFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageStencilUsageCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stencilUsage" ] = p.stencilUsage;
}
}
void to_json( nlohmann::json &j, const VkImageStencilUsageCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageStencilUsageCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageStencilUsageCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageStencilUsageCreateInfo" );
  if( j.find( "stencilUsage" ) != j.end() ) {
    p.stencilUsage = ImageUsageFlags ( j[ "stencilUsage" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImageStencilUsageCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ImageStencilUsageCreateInfo temp;
  from_json( j, temp );
  p = VkImageStencilUsageCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageSwapchainCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkImageSwapchainCreateInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageSwapchainCreateInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageSwapchainCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageSwapchainCreateInfoKHR" );
}
}
void from_json( const nlohmann::json &j, VkImageSwapchainCreateInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: ImageSwapchainCreateInfoKHR temp;
  from_json( j, temp );
  p = VkImageSwapchainCreateInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Format.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageViewASTCDecodeModeEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "decodeMode" ] = p.decodeMode;
}
}
void to_json( nlohmann::json &j, const VkImageViewASTCDecodeModeEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageViewASTCDecodeModeEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageViewASTCDecodeModeEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageViewASTCDecodeModeEXT" );
  if( j.find( "decodeMode" ) != j.end() ) {
    p.decodeMode = Format ( j[ "decodeMode" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImageViewASTCDecodeModeEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ImageViewASTCDecodeModeEXT temp;
  from_json( j, temp );
  p = VkImageViewASTCDecodeModeEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageViewAddressPropertiesNVX &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "size" ] = p.size;
}
}
void to_json( nlohmann::json &j, const VkImageViewAddressPropertiesNVX &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageViewAddressPropertiesNVX ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageViewAddressPropertiesNVX &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageViewAddressPropertiesNVX" );
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
}
}
void from_json( const nlohmann::json &j, VkImageViewAddressPropertiesNVX &p ) {
  VULKAN_HPP_NAMESPACE :: ImageViewAddressPropertiesNVX temp;
  from_json( j, temp );
  p = VkImageViewAddressPropertiesNVX ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageViewCreateFlags.hpp>
#include <vulkan2json/ImageViewType.hpp>
#include <vulkan2json/Format.hpp>
#include <vulkan2json/ComponentMapping.hpp>
#include <vulkan2json/ImageSubresourceRange.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageViewCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "viewType" ] = p.viewType;
  j[ "format" ] = p.format;
  j[ "components" ] = p.components;
  j[ "subresourceRange" ] = p.subresourceRange;
}
}
void to_json( nlohmann::json &j, const VkImageViewCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageViewCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageViewCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageViewCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = ImageViewCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "viewType" ) != j.end() ) {
    p.viewType = ImageViewType ( j[ "viewType" ] );
  }
  if( j.find( "format" ) != j.end() ) {
    p.format = Format ( j[ "format" ] );
  }
  if( j.find( "components" ) != j.end() ) {
    p.components = ComponentMapping ( j[ "components" ] );
  }
  if( j.find( "subresourceRange" ) != j.end() ) {
    p.subresourceRange = ImageSubresourceRange ( j[ "subresourceRange" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImageViewCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ImageViewCreateInfo temp;
  from_json( j, temp );
  p = VkImageViewCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DescriptorType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageViewHandleInfoNVX &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "descriptorType" ] = p.descriptorType;
}
}
void to_json( nlohmann::json &j, const VkImageViewHandleInfoNVX &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageViewHandleInfoNVX ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageViewHandleInfoNVX &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageViewHandleInfoNVX" );
  if( j.find( "descriptorType" ) != j.end() ) {
    p.descriptorType = DescriptorType ( j[ "descriptorType" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImageViewHandleInfoNVX &p ) {
  VULKAN_HPP_NAMESPACE :: ImageViewHandleInfoNVX temp;
  from_json( j, temp );
  p = VkImageViewHandleInfoNVX ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageUsageFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImageViewUsageCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "usage" ] = p.usage;
}
}
void to_json( nlohmann::json &j, const VkImageViewUsageCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImageViewUsageCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImageViewUsageCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageViewUsageCreateInfo" );
  if( j.find( "usage" ) != j.end() ) {
    p.usage = ImageUsageFlags ( j[ "usage" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImageViewUsageCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ImageViewUsageCreateInfo temp;
  from_json( j, temp );
  p = VkImageViewUsageCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/FenceImportFlags.hpp>
#include <vulkan2json/ExternalFenceHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImportFenceFdInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "handleType" ] = p.handleType;
  j[ "fd" ] = p.fd;
}
}
void to_json( nlohmann::json &j, const VkImportFenceFdInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImportFenceFdInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImportFenceFdInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportFenceFdInfoKHR" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = FenceImportFlags ( j[ "flags" ] );
  }
  if( j.find( "handleType" ) != j.end() ) {
    p.handleType = ExternalFenceHandleTypeFlagBits ( j[ "handleType" ] );
  }
  if( j.find( "fd" ) != j.end() ) {
    p.fd = j[ "fd" ];
  }
}
}
void from_json( const nlohmann::json &j, VkImportFenceFdInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: ImportFenceFdInfoKHR temp;
  from_json( j, temp );
  p = VkImportFenceFdInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalMemoryHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImportMemoryFdInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
  j[ "fd" ] = p.fd;
}
}
void to_json( nlohmann::json &j, const VkImportMemoryFdInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImportMemoryFdInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImportMemoryFdInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportMemoryFdInfoKHR" );
  if( j.find( "handleType" ) != j.end() ) {
    p.handleType = ExternalMemoryHandleTypeFlagBits ( j[ "handleType" ] );
  }
  if( j.find( "fd" ) != j.end() ) {
    p.fd = j[ "fd" ];
  }
}
}
void from_json( const nlohmann::json &j, VkImportMemoryFdInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: ImportMemoryFdInfoKHR temp;
  from_json( j, temp );
  p = VkImportMemoryFdInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalMemoryHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImportMemoryHostPointerInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
  j[ "pHostPointer" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pHostPointer ) );
}
}
void to_json( nlohmann::json &j, const VkImportMemoryHostPointerInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImportMemoryHostPointerInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImportMemoryHostPointerInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportMemoryHostPointerInfoEXT" );
  if( j.find( "handleType" ) != j.end() ) {
    p.handleType = ExternalMemoryHandleTypeFlagBits ( j[ "handleType" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkImportMemoryHostPointerInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ImportMemoryHostPointerInfoEXT temp;
  from_json( j, temp );
  p = VkImportMemoryHostPointerInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SemaphoreImportFlags.hpp>
#include <vulkan2json/ExternalSemaphoreHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ImportSemaphoreFdInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "handleType" ] = p.handleType;
  j[ "fd" ] = p.fd;
}
}
void to_json( nlohmann::json &j, const VkImportSemaphoreFdInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ImportSemaphoreFdInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ImportSemaphoreFdInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportSemaphoreFdInfoKHR" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = SemaphoreImportFlags ( j[ "flags" ] );
  }
  if( j.find( "handleType" ) != j.end() ) {
    p.handleType = ExternalSemaphoreHandleTypeFlagBits ( j[ "handleType" ] );
  }
  if( j.find( "fd" ) != j.end() ) {
    p.fd = j[ "fd" ];
  }
}
}
void from_json( const nlohmann::json &j, VkImportSemaphoreFdInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: ImportSemaphoreFdInfoKHR temp;
  from_json( j, temp );
  p = VkImportSemaphoreFdInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/IndirectCommandsTokenTypeNV.hpp>
#include <vulkan2json/ShaderStageFlags.hpp>
#include <vulkan2json/IndirectStateFlagsNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const IndirectCommandsLayoutTokenNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "tokenType" ] = p.tokenType;
  j[ "stream" ] = p.stream;
  j[ "offset" ] = p.offset;
  j[ "vertexBindingUnit" ] = p.vertexBindingUnit;
  j[ "vertexDynamicStride" ] = bool( p.vertexDynamicStride );
  j[ "pushconstantShaderStageFlags" ] = p.pushconstantShaderStageFlags;
  j[ "pushconstantOffset" ] = p.pushconstantOffset;
  j[ "pushconstantSize" ] = p.pushconstantSize;
  j[ "indirectStateFlags" ] = p.indirectStateFlags;
  j[ "indexTypeCount" ] = p.indexTypeCount;
  j[ "pIndexTypes" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pIndexTypes ) );
  j[ "pIndexTypeValues" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pIndexTypeValues ) );
}
}
void to_json( nlohmann::json &j, const VkIndirectCommandsLayoutTokenNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: IndirectCommandsLayoutTokenNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, IndirectCommandsLayoutTokenNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for IndirectCommandsLayoutTokenNV" );
  if( j.find( "tokenType" ) != j.end() ) {
    p.tokenType = IndirectCommandsTokenTypeNV ( j[ "tokenType" ] );
  }
  if( j.find( "stream" ) != j.end() ) {
    p.stream = j[ "stream" ];
  }
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
  if( j.find( "vertexBindingUnit" ) != j.end() ) {
    p.vertexBindingUnit = j[ "vertexBindingUnit" ];
  }
  if( j.find( "vertexDynamicStride" ) != j.end() ) {
    p.vertexDynamicStride = j[ "vertexDynamicStride" ];
  }
  if( j.find( "pushconstantShaderStageFlags" ) != j.end() ) {
    p.pushconstantShaderStageFlags = ShaderStageFlags ( j[ "pushconstantShaderStageFlags" ] );
  }
  if( j.find( "pushconstantOffset" ) != j.end() ) {
    p.pushconstantOffset = j[ "pushconstantOffset" ];
  }
  if( j.find( "pushconstantSize" ) != j.end() ) {
    p.pushconstantSize = j[ "pushconstantSize" ];
  }
  if( j.find( "indirectStateFlags" ) != j.end() ) {
    p.indirectStateFlags = IndirectStateFlagsNV ( j[ "indirectStateFlags" ] );
  }
  if( j.find( "indexTypeCount" ) != j.end() ) {
    p.indexTypeCount = j[ "indexTypeCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkIndirectCommandsLayoutTokenNV &p ) {
  VULKAN_HPP_NAMESPACE :: IndirectCommandsLayoutTokenNV temp;
  from_json( j, temp );
  p = VkIndirectCommandsLayoutTokenNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/IndirectCommandsLayoutUsageFlagsNV.hpp>
#include <vulkan2json/PipelineBindPoint.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const IndirectCommandsLayoutCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pipelineBindPoint" ] = p.pipelineBindPoint;
  j[ "tokenCount" ] = p.tokenCount;
  j[ "pTokens" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pTokens ) );
  j[ "streamCount" ] = p.streamCount;
  j[ "pStreamStrides" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStreamStrides ) );
}
}
void to_json( nlohmann::json &j, const VkIndirectCommandsLayoutCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: IndirectCommandsLayoutCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, IndirectCommandsLayoutCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for IndirectCommandsLayoutCreateInfoNV" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = IndirectCommandsLayoutUsageFlagsNV ( j[ "flags" ] );
  }
  if( j.find( "pipelineBindPoint" ) != j.end() ) {
    p.pipelineBindPoint = PipelineBindPoint ( j[ "pipelineBindPoint" ] );
  }
  if( j.find( "tokenCount" ) != j.end() ) {
    p.tokenCount = j[ "tokenCount" ];
  }
  if( j.find( "streamCount" ) != j.end() ) {
    p.streamCount = j[ "streamCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkIndirectCommandsLayoutCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: IndirectCommandsLayoutCreateInfoNV temp;
  from_json( j, temp );
  p = VkIndirectCommandsLayoutCreateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const InitializePerformanceApiInfoINTEL &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pUserData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pUserData ) );
}
}
void to_json( nlohmann::json &j, const VkInitializePerformanceApiInfoINTEL &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: InitializePerformanceApiInfoINTEL ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, InitializePerformanceApiInfoINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for InitializePerformanceApiInfoINTEL" );
}
}
void from_json( const nlohmann::json &j, VkInitializePerformanceApiInfoINTEL &p ) {
  VULKAN_HPP_NAMESPACE :: InitializePerformanceApiInfoINTEL temp;
  from_json( j, temp );
  p = VkInitializePerformanceApiInfoINTEL ( temp );
}
#include <vulkan2json/ImageAspectFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const InputAttachmentAspectReference &p ) {
  j = nlohmann::json::object();
  j[ "subpass" ] = p.subpass;
  j[ "inputAttachmentIndex" ] = p.inputAttachmentIndex;
  j[ "aspectMask" ] = p.aspectMask;
}
}
void to_json( nlohmann::json &j, const VkInputAttachmentAspectReference &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: InputAttachmentAspectReference ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, InputAttachmentAspectReference &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for InputAttachmentAspectReference" );
  if( j.find( "subpass" ) != j.end() ) {
    p.subpass = j[ "subpass" ];
  }
  if( j.find( "inputAttachmentIndex" ) != j.end() ) {
    p.inputAttachmentIndex = j[ "inputAttachmentIndex" ];
  }
  if( j.find( "aspectMask" ) != j.end() ) {
    p.aspectMask = ImageAspectFlags ( j[ "aspectMask" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkInputAttachmentAspectReference &p ) {
  VULKAN_HPP_NAMESPACE :: InputAttachmentAspectReference temp;
  from_json( j, temp );
  p = VkInputAttachmentAspectReference ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/InstanceCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const InstanceCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pApplicationInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pApplicationInfo ) );
  j[ "enabledLayerCount" ] = p.enabledLayerCount;
  j[ "ppEnabledLayerNames" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.ppEnabledLayerNames ) );
  j[ "enabledExtensionCount" ] = p.enabledExtensionCount;
  j[ "ppEnabledExtensionNames" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.ppEnabledExtensionNames ) );
}
}
void to_json( nlohmann::json &j, const VkInstanceCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: InstanceCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, InstanceCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for InstanceCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = InstanceCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "enabledLayerCount" ) != j.end() ) {
    p.enabledLayerCount = j[ "enabledLayerCount" ];
  }
  if( j.find( "enabledExtensionCount" ) != j.end() ) {
    p.enabledExtensionCount = j[ "enabledExtensionCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkInstanceCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: InstanceCreateInfo temp;
  from_json( j, temp );
  p = VkInstanceCreateInfo ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const LayerProperties &p ) {
  j = nlohmann::json::object();
  j[ "layerName" ] = std::string( p.layerName.begin(), std::find( p.layerName.begin(), p.layerName.end(), '\0' ) );
  j[ "specVersion" ] = p.specVersion;
  j[ "implementationVersion" ] = p.implementationVersion;
  j[ "description" ] = std::string( p.description.begin(), std::find( p.description.begin(), p.description.end(), '\0' ) );
}
}
void to_json( nlohmann::json &j, const VkLayerProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: LayerProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, LayerProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for LayerProperties" );
  if( j.find( "layerName" ) != j.end() ) {
    {
      std::string s = j[ "layerName" ];
      if( !p.layerName.empty() ) {
        p.layerName[ p.layerName.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.layerName.size() - 1u ) ), p.layerName.begin() );
      }
    }
  }
  if( j.find( "specVersion" ) != j.end() ) {
    p.specVersion = j[ "specVersion" ];
  }
  if( j.find( "implementationVersion" ) != j.end() ) {
    p.implementationVersion = j[ "implementationVersion" ];
  }
  if( j.find( "description" ) != j.end() ) {
    {
      std::string s = j[ "description" ];
      if( !p.description.empty() ) {
        p.description[ p.description.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.description.size() - 1u ) ), p.description.begin() );
      }
    }
  }
}
}
void from_json( const nlohmann::json &j, VkLayerProperties &p ) {
  VULKAN_HPP_NAMESPACE :: LayerProperties temp;
  from_json( j, temp );
  p = VkLayerProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MappedMemoryRange &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "offset" ] = p.offset;
  j[ "size" ] = p.size;
}
}
void to_json( nlohmann::json &j, const VkMappedMemoryRange &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MappedMemoryRange ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MappedMemoryRange &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MappedMemoryRange" );
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
}
}
void from_json( const nlohmann::json &j, VkMappedMemoryRange &p ) {
  VULKAN_HPP_NAMESPACE :: MappedMemoryRange temp;
  from_json( j, temp );
  p = VkMappedMemoryRange ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/MemoryAllocateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryAllocateFlagsInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "deviceMask" ] = p.deviceMask;
}
}
void to_json( nlohmann::json &j, const VkMemoryAllocateFlagsInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryAllocateFlagsInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryAllocateFlagsInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryAllocateFlagsInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = MemoryAllocateFlags ( j[ "flags" ] );
  }
  if( j.find( "deviceMask" ) != j.end() ) {
    p.deviceMask = j[ "deviceMask" ];
  }
}
}
void from_json( const nlohmann::json &j, VkMemoryAllocateFlagsInfo &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryAllocateFlagsInfo temp;
  from_json( j, temp );
  p = VkMemoryAllocateFlagsInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryAllocateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "allocationSize" ] = p.allocationSize;
  j[ "memoryTypeIndex" ] = p.memoryTypeIndex;
}
}
void to_json( nlohmann::json &j, const VkMemoryAllocateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryAllocateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryAllocateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryAllocateInfo" );
  if( j.find( "allocationSize" ) != j.end() ) {
    p.allocationSize = j[ "allocationSize" ];
  }
  if( j.find( "memoryTypeIndex" ) != j.end() ) {
    p.memoryTypeIndex = j[ "memoryTypeIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkMemoryAllocateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryAllocateInfo temp;
  from_json( j, temp );
  p = VkMemoryAllocateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/AccessFlags.hpp>
#include <vulkan2json/AccessFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryBarrier &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
}
}
void to_json( nlohmann::json &j, const VkMemoryBarrier &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryBarrier ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryBarrier &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryBarrier" );
  if( j.find( "srcAccessMask" ) != j.end() ) {
    p.srcAccessMask = AccessFlags ( j[ "srcAccessMask" ] );
  }
  if( j.find( "dstAccessMask" ) != j.end() ) {
    p.dstAccessMask = AccessFlags ( j[ "dstAccessMask" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkMemoryBarrier &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryBarrier temp;
  from_json( j, temp );
  p = VkMemoryBarrier ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryDedicatedAllocateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkMemoryDedicatedAllocateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryDedicatedAllocateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryDedicatedAllocateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryDedicatedAllocateInfo" );
}
}
void from_json( const nlohmann::json &j, VkMemoryDedicatedAllocateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryDedicatedAllocateInfo temp;
  from_json( j, temp );
  p = VkMemoryDedicatedAllocateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryDedicatedRequirements &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "prefersDedicatedAllocation" ] = bool( p.prefersDedicatedAllocation );
  j[ "requiresDedicatedAllocation" ] = bool( p.requiresDedicatedAllocation );
}
}
void to_json( nlohmann::json &j, const VkMemoryDedicatedRequirements &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryDedicatedRequirements ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryDedicatedRequirements &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryDedicatedRequirements" );
  if( j.find( "prefersDedicatedAllocation" ) != j.end() ) {
    p.prefersDedicatedAllocation = j[ "prefersDedicatedAllocation" ];
  }
  if( j.find( "requiresDedicatedAllocation" ) != j.end() ) {
    p.requiresDedicatedAllocation = j[ "requiresDedicatedAllocation" ];
  }
}
}
void from_json( const nlohmann::json &j, VkMemoryDedicatedRequirements &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryDedicatedRequirements temp;
  from_json( j, temp );
  p = VkMemoryDedicatedRequirements ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryFdPropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryTypeBits" ] = p.memoryTypeBits;
}
}
void to_json( nlohmann::json &j, const VkMemoryFdPropertiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryFdPropertiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryFdPropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryFdPropertiesKHR" );
  if( j.find( "memoryTypeBits" ) != j.end() ) {
    p.memoryTypeBits = j[ "memoryTypeBits" ];
  }
}
}
void from_json( const nlohmann::json &j, VkMemoryFdPropertiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryFdPropertiesKHR temp;
  from_json( j, temp );
  p = VkMemoryFdPropertiesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalMemoryHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryGetFdInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
}
void to_json( nlohmann::json &j, const VkMemoryGetFdInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryGetFdInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryGetFdInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryGetFdInfoKHR" );
  if( j.find( "handleType" ) != j.end() ) {
    p.handleType = ExternalMemoryHandleTypeFlagBits ( j[ "handleType" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkMemoryGetFdInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryGetFdInfoKHR temp;
  from_json( j, temp );
  p = VkMemoryGetFdInfoKHR ( temp );
}
#include <vulkan2json/MemoryHeapFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryHeap &p ) {
  j = nlohmann::json::object();
  j[ "size" ] = p.size;
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkMemoryHeap &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryHeap ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryHeap &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryHeap" );
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
  if( j.find( "flags" ) != j.end() ) {
    p.flags = MemoryHeapFlags ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkMemoryHeap &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryHeap temp;
  from_json( j, temp );
  p = VkMemoryHeap ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryHostPointerPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryTypeBits" ] = p.memoryTypeBits;
}
}
void to_json( nlohmann::json &j, const VkMemoryHostPointerPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryHostPointerPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryHostPointerPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryHostPointerPropertiesEXT" );
  if( j.find( "memoryTypeBits" ) != j.end() ) {
    p.memoryTypeBits = j[ "memoryTypeBits" ];
  }
}
}
void from_json( const nlohmann::json &j, VkMemoryHostPointerPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryHostPointerPropertiesEXT temp;
  from_json( j, temp );
  p = VkMemoryHostPointerPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryOpaqueCaptureAddressAllocateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "opaqueCaptureAddress" ] = p.opaqueCaptureAddress;
}
}
void to_json( nlohmann::json &j, const VkMemoryOpaqueCaptureAddressAllocateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryOpaqueCaptureAddressAllocateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryOpaqueCaptureAddressAllocateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryOpaqueCaptureAddressAllocateInfo" );
  if( j.find( "opaqueCaptureAddress" ) != j.end() ) {
    p.opaqueCaptureAddress = j[ "opaqueCaptureAddress" ];
  }
}
}
void from_json( const nlohmann::json &j, VkMemoryOpaqueCaptureAddressAllocateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryOpaqueCaptureAddressAllocateInfo temp;
  from_json( j, temp );
  p = VkMemoryOpaqueCaptureAddressAllocateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryPriorityAllocateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "priority" ] = p.priority;
}
}
void to_json( nlohmann::json &j, const VkMemoryPriorityAllocateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryPriorityAllocateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryPriorityAllocateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryPriorityAllocateInfoEXT" );
  if( j.find( "priority" ) != j.end() ) {
    p.priority = j[ "priority" ];
  }
}
}
void from_json( const nlohmann::json &j, VkMemoryPriorityAllocateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryPriorityAllocateInfoEXT temp;
  from_json( j, temp );
  p = VkMemoryPriorityAllocateInfoEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryRequirements &p ) {
  j = nlohmann::json::object();
  j[ "size" ] = p.size;
  j[ "alignment" ] = p.alignment;
  j[ "memoryTypeBits" ] = p.memoryTypeBits;
}
}
void to_json( nlohmann::json &j, const VkMemoryRequirements &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryRequirements ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryRequirements &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryRequirements" );
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
  if( j.find( "alignment" ) != j.end() ) {
    p.alignment = j[ "alignment" ];
  }
  if( j.find( "memoryTypeBits" ) != j.end() ) {
    p.memoryTypeBits = j[ "memoryTypeBits" ];
  }
}
}
void from_json( const nlohmann::json &j, VkMemoryRequirements &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryRequirements temp;
  from_json( j, temp );
  p = VkMemoryRequirements ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/MemoryRequirements.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryRequirements2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryRequirements" ] = p.memoryRequirements;
}
}
void to_json( nlohmann::json &j, const VkMemoryRequirements2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryRequirements2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryRequirements2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryRequirements2" );
  if( j.find( "memoryRequirements" ) != j.end() ) {
    p.memoryRequirements = MemoryRequirements ( j[ "memoryRequirements" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkMemoryRequirements2 &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryRequirements2 temp;
  from_json( j, temp );
  p = VkMemoryRequirements2 ( temp );
}
#include <vulkan2json/MemoryPropertyFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MemoryType &p ) {
  j = nlohmann::json::object();
  j[ "propertyFlags" ] = p.propertyFlags;
  j[ "heapIndex" ] = p.heapIndex;
}
}
void to_json( nlohmann::json &j, const VkMemoryType &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MemoryType ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MemoryType &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryType" );
  if( j.find( "propertyFlags" ) != j.end() ) {
    p.propertyFlags = MemoryPropertyFlags ( j[ "propertyFlags" ] );
  }
  if( j.find( "heapIndex" ) != j.end() ) {
    p.heapIndex = j[ "heapIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkMemoryType &p ) {
  VULKAN_HPP_NAMESPACE :: MemoryType temp;
  from_json( j, temp );
  p = VkMemoryType ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MultiDrawIndexedInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "firstIndex" ] = p.firstIndex;
  j[ "indexCount" ] = p.indexCount;
  j[ "vertexOffset" ] = p.vertexOffset;
}
}
void to_json( nlohmann::json &j, const VkMultiDrawIndexedInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MultiDrawIndexedInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MultiDrawIndexedInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MultiDrawIndexedInfoEXT" );
  if( j.find( "firstIndex" ) != j.end() ) {
    p.firstIndex = j[ "firstIndex" ];
  }
  if( j.find( "indexCount" ) != j.end() ) {
    p.indexCount = j[ "indexCount" ];
  }
  if( j.find( "vertexOffset" ) != j.end() ) {
    p.vertexOffset = j[ "vertexOffset" ];
  }
}
}
void from_json( const nlohmann::json &j, VkMultiDrawIndexedInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: MultiDrawIndexedInfoEXT temp;
  from_json( j, temp );
  p = VkMultiDrawIndexedInfoEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MultiDrawInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "firstVertex" ] = p.firstVertex;
  j[ "vertexCount" ] = p.vertexCount;
}
}
void to_json( nlohmann::json &j, const VkMultiDrawInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MultiDrawInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MultiDrawInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MultiDrawInfoEXT" );
  if( j.find( "firstVertex" ) != j.end() ) {
    p.firstVertex = j[ "firstVertex" ];
  }
  if( j.find( "vertexCount" ) != j.end() ) {
    p.vertexCount = j[ "vertexCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkMultiDrawInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: MultiDrawInfoEXT temp;
  from_json( j, temp );
  p = VkMultiDrawInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Extent2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MultisamplePropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxSampleLocationGridSize" ] = p.maxSampleLocationGridSize;
}
}
void to_json( nlohmann::json &j, const VkMultisamplePropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MultisamplePropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MultisamplePropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MultisamplePropertiesEXT" );
  if( j.find( "maxSampleLocationGridSize" ) != j.end() ) {
    p.maxSampleLocationGridSize = Extent2D ( j[ "maxSampleLocationGridSize" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkMultisamplePropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: MultisamplePropertiesEXT temp;
  from_json( j, temp );
  p = VkMultisamplePropertiesEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MutableDescriptorTypeListVALVE &p ) {
  j = nlohmann::json::object();
  j[ "descriptorTypeCount" ] = p.descriptorTypeCount;
  j[ "pDescriptorTypes" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDescriptorTypes ) );
}
}
void to_json( nlohmann::json &j, const VkMutableDescriptorTypeListVALVE &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MutableDescriptorTypeListVALVE ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MutableDescriptorTypeListVALVE &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MutableDescriptorTypeListVALVE" );
  if( j.find( "descriptorTypeCount" ) != j.end() ) {
    p.descriptorTypeCount = j[ "descriptorTypeCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkMutableDescriptorTypeListVALVE &p ) {
  VULKAN_HPP_NAMESPACE :: MutableDescriptorTypeListVALVE temp;
  from_json( j, temp );
  p = VkMutableDescriptorTypeListVALVE ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const MutableDescriptorTypeCreateInfoVALVE &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "mutableDescriptorTypeListCount" ] = p.mutableDescriptorTypeListCount;
  j[ "pMutableDescriptorTypeLists" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pMutableDescriptorTypeLists ) );
}
}
void to_json( nlohmann::json &j, const VkMutableDescriptorTypeCreateInfoVALVE &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: MutableDescriptorTypeCreateInfoVALVE ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, MutableDescriptorTypeCreateInfoVALVE &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MutableDescriptorTypeCreateInfoVALVE" );
  if( j.find( "mutableDescriptorTypeListCount" ) != j.end() ) {
    p.mutableDescriptorTypeListCount = j[ "mutableDescriptorTypeListCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkMutableDescriptorTypeCreateInfoVALVE &p ) {
  VULKAN_HPP_NAMESPACE :: MutableDescriptorTypeCreateInfoVALVE temp;
  from_json( j, temp );
  p = VkMutableDescriptorTypeCreateInfoVALVE ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PastPresentationTimingGOOGLE &p ) {
  j = nlohmann::json::object();
  j[ "presentID" ] = p.presentID;
  j[ "desiredPresentTime" ] = p.desiredPresentTime;
  j[ "actualPresentTime" ] = p.actualPresentTime;
  j[ "earliestPresentTime" ] = p.earliestPresentTime;
  j[ "presentMargin" ] = p.presentMargin;
}
}
void to_json( nlohmann::json &j, const VkPastPresentationTimingGOOGLE &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PastPresentationTimingGOOGLE ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PastPresentationTimingGOOGLE &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PastPresentationTimingGOOGLE" );
  if( j.find( "presentID" ) != j.end() ) {
    p.presentID = j[ "presentID" ];
  }
  if( j.find( "desiredPresentTime" ) != j.end() ) {
    p.desiredPresentTime = j[ "desiredPresentTime" ];
  }
  if( j.find( "actualPresentTime" ) != j.end() ) {
    p.actualPresentTime = j[ "actualPresentTime" ];
  }
  if( j.find( "earliestPresentTime" ) != j.end() ) {
    p.earliestPresentTime = j[ "earliestPresentTime" ];
  }
  if( j.find( "presentMargin" ) != j.end() ) {
    p.presentMargin = j[ "presentMargin" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPastPresentationTimingGOOGLE &p ) {
  VULKAN_HPP_NAMESPACE :: PastPresentationTimingGOOGLE temp;
  from_json( j, temp );
  p = VkPastPresentationTimingGOOGLE ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PerformanceConfigurationTypeINTEL.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceConfigurationAcquireInfoINTEL &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "type" ] = p.type;
}
}
void to_json( nlohmann::json &j, const VkPerformanceConfigurationAcquireInfoINTEL &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceConfigurationAcquireInfoINTEL ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceConfigurationAcquireInfoINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceConfigurationAcquireInfoINTEL" );
  if( j.find( "type" ) != j.end() ) {
    p.type = PerformanceConfigurationTypeINTEL ( j[ "type" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPerformanceConfigurationAcquireInfoINTEL &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceConfigurationAcquireInfoINTEL temp;
  from_json( j, temp );
  p = VkPerformanceConfigurationAcquireInfoINTEL ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PerformanceCounterDescriptionFlagsKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceCounterDescriptionKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "name" ] = std::string( p.name.begin(), std::find( p.name.begin(), p.name.end(), '\0' ) );
  j[ "category" ] = std::string( p.category.begin(), std::find( p.category.begin(), p.category.end(), '\0' ) );
  j[ "description" ] = std::string( p.description.begin(), std::find( p.description.begin(), p.description.end(), '\0' ) );
}
}
void to_json( nlohmann::json &j, const VkPerformanceCounterDescriptionKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceCounterDescriptionKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceCounterDescriptionKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceCounterDescriptionKHR" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PerformanceCounterDescriptionFlagsKHR ( j[ "flags" ] );
  }
  if( j.find( "name" ) != j.end() ) {
    {
      std::string s = j[ "name" ];
      if( !p.name.empty() ) {
        p.name[ p.name.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.name.size() - 1u ) ), p.name.begin() );
      }
    }
  }
  if( j.find( "category" ) != j.end() ) {
    {
      std::string s = j[ "category" ];
      if( !p.category.empty() ) {
        p.category[ p.category.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.category.size() - 1u ) ), p.category.begin() );
      }
    }
  }
  if( j.find( "description" ) != j.end() ) {
    {
      std::string s = j[ "description" ];
      if( !p.description.empty() ) {
        p.description[ p.description.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.description.size() - 1u ) ), p.description.begin() );
      }
    }
  }
}
}
void from_json( const nlohmann::json &j, VkPerformanceCounterDescriptionKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceCounterDescriptionKHR temp;
  from_json( j, temp );
  p = VkPerformanceCounterDescriptionKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PerformanceCounterUnitKHR.hpp>
#include <vulkan2json/PerformanceCounterScopeKHR.hpp>
#include <vulkan2json/PerformanceCounterStorageKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceCounterKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "unit" ] = p.unit;
  j[ "scope" ] = p.scope;
  j[ "storage" ] = p.storage;
  j[ "uuid" ] = nlohmann::json::array();
  std::copy( p.uuid.begin(), p.uuid.end(), std::back_inserter( j[ "uuid" ] ) );
}
}
void to_json( nlohmann::json &j, const VkPerformanceCounterKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceCounterKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceCounterKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceCounterKHR" );
  if( j.find( "unit" ) != j.end() ) {
    p.unit = PerformanceCounterUnitKHR ( j[ "unit" ] );
  }
  if( j.find( "scope" ) != j.end() ) {
    p.scope = PerformanceCounterScopeKHR ( j[ "scope" ] );
  }
  if( j.find( "storage" ) != j.end() ) {
    p.storage = PerformanceCounterStorageKHR ( j[ "storage" ] );
  }
  if( j.find( "uuid" ) != j.end() ) {
    if( !j[ "uuid" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PerformanceCounterKHR.uuid" );
    if( !j[ "uuid" ].size() > p.uuid.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PerformanceCounterKHR.uuid" );
    std::fill( p.uuid.begin(), p.uuid.end(), 0 );
    std::copy( j[ "uuid" ].begin(), j[ "uuid" ].end(), p.uuid.begin() );
  }
}
}
void from_json( const nlohmann::json &j, VkPerformanceCounterKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceCounterKHR temp;
  from_json( j, temp );
  p = VkPerformanceCounterKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceMarkerInfoINTEL &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "marker" ] = p.marker;
}
}
void to_json( nlohmann::json &j, const VkPerformanceMarkerInfoINTEL &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceMarkerInfoINTEL ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceMarkerInfoINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceMarkerInfoINTEL" );
  if( j.find( "marker" ) != j.end() ) {
    p.marker = j[ "marker" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPerformanceMarkerInfoINTEL &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceMarkerInfoINTEL temp;
  from_json( j, temp );
  p = VkPerformanceMarkerInfoINTEL ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PerformanceOverrideTypeINTEL.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceOverrideInfoINTEL &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "type" ] = p.type;
  j[ "enable" ] = bool( p.enable );
  j[ "parameter" ] = p.parameter;
}
}
void to_json( nlohmann::json &j, const VkPerformanceOverrideInfoINTEL &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceOverrideInfoINTEL ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceOverrideInfoINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceOverrideInfoINTEL" );
  if( j.find( "type" ) != j.end() ) {
    p.type = PerformanceOverrideTypeINTEL ( j[ "type" ] );
  }
  if( j.find( "enable" ) != j.end() ) {
    p.enable = j[ "enable" ];
  }
  if( j.find( "parameter" ) != j.end() ) {
    p.parameter = j[ "parameter" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPerformanceOverrideInfoINTEL &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceOverrideInfoINTEL temp;
  from_json( j, temp );
  p = VkPerformanceOverrideInfoINTEL ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceQuerySubmitInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "counterPassIndex" ] = p.counterPassIndex;
}
}
void to_json( nlohmann::json &j, const VkPerformanceQuerySubmitInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceQuerySubmitInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceQuerySubmitInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceQuerySubmitInfoKHR" );
  if( j.find( "counterPassIndex" ) != j.end() ) {
    p.counterPassIndex = j[ "counterPassIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPerformanceQuerySubmitInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceQuerySubmitInfoKHR temp;
  from_json( j, temp );
  p = VkPerformanceQuerySubmitInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceStreamMarkerInfoINTEL &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "marker" ] = p.marker;
}
}
void to_json( nlohmann::json &j, const VkPerformanceStreamMarkerInfoINTEL &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceStreamMarkerInfoINTEL ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceStreamMarkerInfoINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceStreamMarkerInfoINTEL" );
  if( j.find( "marker" ) != j.end() ) {
    p.marker = j[ "marker" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPerformanceStreamMarkerInfoINTEL &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceStreamMarkerInfoINTEL temp;
  from_json( j, temp );
  p = VkPerformanceStreamMarkerInfoINTEL ( temp );
}
#include <vulkan2json/PerformanceValueTypeINTEL.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PerformanceValueINTEL &p ) {
  j = nlohmann::json::object();
  j[ "type" ] = p.type;
}
}
void to_json( nlohmann::json &j, const VkPerformanceValueINTEL &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PerformanceValueINTEL ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PerformanceValueINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceValueINTEL" );
  if( j.find( "type" ) != j.end() ) {
    p.type = PerformanceValueTypeINTEL ( j[ "type" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPerformanceValueINTEL &p ) {
  VULKAN_HPP_NAMESPACE :: PerformanceValueINTEL temp;
  from_json( j, temp );
  p = VkPerformanceValueINTEL ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDevice16BitStorageFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "storageBuffer16BitAccess" ] = bool( p.storageBuffer16BitAccess );
  j[ "uniformAndStorageBuffer16BitAccess" ] = bool( p.uniformAndStorageBuffer16BitAccess );
  j[ "storagePushConstant16" ] = bool( p.storagePushConstant16 );
  j[ "storageInputOutput16" ] = bool( p.storageInputOutput16 );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDevice16BitStorageFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDevice16BitStorageFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDevice16BitStorageFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevice16BitStorageFeatures" );
  if( j.find( "storageBuffer16BitAccess" ) != j.end() ) {
    p.storageBuffer16BitAccess = j[ "storageBuffer16BitAccess" ];
  }
  if( j.find( "uniformAndStorageBuffer16BitAccess" ) != j.end() ) {
    p.uniformAndStorageBuffer16BitAccess = j[ "uniformAndStorageBuffer16BitAccess" ];
  }
  if( j.find( "storagePushConstant16" ) != j.end() ) {
    p.storagePushConstant16 = j[ "storagePushConstant16" ];
  }
  if( j.find( "storageInputOutput16" ) != j.end() ) {
    p.storageInputOutput16 = j[ "storageInputOutput16" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDevice16BitStorageFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDevice16BitStorageFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDevice16BitStorageFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDevice4444FormatsFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "formatA4R4G4B4" ] = bool( p.formatA4R4G4B4 );
  j[ "formatA4B4G4R4" ] = bool( p.formatA4B4G4R4 );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDevice4444FormatsFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDevice4444FormatsFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDevice4444FormatsFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevice4444FormatsFeaturesEXT" );
  if( j.find( "formatA4R4G4B4" ) != j.end() ) {
    p.formatA4R4G4B4 = j[ "formatA4R4G4B4" ];
  }
  if( j.find( "formatA4B4G4R4" ) != j.end() ) {
    p.formatA4B4G4R4 = j[ "formatA4B4G4R4" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDevice4444FormatsFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDevice4444FormatsFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDevice4444FormatsFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDevice8BitStorageFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "storageBuffer8BitAccess" ] = bool( p.storageBuffer8BitAccess );
  j[ "uniformAndStorageBuffer8BitAccess" ] = bool( p.uniformAndStorageBuffer8BitAccess );
  j[ "storagePushConstant8" ] = bool( p.storagePushConstant8 );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDevice8BitStorageFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDevice8BitStorageFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDevice8BitStorageFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevice8BitStorageFeatures" );
  if( j.find( "storageBuffer8BitAccess" ) != j.end() ) {
    p.storageBuffer8BitAccess = j[ "storageBuffer8BitAccess" ];
  }
  if( j.find( "uniformAndStorageBuffer8BitAccess" ) != j.end() ) {
    p.uniformAndStorageBuffer8BitAccess = j[ "uniformAndStorageBuffer8BitAccess" ];
  }
  if( j.find( "storagePushConstant8" ) != j.end() ) {
    p.storagePushConstant8 = j[ "storagePushConstant8" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDevice8BitStorageFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDevice8BitStorageFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDevice8BitStorageFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceASTCDecodeFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "decodeModeSharedExponent" ] = bool( p.decodeModeSharedExponent );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceASTCDecodeFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceASTCDecodeFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceASTCDecodeFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceASTCDecodeFeaturesEXT" );
  if( j.find( "decodeModeSharedExponent" ) != j.end() ) {
    p.decodeModeSharedExponent = j[ "decodeModeSharedExponent" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceASTCDecodeFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceASTCDecodeFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceASTCDecodeFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceAccelerationStructureFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "accelerationStructure" ] = bool( p.accelerationStructure );
  j[ "accelerationStructureCaptureReplay" ] = bool( p.accelerationStructureCaptureReplay );
  j[ "accelerationStructureIndirectBuild" ] = bool( p.accelerationStructureIndirectBuild );
  j[ "accelerationStructureHostCommands" ] = bool( p.accelerationStructureHostCommands );
  j[ "descriptorBindingAccelerationStructureUpdateAfterBind" ] = bool( p.descriptorBindingAccelerationStructureUpdateAfterBind );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceAccelerationStructureFeaturesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceAccelerationStructureFeaturesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceAccelerationStructureFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceAccelerationStructureFeaturesKHR" );
  if( j.find( "accelerationStructure" ) != j.end() ) {
    p.accelerationStructure = j[ "accelerationStructure" ];
  }
  if( j.find( "accelerationStructureCaptureReplay" ) != j.end() ) {
    p.accelerationStructureCaptureReplay = j[ "accelerationStructureCaptureReplay" ];
  }
  if( j.find( "accelerationStructureIndirectBuild" ) != j.end() ) {
    p.accelerationStructureIndirectBuild = j[ "accelerationStructureIndirectBuild" ];
  }
  if( j.find( "accelerationStructureHostCommands" ) != j.end() ) {
    p.accelerationStructureHostCommands = j[ "accelerationStructureHostCommands" ];
  }
  if( j.find( "descriptorBindingAccelerationStructureUpdateAfterBind" ) != j.end() ) {
    p.descriptorBindingAccelerationStructureUpdateAfterBind = j[ "descriptorBindingAccelerationStructureUpdateAfterBind" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceAccelerationStructureFeaturesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceAccelerationStructureFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceAccelerationStructureFeaturesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceAccelerationStructurePropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxGeometryCount" ] = p.maxGeometryCount;
  j[ "maxInstanceCount" ] = p.maxInstanceCount;
  j[ "maxPrimitiveCount" ] = p.maxPrimitiveCount;
  j[ "maxPerStageDescriptorAccelerationStructures" ] = p.maxPerStageDescriptorAccelerationStructures;
  j[ "maxPerStageDescriptorUpdateAfterBindAccelerationStructures" ] = p.maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
  j[ "maxDescriptorSetAccelerationStructures" ] = p.maxDescriptorSetAccelerationStructures;
  j[ "maxDescriptorSetUpdateAfterBindAccelerationStructures" ] = p.maxDescriptorSetUpdateAfterBindAccelerationStructures;
  j[ "minAccelerationStructureScratchOffsetAlignment" ] = p.minAccelerationStructureScratchOffsetAlignment;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceAccelerationStructurePropertiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceAccelerationStructurePropertiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceAccelerationStructurePropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceAccelerationStructurePropertiesKHR" );
  if( j.find( "maxGeometryCount" ) != j.end() ) {
    p.maxGeometryCount = j[ "maxGeometryCount" ];
  }
  if( j.find( "maxInstanceCount" ) != j.end() ) {
    p.maxInstanceCount = j[ "maxInstanceCount" ];
  }
  if( j.find( "maxPrimitiveCount" ) != j.end() ) {
    p.maxPrimitiveCount = j[ "maxPrimitiveCount" ];
  }
  if( j.find( "maxPerStageDescriptorAccelerationStructures" ) != j.end() ) {
    p.maxPerStageDescriptorAccelerationStructures = j[ "maxPerStageDescriptorAccelerationStructures" ];
  }
  if( j.find( "maxPerStageDescriptorUpdateAfterBindAccelerationStructures" ) != j.end() ) {
    p.maxPerStageDescriptorUpdateAfterBindAccelerationStructures = j[ "maxPerStageDescriptorUpdateAfterBindAccelerationStructures" ];
  }
  if( j.find( "maxDescriptorSetAccelerationStructures" ) != j.end() ) {
    p.maxDescriptorSetAccelerationStructures = j[ "maxDescriptorSetAccelerationStructures" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindAccelerationStructures" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindAccelerationStructures = j[ "maxDescriptorSetUpdateAfterBindAccelerationStructures" ];
  }
  if( j.find( "minAccelerationStructureScratchOffsetAlignment" ) != j.end() ) {
    p.minAccelerationStructureScratchOffsetAlignment = j[ "minAccelerationStructureScratchOffsetAlignment" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceAccelerationStructurePropertiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceAccelerationStructurePropertiesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceAccelerationStructurePropertiesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceBlendOperationAdvancedFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "advancedBlendCoherentOperations" ] = bool( p.advancedBlendCoherentOperations );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceBlendOperationAdvancedFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceBlendOperationAdvancedFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceBlendOperationAdvancedFeaturesEXT" );
  if( j.find( "advancedBlendCoherentOperations" ) != j.end() ) {
    p.advancedBlendCoherentOperations = j[ "advancedBlendCoherentOperations" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceBlendOperationAdvancedFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceBlendOperationAdvancedPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "advancedBlendMaxColorAttachments" ] = p.advancedBlendMaxColorAttachments;
  j[ "advancedBlendIndependentBlend" ] = bool( p.advancedBlendIndependentBlend );
  j[ "advancedBlendNonPremultipliedSrcColor" ] = bool( p.advancedBlendNonPremultipliedSrcColor );
  j[ "advancedBlendNonPremultipliedDstColor" ] = bool( p.advancedBlendNonPremultipliedDstColor );
  j[ "advancedBlendCorrelatedOverlap" ] = bool( p.advancedBlendCorrelatedOverlap );
  j[ "advancedBlendAllOperations" ] = bool( p.advancedBlendAllOperations );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceBlendOperationAdvancedPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceBlendOperationAdvancedPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceBlendOperationAdvancedPropertiesEXT" );
  if( j.find( "advancedBlendMaxColorAttachments" ) != j.end() ) {
    p.advancedBlendMaxColorAttachments = j[ "advancedBlendMaxColorAttachments" ];
  }
  if( j.find( "advancedBlendIndependentBlend" ) != j.end() ) {
    p.advancedBlendIndependentBlend = j[ "advancedBlendIndependentBlend" ];
  }
  if( j.find( "advancedBlendNonPremultipliedSrcColor" ) != j.end() ) {
    p.advancedBlendNonPremultipliedSrcColor = j[ "advancedBlendNonPremultipliedSrcColor" ];
  }
  if( j.find( "advancedBlendNonPremultipliedDstColor" ) != j.end() ) {
    p.advancedBlendNonPremultipliedDstColor = j[ "advancedBlendNonPremultipliedDstColor" ];
  }
  if( j.find( "advancedBlendCorrelatedOverlap" ) != j.end() ) {
    p.advancedBlendCorrelatedOverlap = j[ "advancedBlendCorrelatedOverlap" ];
  }
  if( j.find( "advancedBlendAllOperations" ) != j.end() ) {
    p.advancedBlendAllOperations = j[ "advancedBlendAllOperations" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceBlendOperationAdvancedPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceBufferDeviceAddressFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "bufferDeviceAddress" ] = bool( p.bufferDeviceAddress );
  j[ "bufferDeviceAddressCaptureReplay" ] = bool( p.bufferDeviceAddressCaptureReplay );
  j[ "bufferDeviceAddressMultiDevice" ] = bool( p.bufferDeviceAddressMultiDevice );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceBufferDeviceAddressFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceBufferDeviceAddressFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceBufferDeviceAddressFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceBufferDeviceAddressFeatures" );
  if( j.find( "bufferDeviceAddress" ) != j.end() ) {
    p.bufferDeviceAddress = j[ "bufferDeviceAddress" ];
  }
  if( j.find( "bufferDeviceAddressCaptureReplay" ) != j.end() ) {
    p.bufferDeviceAddressCaptureReplay = j[ "bufferDeviceAddressCaptureReplay" ];
  }
  if( j.find( "bufferDeviceAddressMultiDevice" ) != j.end() ) {
    p.bufferDeviceAddressMultiDevice = j[ "bufferDeviceAddressMultiDevice" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceBufferDeviceAddressFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceBufferDeviceAddressFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceBufferDeviceAddressFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceBufferDeviceAddressFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "bufferDeviceAddress" ] = bool( p.bufferDeviceAddress );
  j[ "bufferDeviceAddressCaptureReplay" ] = bool( p.bufferDeviceAddressCaptureReplay );
  j[ "bufferDeviceAddressMultiDevice" ] = bool( p.bufferDeviceAddressMultiDevice );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceBufferDeviceAddressFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceBufferDeviceAddressFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceBufferDeviceAddressFeaturesEXT" );
  if( j.find( "bufferDeviceAddress" ) != j.end() ) {
    p.bufferDeviceAddress = j[ "bufferDeviceAddress" ];
  }
  if( j.find( "bufferDeviceAddressCaptureReplay" ) != j.end() ) {
    p.bufferDeviceAddressCaptureReplay = j[ "bufferDeviceAddressCaptureReplay" ];
  }
  if( j.find( "bufferDeviceAddressMultiDevice" ) != j.end() ) {
    p.bufferDeviceAddressMultiDevice = j[ "bufferDeviceAddressMultiDevice" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceBufferDeviceAddressFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceCoherentMemoryFeaturesAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceCoherentMemory" ] = bool( p.deviceCoherentMemory );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceCoherentMemoryFeaturesAMD &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceCoherentMemoryFeaturesAMD ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceCoherentMemoryFeaturesAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceCoherentMemoryFeaturesAMD" );
  if( j.find( "deviceCoherentMemory" ) != j.end() ) {
    p.deviceCoherentMemory = j[ "deviceCoherentMemory" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceCoherentMemoryFeaturesAMD &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceCoherentMemoryFeaturesAMD temp;
  from_json( j, temp );
  p = VkPhysicalDeviceCoherentMemoryFeaturesAMD ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceColorWriteEnableFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "colorWriteEnable" ] = bool( p.colorWriteEnable );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceColorWriteEnableFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceColorWriteEnableFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceColorWriteEnableFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceColorWriteEnableFeaturesEXT" );
  if( j.find( "colorWriteEnable" ) != j.end() ) {
    p.colorWriteEnable = j[ "colorWriteEnable" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceColorWriteEnableFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceColorWriteEnableFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceColorWriteEnableFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceComputeShaderDerivativesFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "computeDerivativeGroupQuads" ] = bool( p.computeDerivativeGroupQuads );
  j[ "computeDerivativeGroupLinear" ] = bool( p.computeDerivativeGroupLinear );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceComputeShaderDerivativesFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceComputeShaderDerivativesFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceComputeShaderDerivativesFeaturesNV" );
  if( j.find( "computeDerivativeGroupQuads" ) != j.end() ) {
    p.computeDerivativeGroupQuads = j[ "computeDerivativeGroupQuads" ];
  }
  if( j.find( "computeDerivativeGroupLinear" ) != j.end() ) {
    p.computeDerivativeGroupLinear = j[ "computeDerivativeGroupLinear" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceComputeShaderDerivativesFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceComputeShaderDerivativesFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceConditionalRenderingFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "conditionalRendering" ] = bool( p.conditionalRendering );
  j[ "inheritedConditionalRendering" ] = bool( p.inheritedConditionalRendering );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceConditionalRenderingFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceConditionalRenderingFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceConditionalRenderingFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceConditionalRenderingFeaturesEXT" );
  if( j.find( "conditionalRendering" ) != j.end() ) {
    p.conditionalRendering = j[ "conditionalRendering" ];
  }
  if( j.find( "inheritedConditionalRendering" ) != j.end() ) {
    p.inheritedConditionalRendering = j[ "inheritedConditionalRendering" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceConditionalRenderingFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceConditionalRenderingFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceConditionalRenderingFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceConservativeRasterizationPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "primitiveOverestimationSize" ] = p.primitiveOverestimationSize;
  j[ "maxExtraPrimitiveOverestimationSize" ] = p.maxExtraPrimitiveOverestimationSize;
  j[ "extraPrimitiveOverestimationSizeGranularity" ] = p.extraPrimitiveOverestimationSizeGranularity;
  j[ "primitiveUnderestimation" ] = bool( p.primitiveUnderestimation );
  j[ "conservativePointAndLineRasterization" ] = bool( p.conservativePointAndLineRasterization );
  j[ "degenerateTrianglesRasterized" ] = bool( p.degenerateTrianglesRasterized );
  j[ "degenerateLinesRasterized" ] = bool( p.degenerateLinesRasterized );
  j[ "fullyCoveredFragmentShaderInputVariable" ] = bool( p.fullyCoveredFragmentShaderInputVariable );
  j[ "conservativeRasterizationPostDepthCoverage" ] = bool( p.conservativeRasterizationPostDepthCoverage );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceConservativeRasterizationPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceConservativeRasterizationPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceConservativeRasterizationPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceConservativeRasterizationPropertiesEXT" );
  if( j.find( "primitiveOverestimationSize" ) != j.end() ) {
    p.primitiveOverestimationSize = j[ "primitiveOverestimationSize" ];
  }
  if( j.find( "maxExtraPrimitiveOverestimationSize" ) != j.end() ) {
    p.maxExtraPrimitiveOverestimationSize = j[ "maxExtraPrimitiveOverestimationSize" ];
  }
  if( j.find( "extraPrimitiveOverestimationSizeGranularity" ) != j.end() ) {
    p.extraPrimitiveOverestimationSizeGranularity = j[ "extraPrimitiveOverestimationSizeGranularity" ];
  }
  if( j.find( "primitiveUnderestimation" ) != j.end() ) {
    p.primitiveUnderestimation = j[ "primitiveUnderestimation" ];
  }
  if( j.find( "conservativePointAndLineRasterization" ) != j.end() ) {
    p.conservativePointAndLineRasterization = j[ "conservativePointAndLineRasterization" ];
  }
  if( j.find( "degenerateTrianglesRasterized" ) != j.end() ) {
    p.degenerateTrianglesRasterized = j[ "degenerateTrianglesRasterized" ];
  }
  if( j.find( "degenerateLinesRasterized" ) != j.end() ) {
    p.degenerateLinesRasterized = j[ "degenerateLinesRasterized" ];
  }
  if( j.find( "fullyCoveredFragmentShaderInputVariable" ) != j.end() ) {
    p.fullyCoveredFragmentShaderInputVariable = j[ "fullyCoveredFragmentShaderInputVariable" ];
  }
  if( j.find( "conservativeRasterizationPostDepthCoverage" ) != j.end() ) {
    p.conservativeRasterizationPostDepthCoverage = j[ "conservativeRasterizationPostDepthCoverage" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceConservativeRasterizationPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceConservativeRasterizationPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceConservativeRasterizationPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceCooperativeMatrixFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "cooperativeMatrix" ] = bool( p.cooperativeMatrix );
  j[ "cooperativeMatrixRobustBufferAccess" ] = bool( p.cooperativeMatrixRobustBufferAccess );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceCooperativeMatrixFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceCooperativeMatrixFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceCooperativeMatrixFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceCooperativeMatrixFeaturesNV" );
  if( j.find( "cooperativeMatrix" ) != j.end() ) {
    p.cooperativeMatrix = j[ "cooperativeMatrix" ];
  }
  if( j.find( "cooperativeMatrixRobustBufferAccess" ) != j.end() ) {
    p.cooperativeMatrixRobustBufferAccess = j[ "cooperativeMatrixRobustBufferAccess" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceCooperativeMatrixFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceCooperativeMatrixFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceCooperativeMatrixFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ShaderStageFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceCooperativeMatrixPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "cooperativeMatrixSupportedStages" ] = p.cooperativeMatrixSupportedStages;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceCooperativeMatrixPropertiesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceCooperativeMatrixPropertiesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceCooperativeMatrixPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceCooperativeMatrixPropertiesNV" );
  if( j.find( "cooperativeMatrixSupportedStages" ) != j.end() ) {
    p.cooperativeMatrixSupportedStages = ShaderStageFlags ( j[ "cooperativeMatrixSupportedStages" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceCooperativeMatrixPropertiesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceCooperativeMatrixPropertiesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceCooperativeMatrixPropertiesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceCornerSampledImageFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "cornerSampledImage" ] = bool( p.cornerSampledImage );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceCornerSampledImageFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceCornerSampledImageFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceCornerSampledImageFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceCornerSampledImageFeaturesNV" );
  if( j.find( "cornerSampledImage" ) != j.end() ) {
    p.cornerSampledImage = j[ "cornerSampledImage" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceCornerSampledImageFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceCornerSampledImageFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceCornerSampledImageFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceCoverageReductionModeFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "coverageReductionMode" ] = bool( p.coverageReductionMode );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceCoverageReductionModeFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceCoverageReductionModeFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceCoverageReductionModeFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceCoverageReductionModeFeaturesNV" );
  if( j.find( "coverageReductionMode" ) != j.end() ) {
    p.coverageReductionMode = j[ "coverageReductionMode" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceCoverageReductionModeFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceCoverageReductionModeFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceCoverageReductionModeFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceCustomBorderColorFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "customBorderColors" ] = bool( p.customBorderColors );
  j[ "customBorderColorWithoutFormat" ] = bool( p.customBorderColorWithoutFormat );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceCustomBorderColorFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceCustomBorderColorFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceCustomBorderColorFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceCustomBorderColorFeaturesEXT" );
  if( j.find( "customBorderColors" ) != j.end() ) {
    p.customBorderColors = j[ "customBorderColors" ];
  }
  if( j.find( "customBorderColorWithoutFormat" ) != j.end() ) {
    p.customBorderColorWithoutFormat = j[ "customBorderColorWithoutFormat" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceCustomBorderColorFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceCustomBorderColorFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceCustomBorderColorFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceCustomBorderColorPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxCustomBorderColorSamplers" ] = p.maxCustomBorderColorSamplers;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceCustomBorderColorPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceCustomBorderColorPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceCustomBorderColorPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceCustomBorderColorPropertiesEXT" );
  if( j.find( "maxCustomBorderColorSamplers" ) != j.end() ) {
    p.maxCustomBorderColorSamplers = j[ "maxCustomBorderColorSamplers" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceCustomBorderColorPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceCustomBorderColorPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceCustomBorderColorPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dedicatedAllocationImageAliasing" ] = bool( p.dedicatedAllocationImageAliasing );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV" );
  if( j.find( "dedicatedAllocationImageAliasing" ) != j.end() ) {
    p.dedicatedAllocationImageAliasing = j[ "dedicatedAllocationImageAliasing" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceDepthClipEnableFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "depthClipEnable" ] = bool( p.depthClipEnable );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceDepthClipEnableFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceDepthClipEnableFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceDepthClipEnableFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDepthClipEnableFeaturesEXT" );
  if( j.find( "depthClipEnable" ) != j.end() ) {
    p.depthClipEnable = j[ "depthClipEnable" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceDepthClipEnableFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceDepthClipEnableFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDepthClipEnableFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ResolveModeFlags.hpp>
#include <vulkan2json/ResolveModeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceDepthStencilResolveProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "supportedDepthResolveModes" ] = p.supportedDepthResolveModes;
  j[ "supportedStencilResolveModes" ] = p.supportedStencilResolveModes;
  j[ "independentResolveNone" ] = bool( p.independentResolveNone );
  j[ "independentResolve" ] = bool( p.independentResolve );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceDepthStencilResolveProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceDepthStencilResolveProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceDepthStencilResolveProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDepthStencilResolveProperties" );
  if( j.find( "supportedDepthResolveModes" ) != j.end() ) {
    p.supportedDepthResolveModes = ResolveModeFlags ( j[ "supportedDepthResolveModes" ] );
  }
  if( j.find( "supportedStencilResolveModes" ) != j.end() ) {
    p.supportedStencilResolveModes = ResolveModeFlags ( j[ "supportedStencilResolveModes" ] );
  }
  if( j.find( "independentResolveNone" ) != j.end() ) {
    p.independentResolveNone = j[ "independentResolveNone" ];
  }
  if( j.find( "independentResolve" ) != j.end() ) {
    p.independentResolve = j[ "independentResolve" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceDepthStencilResolveProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceDepthStencilResolveProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDepthStencilResolveProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceDescriptorIndexingFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderInputAttachmentArrayDynamicIndexing" ] = bool( p.shaderInputAttachmentArrayDynamicIndexing );
  j[ "shaderUniformTexelBufferArrayDynamicIndexing" ] = bool( p.shaderUniformTexelBufferArrayDynamicIndexing );
  j[ "shaderStorageTexelBufferArrayDynamicIndexing" ] = bool( p.shaderStorageTexelBufferArrayDynamicIndexing );
  j[ "shaderUniformBufferArrayNonUniformIndexing" ] = bool( p.shaderUniformBufferArrayNonUniformIndexing );
  j[ "shaderSampledImageArrayNonUniformIndexing" ] = bool( p.shaderSampledImageArrayNonUniformIndexing );
  j[ "shaderStorageBufferArrayNonUniformIndexing" ] = bool( p.shaderStorageBufferArrayNonUniformIndexing );
  j[ "shaderStorageImageArrayNonUniformIndexing" ] = bool( p.shaderStorageImageArrayNonUniformIndexing );
  j[ "shaderInputAttachmentArrayNonUniformIndexing" ] = bool( p.shaderInputAttachmentArrayNonUniformIndexing );
  j[ "shaderUniformTexelBufferArrayNonUniformIndexing" ] = bool( p.shaderUniformTexelBufferArrayNonUniformIndexing );
  j[ "shaderStorageTexelBufferArrayNonUniformIndexing" ] = bool( p.shaderStorageTexelBufferArrayNonUniformIndexing );
  j[ "descriptorBindingUniformBufferUpdateAfterBind" ] = bool( p.descriptorBindingUniformBufferUpdateAfterBind );
  j[ "descriptorBindingSampledImageUpdateAfterBind" ] = bool( p.descriptorBindingSampledImageUpdateAfterBind );
  j[ "descriptorBindingStorageImageUpdateAfterBind" ] = bool( p.descriptorBindingStorageImageUpdateAfterBind );
  j[ "descriptorBindingStorageBufferUpdateAfterBind" ] = bool( p.descriptorBindingStorageBufferUpdateAfterBind );
  j[ "descriptorBindingUniformTexelBufferUpdateAfterBind" ] = bool( p.descriptorBindingUniformTexelBufferUpdateAfterBind );
  j[ "descriptorBindingStorageTexelBufferUpdateAfterBind" ] = bool( p.descriptorBindingStorageTexelBufferUpdateAfterBind );
  j[ "descriptorBindingUpdateUnusedWhilePending" ] = bool( p.descriptorBindingUpdateUnusedWhilePending );
  j[ "descriptorBindingPartiallyBound" ] = bool( p.descriptorBindingPartiallyBound );
  j[ "descriptorBindingVariableDescriptorCount" ] = bool( p.descriptorBindingVariableDescriptorCount );
  j[ "runtimeDescriptorArray" ] = bool( p.runtimeDescriptorArray );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceDescriptorIndexingFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceDescriptorIndexingFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceDescriptorIndexingFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDescriptorIndexingFeatures" );
  if( j.find( "shaderInputAttachmentArrayDynamicIndexing" ) != j.end() ) {
    p.shaderInputAttachmentArrayDynamicIndexing = j[ "shaderInputAttachmentArrayDynamicIndexing" ];
  }
  if( j.find( "shaderUniformTexelBufferArrayDynamicIndexing" ) != j.end() ) {
    p.shaderUniformTexelBufferArrayDynamicIndexing = j[ "shaderUniformTexelBufferArrayDynamicIndexing" ];
  }
  if( j.find( "shaderStorageTexelBufferArrayDynamicIndexing" ) != j.end() ) {
    p.shaderStorageTexelBufferArrayDynamicIndexing = j[ "shaderStorageTexelBufferArrayDynamicIndexing" ];
  }
  if( j.find( "shaderUniformBufferArrayNonUniformIndexing" ) != j.end() ) {
    p.shaderUniformBufferArrayNonUniformIndexing = j[ "shaderUniformBufferArrayNonUniformIndexing" ];
  }
  if( j.find( "shaderSampledImageArrayNonUniformIndexing" ) != j.end() ) {
    p.shaderSampledImageArrayNonUniformIndexing = j[ "shaderSampledImageArrayNonUniformIndexing" ];
  }
  if( j.find( "shaderStorageBufferArrayNonUniformIndexing" ) != j.end() ) {
    p.shaderStorageBufferArrayNonUniformIndexing = j[ "shaderStorageBufferArrayNonUniformIndexing" ];
  }
  if( j.find( "shaderStorageImageArrayNonUniformIndexing" ) != j.end() ) {
    p.shaderStorageImageArrayNonUniformIndexing = j[ "shaderStorageImageArrayNonUniformIndexing" ];
  }
  if( j.find( "shaderInputAttachmentArrayNonUniformIndexing" ) != j.end() ) {
    p.shaderInputAttachmentArrayNonUniformIndexing = j[ "shaderInputAttachmentArrayNonUniformIndexing" ];
  }
  if( j.find( "shaderUniformTexelBufferArrayNonUniformIndexing" ) != j.end() ) {
    p.shaderUniformTexelBufferArrayNonUniformIndexing = j[ "shaderUniformTexelBufferArrayNonUniformIndexing" ];
  }
  if( j.find( "shaderStorageTexelBufferArrayNonUniformIndexing" ) != j.end() ) {
    p.shaderStorageTexelBufferArrayNonUniformIndexing = j[ "shaderStorageTexelBufferArrayNonUniformIndexing" ];
  }
  if( j.find( "descriptorBindingUniformBufferUpdateAfterBind" ) != j.end() ) {
    p.descriptorBindingUniformBufferUpdateAfterBind = j[ "descriptorBindingUniformBufferUpdateAfterBind" ];
  }
  if( j.find( "descriptorBindingSampledImageUpdateAfterBind" ) != j.end() ) {
    p.descriptorBindingSampledImageUpdateAfterBind = j[ "descriptorBindingSampledImageUpdateAfterBind" ];
  }
  if( j.find( "descriptorBindingStorageImageUpdateAfterBind" ) != j.end() ) {
    p.descriptorBindingStorageImageUpdateAfterBind = j[ "descriptorBindingStorageImageUpdateAfterBind" ];
  }
  if( j.find( "descriptorBindingStorageBufferUpdateAfterBind" ) != j.end() ) {
    p.descriptorBindingStorageBufferUpdateAfterBind = j[ "descriptorBindingStorageBufferUpdateAfterBind" ];
  }
  if( j.find( "descriptorBindingUniformTexelBufferUpdateAfterBind" ) != j.end() ) {
    p.descriptorBindingUniformTexelBufferUpdateAfterBind = j[ "descriptorBindingUniformTexelBufferUpdateAfterBind" ];
  }
  if( j.find( "descriptorBindingStorageTexelBufferUpdateAfterBind" ) != j.end() ) {
    p.descriptorBindingStorageTexelBufferUpdateAfterBind = j[ "descriptorBindingStorageTexelBufferUpdateAfterBind" ];
  }
  if( j.find( "descriptorBindingUpdateUnusedWhilePending" ) != j.end() ) {
    p.descriptorBindingUpdateUnusedWhilePending = j[ "descriptorBindingUpdateUnusedWhilePending" ];
  }
  if( j.find( "descriptorBindingPartiallyBound" ) != j.end() ) {
    p.descriptorBindingPartiallyBound = j[ "descriptorBindingPartiallyBound" ];
  }
  if( j.find( "descriptorBindingVariableDescriptorCount" ) != j.end() ) {
    p.descriptorBindingVariableDescriptorCount = j[ "descriptorBindingVariableDescriptorCount" ];
  }
  if( j.find( "runtimeDescriptorArray" ) != j.end() ) {
    p.runtimeDescriptorArray = j[ "runtimeDescriptorArray" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceDescriptorIndexingFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceDescriptorIndexingFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDescriptorIndexingFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceDescriptorIndexingProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxUpdateAfterBindDescriptorsInAllPools" ] = p.maxUpdateAfterBindDescriptorsInAllPools;
  j[ "shaderUniformBufferArrayNonUniformIndexingNative" ] = bool( p.shaderUniformBufferArrayNonUniformIndexingNative );
  j[ "shaderSampledImageArrayNonUniformIndexingNative" ] = bool( p.shaderSampledImageArrayNonUniformIndexingNative );
  j[ "shaderStorageBufferArrayNonUniformIndexingNative" ] = bool( p.shaderStorageBufferArrayNonUniformIndexingNative );
  j[ "shaderStorageImageArrayNonUniformIndexingNative" ] = bool( p.shaderStorageImageArrayNonUniformIndexingNative );
  j[ "shaderInputAttachmentArrayNonUniformIndexingNative" ] = bool( p.shaderInputAttachmentArrayNonUniformIndexingNative );
  j[ "robustBufferAccessUpdateAfterBind" ] = bool( p.robustBufferAccessUpdateAfterBind );
  j[ "quadDivergentImplicitLod" ] = bool( p.quadDivergentImplicitLod );
  j[ "maxPerStageDescriptorUpdateAfterBindSamplers" ] = p.maxPerStageDescriptorUpdateAfterBindSamplers;
  j[ "maxPerStageDescriptorUpdateAfterBindUniformBuffers" ] = p.maxPerStageDescriptorUpdateAfterBindUniformBuffers;
  j[ "maxPerStageDescriptorUpdateAfterBindStorageBuffers" ] = p.maxPerStageDescriptorUpdateAfterBindStorageBuffers;
  j[ "maxPerStageDescriptorUpdateAfterBindSampledImages" ] = p.maxPerStageDescriptorUpdateAfterBindSampledImages;
  j[ "maxPerStageDescriptorUpdateAfterBindStorageImages" ] = p.maxPerStageDescriptorUpdateAfterBindStorageImages;
  j[ "maxPerStageDescriptorUpdateAfterBindInputAttachments" ] = p.maxPerStageDescriptorUpdateAfterBindInputAttachments;
  j[ "maxPerStageUpdateAfterBindResources" ] = p.maxPerStageUpdateAfterBindResources;
  j[ "maxDescriptorSetUpdateAfterBindSamplers" ] = p.maxDescriptorSetUpdateAfterBindSamplers;
  j[ "maxDescriptorSetUpdateAfterBindUniformBuffers" ] = p.maxDescriptorSetUpdateAfterBindUniformBuffers;
  j[ "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic" ] = p.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
  j[ "maxDescriptorSetUpdateAfterBindStorageBuffers" ] = p.maxDescriptorSetUpdateAfterBindStorageBuffers;
  j[ "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic" ] = p.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
  j[ "maxDescriptorSetUpdateAfterBindSampledImages" ] = p.maxDescriptorSetUpdateAfterBindSampledImages;
  j[ "maxDescriptorSetUpdateAfterBindStorageImages" ] = p.maxDescriptorSetUpdateAfterBindStorageImages;
  j[ "maxDescriptorSetUpdateAfterBindInputAttachments" ] = p.maxDescriptorSetUpdateAfterBindInputAttachments;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceDescriptorIndexingProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceDescriptorIndexingProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceDescriptorIndexingProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDescriptorIndexingProperties" );
  if( j.find( "maxUpdateAfterBindDescriptorsInAllPools" ) != j.end() ) {
    p.maxUpdateAfterBindDescriptorsInAllPools = j[ "maxUpdateAfterBindDescriptorsInAllPools" ];
  }
  if( j.find( "shaderUniformBufferArrayNonUniformIndexingNative" ) != j.end() ) {
    p.shaderUniformBufferArrayNonUniformIndexingNative = j[ "shaderUniformBufferArrayNonUniformIndexingNative" ];
  }
  if( j.find( "shaderSampledImageArrayNonUniformIndexingNative" ) != j.end() ) {
    p.shaderSampledImageArrayNonUniformIndexingNative = j[ "shaderSampledImageArrayNonUniformIndexingNative" ];
  }
  if( j.find( "shaderStorageBufferArrayNonUniformIndexingNative" ) != j.end() ) {
    p.shaderStorageBufferArrayNonUniformIndexingNative = j[ "shaderStorageBufferArrayNonUniformIndexingNative" ];
  }
  if( j.find( "shaderStorageImageArrayNonUniformIndexingNative" ) != j.end() ) {
    p.shaderStorageImageArrayNonUniformIndexingNative = j[ "shaderStorageImageArrayNonUniformIndexingNative" ];
  }
  if( j.find( "shaderInputAttachmentArrayNonUniformIndexingNative" ) != j.end() ) {
    p.shaderInputAttachmentArrayNonUniformIndexingNative = j[ "shaderInputAttachmentArrayNonUniformIndexingNative" ];
  }
  if( j.find( "robustBufferAccessUpdateAfterBind" ) != j.end() ) {
    p.robustBufferAccessUpdateAfterBind = j[ "robustBufferAccessUpdateAfterBind" ];
  }
  if( j.find( "quadDivergentImplicitLod" ) != j.end() ) {
    p.quadDivergentImplicitLod = j[ "quadDivergentImplicitLod" ];
  }
  if( j.find( "maxPerStageDescriptorUpdateAfterBindSamplers" ) != j.end() ) {
    p.maxPerStageDescriptorUpdateAfterBindSamplers = j[ "maxPerStageDescriptorUpdateAfterBindSamplers" ];
  }
  if( j.find( "maxPerStageDescriptorUpdateAfterBindUniformBuffers" ) != j.end() ) {
    p.maxPerStageDescriptorUpdateAfterBindUniformBuffers = j[ "maxPerStageDescriptorUpdateAfterBindUniformBuffers" ];
  }
  if( j.find( "maxPerStageDescriptorUpdateAfterBindStorageBuffers" ) != j.end() ) {
    p.maxPerStageDescriptorUpdateAfterBindStorageBuffers = j[ "maxPerStageDescriptorUpdateAfterBindStorageBuffers" ];
  }
  if( j.find( "maxPerStageDescriptorUpdateAfterBindSampledImages" ) != j.end() ) {
    p.maxPerStageDescriptorUpdateAfterBindSampledImages = j[ "maxPerStageDescriptorUpdateAfterBindSampledImages" ];
  }
  if( j.find( "maxPerStageDescriptorUpdateAfterBindStorageImages" ) != j.end() ) {
    p.maxPerStageDescriptorUpdateAfterBindStorageImages = j[ "maxPerStageDescriptorUpdateAfterBindStorageImages" ];
  }
  if( j.find( "maxPerStageDescriptorUpdateAfterBindInputAttachments" ) != j.end() ) {
    p.maxPerStageDescriptorUpdateAfterBindInputAttachments = j[ "maxPerStageDescriptorUpdateAfterBindInputAttachments" ];
  }
  if( j.find( "maxPerStageUpdateAfterBindResources" ) != j.end() ) {
    p.maxPerStageUpdateAfterBindResources = j[ "maxPerStageUpdateAfterBindResources" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindSamplers" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindSamplers = j[ "maxDescriptorSetUpdateAfterBindSamplers" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindUniformBuffers" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindUniformBuffers = j[ "maxDescriptorSetUpdateAfterBindUniformBuffers" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = j[ "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindStorageBuffers" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindStorageBuffers = j[ "maxDescriptorSetUpdateAfterBindStorageBuffers" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = j[ "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindSampledImages" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindSampledImages = j[ "maxDescriptorSetUpdateAfterBindSampledImages" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindStorageImages" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindStorageImages = j[ "maxDescriptorSetUpdateAfterBindStorageImages" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindInputAttachments" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindInputAttachments = j[ "maxDescriptorSetUpdateAfterBindInputAttachments" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceDescriptorIndexingProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceDescriptorIndexingProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDescriptorIndexingProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceDeviceGeneratedCommandsFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceGeneratedCommands" ] = bool( p.deviceGeneratedCommands );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceDeviceGeneratedCommandsFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceDeviceGeneratedCommandsFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV" );
  if( j.find( "deviceGeneratedCommands" ) != j.end() ) {
    p.deviceGeneratedCommands = j[ "deviceGeneratedCommands" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceDeviceGeneratedCommandsFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceDeviceGeneratedCommandsPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxGraphicsShaderGroupCount" ] = p.maxGraphicsShaderGroupCount;
  j[ "maxIndirectSequenceCount" ] = p.maxIndirectSequenceCount;
  j[ "maxIndirectCommandsTokenCount" ] = p.maxIndirectCommandsTokenCount;
  j[ "maxIndirectCommandsStreamCount" ] = p.maxIndirectCommandsStreamCount;
  j[ "maxIndirectCommandsTokenOffset" ] = p.maxIndirectCommandsTokenOffset;
  j[ "maxIndirectCommandsStreamStride" ] = p.maxIndirectCommandsStreamStride;
  j[ "minSequencesCountBufferOffsetAlignment" ] = p.minSequencesCountBufferOffsetAlignment;
  j[ "minSequencesIndexBufferOffsetAlignment" ] = p.minSequencesIndexBufferOffsetAlignment;
  j[ "minIndirectCommandsBufferOffsetAlignment" ] = p.minIndirectCommandsBufferOffsetAlignment;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceDeviceGeneratedCommandsPropertiesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceDeviceGeneratedCommandsPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV" );
  if( j.find( "maxGraphicsShaderGroupCount" ) != j.end() ) {
    p.maxGraphicsShaderGroupCount = j[ "maxGraphicsShaderGroupCount" ];
  }
  if( j.find( "maxIndirectSequenceCount" ) != j.end() ) {
    p.maxIndirectSequenceCount = j[ "maxIndirectSequenceCount" ];
  }
  if( j.find( "maxIndirectCommandsTokenCount" ) != j.end() ) {
    p.maxIndirectCommandsTokenCount = j[ "maxIndirectCommandsTokenCount" ];
  }
  if( j.find( "maxIndirectCommandsStreamCount" ) != j.end() ) {
    p.maxIndirectCommandsStreamCount = j[ "maxIndirectCommandsStreamCount" ];
  }
  if( j.find( "maxIndirectCommandsTokenOffset" ) != j.end() ) {
    p.maxIndirectCommandsTokenOffset = j[ "maxIndirectCommandsTokenOffset" ];
  }
  if( j.find( "maxIndirectCommandsStreamStride" ) != j.end() ) {
    p.maxIndirectCommandsStreamStride = j[ "maxIndirectCommandsStreamStride" ];
  }
  if( j.find( "minSequencesCountBufferOffsetAlignment" ) != j.end() ) {
    p.minSequencesCountBufferOffsetAlignment = j[ "minSequencesCountBufferOffsetAlignment" ];
  }
  if( j.find( "minSequencesIndexBufferOffsetAlignment" ) != j.end() ) {
    p.minSequencesIndexBufferOffsetAlignment = j[ "minSequencesIndexBufferOffsetAlignment" ];
  }
  if( j.find( "minIndirectCommandsBufferOffsetAlignment" ) != j.end() ) {
    p.minIndirectCommandsBufferOffsetAlignment = j[ "minIndirectCommandsBufferOffsetAlignment" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceDeviceGeneratedCommandsPropertiesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceDeviceMemoryReportFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceMemoryReport" ] = bool( p.deviceMemoryReport );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceDeviceMemoryReportFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceDeviceMemoryReportFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDeviceMemoryReportFeaturesEXT" );
  if( j.find( "deviceMemoryReport" ) != j.end() ) {
    p.deviceMemoryReport = j[ "deviceMemoryReport" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceDeviceMemoryReportFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDeviceMemoryReportFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceDiagnosticsConfigFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "diagnosticsConfig" ] = bool( p.diagnosticsConfig );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceDiagnosticsConfigFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceDiagnosticsConfigFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceDiagnosticsConfigFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDiagnosticsConfigFeaturesNV" );
  if( j.find( "diagnosticsConfig" ) != j.end() ) {
    p.diagnosticsConfig = j[ "diagnosticsConfig" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceDiagnosticsConfigFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceDiagnosticsConfigFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDiagnosticsConfigFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceDiscardRectanglePropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxDiscardRectangles" ] = p.maxDiscardRectangles;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceDiscardRectanglePropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceDiscardRectanglePropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceDiscardRectanglePropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDiscardRectanglePropertiesEXT" );
  if( j.find( "maxDiscardRectangles" ) != j.end() ) {
    p.maxDiscardRectangles = j[ "maxDiscardRectangles" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceDiscardRectanglePropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceDiscardRectanglePropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDiscardRectanglePropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DriverId.hpp>
#include <vulkan2json/ConformanceVersion.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceDriverProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "driverID" ] = p.driverID;
  j[ "driverName" ] = std::string( p.driverName.begin(), std::find( p.driverName.begin(), p.driverName.end(), '\0' ) );
  j[ "driverInfo" ] = std::string( p.driverInfo.begin(), std::find( p.driverInfo.begin(), p.driverInfo.end(), '\0' ) );
  j[ "conformanceVersion" ] = p.conformanceVersion;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceDriverProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceDriverProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceDriverProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDriverProperties" );
  if( j.find( "driverID" ) != j.end() ) {
    p.driverID = DriverId ( j[ "driverID" ] );
  }
  if( j.find( "driverName" ) != j.end() ) {
    {
      std::string s = j[ "driverName" ];
      if( !p.driverName.empty() ) {
        p.driverName[ p.driverName.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.driverName.size() - 1u ) ), p.driverName.begin() );
      }
    }
  }
  if( j.find( "driverInfo" ) != j.end() ) {
    {
      std::string s = j[ "driverInfo" ];
      if( !p.driverInfo.empty() ) {
        p.driverInfo[ p.driverInfo.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.driverInfo.size() - 1u ) ), p.driverInfo.begin() );
      }
    }
  }
  if( j.find( "conformanceVersion" ) != j.end() ) {
    p.conformanceVersion = ConformanceVersion ( j[ "conformanceVersion" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceDriverProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceDriverProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDriverProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceDrmPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "hasPrimary" ] = bool( p.hasPrimary );
  j[ "hasRender" ] = bool( p.hasRender );
  j[ "primaryMajor" ] = p.primaryMajor;
  j[ "primaryMinor" ] = p.primaryMinor;
  j[ "renderMajor" ] = p.renderMajor;
  j[ "renderMinor" ] = p.renderMinor;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceDrmPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceDrmPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceDrmPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDrmPropertiesEXT" );
  if( j.find( "hasPrimary" ) != j.end() ) {
    p.hasPrimary = j[ "hasPrimary" ];
  }
  if( j.find( "hasRender" ) != j.end() ) {
    p.hasRender = j[ "hasRender" ];
  }
  if( j.find( "primaryMajor" ) != j.end() ) {
    p.primaryMajor = j[ "primaryMajor" ];
  }
  if( j.find( "primaryMinor" ) != j.end() ) {
    p.primaryMinor = j[ "primaryMinor" ];
  }
  if( j.find( "renderMajor" ) != j.end() ) {
    p.renderMajor = j[ "renderMajor" ];
  }
  if( j.find( "renderMinor" ) != j.end() ) {
    p.renderMinor = j[ "renderMinor" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceDrmPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceDrmPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDrmPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceExclusiveScissorFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "exclusiveScissor" ] = bool( p.exclusiveScissor );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceExclusiveScissorFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceExclusiveScissorFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceExclusiveScissorFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExclusiveScissorFeaturesNV" );
  if( j.find( "exclusiveScissor" ) != j.end() ) {
    p.exclusiveScissor = j[ "exclusiveScissor" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceExclusiveScissorFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceExclusiveScissorFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExclusiveScissorFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceExtendedDynamicState2FeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "extendedDynamicState2" ] = bool( p.extendedDynamicState2 );
  j[ "extendedDynamicState2LogicOp" ] = bool( p.extendedDynamicState2LogicOp );
  j[ "extendedDynamicState2PatchControlPoints" ] = bool( p.extendedDynamicState2PatchControlPoints );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceExtendedDynamicState2FeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceExtendedDynamicState2FeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExtendedDynamicState2FeaturesEXT" );
  if( j.find( "extendedDynamicState2" ) != j.end() ) {
    p.extendedDynamicState2 = j[ "extendedDynamicState2" ];
  }
  if( j.find( "extendedDynamicState2LogicOp" ) != j.end() ) {
    p.extendedDynamicState2LogicOp = j[ "extendedDynamicState2LogicOp" ];
  }
  if( j.find( "extendedDynamicState2PatchControlPoints" ) != j.end() ) {
    p.extendedDynamicState2PatchControlPoints = j[ "extendedDynamicState2PatchControlPoints" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceExtendedDynamicState2FeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExtendedDynamicState2FeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceExtendedDynamicStateFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "extendedDynamicState" ] = bool( p.extendedDynamicState );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceExtendedDynamicStateFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceExtendedDynamicStateFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExtendedDynamicStateFeaturesEXT" );
  if( j.find( "extendedDynamicState" ) != j.end() ) {
    p.extendedDynamicState = j[ "extendedDynamicState" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceExtendedDynamicStateFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExtendedDynamicStateFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/BufferCreateFlags.hpp>
#include <vulkan2json/BufferUsageFlags.hpp>
#include <vulkan2json/ExternalMemoryHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceExternalBufferInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "usage" ] = p.usage;
  j[ "handleType" ] = p.handleType;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceExternalBufferInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceExternalBufferInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceExternalBufferInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExternalBufferInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = BufferCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "usage" ) != j.end() ) {
    p.usage = BufferUsageFlags ( j[ "usage" ] );
  }
  if( j.find( "handleType" ) != j.end() ) {
    p.handleType = ExternalMemoryHandleTypeFlagBits ( j[ "handleType" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceExternalBufferInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceExternalBufferInfo temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExternalBufferInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalFenceHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceExternalFenceInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceExternalFenceInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceExternalFenceInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceExternalFenceInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExternalFenceInfo" );
  if( j.find( "handleType" ) != j.end() ) {
    p.handleType = ExternalFenceHandleTypeFlagBits ( j[ "handleType" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceExternalFenceInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceExternalFenceInfo temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExternalFenceInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalMemoryHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceExternalImageFormatInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceExternalImageFormatInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceExternalImageFormatInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceExternalImageFormatInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExternalImageFormatInfo" );
  if( j.find( "handleType" ) != j.end() ) {
    p.handleType = ExternalMemoryHandleTypeFlagBits ( j[ "handleType" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceExternalImageFormatInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceExternalImageFormatInfo temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExternalImageFormatInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceExternalMemoryHostPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "minImportedHostPointerAlignment" ] = p.minImportedHostPointerAlignment;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceExternalMemoryHostPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceExternalMemoryHostPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceExternalMemoryHostPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExternalMemoryHostPropertiesEXT" );
  if( j.find( "minImportedHostPointerAlignment" ) != j.end() ) {
    p.minImportedHostPointerAlignment = j[ "minImportedHostPointerAlignment" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceExternalMemoryHostPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceExternalMemoryHostPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExternalMemoryHostPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalSemaphoreHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceExternalSemaphoreInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceExternalSemaphoreInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceExternalSemaphoreInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceExternalSemaphoreInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExternalSemaphoreInfo" );
  if( j.find( "handleType" ) != j.end() ) {
    p.handleType = ExternalSemaphoreHandleTypeFlagBits ( j[ "handleType" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceExternalSemaphoreInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceExternalSemaphoreInfo temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExternalSemaphoreInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PhysicalDeviceFeatures.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceFeatures2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "features" ] = p.features;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceFeatures2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceFeatures2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceFeatures2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFeatures2" );
  if( j.find( "features" ) != j.end() ) {
    p.features = PhysicalDeviceFeatures ( j[ "features" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceFeatures2 &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceFeatures2 temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFeatures2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ShaderFloatControlsIndependence.hpp>
#include <vulkan2json/ShaderFloatControlsIndependence.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceFloatControlsProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "denormBehaviorIndependence" ] = p.denormBehaviorIndependence;
  j[ "roundingModeIndependence" ] = p.roundingModeIndependence;
  j[ "shaderSignedZeroInfNanPreserveFloat16" ] = bool( p.shaderSignedZeroInfNanPreserveFloat16 );
  j[ "shaderSignedZeroInfNanPreserveFloat32" ] = bool( p.shaderSignedZeroInfNanPreserveFloat32 );
  j[ "shaderSignedZeroInfNanPreserveFloat64" ] = bool( p.shaderSignedZeroInfNanPreserveFloat64 );
  j[ "shaderDenormPreserveFloat16" ] = bool( p.shaderDenormPreserveFloat16 );
  j[ "shaderDenormPreserveFloat32" ] = bool( p.shaderDenormPreserveFloat32 );
  j[ "shaderDenormPreserveFloat64" ] = bool( p.shaderDenormPreserveFloat64 );
  j[ "shaderDenormFlushToZeroFloat16" ] = bool( p.shaderDenormFlushToZeroFloat16 );
  j[ "shaderDenormFlushToZeroFloat32" ] = bool( p.shaderDenormFlushToZeroFloat32 );
  j[ "shaderDenormFlushToZeroFloat64" ] = bool( p.shaderDenormFlushToZeroFloat64 );
  j[ "shaderRoundingModeRTEFloat16" ] = bool( p.shaderRoundingModeRTEFloat16 );
  j[ "shaderRoundingModeRTEFloat32" ] = bool( p.shaderRoundingModeRTEFloat32 );
  j[ "shaderRoundingModeRTEFloat64" ] = bool( p.shaderRoundingModeRTEFloat64 );
  j[ "shaderRoundingModeRTZFloat16" ] = bool( p.shaderRoundingModeRTZFloat16 );
  j[ "shaderRoundingModeRTZFloat32" ] = bool( p.shaderRoundingModeRTZFloat32 );
  j[ "shaderRoundingModeRTZFloat64" ] = bool( p.shaderRoundingModeRTZFloat64 );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceFloatControlsProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceFloatControlsProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceFloatControlsProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFloatControlsProperties" );
  if( j.find( "denormBehaviorIndependence" ) != j.end() ) {
    p.denormBehaviorIndependence = ShaderFloatControlsIndependence ( j[ "denormBehaviorIndependence" ] );
  }
  if( j.find( "roundingModeIndependence" ) != j.end() ) {
    p.roundingModeIndependence = ShaderFloatControlsIndependence ( j[ "roundingModeIndependence" ] );
  }
  if( j.find( "shaderSignedZeroInfNanPreserveFloat16" ) != j.end() ) {
    p.shaderSignedZeroInfNanPreserveFloat16 = j[ "shaderSignedZeroInfNanPreserveFloat16" ];
  }
  if( j.find( "shaderSignedZeroInfNanPreserveFloat32" ) != j.end() ) {
    p.shaderSignedZeroInfNanPreserveFloat32 = j[ "shaderSignedZeroInfNanPreserveFloat32" ];
  }
  if( j.find( "shaderSignedZeroInfNanPreserveFloat64" ) != j.end() ) {
    p.shaderSignedZeroInfNanPreserveFloat64 = j[ "shaderSignedZeroInfNanPreserveFloat64" ];
  }
  if( j.find( "shaderDenormPreserveFloat16" ) != j.end() ) {
    p.shaderDenormPreserveFloat16 = j[ "shaderDenormPreserveFloat16" ];
  }
  if( j.find( "shaderDenormPreserveFloat32" ) != j.end() ) {
    p.shaderDenormPreserveFloat32 = j[ "shaderDenormPreserveFloat32" ];
  }
  if( j.find( "shaderDenormPreserveFloat64" ) != j.end() ) {
    p.shaderDenormPreserveFloat64 = j[ "shaderDenormPreserveFloat64" ];
  }
  if( j.find( "shaderDenormFlushToZeroFloat16" ) != j.end() ) {
    p.shaderDenormFlushToZeroFloat16 = j[ "shaderDenormFlushToZeroFloat16" ];
  }
  if( j.find( "shaderDenormFlushToZeroFloat32" ) != j.end() ) {
    p.shaderDenormFlushToZeroFloat32 = j[ "shaderDenormFlushToZeroFloat32" ];
  }
  if( j.find( "shaderDenormFlushToZeroFloat64" ) != j.end() ) {
    p.shaderDenormFlushToZeroFloat64 = j[ "shaderDenormFlushToZeroFloat64" ];
  }
  if( j.find( "shaderRoundingModeRTEFloat16" ) != j.end() ) {
    p.shaderRoundingModeRTEFloat16 = j[ "shaderRoundingModeRTEFloat16" ];
  }
  if( j.find( "shaderRoundingModeRTEFloat32" ) != j.end() ) {
    p.shaderRoundingModeRTEFloat32 = j[ "shaderRoundingModeRTEFloat32" ];
  }
  if( j.find( "shaderRoundingModeRTEFloat64" ) != j.end() ) {
    p.shaderRoundingModeRTEFloat64 = j[ "shaderRoundingModeRTEFloat64" ];
  }
  if( j.find( "shaderRoundingModeRTZFloat16" ) != j.end() ) {
    p.shaderRoundingModeRTZFloat16 = j[ "shaderRoundingModeRTZFloat16" ];
  }
  if( j.find( "shaderRoundingModeRTZFloat32" ) != j.end() ) {
    p.shaderRoundingModeRTZFloat32 = j[ "shaderRoundingModeRTZFloat32" ];
  }
  if( j.find( "shaderRoundingModeRTZFloat64" ) != j.end() ) {
    p.shaderRoundingModeRTZFloat64 = j[ "shaderRoundingModeRTZFloat64" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceFloatControlsProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceFloatControlsProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFloatControlsProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceFragmentDensityMap2FeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fragmentDensityMapDeferred" ] = bool( p.fragmentDensityMapDeferred );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentDensityMap2FeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceFragmentDensityMap2FeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentDensityMap2FeaturesEXT" );
  if( j.find( "fragmentDensityMapDeferred" ) != j.end() ) {
    p.fragmentDensityMapDeferred = j[ "fragmentDensityMapDeferred" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentDensityMap2FeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentDensityMap2FeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceFragmentDensityMap2PropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "subsampledLoads" ] = bool( p.subsampledLoads );
  j[ "subsampledCoarseReconstructionEarlyAccess" ] = bool( p.subsampledCoarseReconstructionEarlyAccess );
  j[ "maxSubsampledArrayLayers" ] = p.maxSubsampledArrayLayers;
  j[ "maxDescriptorSetSubsampledSamplers" ] = p.maxDescriptorSetSubsampledSamplers;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentDensityMap2PropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceFragmentDensityMap2PropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentDensityMap2PropertiesEXT" );
  if( j.find( "subsampledLoads" ) != j.end() ) {
    p.subsampledLoads = j[ "subsampledLoads" ];
  }
  if( j.find( "subsampledCoarseReconstructionEarlyAccess" ) != j.end() ) {
    p.subsampledCoarseReconstructionEarlyAccess = j[ "subsampledCoarseReconstructionEarlyAccess" ];
  }
  if( j.find( "maxSubsampledArrayLayers" ) != j.end() ) {
    p.maxSubsampledArrayLayers = j[ "maxSubsampledArrayLayers" ];
  }
  if( j.find( "maxDescriptorSetSubsampledSamplers" ) != j.end() ) {
    p.maxDescriptorSetSubsampledSamplers = j[ "maxDescriptorSetSubsampledSamplers" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentDensityMap2PropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentDensityMap2PropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceFragmentDensityMapFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fragmentDensityMap" ] = bool( p.fragmentDensityMap );
  j[ "fragmentDensityMapDynamic" ] = bool( p.fragmentDensityMapDynamic );
  j[ "fragmentDensityMapNonSubsampledImages" ] = bool( p.fragmentDensityMapNonSubsampledImages );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentDensityMapFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentDensityMapFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceFragmentDensityMapFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentDensityMapFeaturesEXT" );
  if( j.find( "fragmentDensityMap" ) != j.end() ) {
    p.fragmentDensityMap = j[ "fragmentDensityMap" ];
  }
  if( j.find( "fragmentDensityMapDynamic" ) != j.end() ) {
    p.fragmentDensityMapDynamic = j[ "fragmentDensityMapDynamic" ];
  }
  if( j.find( "fragmentDensityMapNonSubsampledImages" ) != j.end() ) {
    p.fragmentDensityMapNonSubsampledImages = j[ "fragmentDensityMapNonSubsampledImages" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentDensityMapFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentDensityMapFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentDensityMapFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/Extent2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceFragmentDensityMapPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "minFragmentDensityTexelSize" ] = p.minFragmentDensityTexelSize;
  j[ "maxFragmentDensityTexelSize" ] = p.maxFragmentDensityTexelSize;
  j[ "fragmentDensityInvocations" ] = bool( p.fragmentDensityInvocations );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentDensityMapPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentDensityMapPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceFragmentDensityMapPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentDensityMapPropertiesEXT" );
  if( j.find( "minFragmentDensityTexelSize" ) != j.end() ) {
    p.minFragmentDensityTexelSize = Extent2D ( j[ "minFragmentDensityTexelSize" ] );
  }
  if( j.find( "maxFragmentDensityTexelSize" ) != j.end() ) {
    p.maxFragmentDensityTexelSize = Extent2D ( j[ "maxFragmentDensityTexelSize" ] );
  }
  if( j.find( "fragmentDensityInvocations" ) != j.end() ) {
    p.fragmentDensityInvocations = j[ "fragmentDensityInvocations" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentDensityMapPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentDensityMapPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentDensityMapPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceFragmentShaderBarycentricFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fragmentShaderBarycentric" ] = bool( p.fragmentShaderBarycentric );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentShaderBarycentricFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceFragmentShaderBarycentricFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentShaderBarycentricFeaturesNV" );
  if( j.find( "fragmentShaderBarycentric" ) != j.end() ) {
    p.fragmentShaderBarycentric = j[ "fragmentShaderBarycentric" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentShaderBarycentricFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceFragmentShaderInterlockFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fragmentShaderSampleInterlock" ] = bool( p.fragmentShaderSampleInterlock );
  j[ "fragmentShaderPixelInterlock" ] = bool( p.fragmentShaderPixelInterlock );
  j[ "fragmentShaderShadingRateInterlock" ] = bool( p.fragmentShaderShadingRateInterlock );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentShaderInterlockFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceFragmentShaderInterlockFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentShaderInterlockFeaturesEXT" );
  if( j.find( "fragmentShaderSampleInterlock" ) != j.end() ) {
    p.fragmentShaderSampleInterlock = j[ "fragmentShaderSampleInterlock" ];
  }
  if( j.find( "fragmentShaderPixelInterlock" ) != j.end() ) {
    p.fragmentShaderPixelInterlock = j[ "fragmentShaderPixelInterlock" ];
  }
  if( j.find( "fragmentShaderShadingRateInterlock" ) != j.end() ) {
    p.fragmentShaderShadingRateInterlock = j[ "fragmentShaderShadingRateInterlock" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentShaderInterlockFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceFragmentShadingRateEnumsFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fragmentShadingRateEnums" ] = bool( p.fragmentShadingRateEnums );
  j[ "supersampleFragmentShadingRates" ] = bool( p.supersampleFragmentShadingRates );
  j[ "noInvocationFragmentShadingRates" ] = bool( p.noInvocationFragmentShadingRates );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentShadingRateEnumsFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceFragmentShadingRateEnumsFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV" );
  if( j.find( "fragmentShadingRateEnums" ) != j.end() ) {
    p.fragmentShadingRateEnums = j[ "fragmentShadingRateEnums" ];
  }
  if( j.find( "supersampleFragmentShadingRates" ) != j.end() ) {
    p.supersampleFragmentShadingRates = j[ "supersampleFragmentShadingRates" ];
  }
  if( j.find( "noInvocationFragmentShadingRates" ) != j.end() ) {
    p.noInvocationFragmentShadingRates = j[ "noInvocationFragmentShadingRates" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentShadingRateEnumsFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceFragmentShadingRateEnumsPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxFragmentShadingRateInvocationCount" ] = p.maxFragmentShadingRateInvocationCount;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentShadingRateEnumsPropertiesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceFragmentShadingRateEnumsPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV" );
  if( j.find( "maxFragmentShadingRateInvocationCount" ) != j.end() ) {
    p.maxFragmentShadingRateInvocationCount = SampleCountFlagBits ( j[ "maxFragmentShadingRateInvocationCount" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentShadingRateEnumsPropertiesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceFragmentShadingRateFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pipelineFragmentShadingRate" ] = bool( p.pipelineFragmentShadingRate );
  j[ "primitiveFragmentShadingRate" ] = bool( p.primitiveFragmentShadingRate );
  j[ "attachmentFragmentShadingRate" ] = bool( p.attachmentFragmentShadingRate );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentShadingRateFeaturesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentShadingRateFeaturesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceFragmentShadingRateFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentShadingRateFeaturesKHR" );
  if( j.find( "pipelineFragmentShadingRate" ) != j.end() ) {
    p.pipelineFragmentShadingRate = j[ "pipelineFragmentShadingRate" ];
  }
  if( j.find( "primitiveFragmentShadingRate" ) != j.end() ) {
    p.primitiveFragmentShadingRate = j[ "primitiveFragmentShadingRate" ];
  }
  if( j.find( "attachmentFragmentShadingRate" ) != j.end() ) {
    p.attachmentFragmentShadingRate = j[ "attachmentFragmentShadingRate" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentShadingRateFeaturesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentShadingRateFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentShadingRateFeaturesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/Extent2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceFragmentShadingRateKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "sampleCounts" ] = p.sampleCounts;
  j[ "fragmentSize" ] = p.fragmentSize;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentShadingRateKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentShadingRateKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceFragmentShadingRateKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentShadingRateKHR" );
  if( j.find( "sampleCounts" ) != j.end() ) {
    p.sampleCounts = SampleCountFlags ( j[ "sampleCounts" ] );
  }
  if( j.find( "fragmentSize" ) != j.end() ) {
    p.fragmentSize = Extent2D ( j[ "fragmentSize" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentShadingRateKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentShadingRateKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentShadingRateKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceFragmentShadingRatePropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "minFragmentShadingRateAttachmentTexelSize" ] = p.minFragmentShadingRateAttachmentTexelSize;
  j[ "maxFragmentShadingRateAttachmentTexelSize" ] = p.maxFragmentShadingRateAttachmentTexelSize;
  j[ "maxFragmentShadingRateAttachmentTexelSizeAspectRatio" ] = p.maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
  j[ "primitiveFragmentShadingRateWithMultipleViewports" ] = bool( p.primitiveFragmentShadingRateWithMultipleViewports );
  j[ "layeredShadingRateAttachments" ] = bool( p.layeredShadingRateAttachments );
  j[ "fragmentShadingRateNonTrivialCombinerOps" ] = bool( p.fragmentShadingRateNonTrivialCombinerOps );
  j[ "maxFragmentSize" ] = p.maxFragmentSize;
  j[ "maxFragmentSizeAspectRatio" ] = p.maxFragmentSizeAspectRatio;
  j[ "maxFragmentShadingRateCoverageSamples" ] = p.maxFragmentShadingRateCoverageSamples;
  j[ "maxFragmentShadingRateRasterizationSamples" ] = p.maxFragmentShadingRateRasterizationSamples;
  j[ "fragmentShadingRateWithShaderDepthStencilWrites" ] = bool( p.fragmentShadingRateWithShaderDepthStencilWrites );
  j[ "fragmentShadingRateWithSampleMask" ] = bool( p.fragmentShadingRateWithSampleMask );
  j[ "fragmentShadingRateWithShaderSampleMask" ] = bool( p.fragmentShadingRateWithShaderSampleMask );
  j[ "fragmentShadingRateWithConservativeRasterization" ] = bool( p.fragmentShadingRateWithConservativeRasterization );
  j[ "fragmentShadingRateWithFragmentShaderInterlock" ] = bool( p.fragmentShadingRateWithFragmentShaderInterlock );
  j[ "fragmentShadingRateWithCustomSampleLocations" ] = bool( p.fragmentShadingRateWithCustomSampleLocations );
  j[ "fragmentShadingRateStrictMultiplyCombiner" ] = bool( p.fragmentShadingRateStrictMultiplyCombiner );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentShadingRatePropertiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentShadingRatePropertiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceFragmentShadingRatePropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentShadingRatePropertiesKHR" );
  if( j.find( "minFragmentShadingRateAttachmentTexelSize" ) != j.end() ) {
    p.minFragmentShadingRateAttachmentTexelSize = Extent2D ( j[ "minFragmentShadingRateAttachmentTexelSize" ] );
  }
  if( j.find( "maxFragmentShadingRateAttachmentTexelSize" ) != j.end() ) {
    p.maxFragmentShadingRateAttachmentTexelSize = Extent2D ( j[ "maxFragmentShadingRateAttachmentTexelSize" ] );
  }
  if( j.find( "maxFragmentShadingRateAttachmentTexelSizeAspectRatio" ) != j.end() ) {
    p.maxFragmentShadingRateAttachmentTexelSizeAspectRatio = j[ "maxFragmentShadingRateAttachmentTexelSizeAspectRatio" ];
  }
  if( j.find( "primitiveFragmentShadingRateWithMultipleViewports" ) != j.end() ) {
    p.primitiveFragmentShadingRateWithMultipleViewports = j[ "primitiveFragmentShadingRateWithMultipleViewports" ];
  }
  if( j.find( "layeredShadingRateAttachments" ) != j.end() ) {
    p.layeredShadingRateAttachments = j[ "layeredShadingRateAttachments" ];
  }
  if( j.find( "fragmentShadingRateNonTrivialCombinerOps" ) != j.end() ) {
    p.fragmentShadingRateNonTrivialCombinerOps = j[ "fragmentShadingRateNonTrivialCombinerOps" ];
  }
  if( j.find( "maxFragmentSize" ) != j.end() ) {
    p.maxFragmentSize = Extent2D ( j[ "maxFragmentSize" ] );
  }
  if( j.find( "maxFragmentSizeAspectRatio" ) != j.end() ) {
    p.maxFragmentSizeAspectRatio = j[ "maxFragmentSizeAspectRatio" ];
  }
  if( j.find( "maxFragmentShadingRateCoverageSamples" ) != j.end() ) {
    p.maxFragmentShadingRateCoverageSamples = j[ "maxFragmentShadingRateCoverageSamples" ];
  }
  if( j.find( "maxFragmentShadingRateRasterizationSamples" ) != j.end() ) {
    p.maxFragmentShadingRateRasterizationSamples = SampleCountFlagBits ( j[ "maxFragmentShadingRateRasterizationSamples" ] );
  }
  if( j.find( "fragmentShadingRateWithShaderDepthStencilWrites" ) != j.end() ) {
    p.fragmentShadingRateWithShaderDepthStencilWrites = j[ "fragmentShadingRateWithShaderDepthStencilWrites" ];
  }
  if( j.find( "fragmentShadingRateWithSampleMask" ) != j.end() ) {
    p.fragmentShadingRateWithSampleMask = j[ "fragmentShadingRateWithSampleMask" ];
  }
  if( j.find( "fragmentShadingRateWithShaderSampleMask" ) != j.end() ) {
    p.fragmentShadingRateWithShaderSampleMask = j[ "fragmentShadingRateWithShaderSampleMask" ];
  }
  if( j.find( "fragmentShadingRateWithConservativeRasterization" ) != j.end() ) {
    p.fragmentShadingRateWithConservativeRasterization = j[ "fragmentShadingRateWithConservativeRasterization" ];
  }
  if( j.find( "fragmentShadingRateWithFragmentShaderInterlock" ) != j.end() ) {
    p.fragmentShadingRateWithFragmentShaderInterlock = j[ "fragmentShadingRateWithFragmentShaderInterlock" ];
  }
  if( j.find( "fragmentShadingRateWithCustomSampleLocations" ) != j.end() ) {
    p.fragmentShadingRateWithCustomSampleLocations = j[ "fragmentShadingRateWithCustomSampleLocations" ];
  }
  if( j.find( "fragmentShadingRateStrictMultiplyCombiner" ) != j.end() ) {
    p.fragmentShadingRateStrictMultiplyCombiner = j[ "fragmentShadingRateStrictMultiplyCombiner" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentShadingRatePropertiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceFragmentShadingRatePropertiesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentShadingRatePropertiesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceGlobalPriorityQueryFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "globalPriorityQuery" ] = bool( p.globalPriorityQuery );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceGlobalPriorityQueryFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceGlobalPriorityQueryFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceGlobalPriorityQueryFeaturesEXT" );
  if( j.find( "globalPriorityQuery" ) != j.end() ) {
    p.globalPriorityQuery = j[ "globalPriorityQuery" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceGlobalPriorityQueryFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceGroupProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "physicalDeviceCount" ] = p.physicalDeviceCount;
  j[ "subsetAllocation" ] = bool( p.subsetAllocation );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceGroupProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceGroupProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceGroupProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceGroupProperties" );
  if( j.find( "physicalDeviceCount" ) != j.end() ) {
    p.physicalDeviceCount = j[ "physicalDeviceCount" ];
  }
  if( j.find( "subsetAllocation" ) != j.end() ) {
    p.subsetAllocation = j[ "subsetAllocation" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceGroupProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceGroupProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceGroupProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceHostQueryResetFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "hostQueryReset" ] = bool( p.hostQueryReset );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceHostQueryResetFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceHostQueryResetFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceHostQueryResetFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceHostQueryResetFeatures" );
  if( j.find( "hostQueryReset" ) != j.end() ) {
    p.hostQueryReset = j[ "hostQueryReset" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceHostQueryResetFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceHostQueryResetFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceHostQueryResetFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceIDProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceUUID" ] = nlohmann::json::array();
  std::copy( p.deviceUUID.begin(), p.deviceUUID.end(), std::back_inserter( j[ "deviceUUID" ] ) );
  j[ "driverUUID" ] = nlohmann::json::array();
  std::copy( p.driverUUID.begin(), p.driverUUID.end(), std::back_inserter( j[ "driverUUID" ] ) );
  j[ "deviceLUID" ] = nlohmann::json::array();
  std::copy( p.deviceLUID.begin(), p.deviceLUID.end(), std::back_inserter( j[ "deviceLUID" ] ) );
  j[ "deviceNodeMask" ] = p.deviceNodeMask;
  j[ "deviceLUIDValid" ] = bool( p.deviceLUIDValid );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceIDProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceIDProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceIDProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceIDProperties" );
  if( j.find( "deviceUUID" ) != j.end() ) {
    if( !j[ "deviceUUID" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceIDProperties.deviceUUID" );
    if( !j[ "deviceUUID" ].size() > p.deviceUUID.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceIDProperties.deviceUUID" );
    std::fill( p.deviceUUID.begin(), p.deviceUUID.end(), 0 );
    std::copy( j[ "deviceUUID" ].begin(), j[ "deviceUUID" ].end(), p.deviceUUID.begin() );
  }
  if( j.find( "driverUUID" ) != j.end() ) {
    if( !j[ "driverUUID" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceIDProperties.driverUUID" );
    if( !j[ "driverUUID" ].size() > p.driverUUID.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceIDProperties.driverUUID" );
    std::fill( p.driverUUID.begin(), p.driverUUID.end(), 0 );
    std::copy( j[ "driverUUID" ].begin(), j[ "driverUUID" ].end(), p.driverUUID.begin() );
  }
  if( j.find( "deviceLUID" ) != j.end() ) {
    if( !j[ "deviceLUID" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceIDProperties.deviceLUID" );
    if( !j[ "deviceLUID" ].size() > p.deviceLUID.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceIDProperties.deviceLUID" );
    std::fill( p.deviceLUID.begin(), p.deviceLUID.end(), 0 );
    std::copy( j[ "deviceLUID" ].begin(), j[ "deviceLUID" ].end(), p.deviceLUID.begin() );
  }
  if( j.find( "deviceNodeMask" ) != j.end() ) {
    p.deviceNodeMask = j[ "deviceNodeMask" ];
  }
  if( j.find( "deviceLUIDValid" ) != j.end() ) {
    p.deviceLUIDValid = j[ "deviceLUIDValid" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceIDProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceIDProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceIDProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SharingMode.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceImageDrmFormatModifierInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "drmFormatModifier" ] = p.drmFormatModifier;
  j[ "sharingMode" ] = p.sharingMode;
  j[ "queueFamilyIndexCount" ] = p.queueFamilyIndexCount;
  j[ "pQueueFamilyIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pQueueFamilyIndices ) );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceImageDrmFormatModifierInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceImageDrmFormatModifierInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceImageDrmFormatModifierInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceImageDrmFormatModifierInfoEXT" );
  if( j.find( "drmFormatModifier" ) != j.end() ) {
    p.drmFormatModifier = j[ "drmFormatModifier" ];
  }
  if( j.find( "sharingMode" ) != j.end() ) {
    p.sharingMode = SharingMode ( j[ "sharingMode" ] );
  }
  if( j.find( "queueFamilyIndexCount" ) != j.end() ) {
    p.queueFamilyIndexCount = j[ "queueFamilyIndexCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceImageDrmFormatModifierInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceImageDrmFormatModifierInfoEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceImageDrmFormatModifierInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Format.hpp>
#include <vulkan2json/ImageType.hpp>
#include <vulkan2json/ImageTiling.hpp>
#include <vulkan2json/ImageUsageFlags.hpp>
#include <vulkan2json/ImageCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceImageFormatInfo2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "format" ] = p.format;
  j[ "type" ] = p.type;
  j[ "tiling" ] = p.tiling;
  j[ "usage" ] = p.usage;
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceImageFormatInfo2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceImageFormatInfo2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceImageFormatInfo2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceImageFormatInfo2" );
  if( j.find( "format" ) != j.end() ) {
    p.format = Format ( j[ "format" ] );
  }
  if( j.find( "type" ) != j.end() ) {
    p.type = ImageType ( j[ "type" ] );
  }
  if( j.find( "tiling" ) != j.end() ) {
    p.tiling = ImageTiling ( j[ "tiling" ] );
  }
  if( j.find( "usage" ) != j.end() ) {
    p.usage = ImageUsageFlags ( j[ "usage" ] );
  }
  if( j.find( "flags" ) != j.end() ) {
    p.flags = ImageCreateFlags ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceImageFormatInfo2 &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceImageFormatInfo2 temp;
  from_json( j, temp );
  p = VkPhysicalDeviceImageFormatInfo2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceImageRobustnessFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "robustImageAccess" ] = bool( p.robustImageAccess );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceImageRobustnessFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceImageRobustnessFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceImageRobustnessFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceImageRobustnessFeaturesEXT" );
  if( j.find( "robustImageAccess" ) != j.end() ) {
    p.robustImageAccess = j[ "robustImageAccess" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceImageRobustnessFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceImageRobustnessFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceImageRobustnessFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageViewType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceImageViewImageFormatInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "imageViewType" ] = p.imageViewType;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceImageViewImageFormatInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceImageViewImageFormatInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceImageViewImageFormatInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceImageViewImageFormatInfoEXT" );
  if( j.find( "imageViewType" ) != j.end() ) {
    p.imageViewType = ImageViewType ( j[ "imageViewType" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceImageViewImageFormatInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceImageViewImageFormatInfoEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceImageViewImageFormatInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceImagelessFramebufferFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "imagelessFramebuffer" ] = bool( p.imagelessFramebuffer );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceImagelessFramebufferFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceImagelessFramebufferFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceImagelessFramebufferFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceImagelessFramebufferFeatures" );
  if( j.find( "imagelessFramebuffer" ) != j.end() ) {
    p.imagelessFramebuffer = j[ "imagelessFramebuffer" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceImagelessFramebufferFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceImagelessFramebufferFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceImagelessFramebufferFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceIndexTypeUint8FeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "indexTypeUint8" ] = bool( p.indexTypeUint8 );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceIndexTypeUint8FeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceIndexTypeUint8FeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceIndexTypeUint8FeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceIndexTypeUint8FeaturesEXT" );
  if( j.find( "indexTypeUint8" ) != j.end() ) {
    p.indexTypeUint8 = j[ "indexTypeUint8" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceIndexTypeUint8FeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceIndexTypeUint8FeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceIndexTypeUint8FeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceInheritedViewportScissorFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "inheritedViewportScissor2D" ] = bool( p.inheritedViewportScissor2D );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceInheritedViewportScissorFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceInheritedViewportScissorFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceInheritedViewportScissorFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceInheritedViewportScissorFeaturesNV" );
  if( j.find( "inheritedViewportScissor2D" ) != j.end() ) {
    p.inheritedViewportScissor2D = j[ "inheritedViewportScissor2D" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceInheritedViewportScissorFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceInheritedViewportScissorFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceInheritedViewportScissorFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceInlineUniformBlockFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "inlineUniformBlock" ] = bool( p.inlineUniformBlock );
  j[ "descriptorBindingInlineUniformBlockUpdateAfterBind" ] = bool( p.descriptorBindingInlineUniformBlockUpdateAfterBind );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceInlineUniformBlockFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceInlineUniformBlockFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceInlineUniformBlockFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceInlineUniformBlockFeaturesEXT" );
  if( j.find( "inlineUniformBlock" ) != j.end() ) {
    p.inlineUniformBlock = j[ "inlineUniformBlock" ];
  }
  if( j.find( "descriptorBindingInlineUniformBlockUpdateAfterBind" ) != j.end() ) {
    p.descriptorBindingInlineUniformBlockUpdateAfterBind = j[ "descriptorBindingInlineUniformBlockUpdateAfterBind" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceInlineUniformBlockFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceInlineUniformBlockFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceInlineUniformBlockFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceInlineUniformBlockPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxInlineUniformBlockSize" ] = p.maxInlineUniformBlockSize;
  j[ "maxPerStageDescriptorInlineUniformBlocks" ] = p.maxPerStageDescriptorInlineUniformBlocks;
  j[ "maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks" ] = p.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
  j[ "maxDescriptorSetInlineUniformBlocks" ] = p.maxDescriptorSetInlineUniformBlocks;
  j[ "maxDescriptorSetUpdateAfterBindInlineUniformBlocks" ] = p.maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceInlineUniformBlockPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceInlineUniformBlockPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceInlineUniformBlockPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceInlineUniformBlockPropertiesEXT" );
  if( j.find( "maxInlineUniformBlockSize" ) != j.end() ) {
    p.maxInlineUniformBlockSize = j[ "maxInlineUniformBlockSize" ];
  }
  if( j.find( "maxPerStageDescriptorInlineUniformBlocks" ) != j.end() ) {
    p.maxPerStageDescriptorInlineUniformBlocks = j[ "maxPerStageDescriptorInlineUniformBlocks" ];
  }
  if( j.find( "maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks" ) != j.end() ) {
    p.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = j[ "maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks" ];
  }
  if( j.find( "maxDescriptorSetInlineUniformBlocks" ) != j.end() ) {
    p.maxDescriptorSetInlineUniformBlocks = j[ "maxDescriptorSetInlineUniformBlocks" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindInlineUniformBlocks" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindInlineUniformBlocks = j[ "maxDescriptorSetUpdateAfterBindInlineUniformBlocks" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceInlineUniformBlockPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceInlineUniformBlockPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceInlineUniformBlockPropertiesEXT ( temp );
}
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceLimits &p ) {
  j = nlohmann::json::object();
  j[ "maxImageDimension1D" ] = p.maxImageDimension1D;
  j[ "maxImageDimension2D" ] = p.maxImageDimension2D;
  j[ "maxImageDimension3D" ] = p.maxImageDimension3D;
  j[ "maxImageDimensionCube" ] = p.maxImageDimensionCube;
  j[ "maxImageArrayLayers" ] = p.maxImageArrayLayers;
  j[ "maxTexelBufferElements" ] = p.maxTexelBufferElements;
  j[ "maxUniformBufferRange" ] = p.maxUniformBufferRange;
  j[ "maxStorageBufferRange" ] = p.maxStorageBufferRange;
  j[ "maxPushConstantsSize" ] = p.maxPushConstantsSize;
  j[ "maxMemoryAllocationCount" ] = p.maxMemoryAllocationCount;
  j[ "maxSamplerAllocationCount" ] = p.maxSamplerAllocationCount;
  j[ "bufferImageGranularity" ] = p.bufferImageGranularity;
  j[ "sparseAddressSpaceSize" ] = p.sparseAddressSpaceSize;
  j[ "maxBoundDescriptorSets" ] = p.maxBoundDescriptorSets;
  j[ "maxPerStageDescriptorSamplers" ] = p.maxPerStageDescriptorSamplers;
  j[ "maxPerStageDescriptorUniformBuffers" ] = p.maxPerStageDescriptorUniformBuffers;
  j[ "maxPerStageDescriptorStorageBuffers" ] = p.maxPerStageDescriptorStorageBuffers;
  j[ "maxPerStageDescriptorSampledImages" ] = p.maxPerStageDescriptorSampledImages;
  j[ "maxPerStageDescriptorStorageImages" ] = p.maxPerStageDescriptorStorageImages;
  j[ "maxPerStageDescriptorInputAttachments" ] = p.maxPerStageDescriptorInputAttachments;
  j[ "maxPerStageResources" ] = p.maxPerStageResources;
  j[ "maxDescriptorSetSamplers" ] = p.maxDescriptorSetSamplers;
  j[ "maxDescriptorSetUniformBuffers" ] = p.maxDescriptorSetUniformBuffers;
  j[ "maxDescriptorSetUniformBuffersDynamic" ] = p.maxDescriptorSetUniformBuffersDynamic;
  j[ "maxDescriptorSetStorageBuffers" ] = p.maxDescriptorSetStorageBuffers;
  j[ "maxDescriptorSetStorageBuffersDynamic" ] = p.maxDescriptorSetStorageBuffersDynamic;
  j[ "maxDescriptorSetSampledImages" ] = p.maxDescriptorSetSampledImages;
  j[ "maxDescriptorSetStorageImages" ] = p.maxDescriptorSetStorageImages;
  j[ "maxDescriptorSetInputAttachments" ] = p.maxDescriptorSetInputAttachments;
  j[ "maxVertexInputAttributes" ] = p.maxVertexInputAttributes;
  j[ "maxVertexInputBindings" ] = p.maxVertexInputBindings;
  j[ "maxVertexInputAttributeOffset" ] = p.maxVertexInputAttributeOffset;
  j[ "maxVertexInputBindingStride" ] = p.maxVertexInputBindingStride;
  j[ "maxVertexOutputComponents" ] = p.maxVertexOutputComponents;
  j[ "maxTessellationGenerationLevel" ] = p.maxTessellationGenerationLevel;
  j[ "maxTessellationPatchSize" ] = p.maxTessellationPatchSize;
  j[ "maxTessellationControlPerVertexInputComponents" ] = p.maxTessellationControlPerVertexInputComponents;
  j[ "maxTessellationControlPerVertexOutputComponents" ] = p.maxTessellationControlPerVertexOutputComponents;
  j[ "maxTessellationControlPerPatchOutputComponents" ] = p.maxTessellationControlPerPatchOutputComponents;
  j[ "maxTessellationControlTotalOutputComponents" ] = p.maxTessellationControlTotalOutputComponents;
  j[ "maxTessellationEvaluationInputComponents" ] = p.maxTessellationEvaluationInputComponents;
  j[ "maxTessellationEvaluationOutputComponents" ] = p.maxTessellationEvaluationOutputComponents;
  j[ "maxGeometryShaderInvocations" ] = p.maxGeometryShaderInvocations;
  j[ "maxGeometryInputComponents" ] = p.maxGeometryInputComponents;
  j[ "maxGeometryOutputComponents" ] = p.maxGeometryOutputComponents;
  j[ "maxGeometryOutputVertices" ] = p.maxGeometryOutputVertices;
  j[ "maxGeometryTotalOutputComponents" ] = p.maxGeometryTotalOutputComponents;
  j[ "maxFragmentInputComponents" ] = p.maxFragmentInputComponents;
  j[ "maxFragmentOutputAttachments" ] = p.maxFragmentOutputAttachments;
  j[ "maxFragmentDualSrcAttachments" ] = p.maxFragmentDualSrcAttachments;
  j[ "maxFragmentCombinedOutputResources" ] = p.maxFragmentCombinedOutputResources;
  j[ "maxComputeSharedMemorySize" ] = p.maxComputeSharedMemorySize;
  j[ "maxComputeWorkGroupCount" ] = nlohmann::json::array();
  std::copy( p.maxComputeWorkGroupCount.begin(), p.maxComputeWorkGroupCount.end(), std::back_inserter( j[ "maxComputeWorkGroupCount" ] ) );
  j[ "maxComputeWorkGroupInvocations" ] = p.maxComputeWorkGroupInvocations;
  j[ "maxComputeWorkGroupSize" ] = nlohmann::json::array();
  std::copy( p.maxComputeWorkGroupSize.begin(), p.maxComputeWorkGroupSize.end(), std::back_inserter( j[ "maxComputeWorkGroupSize" ] ) );
  j[ "subPixelPrecisionBits" ] = p.subPixelPrecisionBits;
  j[ "subTexelPrecisionBits" ] = p.subTexelPrecisionBits;
  j[ "mipmapPrecisionBits" ] = p.mipmapPrecisionBits;
  j[ "maxDrawIndexedIndexValue" ] = p.maxDrawIndexedIndexValue;
  j[ "maxDrawIndirectCount" ] = p.maxDrawIndirectCount;
  j[ "maxSamplerLodBias" ] = p.maxSamplerLodBias;
  j[ "maxSamplerAnisotropy" ] = p.maxSamplerAnisotropy;
  j[ "maxViewports" ] = p.maxViewports;
  j[ "maxViewportDimensions" ] = nlohmann::json::array();
  std::copy( p.maxViewportDimensions.begin(), p.maxViewportDimensions.end(), std::back_inserter( j[ "maxViewportDimensions" ] ) );
  j[ "viewportBoundsRange" ] = nlohmann::json::array();
  std::copy( p.viewportBoundsRange.begin(), p.viewportBoundsRange.end(), std::back_inserter( j[ "viewportBoundsRange" ] ) );
  j[ "viewportSubPixelBits" ] = p.viewportSubPixelBits;
  j[ "minMemoryMapAlignment" ] = p.minMemoryMapAlignment;
  j[ "minTexelBufferOffsetAlignment" ] = p.minTexelBufferOffsetAlignment;
  j[ "minUniformBufferOffsetAlignment" ] = p.minUniformBufferOffsetAlignment;
  j[ "minStorageBufferOffsetAlignment" ] = p.minStorageBufferOffsetAlignment;
  j[ "minTexelOffset" ] = p.minTexelOffset;
  j[ "maxTexelOffset" ] = p.maxTexelOffset;
  j[ "minTexelGatherOffset" ] = p.minTexelGatherOffset;
  j[ "maxTexelGatherOffset" ] = p.maxTexelGatherOffset;
  j[ "minInterpolationOffset" ] = p.minInterpolationOffset;
  j[ "maxInterpolationOffset" ] = p.maxInterpolationOffset;
  j[ "subPixelInterpolationOffsetBits" ] = p.subPixelInterpolationOffsetBits;
  j[ "maxFramebufferWidth" ] = p.maxFramebufferWidth;
  j[ "maxFramebufferHeight" ] = p.maxFramebufferHeight;
  j[ "maxFramebufferLayers" ] = p.maxFramebufferLayers;
  j[ "framebufferColorSampleCounts" ] = p.framebufferColorSampleCounts;
  j[ "framebufferDepthSampleCounts" ] = p.framebufferDepthSampleCounts;
  j[ "framebufferStencilSampleCounts" ] = p.framebufferStencilSampleCounts;
  j[ "framebufferNoAttachmentsSampleCounts" ] = p.framebufferNoAttachmentsSampleCounts;
  j[ "maxColorAttachments" ] = p.maxColorAttachments;
  j[ "sampledImageColorSampleCounts" ] = p.sampledImageColorSampleCounts;
  j[ "sampledImageIntegerSampleCounts" ] = p.sampledImageIntegerSampleCounts;
  j[ "sampledImageDepthSampleCounts" ] = p.sampledImageDepthSampleCounts;
  j[ "sampledImageStencilSampleCounts" ] = p.sampledImageStencilSampleCounts;
  j[ "storageImageSampleCounts" ] = p.storageImageSampleCounts;
  j[ "maxSampleMaskWords" ] = p.maxSampleMaskWords;
  j[ "timestampComputeAndGraphics" ] = bool( p.timestampComputeAndGraphics );
  j[ "timestampPeriod" ] = p.timestampPeriod;
  j[ "maxClipDistances" ] = p.maxClipDistances;
  j[ "maxCullDistances" ] = p.maxCullDistances;
  j[ "maxCombinedClipAndCullDistances" ] = p.maxCombinedClipAndCullDistances;
  j[ "discreteQueuePriorities" ] = p.discreteQueuePriorities;
  j[ "pointSizeRange" ] = nlohmann::json::array();
  std::copy( p.pointSizeRange.begin(), p.pointSizeRange.end(), std::back_inserter( j[ "pointSizeRange" ] ) );
  j[ "lineWidthRange" ] = nlohmann::json::array();
  std::copy( p.lineWidthRange.begin(), p.lineWidthRange.end(), std::back_inserter( j[ "lineWidthRange" ] ) );
  j[ "pointSizeGranularity" ] = p.pointSizeGranularity;
  j[ "lineWidthGranularity" ] = p.lineWidthGranularity;
  j[ "strictLines" ] = bool( p.strictLines );
  j[ "standardSampleLocations" ] = bool( p.standardSampleLocations );
  j[ "optimalBufferCopyOffsetAlignment" ] = p.optimalBufferCopyOffsetAlignment;
  j[ "optimalBufferCopyRowPitchAlignment" ] = p.optimalBufferCopyRowPitchAlignment;
  j[ "nonCoherentAtomSize" ] = p.nonCoherentAtomSize;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceLimits &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceLimits ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceLimits &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceLimits" );
  if( j.find( "maxImageDimension1D" ) != j.end() ) {
    p.maxImageDimension1D = j[ "maxImageDimension1D" ];
  }
  if( j.find( "maxImageDimension2D" ) != j.end() ) {
    p.maxImageDimension2D = j[ "maxImageDimension2D" ];
  }
  if( j.find( "maxImageDimension3D" ) != j.end() ) {
    p.maxImageDimension3D = j[ "maxImageDimension3D" ];
  }
  if( j.find( "maxImageDimensionCube" ) != j.end() ) {
    p.maxImageDimensionCube = j[ "maxImageDimensionCube" ];
  }
  if( j.find( "maxImageArrayLayers" ) != j.end() ) {
    p.maxImageArrayLayers = j[ "maxImageArrayLayers" ];
  }
  if( j.find( "maxTexelBufferElements" ) != j.end() ) {
    p.maxTexelBufferElements = j[ "maxTexelBufferElements" ];
  }
  if( j.find( "maxUniformBufferRange" ) != j.end() ) {
    p.maxUniformBufferRange = j[ "maxUniformBufferRange" ];
  }
  if( j.find( "maxStorageBufferRange" ) != j.end() ) {
    p.maxStorageBufferRange = j[ "maxStorageBufferRange" ];
  }
  if( j.find( "maxPushConstantsSize" ) != j.end() ) {
    p.maxPushConstantsSize = j[ "maxPushConstantsSize" ];
  }
  if( j.find( "maxMemoryAllocationCount" ) != j.end() ) {
    p.maxMemoryAllocationCount = j[ "maxMemoryAllocationCount" ];
  }
  if( j.find( "maxSamplerAllocationCount" ) != j.end() ) {
    p.maxSamplerAllocationCount = j[ "maxSamplerAllocationCount" ];
  }
  if( j.find( "bufferImageGranularity" ) != j.end() ) {
    p.bufferImageGranularity = j[ "bufferImageGranularity" ];
  }
  if( j.find( "sparseAddressSpaceSize" ) != j.end() ) {
    p.sparseAddressSpaceSize = j[ "sparseAddressSpaceSize" ];
  }
  if( j.find( "maxBoundDescriptorSets" ) != j.end() ) {
    p.maxBoundDescriptorSets = j[ "maxBoundDescriptorSets" ];
  }
  if( j.find( "maxPerStageDescriptorSamplers" ) != j.end() ) {
    p.maxPerStageDescriptorSamplers = j[ "maxPerStageDescriptorSamplers" ];
  }
  if( j.find( "maxPerStageDescriptorUniformBuffers" ) != j.end() ) {
    p.maxPerStageDescriptorUniformBuffers = j[ "maxPerStageDescriptorUniformBuffers" ];
  }
  if( j.find( "maxPerStageDescriptorStorageBuffers" ) != j.end() ) {
    p.maxPerStageDescriptorStorageBuffers = j[ "maxPerStageDescriptorStorageBuffers" ];
  }
  if( j.find( "maxPerStageDescriptorSampledImages" ) != j.end() ) {
    p.maxPerStageDescriptorSampledImages = j[ "maxPerStageDescriptorSampledImages" ];
  }
  if( j.find( "maxPerStageDescriptorStorageImages" ) != j.end() ) {
    p.maxPerStageDescriptorStorageImages = j[ "maxPerStageDescriptorStorageImages" ];
  }
  if( j.find( "maxPerStageDescriptorInputAttachments" ) != j.end() ) {
    p.maxPerStageDescriptorInputAttachments = j[ "maxPerStageDescriptorInputAttachments" ];
  }
  if( j.find( "maxPerStageResources" ) != j.end() ) {
    p.maxPerStageResources = j[ "maxPerStageResources" ];
  }
  if( j.find( "maxDescriptorSetSamplers" ) != j.end() ) {
    p.maxDescriptorSetSamplers = j[ "maxDescriptorSetSamplers" ];
  }
  if( j.find( "maxDescriptorSetUniformBuffers" ) != j.end() ) {
    p.maxDescriptorSetUniformBuffers = j[ "maxDescriptorSetUniformBuffers" ];
  }
  if( j.find( "maxDescriptorSetUniformBuffersDynamic" ) != j.end() ) {
    p.maxDescriptorSetUniformBuffersDynamic = j[ "maxDescriptorSetUniformBuffersDynamic" ];
  }
  if( j.find( "maxDescriptorSetStorageBuffers" ) != j.end() ) {
    p.maxDescriptorSetStorageBuffers = j[ "maxDescriptorSetStorageBuffers" ];
  }
  if( j.find( "maxDescriptorSetStorageBuffersDynamic" ) != j.end() ) {
    p.maxDescriptorSetStorageBuffersDynamic = j[ "maxDescriptorSetStorageBuffersDynamic" ];
  }
  if( j.find( "maxDescriptorSetSampledImages" ) != j.end() ) {
    p.maxDescriptorSetSampledImages = j[ "maxDescriptorSetSampledImages" ];
  }
  if( j.find( "maxDescriptorSetStorageImages" ) != j.end() ) {
    p.maxDescriptorSetStorageImages = j[ "maxDescriptorSetStorageImages" ];
  }
  if( j.find( "maxDescriptorSetInputAttachments" ) != j.end() ) {
    p.maxDescriptorSetInputAttachments = j[ "maxDescriptorSetInputAttachments" ];
  }
  if( j.find( "maxVertexInputAttributes" ) != j.end() ) {
    p.maxVertexInputAttributes = j[ "maxVertexInputAttributes" ];
  }
  if( j.find( "maxVertexInputBindings" ) != j.end() ) {
    p.maxVertexInputBindings = j[ "maxVertexInputBindings" ];
  }
  if( j.find( "maxVertexInputAttributeOffset" ) != j.end() ) {
    p.maxVertexInputAttributeOffset = j[ "maxVertexInputAttributeOffset" ];
  }
  if( j.find( "maxVertexInputBindingStride" ) != j.end() ) {
    p.maxVertexInputBindingStride = j[ "maxVertexInputBindingStride" ];
  }
  if( j.find( "maxVertexOutputComponents" ) != j.end() ) {
    p.maxVertexOutputComponents = j[ "maxVertexOutputComponents" ];
  }
  if( j.find( "maxTessellationGenerationLevel" ) != j.end() ) {
    p.maxTessellationGenerationLevel = j[ "maxTessellationGenerationLevel" ];
  }
  if( j.find( "maxTessellationPatchSize" ) != j.end() ) {
    p.maxTessellationPatchSize = j[ "maxTessellationPatchSize" ];
  }
  if( j.find( "maxTessellationControlPerVertexInputComponents" ) != j.end() ) {
    p.maxTessellationControlPerVertexInputComponents = j[ "maxTessellationControlPerVertexInputComponents" ];
  }
  if( j.find( "maxTessellationControlPerVertexOutputComponents" ) != j.end() ) {
    p.maxTessellationControlPerVertexOutputComponents = j[ "maxTessellationControlPerVertexOutputComponents" ];
  }
  if( j.find( "maxTessellationControlPerPatchOutputComponents" ) != j.end() ) {
    p.maxTessellationControlPerPatchOutputComponents = j[ "maxTessellationControlPerPatchOutputComponents" ];
  }
  if( j.find( "maxTessellationControlTotalOutputComponents" ) != j.end() ) {
    p.maxTessellationControlTotalOutputComponents = j[ "maxTessellationControlTotalOutputComponents" ];
  }
  if( j.find( "maxTessellationEvaluationInputComponents" ) != j.end() ) {
    p.maxTessellationEvaluationInputComponents = j[ "maxTessellationEvaluationInputComponents" ];
  }
  if( j.find( "maxTessellationEvaluationOutputComponents" ) != j.end() ) {
    p.maxTessellationEvaluationOutputComponents = j[ "maxTessellationEvaluationOutputComponents" ];
  }
  if( j.find( "maxGeometryShaderInvocations" ) != j.end() ) {
    p.maxGeometryShaderInvocations = j[ "maxGeometryShaderInvocations" ];
  }
  if( j.find( "maxGeometryInputComponents" ) != j.end() ) {
    p.maxGeometryInputComponents = j[ "maxGeometryInputComponents" ];
  }
  if( j.find( "maxGeometryOutputComponents" ) != j.end() ) {
    p.maxGeometryOutputComponents = j[ "maxGeometryOutputComponents" ];
  }
  if( j.find( "maxGeometryOutputVertices" ) != j.end() ) {
    p.maxGeometryOutputVertices = j[ "maxGeometryOutputVertices" ];
  }
  if( j.find( "maxGeometryTotalOutputComponents" ) != j.end() ) {
    p.maxGeometryTotalOutputComponents = j[ "maxGeometryTotalOutputComponents" ];
  }
  if( j.find( "maxFragmentInputComponents" ) != j.end() ) {
    p.maxFragmentInputComponents = j[ "maxFragmentInputComponents" ];
  }
  if( j.find( "maxFragmentOutputAttachments" ) != j.end() ) {
    p.maxFragmentOutputAttachments = j[ "maxFragmentOutputAttachments" ];
  }
  if( j.find( "maxFragmentDualSrcAttachments" ) != j.end() ) {
    p.maxFragmentDualSrcAttachments = j[ "maxFragmentDualSrcAttachments" ];
  }
  if( j.find( "maxFragmentCombinedOutputResources" ) != j.end() ) {
    p.maxFragmentCombinedOutputResources = j[ "maxFragmentCombinedOutputResources" ];
  }
  if( j.find( "maxComputeSharedMemorySize" ) != j.end() ) {
    p.maxComputeSharedMemorySize = j[ "maxComputeSharedMemorySize" ];
  }
  if( j.find( "maxComputeWorkGroupCount" ) != j.end() ) {
    if( !j[ "maxComputeWorkGroupCount" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceLimits.maxComputeWorkGroupCount" );
    if( !j[ "maxComputeWorkGroupCount" ].size() > p.maxComputeWorkGroupCount.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceLimits.maxComputeWorkGroupCount" );
    std::fill( p.maxComputeWorkGroupCount.begin(), p.maxComputeWorkGroupCount.end(), 0 );
    std::copy( j[ "maxComputeWorkGroupCount" ].begin(), j[ "maxComputeWorkGroupCount" ].end(), p.maxComputeWorkGroupCount.begin() );
  }
  if( j.find( "maxComputeWorkGroupInvocations" ) != j.end() ) {
    p.maxComputeWorkGroupInvocations = j[ "maxComputeWorkGroupInvocations" ];
  }
  if( j.find( "maxComputeWorkGroupSize" ) != j.end() ) {
    if( !j[ "maxComputeWorkGroupSize" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceLimits.maxComputeWorkGroupSize" );
    if( !j[ "maxComputeWorkGroupSize" ].size() > p.maxComputeWorkGroupSize.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceLimits.maxComputeWorkGroupSize" );
    std::fill( p.maxComputeWorkGroupSize.begin(), p.maxComputeWorkGroupSize.end(), 0 );
    std::copy( j[ "maxComputeWorkGroupSize" ].begin(), j[ "maxComputeWorkGroupSize" ].end(), p.maxComputeWorkGroupSize.begin() );
  }
  if( j.find( "subPixelPrecisionBits" ) != j.end() ) {
    p.subPixelPrecisionBits = j[ "subPixelPrecisionBits" ];
  }
  if( j.find( "subTexelPrecisionBits" ) != j.end() ) {
    p.subTexelPrecisionBits = j[ "subTexelPrecisionBits" ];
  }
  if( j.find( "mipmapPrecisionBits" ) != j.end() ) {
    p.mipmapPrecisionBits = j[ "mipmapPrecisionBits" ];
  }
  if( j.find( "maxDrawIndexedIndexValue" ) != j.end() ) {
    p.maxDrawIndexedIndexValue = j[ "maxDrawIndexedIndexValue" ];
  }
  if( j.find( "maxDrawIndirectCount" ) != j.end() ) {
    p.maxDrawIndirectCount = j[ "maxDrawIndirectCount" ];
  }
  if( j.find( "maxSamplerLodBias" ) != j.end() ) {
    p.maxSamplerLodBias = j[ "maxSamplerLodBias" ];
  }
  if( j.find( "maxSamplerAnisotropy" ) != j.end() ) {
    p.maxSamplerAnisotropy = j[ "maxSamplerAnisotropy" ];
  }
  if( j.find( "maxViewports" ) != j.end() ) {
    p.maxViewports = j[ "maxViewports" ];
  }
  if( j.find( "maxViewportDimensions" ) != j.end() ) {
    if( !j[ "maxViewportDimensions" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceLimits.maxViewportDimensions" );
    if( !j[ "maxViewportDimensions" ].size() > p.maxViewportDimensions.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceLimits.maxViewportDimensions" );
    std::fill( p.maxViewportDimensions.begin(), p.maxViewportDimensions.end(), 0 );
    std::copy( j[ "maxViewportDimensions" ].begin(), j[ "maxViewportDimensions" ].end(), p.maxViewportDimensions.begin() );
  }
  if( j.find( "viewportBoundsRange" ) != j.end() ) {
    if( !j[ "viewportBoundsRange" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceLimits.viewportBoundsRange" );
    if( !j[ "viewportBoundsRange" ].size() > p.viewportBoundsRange.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceLimits.viewportBoundsRange" );
    std::fill( p.viewportBoundsRange.begin(), p.viewportBoundsRange.end(), 0 );
    std::copy( j[ "viewportBoundsRange" ].begin(), j[ "viewportBoundsRange" ].end(), p.viewportBoundsRange.begin() );
  }
  if( j.find( "viewportSubPixelBits" ) != j.end() ) {
    p.viewportSubPixelBits = j[ "viewportSubPixelBits" ];
  }
  if( j.find( "minMemoryMapAlignment" ) != j.end() ) {
    p.minMemoryMapAlignment = j[ "minMemoryMapAlignment" ];
  }
  if( j.find( "minTexelBufferOffsetAlignment" ) != j.end() ) {
    p.minTexelBufferOffsetAlignment = j[ "minTexelBufferOffsetAlignment" ];
  }
  if( j.find( "minUniformBufferOffsetAlignment" ) != j.end() ) {
    p.minUniformBufferOffsetAlignment = j[ "minUniformBufferOffsetAlignment" ];
  }
  if( j.find( "minStorageBufferOffsetAlignment" ) != j.end() ) {
    p.minStorageBufferOffsetAlignment = j[ "minStorageBufferOffsetAlignment" ];
  }
  if( j.find( "minTexelOffset" ) != j.end() ) {
    p.minTexelOffset = j[ "minTexelOffset" ];
  }
  if( j.find( "maxTexelOffset" ) != j.end() ) {
    p.maxTexelOffset = j[ "maxTexelOffset" ];
  }
  if( j.find( "minTexelGatherOffset" ) != j.end() ) {
    p.minTexelGatherOffset = j[ "minTexelGatherOffset" ];
  }
  if( j.find( "maxTexelGatherOffset" ) != j.end() ) {
    p.maxTexelGatherOffset = j[ "maxTexelGatherOffset" ];
  }
  if( j.find( "minInterpolationOffset" ) != j.end() ) {
    p.minInterpolationOffset = j[ "minInterpolationOffset" ];
  }
  if( j.find( "maxInterpolationOffset" ) != j.end() ) {
    p.maxInterpolationOffset = j[ "maxInterpolationOffset" ];
  }
  if( j.find( "subPixelInterpolationOffsetBits" ) != j.end() ) {
    p.subPixelInterpolationOffsetBits = j[ "subPixelInterpolationOffsetBits" ];
  }
  if( j.find( "maxFramebufferWidth" ) != j.end() ) {
    p.maxFramebufferWidth = j[ "maxFramebufferWidth" ];
  }
  if( j.find( "maxFramebufferHeight" ) != j.end() ) {
    p.maxFramebufferHeight = j[ "maxFramebufferHeight" ];
  }
  if( j.find( "maxFramebufferLayers" ) != j.end() ) {
    p.maxFramebufferLayers = j[ "maxFramebufferLayers" ];
  }
  if( j.find( "framebufferColorSampleCounts" ) != j.end() ) {
    p.framebufferColorSampleCounts = SampleCountFlags ( j[ "framebufferColorSampleCounts" ] );
  }
  if( j.find( "framebufferDepthSampleCounts" ) != j.end() ) {
    p.framebufferDepthSampleCounts = SampleCountFlags ( j[ "framebufferDepthSampleCounts" ] );
  }
  if( j.find( "framebufferStencilSampleCounts" ) != j.end() ) {
    p.framebufferStencilSampleCounts = SampleCountFlags ( j[ "framebufferStencilSampleCounts" ] );
  }
  if( j.find( "framebufferNoAttachmentsSampleCounts" ) != j.end() ) {
    p.framebufferNoAttachmentsSampleCounts = SampleCountFlags ( j[ "framebufferNoAttachmentsSampleCounts" ] );
  }
  if( j.find( "maxColorAttachments" ) != j.end() ) {
    p.maxColorAttachments = j[ "maxColorAttachments" ];
  }
  if( j.find( "sampledImageColorSampleCounts" ) != j.end() ) {
    p.sampledImageColorSampleCounts = SampleCountFlags ( j[ "sampledImageColorSampleCounts" ] );
  }
  if( j.find( "sampledImageIntegerSampleCounts" ) != j.end() ) {
    p.sampledImageIntegerSampleCounts = SampleCountFlags ( j[ "sampledImageIntegerSampleCounts" ] );
  }
  if( j.find( "sampledImageDepthSampleCounts" ) != j.end() ) {
    p.sampledImageDepthSampleCounts = SampleCountFlags ( j[ "sampledImageDepthSampleCounts" ] );
  }
  if( j.find( "sampledImageStencilSampleCounts" ) != j.end() ) {
    p.sampledImageStencilSampleCounts = SampleCountFlags ( j[ "sampledImageStencilSampleCounts" ] );
  }
  if( j.find( "storageImageSampleCounts" ) != j.end() ) {
    p.storageImageSampleCounts = SampleCountFlags ( j[ "storageImageSampleCounts" ] );
  }
  if( j.find( "maxSampleMaskWords" ) != j.end() ) {
    p.maxSampleMaskWords = j[ "maxSampleMaskWords" ];
  }
  if( j.find( "timestampComputeAndGraphics" ) != j.end() ) {
    p.timestampComputeAndGraphics = j[ "timestampComputeAndGraphics" ];
  }
  if( j.find( "timestampPeriod" ) != j.end() ) {
    p.timestampPeriod = j[ "timestampPeriod" ];
  }
  if( j.find( "maxClipDistances" ) != j.end() ) {
    p.maxClipDistances = j[ "maxClipDistances" ];
  }
  if( j.find( "maxCullDistances" ) != j.end() ) {
    p.maxCullDistances = j[ "maxCullDistances" ];
  }
  if( j.find( "maxCombinedClipAndCullDistances" ) != j.end() ) {
    p.maxCombinedClipAndCullDistances = j[ "maxCombinedClipAndCullDistances" ];
  }
  if( j.find( "discreteQueuePriorities" ) != j.end() ) {
    p.discreteQueuePriorities = j[ "discreteQueuePriorities" ];
  }
  if( j.find( "pointSizeRange" ) != j.end() ) {
    if( !j[ "pointSizeRange" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceLimits.pointSizeRange" );
    if( !j[ "pointSizeRange" ].size() > p.pointSizeRange.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceLimits.pointSizeRange" );
    std::fill( p.pointSizeRange.begin(), p.pointSizeRange.end(), 0 );
    std::copy( j[ "pointSizeRange" ].begin(), j[ "pointSizeRange" ].end(), p.pointSizeRange.begin() );
  }
  if( j.find( "lineWidthRange" ) != j.end() ) {
    if( !j[ "lineWidthRange" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceLimits.lineWidthRange" );
    if( !j[ "lineWidthRange" ].size() > p.lineWidthRange.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceLimits.lineWidthRange" );
    std::fill( p.lineWidthRange.begin(), p.lineWidthRange.end(), 0 );
    std::copy( j[ "lineWidthRange" ].begin(), j[ "lineWidthRange" ].end(), p.lineWidthRange.begin() );
  }
  if( j.find( "pointSizeGranularity" ) != j.end() ) {
    p.pointSizeGranularity = j[ "pointSizeGranularity" ];
  }
  if( j.find( "lineWidthGranularity" ) != j.end() ) {
    p.lineWidthGranularity = j[ "lineWidthGranularity" ];
  }
  if( j.find( "strictLines" ) != j.end() ) {
    p.strictLines = j[ "strictLines" ];
  }
  if( j.find( "standardSampleLocations" ) != j.end() ) {
    p.standardSampleLocations = j[ "standardSampleLocations" ];
  }
  if( j.find( "optimalBufferCopyOffsetAlignment" ) != j.end() ) {
    p.optimalBufferCopyOffsetAlignment = j[ "optimalBufferCopyOffsetAlignment" ];
  }
  if( j.find( "optimalBufferCopyRowPitchAlignment" ) != j.end() ) {
    p.optimalBufferCopyRowPitchAlignment = j[ "optimalBufferCopyRowPitchAlignment" ];
  }
  if( j.find( "nonCoherentAtomSize" ) != j.end() ) {
    p.nonCoherentAtomSize = j[ "nonCoherentAtomSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceLimits &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceLimits temp;
  from_json( j, temp );
  p = VkPhysicalDeviceLimits ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceLineRasterizationFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "rectangularLines" ] = bool( p.rectangularLines );
  j[ "bresenhamLines" ] = bool( p.bresenhamLines );
  j[ "smoothLines" ] = bool( p.smoothLines );
  j[ "stippledRectangularLines" ] = bool( p.stippledRectangularLines );
  j[ "stippledBresenhamLines" ] = bool( p.stippledBresenhamLines );
  j[ "stippledSmoothLines" ] = bool( p.stippledSmoothLines );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceLineRasterizationFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceLineRasterizationFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceLineRasterizationFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceLineRasterizationFeaturesEXT" );
  if( j.find( "rectangularLines" ) != j.end() ) {
    p.rectangularLines = j[ "rectangularLines" ];
  }
  if( j.find( "bresenhamLines" ) != j.end() ) {
    p.bresenhamLines = j[ "bresenhamLines" ];
  }
  if( j.find( "smoothLines" ) != j.end() ) {
    p.smoothLines = j[ "smoothLines" ];
  }
  if( j.find( "stippledRectangularLines" ) != j.end() ) {
    p.stippledRectangularLines = j[ "stippledRectangularLines" ];
  }
  if( j.find( "stippledBresenhamLines" ) != j.end() ) {
    p.stippledBresenhamLines = j[ "stippledBresenhamLines" ];
  }
  if( j.find( "stippledSmoothLines" ) != j.end() ) {
    p.stippledSmoothLines = j[ "stippledSmoothLines" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceLineRasterizationFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceLineRasterizationFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceLineRasterizationFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceLineRasterizationPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "lineSubPixelPrecisionBits" ] = p.lineSubPixelPrecisionBits;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceLineRasterizationPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceLineRasterizationPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceLineRasterizationPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceLineRasterizationPropertiesEXT" );
  if( j.find( "lineSubPixelPrecisionBits" ) != j.end() ) {
    p.lineSubPixelPrecisionBits = j[ "lineSubPixelPrecisionBits" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceLineRasterizationPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceLineRasterizationPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceLineRasterizationPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceMaintenance3Properties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxPerSetDescriptors" ] = p.maxPerSetDescriptors;
  j[ "maxMemoryAllocationSize" ] = p.maxMemoryAllocationSize;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceMaintenance3Properties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceMaintenance3Properties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceMaintenance3Properties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMaintenance3Properties" );
  if( j.find( "maxPerSetDescriptors" ) != j.end() ) {
    p.maxPerSetDescriptors = j[ "maxPerSetDescriptors" ];
  }
  if( j.find( "maxMemoryAllocationSize" ) != j.end() ) {
    p.maxMemoryAllocationSize = j[ "maxMemoryAllocationSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceMaintenance3Properties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceMaintenance3Properties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMaintenance3Properties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceMemoryBudgetPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "heapBudget" ] = nlohmann::json::array();
  std::copy( p.heapBudget.begin(), p.heapBudget.end(), std::back_inserter( j[ "heapBudget" ] ) );
  j[ "heapUsage" ] = nlohmann::json::array();
  std::copy( p.heapUsage.begin(), p.heapUsage.end(), std::back_inserter( j[ "heapUsage" ] ) );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceMemoryBudgetPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceMemoryBudgetPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceMemoryBudgetPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMemoryBudgetPropertiesEXT" );
  if( j.find( "heapBudget" ) != j.end() ) {
    if( !j[ "heapBudget" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceMemoryBudgetPropertiesEXT.heapBudget" );
    if( !j[ "heapBudget" ].size() > p.heapBudget.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceMemoryBudgetPropertiesEXT.heapBudget" );
    std::fill( p.heapBudget.begin(), p.heapBudget.end(), 0 );
    std::copy( j[ "heapBudget" ].begin(), j[ "heapBudget" ].end(), p.heapBudget.begin() );
  }
  if( j.find( "heapUsage" ) != j.end() ) {
    if( !j[ "heapUsage" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceMemoryBudgetPropertiesEXT.heapUsage" );
    if( !j[ "heapUsage" ].size() > p.heapUsage.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceMemoryBudgetPropertiesEXT.heapUsage" );
    std::fill( p.heapUsage.begin(), p.heapUsage.end(), 0 );
    std::copy( j[ "heapUsage" ].begin(), j[ "heapUsage" ].end(), p.heapUsage.begin() );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceMemoryBudgetPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceMemoryBudgetPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMemoryBudgetPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceMemoryPriorityFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryPriority" ] = bool( p.memoryPriority );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceMemoryPriorityFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceMemoryPriorityFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceMemoryPriorityFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMemoryPriorityFeaturesEXT" );
  if( j.find( "memoryPriority" ) != j.end() ) {
    p.memoryPriority = j[ "memoryPriority" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceMemoryPriorityFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceMemoryPriorityFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMemoryPriorityFeaturesEXT ( temp );
}
#include <vulkan2json/MemoryType.hpp>
#include <vulkan2json/MemoryHeap.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceMemoryProperties &p ) {
  j = nlohmann::json::object();
  j[ "memoryTypeCount" ] = p.memoryTypeCount;
  j[ "memoryTypes" ] = nlohmann::json::array();
  std::copy( p.memoryTypes.begin(), p.memoryTypes.end(), std::back_inserter( j[ "memoryTypes" ] ) );
  j[ "memoryHeapCount" ] = p.memoryHeapCount;
  j[ "memoryHeaps" ] = nlohmann::json::array();
  std::copy( p.memoryHeaps.begin(), p.memoryHeaps.end(), std::back_inserter( j[ "memoryHeaps" ] ) );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceMemoryProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceMemoryProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceMemoryProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMemoryProperties" );
  if( j.find( "memoryTypeCount" ) != j.end() ) {
    p.memoryTypeCount = j[ "memoryTypeCount" ];
  }
  if( j.find( "memoryTypes" ) != j.end() ) {
    if( !j[ "memoryTypes" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceMemoryProperties.memoryTypes" );
    if( !j[ "memoryTypes" ].size() > p.memoryTypes.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for PhysicalDeviceMemoryProperties.memoryTypes" );
    std::fill( p.memoryTypes.begin(), p.memoryTypes.end(), MemoryType () );
    std::transform( j[ "memoryTypes" ].begin(), j[ "memoryTypes" ].end(), p.memoryTypes.begin(), []( const auto &v ) { return MemoryType ( v ); } );
  }
  if( j.find( "memoryHeapCount" ) != j.end() ) {
    p.memoryHeapCount = j[ "memoryHeapCount" ];
  }
  if( j.find( "memoryHeaps" ) != j.end() ) {
    if( !j[ "memoryHeaps" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceMemoryProperties.memoryHeaps" );
    if( !j[ "memoryHeaps" ].size() > p.memoryHeaps.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for PhysicalDeviceMemoryProperties.memoryHeaps" );
    std::fill( p.memoryHeaps.begin(), p.memoryHeaps.end(), MemoryHeap () );
    std::transform( j[ "memoryHeaps" ].begin(), j[ "memoryHeaps" ].end(), p.memoryHeaps.begin(), []( const auto &v ) { return MemoryHeap ( v ); } );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceMemoryProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceMemoryProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMemoryProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PhysicalDeviceMemoryProperties.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceMemoryProperties2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryProperties" ] = p.memoryProperties;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceMemoryProperties2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceMemoryProperties2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceMemoryProperties2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMemoryProperties2" );
  if( j.find( "memoryProperties" ) != j.end() ) {
    p.memoryProperties = PhysicalDeviceMemoryProperties ( j[ "memoryProperties" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceMemoryProperties2 &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceMemoryProperties2 temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMemoryProperties2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceMeshShaderFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "taskShader" ] = bool( p.taskShader );
  j[ "meshShader" ] = bool( p.meshShader );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceMeshShaderFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceMeshShaderFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceMeshShaderFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMeshShaderFeaturesNV" );
  if( j.find( "taskShader" ) != j.end() ) {
    p.taskShader = j[ "taskShader" ];
  }
  if( j.find( "meshShader" ) != j.end() ) {
    p.meshShader = j[ "meshShader" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceMeshShaderFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceMeshShaderFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMeshShaderFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceMeshShaderPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxDrawMeshTasksCount" ] = p.maxDrawMeshTasksCount;
  j[ "maxTaskWorkGroupInvocations" ] = p.maxTaskWorkGroupInvocations;
  j[ "maxTaskWorkGroupSize" ] = nlohmann::json::array();
  std::copy( p.maxTaskWorkGroupSize.begin(), p.maxTaskWorkGroupSize.end(), std::back_inserter( j[ "maxTaskWorkGroupSize" ] ) );
  j[ "maxTaskTotalMemorySize" ] = p.maxTaskTotalMemorySize;
  j[ "maxTaskOutputCount" ] = p.maxTaskOutputCount;
  j[ "maxMeshWorkGroupInvocations" ] = p.maxMeshWorkGroupInvocations;
  j[ "maxMeshWorkGroupSize" ] = nlohmann::json::array();
  std::copy( p.maxMeshWorkGroupSize.begin(), p.maxMeshWorkGroupSize.end(), std::back_inserter( j[ "maxMeshWorkGroupSize" ] ) );
  j[ "maxMeshTotalMemorySize" ] = p.maxMeshTotalMemorySize;
  j[ "maxMeshOutputVertices" ] = p.maxMeshOutputVertices;
  j[ "maxMeshOutputPrimitives" ] = p.maxMeshOutputPrimitives;
  j[ "maxMeshMultiviewViewCount" ] = p.maxMeshMultiviewViewCount;
  j[ "meshOutputPerVertexGranularity" ] = p.meshOutputPerVertexGranularity;
  j[ "meshOutputPerPrimitiveGranularity" ] = p.meshOutputPerPrimitiveGranularity;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceMeshShaderPropertiesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceMeshShaderPropertiesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceMeshShaderPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMeshShaderPropertiesNV" );
  if( j.find( "maxDrawMeshTasksCount" ) != j.end() ) {
    p.maxDrawMeshTasksCount = j[ "maxDrawMeshTasksCount" ];
  }
  if( j.find( "maxTaskWorkGroupInvocations" ) != j.end() ) {
    p.maxTaskWorkGroupInvocations = j[ "maxTaskWorkGroupInvocations" ];
  }
  if( j.find( "maxTaskWorkGroupSize" ) != j.end() ) {
    if( !j[ "maxTaskWorkGroupSize" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceMeshShaderPropertiesNV.maxTaskWorkGroupSize" );
    if( !j[ "maxTaskWorkGroupSize" ].size() > p.maxTaskWorkGroupSize.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceMeshShaderPropertiesNV.maxTaskWorkGroupSize" );
    std::fill( p.maxTaskWorkGroupSize.begin(), p.maxTaskWorkGroupSize.end(), 0 );
    std::copy( j[ "maxTaskWorkGroupSize" ].begin(), j[ "maxTaskWorkGroupSize" ].end(), p.maxTaskWorkGroupSize.begin() );
  }
  if( j.find( "maxTaskTotalMemorySize" ) != j.end() ) {
    p.maxTaskTotalMemorySize = j[ "maxTaskTotalMemorySize" ];
  }
  if( j.find( "maxTaskOutputCount" ) != j.end() ) {
    p.maxTaskOutputCount = j[ "maxTaskOutputCount" ];
  }
  if( j.find( "maxMeshWorkGroupInvocations" ) != j.end() ) {
    p.maxMeshWorkGroupInvocations = j[ "maxMeshWorkGroupInvocations" ];
  }
  if( j.find( "maxMeshWorkGroupSize" ) != j.end() ) {
    if( !j[ "maxMeshWorkGroupSize" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceMeshShaderPropertiesNV.maxMeshWorkGroupSize" );
    if( !j[ "maxMeshWorkGroupSize" ].size() > p.maxMeshWorkGroupSize.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceMeshShaderPropertiesNV.maxMeshWorkGroupSize" );
    std::fill( p.maxMeshWorkGroupSize.begin(), p.maxMeshWorkGroupSize.end(), 0 );
    std::copy( j[ "maxMeshWorkGroupSize" ].begin(), j[ "maxMeshWorkGroupSize" ].end(), p.maxMeshWorkGroupSize.begin() );
  }
  if( j.find( "maxMeshTotalMemorySize" ) != j.end() ) {
    p.maxMeshTotalMemorySize = j[ "maxMeshTotalMemorySize" ];
  }
  if( j.find( "maxMeshOutputVertices" ) != j.end() ) {
    p.maxMeshOutputVertices = j[ "maxMeshOutputVertices" ];
  }
  if( j.find( "maxMeshOutputPrimitives" ) != j.end() ) {
    p.maxMeshOutputPrimitives = j[ "maxMeshOutputPrimitives" ];
  }
  if( j.find( "maxMeshMultiviewViewCount" ) != j.end() ) {
    p.maxMeshMultiviewViewCount = j[ "maxMeshMultiviewViewCount" ];
  }
  if( j.find( "meshOutputPerVertexGranularity" ) != j.end() ) {
    p.meshOutputPerVertexGranularity = j[ "meshOutputPerVertexGranularity" ];
  }
  if( j.find( "meshOutputPerPrimitiveGranularity" ) != j.end() ) {
    p.meshOutputPerPrimitiveGranularity = j[ "meshOutputPerPrimitiveGranularity" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceMeshShaderPropertiesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceMeshShaderPropertiesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMeshShaderPropertiesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceMultiDrawFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "multiDraw" ] = bool( p.multiDraw );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceMultiDrawFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceMultiDrawFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceMultiDrawFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMultiDrawFeaturesEXT" );
  if( j.find( "multiDraw" ) != j.end() ) {
    p.multiDraw = j[ "multiDraw" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceMultiDrawFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceMultiDrawFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMultiDrawFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceMultiDrawPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxMultiDrawCount" ] = p.maxMultiDrawCount;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceMultiDrawPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceMultiDrawPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceMultiDrawPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMultiDrawPropertiesEXT" );
  if( j.find( "maxMultiDrawCount" ) != j.end() ) {
    p.maxMultiDrawCount = j[ "maxMultiDrawCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceMultiDrawPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceMultiDrawPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMultiDrawPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceMultiviewFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "multiview" ] = bool( p.multiview );
  j[ "multiviewGeometryShader" ] = bool( p.multiviewGeometryShader );
  j[ "multiviewTessellationShader" ] = bool( p.multiviewTessellationShader );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceMultiviewFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceMultiviewFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceMultiviewFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMultiviewFeatures" );
  if( j.find( "multiview" ) != j.end() ) {
    p.multiview = j[ "multiview" ];
  }
  if( j.find( "multiviewGeometryShader" ) != j.end() ) {
    p.multiviewGeometryShader = j[ "multiviewGeometryShader" ];
  }
  if( j.find( "multiviewTessellationShader" ) != j.end() ) {
    p.multiviewTessellationShader = j[ "multiviewTessellationShader" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceMultiviewFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceMultiviewFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMultiviewFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "perViewPositionAllComponents" ] = bool( p.perViewPositionAllComponents );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX" );
  if( j.find( "perViewPositionAllComponents" ) != j.end() ) {
    p.perViewPositionAllComponents = j[ "perViewPositionAllComponents" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceMultiviewProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxMultiviewViewCount" ] = p.maxMultiviewViewCount;
  j[ "maxMultiviewInstanceIndex" ] = p.maxMultiviewInstanceIndex;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceMultiviewProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceMultiviewProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceMultiviewProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMultiviewProperties" );
  if( j.find( "maxMultiviewViewCount" ) != j.end() ) {
    p.maxMultiviewViewCount = j[ "maxMultiviewViewCount" ];
  }
  if( j.find( "maxMultiviewInstanceIndex" ) != j.end() ) {
    p.maxMultiviewInstanceIndex = j[ "maxMultiviewInstanceIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceMultiviewProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceMultiviewProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMultiviewProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceMutableDescriptorTypeFeaturesVALVE &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "mutableDescriptorType" ] = bool( p.mutableDescriptorType );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceMutableDescriptorTypeFeaturesVALVE ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceMutableDescriptorTypeFeaturesVALVE &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE" );
  if( j.find( "mutableDescriptorType" ) != j.end() ) {
    p.mutableDescriptorType = j[ "mutableDescriptorType" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceMutableDescriptorTypeFeaturesVALVE temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDevicePCIBusInfoPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pciDomain" ] = p.pciDomain;
  j[ "pciBus" ] = p.pciBus;
  j[ "pciDevice" ] = p.pciDevice;
  j[ "pciFunction" ] = p.pciFunction;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDevicePCIBusInfoPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDevicePCIBusInfoPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDevicePCIBusInfoPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePCIBusInfoPropertiesEXT" );
  if( j.find( "pciDomain" ) != j.end() ) {
    p.pciDomain = j[ "pciDomain" ];
  }
  if( j.find( "pciBus" ) != j.end() ) {
    p.pciBus = j[ "pciBus" ];
  }
  if( j.find( "pciDevice" ) != j.end() ) {
    p.pciDevice = j[ "pciDevice" ];
  }
  if( j.find( "pciFunction" ) != j.end() ) {
    p.pciFunction = j[ "pciFunction" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDevicePCIBusInfoPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDevicePCIBusInfoPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDevicePCIBusInfoPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDevicePerformanceQueryFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "performanceCounterQueryPools" ] = bool( p.performanceCounterQueryPools );
  j[ "performanceCounterMultipleQueryPools" ] = bool( p.performanceCounterMultipleQueryPools );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDevicePerformanceQueryFeaturesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDevicePerformanceQueryFeaturesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDevicePerformanceQueryFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePerformanceQueryFeaturesKHR" );
  if( j.find( "performanceCounterQueryPools" ) != j.end() ) {
    p.performanceCounterQueryPools = j[ "performanceCounterQueryPools" ];
  }
  if( j.find( "performanceCounterMultipleQueryPools" ) != j.end() ) {
    p.performanceCounterMultipleQueryPools = j[ "performanceCounterMultipleQueryPools" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDevicePerformanceQueryFeaturesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDevicePerformanceQueryFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDevicePerformanceQueryFeaturesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDevicePerformanceQueryPropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "allowCommandBufferQueryCopies" ] = bool( p.allowCommandBufferQueryCopies );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDevicePerformanceQueryPropertiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDevicePerformanceQueryPropertiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDevicePerformanceQueryPropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePerformanceQueryPropertiesKHR" );
  if( j.find( "allowCommandBufferQueryCopies" ) != j.end() ) {
    p.allowCommandBufferQueryCopies = j[ "allowCommandBufferQueryCopies" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDevicePerformanceQueryPropertiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDevicePerformanceQueryPropertiesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDevicePerformanceQueryPropertiesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDevicePipelineCreationCacheControlFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pipelineCreationCacheControl" ] = bool( p.pipelineCreationCacheControl );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDevicePipelineCreationCacheControlFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDevicePipelineCreationCacheControlFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePipelineCreationCacheControlFeaturesEXT" );
  if( j.find( "pipelineCreationCacheControl" ) != j.end() ) {
    p.pipelineCreationCacheControl = j[ "pipelineCreationCacheControl" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDevicePipelineCreationCacheControlFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDevicePipelineExecutablePropertiesFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pipelineExecutableInfo" ] = bool( p.pipelineExecutableInfo );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDevicePipelineExecutablePropertiesFeaturesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDevicePipelineExecutablePropertiesFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR" );
  if( j.find( "pipelineExecutableInfo" ) != j.end() ) {
    p.pipelineExecutableInfo = j[ "pipelineExecutableInfo" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDevicePipelineExecutablePropertiesFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PointClippingBehavior.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDevicePointClippingProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pointClippingBehavior" ] = p.pointClippingBehavior;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDevicePointClippingProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDevicePointClippingProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDevicePointClippingProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePointClippingProperties" );
  if( j.find( "pointClippingBehavior" ) != j.end() ) {
    p.pointClippingBehavior = PointClippingBehavior ( j[ "pointClippingBehavior" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDevicePointClippingProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDevicePointClippingProperties temp;
  from_json( j, temp );
  p = VkPhysicalDevicePointClippingProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDevicePrivateDataFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "privateData" ] = bool( p.privateData );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDevicePrivateDataFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDevicePrivateDataFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDevicePrivateDataFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePrivateDataFeaturesEXT" );
  if( j.find( "privateData" ) != j.end() ) {
    p.privateData = j[ "privateData" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDevicePrivateDataFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDevicePrivateDataFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDevicePrivateDataFeaturesEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceSparseProperties &p ) {
  j = nlohmann::json::object();
  j[ "residencyStandard2DBlockShape" ] = bool( p.residencyStandard2DBlockShape );
  j[ "residencyStandard2DMultisampleBlockShape" ] = bool( p.residencyStandard2DMultisampleBlockShape );
  j[ "residencyStandard3DBlockShape" ] = bool( p.residencyStandard3DBlockShape );
  j[ "residencyAlignedMipSize" ] = bool( p.residencyAlignedMipSize );
  j[ "residencyNonResidentStrict" ] = bool( p.residencyNonResidentStrict );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceSparseProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceSparseProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceSparseProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSparseProperties" );
  if( j.find( "residencyStandard2DBlockShape" ) != j.end() ) {
    p.residencyStandard2DBlockShape = j[ "residencyStandard2DBlockShape" ];
  }
  if( j.find( "residencyStandard2DMultisampleBlockShape" ) != j.end() ) {
    p.residencyStandard2DMultisampleBlockShape = j[ "residencyStandard2DMultisampleBlockShape" ];
  }
  if( j.find( "residencyStandard3DBlockShape" ) != j.end() ) {
    p.residencyStandard3DBlockShape = j[ "residencyStandard3DBlockShape" ];
  }
  if( j.find( "residencyAlignedMipSize" ) != j.end() ) {
    p.residencyAlignedMipSize = j[ "residencyAlignedMipSize" ];
  }
  if( j.find( "residencyNonResidentStrict" ) != j.end() ) {
    p.residencyNonResidentStrict = j[ "residencyNonResidentStrict" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceSparseProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceSparseProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSparseProperties ( temp );
}
#include <vulkan2json/PhysicalDeviceType.hpp>
#include <vulkan2json/PhysicalDeviceLimits.hpp>
#include <vulkan2json/PhysicalDeviceSparseProperties.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceProperties &p ) {
  j = nlohmann::json::object();
  j[ "apiVersion" ] = p.apiVersion;
  j[ "driverVersion" ] = p.driverVersion;
  j[ "vendorID" ] = p.vendorID;
  j[ "deviceID" ] = p.deviceID;
  j[ "deviceType" ] = p.deviceType;
  j[ "deviceName" ] = std::string( p.deviceName.begin(), std::find( p.deviceName.begin(), p.deviceName.end(), '\0' ) );
  j[ "pipelineCacheUUID" ] = nlohmann::json::array();
  std::copy( p.pipelineCacheUUID.begin(), p.pipelineCacheUUID.end(), std::back_inserter( j[ "pipelineCacheUUID" ] ) );
  j[ "limits" ] = p.limits;
  j[ "sparseProperties" ] = p.sparseProperties;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceProperties" );
  if( j.find( "apiVersion" ) != j.end() ) {
    p.apiVersion = j[ "apiVersion" ];
  }
  if( j.find( "driverVersion" ) != j.end() ) {
    p.driverVersion = j[ "driverVersion" ];
  }
  if( j.find( "vendorID" ) != j.end() ) {
    p.vendorID = j[ "vendorID" ];
  }
  if( j.find( "deviceID" ) != j.end() ) {
    p.deviceID = j[ "deviceID" ];
  }
  if( j.find( "deviceType" ) != j.end() ) {
    p.deviceType = PhysicalDeviceType ( j[ "deviceType" ] );
  }
  if( j.find( "deviceName" ) != j.end() ) {
    {
      std::string s = j[ "deviceName" ];
      if( !p.deviceName.empty() ) {
        p.deviceName[ p.deviceName.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.deviceName.size() - 1u ) ), p.deviceName.begin() );
      }
    }
  }
  if( j.find( "pipelineCacheUUID" ) != j.end() ) {
    if( !j[ "pipelineCacheUUID" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceProperties.pipelineCacheUUID" );
    if( !j[ "pipelineCacheUUID" ].size() > p.pipelineCacheUUID.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceProperties.pipelineCacheUUID" );
    std::fill( p.pipelineCacheUUID.begin(), p.pipelineCacheUUID.end(), 0 );
    std::copy( j[ "pipelineCacheUUID" ].begin(), j[ "pipelineCacheUUID" ].end(), p.pipelineCacheUUID.begin() );
  }
  if( j.find( "limits" ) != j.end() ) {
    p.limits = PhysicalDeviceLimits ( j[ "limits" ] );
  }
  if( j.find( "sparseProperties" ) != j.end() ) {
    p.sparseProperties = PhysicalDeviceSparseProperties ( j[ "sparseProperties" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PhysicalDeviceProperties.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceProperties2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "properties" ] = p.properties;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceProperties2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceProperties2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceProperties2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceProperties2" );
  if( j.find( "properties" ) != j.end() ) {
    p.properties = PhysicalDeviceProperties ( j[ "properties" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceProperties2 &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceProperties2 temp;
  from_json( j, temp );
  p = VkPhysicalDeviceProperties2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceProtectedMemoryFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "protectedMemory" ] = bool( p.protectedMemory );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceProtectedMemoryFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceProtectedMemoryFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceProtectedMemoryFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceProtectedMemoryFeatures" );
  if( j.find( "protectedMemory" ) != j.end() ) {
    p.protectedMemory = j[ "protectedMemory" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceProtectedMemoryFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceProtectedMemoryFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceProtectedMemoryFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceProtectedMemoryProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "protectedNoFault" ] = bool( p.protectedNoFault );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceProtectedMemoryProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceProtectedMemoryProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceProtectedMemoryProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceProtectedMemoryProperties" );
  if( j.find( "protectedNoFault" ) != j.end() ) {
    p.protectedNoFault = j[ "protectedNoFault" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceProtectedMemoryProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceProtectedMemoryProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceProtectedMemoryProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceProvokingVertexFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "provokingVertexLast" ] = bool( p.provokingVertexLast );
  j[ "transformFeedbackPreservesProvokingVertex" ] = bool( p.transformFeedbackPreservesProvokingVertex );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceProvokingVertexFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceProvokingVertexFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceProvokingVertexFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceProvokingVertexFeaturesEXT" );
  if( j.find( "provokingVertexLast" ) != j.end() ) {
    p.provokingVertexLast = j[ "provokingVertexLast" ];
  }
  if( j.find( "transformFeedbackPreservesProvokingVertex" ) != j.end() ) {
    p.transformFeedbackPreservesProvokingVertex = j[ "transformFeedbackPreservesProvokingVertex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceProvokingVertexFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceProvokingVertexFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceProvokingVertexFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceProvokingVertexPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "provokingVertexModePerPipeline" ] = bool( p.provokingVertexModePerPipeline );
  j[ "transformFeedbackPreservesTriangleFanProvokingVertex" ] = bool( p.transformFeedbackPreservesTriangleFanProvokingVertex );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceProvokingVertexPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceProvokingVertexPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceProvokingVertexPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceProvokingVertexPropertiesEXT" );
  if( j.find( "provokingVertexModePerPipeline" ) != j.end() ) {
    p.provokingVertexModePerPipeline = j[ "provokingVertexModePerPipeline" ];
  }
  if( j.find( "transformFeedbackPreservesTriangleFanProvokingVertex" ) != j.end() ) {
    p.transformFeedbackPreservesTriangleFanProvokingVertex = j[ "transformFeedbackPreservesTriangleFanProvokingVertex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceProvokingVertexPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceProvokingVertexPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceProvokingVertexPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDevicePushDescriptorPropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxPushDescriptors" ] = p.maxPushDescriptors;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDevicePushDescriptorPropertiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDevicePushDescriptorPropertiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDevicePushDescriptorPropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePushDescriptorPropertiesKHR" );
  if( j.find( "maxPushDescriptors" ) != j.end() ) {
    p.maxPushDescriptors = j[ "maxPushDescriptors" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDevicePushDescriptorPropertiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDevicePushDescriptorPropertiesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDevicePushDescriptorPropertiesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceRayQueryFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "rayQuery" ] = bool( p.rayQuery );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceRayQueryFeaturesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceRayQueryFeaturesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceRayQueryFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRayQueryFeaturesKHR" );
  if( j.find( "rayQuery" ) != j.end() ) {
    p.rayQuery = j[ "rayQuery" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceRayQueryFeaturesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceRayQueryFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRayQueryFeaturesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceRayTracingMotionBlurFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "rayTracingMotionBlur" ] = bool( p.rayTracingMotionBlur );
  j[ "rayTracingMotionBlurPipelineTraceRaysIndirect" ] = bool( p.rayTracingMotionBlurPipelineTraceRaysIndirect );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceRayTracingMotionBlurFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceRayTracingMotionBlurFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRayTracingMotionBlurFeaturesNV" );
  if( j.find( "rayTracingMotionBlur" ) != j.end() ) {
    p.rayTracingMotionBlur = j[ "rayTracingMotionBlur" ];
  }
  if( j.find( "rayTracingMotionBlurPipelineTraceRaysIndirect" ) != j.end() ) {
    p.rayTracingMotionBlurPipelineTraceRaysIndirect = j[ "rayTracingMotionBlurPipelineTraceRaysIndirect" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceRayTracingMotionBlurFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceRayTracingMotionBlurFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRayTracingMotionBlurFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceRayTracingPipelineFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "rayTracingPipeline" ] = bool( p.rayTracingPipeline );
  j[ "rayTracingPipelineShaderGroupHandleCaptureReplay" ] = bool( p.rayTracingPipelineShaderGroupHandleCaptureReplay );
  j[ "rayTracingPipelineShaderGroupHandleCaptureReplayMixed" ] = bool( p.rayTracingPipelineShaderGroupHandleCaptureReplayMixed );
  j[ "rayTracingPipelineTraceRaysIndirect" ] = bool( p.rayTracingPipelineTraceRaysIndirect );
  j[ "rayTraversalPrimitiveCulling" ] = bool( p.rayTraversalPrimitiveCulling );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceRayTracingPipelineFeaturesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceRayTracingPipelineFeaturesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceRayTracingPipelineFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRayTracingPipelineFeaturesKHR" );
  if( j.find( "rayTracingPipeline" ) != j.end() ) {
    p.rayTracingPipeline = j[ "rayTracingPipeline" ];
  }
  if( j.find( "rayTracingPipelineShaderGroupHandleCaptureReplay" ) != j.end() ) {
    p.rayTracingPipelineShaderGroupHandleCaptureReplay = j[ "rayTracingPipelineShaderGroupHandleCaptureReplay" ];
  }
  if( j.find( "rayTracingPipelineShaderGroupHandleCaptureReplayMixed" ) != j.end() ) {
    p.rayTracingPipelineShaderGroupHandleCaptureReplayMixed = j[ "rayTracingPipelineShaderGroupHandleCaptureReplayMixed" ];
  }
  if( j.find( "rayTracingPipelineTraceRaysIndirect" ) != j.end() ) {
    p.rayTracingPipelineTraceRaysIndirect = j[ "rayTracingPipelineTraceRaysIndirect" ];
  }
  if( j.find( "rayTraversalPrimitiveCulling" ) != j.end() ) {
    p.rayTraversalPrimitiveCulling = j[ "rayTraversalPrimitiveCulling" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceRayTracingPipelineFeaturesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceRayTracingPipelineFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRayTracingPipelineFeaturesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceRayTracingPipelinePropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderGroupHandleSize" ] = p.shaderGroupHandleSize;
  j[ "maxRayRecursionDepth" ] = p.maxRayRecursionDepth;
  j[ "maxShaderGroupStride" ] = p.maxShaderGroupStride;
  j[ "shaderGroupBaseAlignment" ] = p.shaderGroupBaseAlignment;
  j[ "shaderGroupHandleCaptureReplaySize" ] = p.shaderGroupHandleCaptureReplaySize;
  j[ "maxRayDispatchInvocationCount" ] = p.maxRayDispatchInvocationCount;
  j[ "shaderGroupHandleAlignment" ] = p.shaderGroupHandleAlignment;
  j[ "maxRayHitAttributeSize" ] = p.maxRayHitAttributeSize;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceRayTracingPipelinePropertiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceRayTracingPipelinePropertiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceRayTracingPipelinePropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRayTracingPipelinePropertiesKHR" );
  if( j.find( "shaderGroupHandleSize" ) != j.end() ) {
    p.shaderGroupHandleSize = j[ "shaderGroupHandleSize" ];
  }
  if( j.find( "maxRayRecursionDepth" ) != j.end() ) {
    p.maxRayRecursionDepth = j[ "maxRayRecursionDepth" ];
  }
  if( j.find( "maxShaderGroupStride" ) != j.end() ) {
    p.maxShaderGroupStride = j[ "maxShaderGroupStride" ];
  }
  if( j.find( "shaderGroupBaseAlignment" ) != j.end() ) {
    p.shaderGroupBaseAlignment = j[ "shaderGroupBaseAlignment" ];
  }
  if( j.find( "shaderGroupHandleCaptureReplaySize" ) != j.end() ) {
    p.shaderGroupHandleCaptureReplaySize = j[ "shaderGroupHandleCaptureReplaySize" ];
  }
  if( j.find( "maxRayDispatchInvocationCount" ) != j.end() ) {
    p.maxRayDispatchInvocationCount = j[ "maxRayDispatchInvocationCount" ];
  }
  if( j.find( "shaderGroupHandleAlignment" ) != j.end() ) {
    p.shaderGroupHandleAlignment = j[ "shaderGroupHandleAlignment" ];
  }
  if( j.find( "maxRayHitAttributeSize" ) != j.end() ) {
    p.maxRayHitAttributeSize = j[ "maxRayHitAttributeSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceRayTracingPipelinePropertiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceRayTracingPipelinePropertiesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRayTracingPipelinePropertiesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceRayTracingPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderGroupHandleSize" ] = p.shaderGroupHandleSize;
  j[ "maxRecursionDepth" ] = p.maxRecursionDepth;
  j[ "maxShaderGroupStride" ] = p.maxShaderGroupStride;
  j[ "shaderGroupBaseAlignment" ] = p.shaderGroupBaseAlignment;
  j[ "maxGeometryCount" ] = p.maxGeometryCount;
  j[ "maxInstanceCount" ] = p.maxInstanceCount;
  j[ "maxTriangleCount" ] = p.maxTriangleCount;
  j[ "maxDescriptorSetAccelerationStructures" ] = p.maxDescriptorSetAccelerationStructures;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceRayTracingPropertiesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceRayTracingPropertiesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceRayTracingPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRayTracingPropertiesNV" );
  if( j.find( "shaderGroupHandleSize" ) != j.end() ) {
    p.shaderGroupHandleSize = j[ "shaderGroupHandleSize" ];
  }
  if( j.find( "maxRecursionDepth" ) != j.end() ) {
    p.maxRecursionDepth = j[ "maxRecursionDepth" ];
  }
  if( j.find( "maxShaderGroupStride" ) != j.end() ) {
    p.maxShaderGroupStride = j[ "maxShaderGroupStride" ];
  }
  if( j.find( "shaderGroupBaseAlignment" ) != j.end() ) {
    p.shaderGroupBaseAlignment = j[ "shaderGroupBaseAlignment" ];
  }
  if( j.find( "maxGeometryCount" ) != j.end() ) {
    p.maxGeometryCount = j[ "maxGeometryCount" ];
  }
  if( j.find( "maxInstanceCount" ) != j.end() ) {
    p.maxInstanceCount = j[ "maxInstanceCount" ];
  }
  if( j.find( "maxTriangleCount" ) != j.end() ) {
    p.maxTriangleCount = j[ "maxTriangleCount" ];
  }
  if( j.find( "maxDescriptorSetAccelerationStructures" ) != j.end() ) {
    p.maxDescriptorSetAccelerationStructures = j[ "maxDescriptorSetAccelerationStructures" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceRayTracingPropertiesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceRayTracingPropertiesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRayTracingPropertiesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceRepresentativeFragmentTestFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "representativeFragmentTest" ] = bool( p.representativeFragmentTest );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceRepresentativeFragmentTestFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceRepresentativeFragmentTestFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRepresentativeFragmentTestFeaturesNV" );
  if( j.find( "representativeFragmentTest" ) != j.end() ) {
    p.representativeFragmentTest = j[ "representativeFragmentTest" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceRepresentativeFragmentTestFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceRobustness2FeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "robustBufferAccess2" ] = bool( p.robustBufferAccess2 );
  j[ "robustImageAccess2" ] = bool( p.robustImageAccess2 );
  j[ "nullDescriptor" ] = bool( p.nullDescriptor );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceRobustness2FeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceRobustness2FeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceRobustness2FeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRobustness2FeaturesEXT" );
  if( j.find( "robustBufferAccess2" ) != j.end() ) {
    p.robustBufferAccess2 = j[ "robustBufferAccess2" ];
  }
  if( j.find( "robustImageAccess2" ) != j.end() ) {
    p.robustImageAccess2 = j[ "robustImageAccess2" ];
  }
  if( j.find( "nullDescriptor" ) != j.end() ) {
    p.nullDescriptor = j[ "nullDescriptor" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceRobustness2FeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceRobustness2FeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRobustness2FeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceRobustness2PropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "robustStorageBufferAccessSizeAlignment" ] = p.robustStorageBufferAccessSizeAlignment;
  j[ "robustUniformBufferAccessSizeAlignment" ] = p.robustUniformBufferAccessSizeAlignment;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceRobustness2PropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceRobustness2PropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceRobustness2PropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRobustness2PropertiesEXT" );
  if( j.find( "robustStorageBufferAccessSizeAlignment" ) != j.end() ) {
    p.robustStorageBufferAccessSizeAlignment = j[ "robustStorageBufferAccessSizeAlignment" ];
  }
  if( j.find( "robustUniformBufferAccessSizeAlignment" ) != j.end() ) {
    p.robustUniformBufferAccessSizeAlignment = j[ "robustUniformBufferAccessSizeAlignment" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceRobustness2PropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceRobustness2PropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRobustness2PropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/Extent2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceSampleLocationsPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "sampleLocationSampleCounts" ] = p.sampleLocationSampleCounts;
  j[ "maxSampleLocationGridSize" ] = p.maxSampleLocationGridSize;
  j[ "sampleLocationCoordinateRange" ] = nlohmann::json::array();
  std::copy( p.sampleLocationCoordinateRange.begin(), p.sampleLocationCoordinateRange.end(), std::back_inserter( j[ "sampleLocationCoordinateRange" ] ) );
  j[ "sampleLocationSubPixelBits" ] = p.sampleLocationSubPixelBits;
  j[ "variableSampleLocations" ] = bool( p.variableSampleLocations );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceSampleLocationsPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceSampleLocationsPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceSampleLocationsPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSampleLocationsPropertiesEXT" );
  if( j.find( "sampleLocationSampleCounts" ) != j.end() ) {
    p.sampleLocationSampleCounts = SampleCountFlags ( j[ "sampleLocationSampleCounts" ] );
  }
  if( j.find( "maxSampleLocationGridSize" ) != j.end() ) {
    p.maxSampleLocationGridSize = Extent2D ( j[ "maxSampleLocationGridSize" ] );
  }
  if( j.find( "sampleLocationCoordinateRange" ) != j.end() ) {
    if( !j[ "sampleLocationCoordinateRange" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceSampleLocationsPropertiesEXT.sampleLocationCoordinateRange" );
    if( !j[ "sampleLocationCoordinateRange" ].size() > p.sampleLocationCoordinateRange.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceSampleLocationsPropertiesEXT.sampleLocationCoordinateRange" );
    std::fill( p.sampleLocationCoordinateRange.begin(), p.sampleLocationCoordinateRange.end(), 0 );
    std::copy( j[ "sampleLocationCoordinateRange" ].begin(), j[ "sampleLocationCoordinateRange" ].end(), p.sampleLocationCoordinateRange.begin() );
  }
  if( j.find( "sampleLocationSubPixelBits" ) != j.end() ) {
    p.sampleLocationSubPixelBits = j[ "sampleLocationSubPixelBits" ];
  }
  if( j.find( "variableSampleLocations" ) != j.end() ) {
    p.variableSampleLocations = j[ "variableSampleLocations" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceSampleLocationsPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceSampleLocationsPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSampleLocationsPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceSamplerFilterMinmaxProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "filterMinmaxSingleComponentFormats" ] = bool( p.filterMinmaxSingleComponentFormats );
  j[ "filterMinmaxImageComponentMapping" ] = bool( p.filterMinmaxImageComponentMapping );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceSamplerFilterMinmaxProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceSamplerFilterMinmaxProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceSamplerFilterMinmaxProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSamplerFilterMinmaxProperties" );
  if( j.find( "filterMinmaxSingleComponentFormats" ) != j.end() ) {
    p.filterMinmaxSingleComponentFormats = j[ "filterMinmaxSingleComponentFormats" ];
  }
  if( j.find( "filterMinmaxImageComponentMapping" ) != j.end() ) {
    p.filterMinmaxImageComponentMapping = j[ "filterMinmaxImageComponentMapping" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceSamplerFilterMinmaxProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceSamplerFilterMinmaxProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSamplerFilterMinmaxProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceSamplerYcbcrConversionFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "samplerYcbcrConversion" ] = bool( p.samplerYcbcrConversion );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceSamplerYcbcrConversionFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceSamplerYcbcrConversionFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceSamplerYcbcrConversionFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSamplerYcbcrConversionFeatures" );
  if( j.find( "samplerYcbcrConversion" ) != j.end() ) {
    p.samplerYcbcrConversion = j[ "samplerYcbcrConversion" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceSamplerYcbcrConversionFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceSamplerYcbcrConversionFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSamplerYcbcrConversionFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceScalarBlockLayoutFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "scalarBlockLayout" ] = bool( p.scalarBlockLayout );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceScalarBlockLayoutFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceScalarBlockLayoutFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceScalarBlockLayoutFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceScalarBlockLayoutFeatures" );
  if( j.find( "scalarBlockLayout" ) != j.end() ) {
    p.scalarBlockLayout = j[ "scalarBlockLayout" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceScalarBlockLayoutFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceScalarBlockLayoutFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceScalarBlockLayoutFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceSeparateDepthStencilLayoutsFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "separateDepthStencilLayouts" ] = bool( p.separateDepthStencilLayouts );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceSeparateDepthStencilLayoutsFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceSeparateDepthStencilLayoutsFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSeparateDepthStencilLayoutsFeatures" );
  if( j.find( "separateDepthStencilLayouts" ) != j.end() ) {
    p.separateDepthStencilLayouts = j[ "separateDepthStencilLayouts" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceSeparateDepthStencilLayoutsFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderAtomicFloatFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderBufferFloat32Atomics" ] = bool( p.shaderBufferFloat32Atomics );
  j[ "shaderBufferFloat32AtomicAdd" ] = bool( p.shaderBufferFloat32AtomicAdd );
  j[ "shaderBufferFloat64Atomics" ] = bool( p.shaderBufferFloat64Atomics );
  j[ "shaderBufferFloat64AtomicAdd" ] = bool( p.shaderBufferFloat64AtomicAdd );
  j[ "shaderSharedFloat32Atomics" ] = bool( p.shaderSharedFloat32Atomics );
  j[ "shaderSharedFloat32AtomicAdd" ] = bool( p.shaderSharedFloat32AtomicAdd );
  j[ "shaderSharedFloat64Atomics" ] = bool( p.shaderSharedFloat64Atomics );
  j[ "shaderSharedFloat64AtomicAdd" ] = bool( p.shaderSharedFloat64AtomicAdd );
  j[ "shaderImageFloat32Atomics" ] = bool( p.shaderImageFloat32Atomics );
  j[ "shaderImageFloat32AtomicAdd" ] = bool( p.shaderImageFloat32AtomicAdd );
  j[ "sparseImageFloat32Atomics" ] = bool( p.sparseImageFloat32Atomics );
  j[ "sparseImageFloat32AtomicAdd" ] = bool( p.sparseImageFloat32AtomicAdd );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderAtomicFloatFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderAtomicFloatFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderAtomicFloatFeaturesEXT" );
  if( j.find( "shaderBufferFloat32Atomics" ) != j.end() ) {
    p.shaderBufferFloat32Atomics = j[ "shaderBufferFloat32Atomics" ];
  }
  if( j.find( "shaderBufferFloat32AtomicAdd" ) != j.end() ) {
    p.shaderBufferFloat32AtomicAdd = j[ "shaderBufferFloat32AtomicAdd" ];
  }
  if( j.find( "shaderBufferFloat64Atomics" ) != j.end() ) {
    p.shaderBufferFloat64Atomics = j[ "shaderBufferFloat64Atomics" ];
  }
  if( j.find( "shaderBufferFloat64AtomicAdd" ) != j.end() ) {
    p.shaderBufferFloat64AtomicAdd = j[ "shaderBufferFloat64AtomicAdd" ];
  }
  if( j.find( "shaderSharedFloat32Atomics" ) != j.end() ) {
    p.shaderSharedFloat32Atomics = j[ "shaderSharedFloat32Atomics" ];
  }
  if( j.find( "shaderSharedFloat32AtomicAdd" ) != j.end() ) {
    p.shaderSharedFloat32AtomicAdd = j[ "shaderSharedFloat32AtomicAdd" ];
  }
  if( j.find( "shaderSharedFloat64Atomics" ) != j.end() ) {
    p.shaderSharedFloat64Atomics = j[ "shaderSharedFloat64Atomics" ];
  }
  if( j.find( "shaderSharedFloat64AtomicAdd" ) != j.end() ) {
    p.shaderSharedFloat64AtomicAdd = j[ "shaderSharedFloat64AtomicAdd" ];
  }
  if( j.find( "shaderImageFloat32Atomics" ) != j.end() ) {
    p.shaderImageFloat32Atomics = j[ "shaderImageFloat32Atomics" ];
  }
  if( j.find( "shaderImageFloat32AtomicAdd" ) != j.end() ) {
    p.shaderImageFloat32AtomicAdd = j[ "shaderImageFloat32AtomicAdd" ];
  }
  if( j.find( "sparseImageFloat32Atomics" ) != j.end() ) {
    p.sparseImageFloat32Atomics = j[ "sparseImageFloat32Atomics" ];
  }
  if( j.find( "sparseImageFloat32AtomicAdd" ) != j.end() ) {
    p.sparseImageFloat32AtomicAdd = j[ "sparseImageFloat32AtomicAdd" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderAtomicFloatFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderAtomicFloatFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderAtomicInt64Features &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderBufferInt64Atomics" ] = bool( p.shaderBufferInt64Atomics );
  j[ "shaderSharedInt64Atomics" ] = bool( p.shaderSharedInt64Atomics );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderAtomicInt64Features &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderAtomicInt64Features ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderAtomicInt64Features &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderAtomicInt64Features" );
  if( j.find( "shaderBufferInt64Atomics" ) != j.end() ) {
    p.shaderBufferInt64Atomics = j[ "shaderBufferInt64Atomics" ];
  }
  if( j.find( "shaderSharedInt64Atomics" ) != j.end() ) {
    p.shaderSharedInt64Atomics = j[ "shaderSharedInt64Atomics" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderAtomicInt64Features &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderAtomicInt64Features temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderAtomicInt64Features ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderClockFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderSubgroupClock" ] = bool( p.shaderSubgroupClock );
  j[ "shaderDeviceClock" ] = bool( p.shaderDeviceClock );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderClockFeaturesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderClockFeaturesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderClockFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderClockFeaturesKHR" );
  if( j.find( "shaderSubgroupClock" ) != j.end() ) {
    p.shaderSubgroupClock = j[ "shaderSubgroupClock" ];
  }
  if( j.find( "shaderDeviceClock" ) != j.end() ) {
    p.shaderDeviceClock = j[ "shaderDeviceClock" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderClockFeaturesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderClockFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderClockFeaturesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ShaderCorePropertiesFlagsAMD.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderCoreProperties2AMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderCoreFeatures" ] = p.shaderCoreFeatures;
  j[ "activeComputeUnitCount" ] = p.activeComputeUnitCount;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderCoreProperties2AMD &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderCoreProperties2AMD ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderCoreProperties2AMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderCoreProperties2AMD" );
  if( j.find( "shaderCoreFeatures" ) != j.end() ) {
    p.shaderCoreFeatures = ShaderCorePropertiesFlagsAMD ( j[ "shaderCoreFeatures" ] );
  }
  if( j.find( "activeComputeUnitCount" ) != j.end() ) {
    p.activeComputeUnitCount = j[ "activeComputeUnitCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderCoreProperties2AMD &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderCoreProperties2AMD temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderCoreProperties2AMD ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderCorePropertiesAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderEngineCount" ] = p.shaderEngineCount;
  j[ "shaderArraysPerEngineCount" ] = p.shaderArraysPerEngineCount;
  j[ "computeUnitsPerShaderArray" ] = p.computeUnitsPerShaderArray;
  j[ "simdPerComputeUnit" ] = p.simdPerComputeUnit;
  j[ "wavefrontsPerSimd" ] = p.wavefrontsPerSimd;
  j[ "wavefrontSize" ] = p.wavefrontSize;
  j[ "sgprsPerSimd" ] = p.sgprsPerSimd;
  j[ "minSgprAllocation" ] = p.minSgprAllocation;
  j[ "maxSgprAllocation" ] = p.maxSgprAllocation;
  j[ "sgprAllocationGranularity" ] = p.sgprAllocationGranularity;
  j[ "vgprsPerSimd" ] = p.vgprsPerSimd;
  j[ "minVgprAllocation" ] = p.minVgprAllocation;
  j[ "maxVgprAllocation" ] = p.maxVgprAllocation;
  j[ "vgprAllocationGranularity" ] = p.vgprAllocationGranularity;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderCorePropertiesAMD &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderCorePropertiesAMD ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderCorePropertiesAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderCorePropertiesAMD" );
  if( j.find( "shaderEngineCount" ) != j.end() ) {
    p.shaderEngineCount = j[ "shaderEngineCount" ];
  }
  if( j.find( "shaderArraysPerEngineCount" ) != j.end() ) {
    p.shaderArraysPerEngineCount = j[ "shaderArraysPerEngineCount" ];
  }
  if( j.find( "computeUnitsPerShaderArray" ) != j.end() ) {
    p.computeUnitsPerShaderArray = j[ "computeUnitsPerShaderArray" ];
  }
  if( j.find( "simdPerComputeUnit" ) != j.end() ) {
    p.simdPerComputeUnit = j[ "simdPerComputeUnit" ];
  }
  if( j.find( "wavefrontsPerSimd" ) != j.end() ) {
    p.wavefrontsPerSimd = j[ "wavefrontsPerSimd" ];
  }
  if( j.find( "wavefrontSize" ) != j.end() ) {
    p.wavefrontSize = j[ "wavefrontSize" ];
  }
  if( j.find( "sgprsPerSimd" ) != j.end() ) {
    p.sgprsPerSimd = j[ "sgprsPerSimd" ];
  }
  if( j.find( "minSgprAllocation" ) != j.end() ) {
    p.minSgprAllocation = j[ "minSgprAllocation" ];
  }
  if( j.find( "maxSgprAllocation" ) != j.end() ) {
    p.maxSgprAllocation = j[ "maxSgprAllocation" ];
  }
  if( j.find( "sgprAllocationGranularity" ) != j.end() ) {
    p.sgprAllocationGranularity = j[ "sgprAllocationGranularity" ];
  }
  if( j.find( "vgprsPerSimd" ) != j.end() ) {
    p.vgprsPerSimd = j[ "vgprsPerSimd" ];
  }
  if( j.find( "minVgprAllocation" ) != j.end() ) {
    p.minVgprAllocation = j[ "minVgprAllocation" ];
  }
  if( j.find( "maxVgprAllocation" ) != j.end() ) {
    p.maxVgprAllocation = j[ "maxVgprAllocation" ];
  }
  if( j.find( "vgprAllocationGranularity" ) != j.end() ) {
    p.vgprAllocationGranularity = j[ "vgprAllocationGranularity" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderCorePropertiesAMD &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderCorePropertiesAMD temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderCorePropertiesAMD ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderDemoteToHelperInvocation" ] = bool( p.shaderDemoteToHelperInvocation );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT" );
  if( j.find( "shaderDemoteToHelperInvocation" ) != j.end() ) {
    p.shaderDemoteToHelperInvocation = j[ "shaderDemoteToHelperInvocation" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderDrawParametersFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderDrawParameters" ] = bool( p.shaderDrawParameters );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderDrawParametersFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderDrawParametersFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderDrawParametersFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderDrawParametersFeatures" );
  if( j.find( "shaderDrawParameters" ) != j.end() ) {
    p.shaderDrawParameters = j[ "shaderDrawParameters" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderDrawParametersFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderDrawParametersFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderDrawParametersFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderFloat16Int8Features &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderFloat16" ] = bool( p.shaderFloat16 );
  j[ "shaderInt8" ] = bool( p.shaderInt8 );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderFloat16Int8Features &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderFloat16Int8Features ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderFloat16Int8Features &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderFloat16Int8Features" );
  if( j.find( "shaderFloat16" ) != j.end() ) {
    p.shaderFloat16 = j[ "shaderFloat16" ];
  }
  if( j.find( "shaderInt8" ) != j.end() ) {
    p.shaderInt8 = j[ "shaderInt8" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderFloat16Int8Features &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderFloat16Int8Features temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderFloat16Int8Features ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderImageAtomicInt64FeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderImageInt64Atomics" ] = bool( p.shaderImageInt64Atomics );
  j[ "sparseImageInt64Atomics" ] = bool( p.sparseImageInt64Atomics );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderImageAtomicInt64FeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderImageAtomicInt64FeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT" );
  if( j.find( "shaderImageInt64Atomics" ) != j.end() ) {
    p.shaderImageInt64Atomics = j[ "shaderImageInt64Atomics" ];
  }
  if( j.find( "sparseImageInt64Atomics" ) != j.end() ) {
    p.sparseImageInt64Atomics = j[ "sparseImageInt64Atomics" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderImageAtomicInt64FeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderImageFootprintFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "imageFootprint" ] = bool( p.imageFootprint );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderImageFootprintFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderImageFootprintFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderImageFootprintFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderImageFootprintFeaturesNV" );
  if( j.find( "imageFootprint" ) != j.end() ) {
    p.imageFootprint = j[ "imageFootprint" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderImageFootprintFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderImageFootprintFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderImageFootprintFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderIntegerFunctions2" ] = bool( p.shaderIntegerFunctions2 );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL" );
  if( j.find( "shaderIntegerFunctions2" ) != j.end() ) {
    p.shaderIntegerFunctions2 = j[ "shaderIntegerFunctions2" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderSMBuiltinsFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderSMBuiltins" ] = bool( p.shaderSMBuiltins );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderSMBuiltinsFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderSMBuiltinsFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderSMBuiltinsFeaturesNV" );
  if( j.find( "shaderSMBuiltins" ) != j.end() ) {
    p.shaderSMBuiltins = j[ "shaderSMBuiltins" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderSMBuiltinsFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderSMBuiltinsFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderSMBuiltinsPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderSMCount" ] = p.shaderSMCount;
  j[ "shaderWarpsPerSM" ] = p.shaderWarpsPerSM;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderSMBuiltinsPropertiesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderSMBuiltinsPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderSMBuiltinsPropertiesNV" );
  if( j.find( "shaderSMCount" ) != j.end() ) {
    p.shaderSMCount = j[ "shaderSMCount" ];
  }
  if( j.find( "shaderWarpsPerSM" ) != j.end() ) {
    p.shaderWarpsPerSM = j[ "shaderWarpsPerSM" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderSMBuiltinsPropertiesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderSMBuiltinsPropertiesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderSubgroupExtendedTypesFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderSubgroupExtendedTypes" ] = bool( p.shaderSubgroupExtendedTypes );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderSubgroupExtendedTypesFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderSubgroupExtendedTypesFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderSubgroupExtendedTypesFeatures" );
  if( j.find( "shaderSubgroupExtendedTypes" ) != j.end() ) {
    p.shaderSubgroupExtendedTypes = j[ "shaderSubgroupExtendedTypes" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderSubgroupExtendedTypesFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderSubgroupUniformControlFlow" ] = bool( p.shaderSubgroupUniformControlFlow );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR" );
  if( j.find( "shaderSubgroupUniformControlFlow" ) != j.end() ) {
    p.shaderSubgroupUniformControlFlow = j[ "shaderSubgroupUniformControlFlow" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShaderTerminateInvocationFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderTerminateInvocation" ] = bool( p.shaderTerminateInvocation );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderTerminateInvocationFeaturesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShaderTerminateInvocationFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderTerminateInvocationFeaturesKHR" );
  if( j.find( "shaderTerminateInvocation" ) != j.end() ) {
    p.shaderTerminateInvocation = j[ "shaderTerminateInvocation" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShaderTerminateInvocationFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShadingRateImageFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shadingRateImage" ] = bool( p.shadingRateImage );
  j[ "shadingRateCoarseSampleOrder" ] = bool( p.shadingRateCoarseSampleOrder );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShadingRateImageFeaturesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShadingRateImageFeaturesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShadingRateImageFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShadingRateImageFeaturesNV" );
  if( j.find( "shadingRateImage" ) != j.end() ) {
    p.shadingRateImage = j[ "shadingRateImage" ];
  }
  if( j.find( "shadingRateCoarseSampleOrder" ) != j.end() ) {
    p.shadingRateCoarseSampleOrder = j[ "shadingRateCoarseSampleOrder" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShadingRateImageFeaturesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShadingRateImageFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShadingRateImageFeaturesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Extent2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceShadingRateImagePropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shadingRateTexelSize" ] = p.shadingRateTexelSize;
  j[ "shadingRatePaletteSize" ] = p.shadingRatePaletteSize;
  j[ "shadingRateMaxCoarseSamples" ] = p.shadingRateMaxCoarseSamples;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceShadingRateImagePropertiesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceShadingRateImagePropertiesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceShadingRateImagePropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShadingRateImagePropertiesNV" );
  if( j.find( "shadingRateTexelSize" ) != j.end() ) {
    p.shadingRateTexelSize = Extent2D ( j[ "shadingRateTexelSize" ] );
  }
  if( j.find( "shadingRatePaletteSize" ) != j.end() ) {
    p.shadingRatePaletteSize = j[ "shadingRatePaletteSize" ];
  }
  if( j.find( "shadingRateMaxCoarseSamples" ) != j.end() ) {
    p.shadingRateMaxCoarseSamples = j[ "shadingRateMaxCoarseSamples" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceShadingRateImagePropertiesNV &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceShadingRateImagePropertiesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShadingRateImagePropertiesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Format.hpp>
#include <vulkan2json/ImageType.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
#include <vulkan2json/ImageUsageFlags.hpp>
#include <vulkan2json/ImageTiling.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceSparseImageFormatInfo2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "format" ] = p.format;
  j[ "type" ] = p.type;
  j[ "samples" ] = p.samples;
  j[ "usage" ] = p.usage;
  j[ "tiling" ] = p.tiling;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceSparseImageFormatInfo2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceSparseImageFormatInfo2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceSparseImageFormatInfo2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSparseImageFormatInfo2" );
  if( j.find( "format" ) != j.end() ) {
    p.format = Format ( j[ "format" ] );
  }
  if( j.find( "type" ) != j.end() ) {
    p.type = ImageType ( j[ "type" ] );
  }
  if( j.find( "samples" ) != j.end() ) {
    p.samples = SampleCountFlagBits ( j[ "samples" ] );
  }
  if( j.find( "usage" ) != j.end() ) {
    p.usage = ImageUsageFlags ( j[ "usage" ] );
  }
  if( j.find( "tiling" ) != j.end() ) {
    p.tiling = ImageTiling ( j[ "tiling" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceSparseImageFormatInfo2 &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceSparseImageFormatInfo2 temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSparseImageFormatInfo2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ShaderStageFlags.hpp>
#include <vulkan2json/SubgroupFeatureFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceSubgroupProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "subgroupSize" ] = p.subgroupSize;
  j[ "supportedStages" ] = p.supportedStages;
  j[ "supportedOperations" ] = p.supportedOperations;
  j[ "quadOperationsInAllStages" ] = bool( p.quadOperationsInAllStages );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceSubgroupProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceSubgroupProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceSubgroupProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSubgroupProperties" );
  if( j.find( "subgroupSize" ) != j.end() ) {
    p.subgroupSize = j[ "subgroupSize" ];
  }
  if( j.find( "supportedStages" ) != j.end() ) {
    p.supportedStages = ShaderStageFlags ( j[ "supportedStages" ] );
  }
  if( j.find( "supportedOperations" ) != j.end() ) {
    p.supportedOperations = SubgroupFeatureFlags ( j[ "supportedOperations" ] );
  }
  if( j.find( "quadOperationsInAllStages" ) != j.end() ) {
    p.quadOperationsInAllStages = j[ "quadOperationsInAllStages" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceSubgroupProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceSubgroupProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSubgroupProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceSubgroupSizeControlFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "subgroupSizeControl" ] = bool( p.subgroupSizeControl );
  j[ "computeFullSubgroups" ] = bool( p.computeFullSubgroups );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceSubgroupSizeControlFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceSubgroupSizeControlFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSubgroupSizeControlFeaturesEXT" );
  if( j.find( "subgroupSizeControl" ) != j.end() ) {
    p.subgroupSizeControl = j[ "subgroupSizeControl" ];
  }
  if( j.find( "computeFullSubgroups" ) != j.end() ) {
    p.computeFullSubgroups = j[ "computeFullSubgroups" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceSubgroupSizeControlFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceSubgroupSizeControlFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSubgroupSizeControlFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ShaderStageFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceSubgroupSizeControlPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "minSubgroupSize" ] = p.minSubgroupSize;
  j[ "maxSubgroupSize" ] = p.maxSubgroupSize;
  j[ "maxComputeWorkgroupSubgroups" ] = p.maxComputeWorkgroupSubgroups;
  j[ "requiredSubgroupSizeStages" ] = p.requiredSubgroupSizeStages;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceSubgroupSizeControlPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceSubgroupSizeControlPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSubgroupSizeControlPropertiesEXT" );
  if( j.find( "minSubgroupSize" ) != j.end() ) {
    p.minSubgroupSize = j[ "minSubgroupSize" ];
  }
  if( j.find( "maxSubgroupSize" ) != j.end() ) {
    p.maxSubgroupSize = j[ "maxSubgroupSize" ];
  }
  if( j.find( "maxComputeWorkgroupSubgroups" ) != j.end() ) {
    p.maxComputeWorkgroupSubgroups = j[ "maxComputeWorkgroupSubgroups" ];
  }
  if( j.find( "requiredSubgroupSizeStages" ) != j.end() ) {
    p.requiredSubgroupSizeStages = ShaderStageFlags ( j[ "requiredSubgroupSizeStages" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceSubgroupSizeControlPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceSubgroupSizeControlPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSubgroupSizeControlPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceSubpassShadingFeaturesHUAWEI &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "subpassShading" ] = bool( p.subpassShading );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceSubpassShadingFeaturesHUAWEI ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceSubpassShadingFeaturesHUAWEI &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSubpassShadingFeaturesHUAWEI" );
  if( j.find( "subpassShading" ) != j.end() ) {
    p.subpassShading = j[ "subpassShading" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceSubpassShadingFeaturesHUAWEI &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceSubpassShadingFeaturesHUAWEI temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSubpassShadingFeaturesHUAWEI ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceSubpassShadingPropertiesHUAWEI &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxSubpassShadingWorkgroupSizeAspectRatio" ] = p.maxSubpassShadingWorkgroupSizeAspectRatio;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceSubpassShadingPropertiesHUAWEI ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceSubpassShadingPropertiesHUAWEI &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSubpassShadingPropertiesHUAWEI" );
  if( j.find( "maxSubpassShadingWorkgroupSizeAspectRatio" ) != j.end() ) {
    p.maxSubpassShadingWorkgroupSizeAspectRatio = j[ "maxSubpassShadingWorkgroupSizeAspectRatio" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceSubpassShadingPropertiesHUAWEI temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSubpassShadingPropertiesHUAWEI ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceSurfaceInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceSurfaceInfo2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceSurfaceInfo2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceSurfaceInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSurfaceInfo2KHR" );
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceSurfaceInfo2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceSurfaceInfo2KHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSurfaceInfo2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceSynchronization2FeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "synchronization2" ] = bool( p.synchronization2 );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceSynchronization2FeaturesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceSynchronization2FeaturesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceSynchronization2FeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSynchronization2FeaturesKHR" );
  if( j.find( "synchronization2" ) != j.end() ) {
    p.synchronization2 = j[ "synchronization2" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceSynchronization2FeaturesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceSynchronization2FeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSynchronization2FeaturesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceTexelBufferAlignmentFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "texelBufferAlignment" ] = bool( p.texelBufferAlignment );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceTexelBufferAlignmentFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceTexelBufferAlignmentFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceTexelBufferAlignmentFeaturesEXT" );
  if( j.find( "texelBufferAlignment" ) != j.end() ) {
    p.texelBufferAlignment = j[ "texelBufferAlignment" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceTexelBufferAlignmentFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceTexelBufferAlignmentPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "storageTexelBufferOffsetAlignmentBytes" ] = p.storageTexelBufferOffsetAlignmentBytes;
  j[ "storageTexelBufferOffsetSingleTexelAlignment" ] = bool( p.storageTexelBufferOffsetSingleTexelAlignment );
  j[ "uniformTexelBufferOffsetAlignmentBytes" ] = p.uniformTexelBufferOffsetAlignmentBytes;
  j[ "uniformTexelBufferOffsetSingleTexelAlignment" ] = bool( p.uniformTexelBufferOffsetSingleTexelAlignment );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceTexelBufferAlignmentPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceTexelBufferAlignmentPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceTexelBufferAlignmentPropertiesEXT" );
  if( j.find( "storageTexelBufferOffsetAlignmentBytes" ) != j.end() ) {
    p.storageTexelBufferOffsetAlignmentBytes = j[ "storageTexelBufferOffsetAlignmentBytes" ];
  }
  if( j.find( "storageTexelBufferOffsetSingleTexelAlignment" ) != j.end() ) {
    p.storageTexelBufferOffsetSingleTexelAlignment = j[ "storageTexelBufferOffsetSingleTexelAlignment" ];
  }
  if( j.find( "uniformTexelBufferOffsetAlignmentBytes" ) != j.end() ) {
    p.uniformTexelBufferOffsetAlignmentBytes = j[ "uniformTexelBufferOffsetAlignmentBytes" ];
  }
  if( j.find( "uniformTexelBufferOffsetSingleTexelAlignment" ) != j.end() ) {
    p.uniformTexelBufferOffsetSingleTexelAlignment = j[ "uniformTexelBufferOffsetSingleTexelAlignment" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceTexelBufferAlignmentPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "textureCompressionASTC_HDR" ] = bool( p.textureCompressionASTC_HDR );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT" );
  if( j.find( "textureCompressionASTC_HDR" ) != j.end() ) {
    p.textureCompressionASTC_HDR = j[ "textureCompressionASTC_HDR" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceTimelineSemaphoreFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "timelineSemaphore" ] = bool( p.timelineSemaphore );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceTimelineSemaphoreFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceTimelineSemaphoreFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceTimelineSemaphoreFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceTimelineSemaphoreFeatures" );
  if( j.find( "timelineSemaphore" ) != j.end() ) {
    p.timelineSemaphore = j[ "timelineSemaphore" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceTimelineSemaphoreFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceTimelineSemaphoreFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceTimelineSemaphoreFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceTimelineSemaphoreProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxTimelineSemaphoreValueDifference" ] = p.maxTimelineSemaphoreValueDifference;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceTimelineSemaphoreProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceTimelineSemaphoreProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceTimelineSemaphoreProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceTimelineSemaphoreProperties" );
  if( j.find( "maxTimelineSemaphoreValueDifference" ) != j.end() ) {
    p.maxTimelineSemaphoreValueDifference = j[ "maxTimelineSemaphoreValueDifference" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceTimelineSemaphoreProperties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceTimelineSemaphoreProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceTimelineSemaphoreProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ToolPurposeFlagsEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceToolPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "name" ] = std::string( p.name.begin(), std::find( p.name.begin(), p.name.end(), '\0' ) );
  j[ "version" ] = std::string( p.version.begin(), std::find( p.version.begin(), p.version.end(), '\0' ) );
  j[ "purposes" ] = p.purposes;
  j[ "description" ] = std::string( p.description.begin(), std::find( p.description.begin(), p.description.end(), '\0' ) );
  j[ "layer" ] = std::string( p.layer.begin(), std::find( p.layer.begin(), p.layer.end(), '\0' ) );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceToolPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceToolPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceToolPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceToolPropertiesEXT" );
  if( j.find( "name" ) != j.end() ) {
    {
      std::string s = j[ "name" ];
      if( !p.name.empty() ) {
        p.name[ p.name.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.name.size() - 1u ) ), p.name.begin() );
      }
    }
  }
  if( j.find( "version" ) != j.end() ) {
    {
      std::string s = j[ "version" ];
      if( !p.version.empty() ) {
        p.version[ p.version.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.version.size() - 1u ) ), p.version.begin() );
      }
    }
  }
  if( j.find( "purposes" ) != j.end() ) {
    p.purposes = ToolPurposeFlagsEXT ( j[ "purposes" ] );
  }
  if( j.find( "description" ) != j.end() ) {
    {
      std::string s = j[ "description" ];
      if( !p.description.empty() ) {
        p.description[ p.description.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.description.size() - 1u ) ), p.description.begin() );
      }
    }
  }
  if( j.find( "layer" ) != j.end() ) {
    {
      std::string s = j[ "layer" ];
      if( !p.layer.empty() ) {
        p.layer[ p.layer.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.layer.size() - 1u ) ), p.layer.begin() );
      }
    }
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceToolPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceToolPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceToolPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceTransformFeedbackFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "transformFeedback" ] = bool( p.transformFeedback );
  j[ "geometryStreams" ] = bool( p.geometryStreams );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceTransformFeedbackFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceTransformFeedbackFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceTransformFeedbackFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceTransformFeedbackFeaturesEXT" );
  if( j.find( "transformFeedback" ) != j.end() ) {
    p.transformFeedback = j[ "transformFeedback" ];
  }
  if( j.find( "geometryStreams" ) != j.end() ) {
    p.geometryStreams = j[ "geometryStreams" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceTransformFeedbackFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceTransformFeedbackFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceTransformFeedbackFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceTransformFeedbackPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxTransformFeedbackStreams" ] = p.maxTransformFeedbackStreams;
  j[ "maxTransformFeedbackBuffers" ] = p.maxTransformFeedbackBuffers;
  j[ "maxTransformFeedbackBufferSize" ] = p.maxTransformFeedbackBufferSize;
  j[ "maxTransformFeedbackStreamDataSize" ] = p.maxTransformFeedbackStreamDataSize;
  j[ "maxTransformFeedbackBufferDataSize" ] = p.maxTransformFeedbackBufferDataSize;
  j[ "maxTransformFeedbackBufferDataStride" ] = p.maxTransformFeedbackBufferDataStride;
  j[ "transformFeedbackQueries" ] = bool( p.transformFeedbackQueries );
  j[ "transformFeedbackStreamsLinesTriangles" ] = bool( p.transformFeedbackStreamsLinesTriangles );
  j[ "transformFeedbackRasterizationStreamSelect" ] = bool( p.transformFeedbackRasterizationStreamSelect );
  j[ "transformFeedbackDraw" ] = bool( p.transformFeedbackDraw );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceTransformFeedbackPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceTransformFeedbackPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceTransformFeedbackPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceTransformFeedbackPropertiesEXT" );
  if( j.find( "maxTransformFeedbackStreams" ) != j.end() ) {
    p.maxTransformFeedbackStreams = j[ "maxTransformFeedbackStreams" ];
  }
  if( j.find( "maxTransformFeedbackBuffers" ) != j.end() ) {
    p.maxTransformFeedbackBuffers = j[ "maxTransformFeedbackBuffers" ];
  }
  if( j.find( "maxTransformFeedbackBufferSize" ) != j.end() ) {
    p.maxTransformFeedbackBufferSize = j[ "maxTransformFeedbackBufferSize" ];
  }
  if( j.find( "maxTransformFeedbackStreamDataSize" ) != j.end() ) {
    p.maxTransformFeedbackStreamDataSize = j[ "maxTransformFeedbackStreamDataSize" ];
  }
  if( j.find( "maxTransformFeedbackBufferDataSize" ) != j.end() ) {
    p.maxTransformFeedbackBufferDataSize = j[ "maxTransformFeedbackBufferDataSize" ];
  }
  if( j.find( "maxTransformFeedbackBufferDataStride" ) != j.end() ) {
    p.maxTransformFeedbackBufferDataStride = j[ "maxTransformFeedbackBufferDataStride" ];
  }
  if( j.find( "transformFeedbackQueries" ) != j.end() ) {
    p.transformFeedbackQueries = j[ "transformFeedbackQueries" ];
  }
  if( j.find( "transformFeedbackStreamsLinesTriangles" ) != j.end() ) {
    p.transformFeedbackStreamsLinesTriangles = j[ "transformFeedbackStreamsLinesTriangles" ];
  }
  if( j.find( "transformFeedbackRasterizationStreamSelect" ) != j.end() ) {
    p.transformFeedbackRasterizationStreamSelect = j[ "transformFeedbackRasterizationStreamSelect" ];
  }
  if( j.find( "transformFeedbackDraw" ) != j.end() ) {
    p.transformFeedbackDraw = j[ "transformFeedbackDraw" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceTransformFeedbackPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceTransformFeedbackPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceTransformFeedbackPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceUniformBufferStandardLayoutFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "uniformBufferStandardLayout" ] = bool( p.uniformBufferStandardLayout );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceUniformBufferStandardLayoutFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceUniformBufferStandardLayoutFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceUniformBufferStandardLayoutFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceUniformBufferStandardLayoutFeatures" );
  if( j.find( "uniformBufferStandardLayout" ) != j.end() ) {
    p.uniformBufferStandardLayout = j[ "uniformBufferStandardLayout" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceUniformBufferStandardLayoutFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceUniformBufferStandardLayoutFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceUniformBufferStandardLayoutFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceVariablePointersFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "variablePointersStorageBuffer" ] = bool( p.variablePointersStorageBuffer );
  j[ "variablePointers" ] = bool( p.variablePointers );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceVariablePointersFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceVariablePointersFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceVariablePointersFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVariablePointersFeatures" );
  if( j.find( "variablePointersStorageBuffer" ) != j.end() ) {
    p.variablePointersStorageBuffer = j[ "variablePointersStorageBuffer" ];
  }
  if( j.find( "variablePointers" ) != j.end() ) {
    p.variablePointers = j[ "variablePointers" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceVariablePointersFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceVariablePointersFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVariablePointersFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceVertexAttributeDivisorFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "vertexAttributeInstanceRateDivisor" ] = bool( p.vertexAttributeInstanceRateDivisor );
  j[ "vertexAttributeInstanceRateZeroDivisor" ] = bool( p.vertexAttributeInstanceRateZeroDivisor );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceVertexAttributeDivisorFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceVertexAttributeDivisorFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVertexAttributeDivisorFeaturesEXT" );
  if( j.find( "vertexAttributeInstanceRateDivisor" ) != j.end() ) {
    p.vertexAttributeInstanceRateDivisor = j[ "vertexAttributeInstanceRateDivisor" ];
  }
  if( j.find( "vertexAttributeInstanceRateZeroDivisor" ) != j.end() ) {
    p.vertexAttributeInstanceRateZeroDivisor = j[ "vertexAttributeInstanceRateZeroDivisor" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceVertexAttributeDivisorFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceVertexAttributeDivisorPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxVertexAttribDivisor" ] = p.maxVertexAttribDivisor;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceVertexAttributeDivisorPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceVertexAttributeDivisorPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVertexAttributeDivisorPropertiesEXT" );
  if( j.find( "maxVertexAttribDivisor" ) != j.end() ) {
    p.maxVertexAttribDivisor = j[ "maxVertexAttribDivisor" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceVertexAttributeDivisorPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceVertexInputDynamicStateFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "vertexInputDynamicState" ] = bool( p.vertexInputDynamicState );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceVertexInputDynamicStateFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceVertexInputDynamicStateFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVertexInputDynamicStateFeaturesEXT" );
  if( j.find( "vertexInputDynamicState" ) != j.end() ) {
    p.vertexInputDynamicState = j[ "vertexInputDynamicState" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceVertexInputDynamicStateFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceVulkan11Features &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "storageBuffer16BitAccess" ] = bool( p.storageBuffer16BitAccess );
  j[ "uniformAndStorageBuffer16BitAccess" ] = bool( p.uniformAndStorageBuffer16BitAccess );
  j[ "storagePushConstant16" ] = bool( p.storagePushConstant16 );
  j[ "storageInputOutput16" ] = bool( p.storageInputOutput16 );
  j[ "multiview" ] = bool( p.multiview );
  j[ "multiviewGeometryShader" ] = bool( p.multiviewGeometryShader );
  j[ "multiviewTessellationShader" ] = bool( p.multiviewTessellationShader );
  j[ "variablePointersStorageBuffer" ] = bool( p.variablePointersStorageBuffer );
  j[ "variablePointers" ] = bool( p.variablePointers );
  j[ "protectedMemory" ] = bool( p.protectedMemory );
  j[ "samplerYcbcrConversion" ] = bool( p.samplerYcbcrConversion );
  j[ "shaderDrawParameters" ] = bool( p.shaderDrawParameters );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceVulkan11Features &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceVulkan11Features ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceVulkan11Features &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVulkan11Features" );
  if( j.find( "storageBuffer16BitAccess" ) != j.end() ) {
    p.storageBuffer16BitAccess = j[ "storageBuffer16BitAccess" ];
  }
  if( j.find( "uniformAndStorageBuffer16BitAccess" ) != j.end() ) {
    p.uniformAndStorageBuffer16BitAccess = j[ "uniformAndStorageBuffer16BitAccess" ];
  }
  if( j.find( "storagePushConstant16" ) != j.end() ) {
    p.storagePushConstant16 = j[ "storagePushConstant16" ];
  }
  if( j.find( "storageInputOutput16" ) != j.end() ) {
    p.storageInputOutput16 = j[ "storageInputOutput16" ];
  }
  if( j.find( "multiview" ) != j.end() ) {
    p.multiview = j[ "multiview" ];
  }
  if( j.find( "multiviewGeometryShader" ) != j.end() ) {
    p.multiviewGeometryShader = j[ "multiviewGeometryShader" ];
  }
  if( j.find( "multiviewTessellationShader" ) != j.end() ) {
    p.multiviewTessellationShader = j[ "multiviewTessellationShader" ];
  }
  if( j.find( "variablePointersStorageBuffer" ) != j.end() ) {
    p.variablePointersStorageBuffer = j[ "variablePointersStorageBuffer" ];
  }
  if( j.find( "variablePointers" ) != j.end() ) {
    p.variablePointers = j[ "variablePointers" ];
  }
  if( j.find( "protectedMemory" ) != j.end() ) {
    p.protectedMemory = j[ "protectedMemory" ];
  }
  if( j.find( "samplerYcbcrConversion" ) != j.end() ) {
    p.samplerYcbcrConversion = j[ "samplerYcbcrConversion" ];
  }
  if( j.find( "shaderDrawParameters" ) != j.end() ) {
    p.shaderDrawParameters = j[ "shaderDrawParameters" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceVulkan11Features &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceVulkan11Features temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVulkan11Features ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ShaderStageFlags.hpp>
#include <vulkan2json/SubgroupFeatureFlags.hpp>
#include <vulkan2json/PointClippingBehavior.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceVulkan11Properties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceUUID" ] = nlohmann::json::array();
  std::copy( p.deviceUUID.begin(), p.deviceUUID.end(), std::back_inserter( j[ "deviceUUID" ] ) );
  j[ "driverUUID" ] = nlohmann::json::array();
  std::copy( p.driverUUID.begin(), p.driverUUID.end(), std::back_inserter( j[ "driverUUID" ] ) );
  j[ "deviceLUID" ] = nlohmann::json::array();
  std::copy( p.deviceLUID.begin(), p.deviceLUID.end(), std::back_inserter( j[ "deviceLUID" ] ) );
  j[ "deviceNodeMask" ] = p.deviceNodeMask;
  j[ "deviceLUIDValid" ] = bool( p.deviceLUIDValid );
  j[ "subgroupSize" ] = p.subgroupSize;
  j[ "subgroupSupportedStages" ] = p.subgroupSupportedStages;
  j[ "subgroupSupportedOperations" ] = p.subgroupSupportedOperations;
  j[ "subgroupQuadOperationsInAllStages" ] = bool( p.subgroupQuadOperationsInAllStages );
  j[ "pointClippingBehavior" ] = p.pointClippingBehavior;
  j[ "maxMultiviewViewCount" ] = p.maxMultiviewViewCount;
  j[ "maxMultiviewInstanceIndex" ] = p.maxMultiviewInstanceIndex;
  j[ "protectedNoFault" ] = bool( p.protectedNoFault );
  j[ "maxPerSetDescriptors" ] = p.maxPerSetDescriptors;
  j[ "maxMemoryAllocationSize" ] = p.maxMemoryAllocationSize;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceVulkan11Properties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceVulkan11Properties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceVulkan11Properties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVulkan11Properties" );
  if( j.find( "deviceUUID" ) != j.end() ) {
    if( !j[ "deviceUUID" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceVulkan11Properties.deviceUUID" );
    if( !j[ "deviceUUID" ].size() > p.deviceUUID.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceVulkan11Properties.deviceUUID" );
    std::fill( p.deviceUUID.begin(), p.deviceUUID.end(), 0 );
    std::copy( j[ "deviceUUID" ].begin(), j[ "deviceUUID" ].end(), p.deviceUUID.begin() );
  }
  if( j.find( "driverUUID" ) != j.end() ) {
    if( !j[ "driverUUID" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceVulkan11Properties.driverUUID" );
    if( !j[ "driverUUID" ].size() > p.driverUUID.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceVulkan11Properties.driverUUID" );
    std::fill( p.driverUUID.begin(), p.driverUUID.end(), 0 );
    std::copy( j[ "driverUUID" ].begin(), j[ "driverUUID" ].end(), p.driverUUID.begin() );
  }
  if( j.find( "deviceLUID" ) != j.end() ) {
    if( !j[ "deviceLUID" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceVulkan11Properties.deviceLUID" );
    if( !j[ "deviceLUID" ].size() > p.deviceLUID.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceVulkan11Properties.deviceLUID" );
    std::fill( p.deviceLUID.begin(), p.deviceLUID.end(), 0 );
    std::copy( j[ "deviceLUID" ].begin(), j[ "deviceLUID" ].end(), p.deviceLUID.begin() );
  }
  if( j.find( "deviceNodeMask" ) != j.end() ) {
    p.deviceNodeMask = j[ "deviceNodeMask" ];
  }
  if( j.find( "deviceLUIDValid" ) != j.end() ) {
    p.deviceLUIDValid = j[ "deviceLUIDValid" ];
  }
  if( j.find( "subgroupSize" ) != j.end() ) {
    p.subgroupSize = j[ "subgroupSize" ];
  }
  if( j.find( "subgroupSupportedStages" ) != j.end() ) {
    p.subgroupSupportedStages = ShaderStageFlags ( j[ "subgroupSupportedStages" ] );
  }
  if( j.find( "subgroupSupportedOperations" ) != j.end() ) {
    p.subgroupSupportedOperations = SubgroupFeatureFlags ( j[ "subgroupSupportedOperations" ] );
  }
  if( j.find( "subgroupQuadOperationsInAllStages" ) != j.end() ) {
    p.subgroupQuadOperationsInAllStages = j[ "subgroupQuadOperationsInAllStages" ];
  }
  if( j.find( "pointClippingBehavior" ) != j.end() ) {
    p.pointClippingBehavior = PointClippingBehavior ( j[ "pointClippingBehavior" ] );
  }
  if( j.find( "maxMultiviewViewCount" ) != j.end() ) {
    p.maxMultiviewViewCount = j[ "maxMultiviewViewCount" ];
  }
  if( j.find( "maxMultiviewInstanceIndex" ) != j.end() ) {
    p.maxMultiviewInstanceIndex = j[ "maxMultiviewInstanceIndex" ];
  }
  if( j.find( "protectedNoFault" ) != j.end() ) {
    p.protectedNoFault = j[ "protectedNoFault" ];
  }
  if( j.find( "maxPerSetDescriptors" ) != j.end() ) {
    p.maxPerSetDescriptors = j[ "maxPerSetDescriptors" ];
  }
  if( j.find( "maxMemoryAllocationSize" ) != j.end() ) {
    p.maxMemoryAllocationSize = j[ "maxMemoryAllocationSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceVulkan11Properties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceVulkan11Properties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVulkan11Properties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceVulkan12Features &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "samplerMirrorClampToEdge" ] = bool( p.samplerMirrorClampToEdge );
  j[ "drawIndirectCount" ] = bool( p.drawIndirectCount );
  j[ "storageBuffer8BitAccess" ] = bool( p.storageBuffer8BitAccess );
  j[ "uniformAndStorageBuffer8BitAccess" ] = bool( p.uniformAndStorageBuffer8BitAccess );
  j[ "storagePushConstant8" ] = bool( p.storagePushConstant8 );
  j[ "shaderBufferInt64Atomics" ] = bool( p.shaderBufferInt64Atomics );
  j[ "shaderSharedInt64Atomics" ] = bool( p.shaderSharedInt64Atomics );
  j[ "shaderFloat16" ] = bool( p.shaderFloat16 );
  j[ "shaderInt8" ] = bool( p.shaderInt8 );
  j[ "descriptorIndexing" ] = bool( p.descriptorIndexing );
  j[ "shaderInputAttachmentArrayDynamicIndexing" ] = bool( p.shaderInputAttachmentArrayDynamicIndexing );
  j[ "shaderUniformTexelBufferArrayDynamicIndexing" ] = bool( p.shaderUniformTexelBufferArrayDynamicIndexing );
  j[ "shaderStorageTexelBufferArrayDynamicIndexing" ] = bool( p.shaderStorageTexelBufferArrayDynamicIndexing );
  j[ "shaderUniformBufferArrayNonUniformIndexing" ] = bool( p.shaderUniformBufferArrayNonUniformIndexing );
  j[ "shaderSampledImageArrayNonUniformIndexing" ] = bool( p.shaderSampledImageArrayNonUniformIndexing );
  j[ "shaderStorageBufferArrayNonUniformIndexing" ] = bool( p.shaderStorageBufferArrayNonUniformIndexing );
  j[ "shaderStorageImageArrayNonUniformIndexing" ] = bool( p.shaderStorageImageArrayNonUniformIndexing );
  j[ "shaderInputAttachmentArrayNonUniformIndexing" ] = bool( p.shaderInputAttachmentArrayNonUniformIndexing );
  j[ "shaderUniformTexelBufferArrayNonUniformIndexing" ] = bool( p.shaderUniformTexelBufferArrayNonUniformIndexing );
  j[ "shaderStorageTexelBufferArrayNonUniformIndexing" ] = bool( p.shaderStorageTexelBufferArrayNonUniformIndexing );
  j[ "descriptorBindingUniformBufferUpdateAfterBind" ] = bool( p.descriptorBindingUniformBufferUpdateAfterBind );
  j[ "descriptorBindingSampledImageUpdateAfterBind" ] = bool( p.descriptorBindingSampledImageUpdateAfterBind );
  j[ "descriptorBindingStorageImageUpdateAfterBind" ] = bool( p.descriptorBindingStorageImageUpdateAfterBind );
  j[ "descriptorBindingStorageBufferUpdateAfterBind" ] = bool( p.descriptorBindingStorageBufferUpdateAfterBind );
  j[ "descriptorBindingUniformTexelBufferUpdateAfterBind" ] = bool( p.descriptorBindingUniformTexelBufferUpdateAfterBind );
  j[ "descriptorBindingStorageTexelBufferUpdateAfterBind" ] = bool( p.descriptorBindingStorageTexelBufferUpdateAfterBind );
  j[ "descriptorBindingUpdateUnusedWhilePending" ] = bool( p.descriptorBindingUpdateUnusedWhilePending );
  j[ "descriptorBindingPartiallyBound" ] = bool( p.descriptorBindingPartiallyBound );
  j[ "descriptorBindingVariableDescriptorCount" ] = bool( p.descriptorBindingVariableDescriptorCount );
  j[ "runtimeDescriptorArray" ] = bool( p.runtimeDescriptorArray );
  j[ "samplerFilterMinmax" ] = bool( p.samplerFilterMinmax );
  j[ "scalarBlockLayout" ] = bool( p.scalarBlockLayout );
  j[ "imagelessFramebuffer" ] = bool( p.imagelessFramebuffer );
  j[ "uniformBufferStandardLayout" ] = bool( p.uniformBufferStandardLayout );
  j[ "shaderSubgroupExtendedTypes" ] = bool( p.shaderSubgroupExtendedTypes );
  j[ "separateDepthStencilLayouts" ] = bool( p.separateDepthStencilLayouts );
  j[ "hostQueryReset" ] = bool( p.hostQueryReset );
  j[ "timelineSemaphore" ] = bool( p.timelineSemaphore );
  j[ "bufferDeviceAddress" ] = bool( p.bufferDeviceAddress );
  j[ "bufferDeviceAddressCaptureReplay" ] = bool( p.bufferDeviceAddressCaptureReplay );
  j[ "bufferDeviceAddressMultiDevice" ] = bool( p.bufferDeviceAddressMultiDevice );
  j[ "vulkanMemoryModel" ] = bool( p.vulkanMemoryModel );
  j[ "vulkanMemoryModelDeviceScope" ] = bool( p.vulkanMemoryModelDeviceScope );
  j[ "vulkanMemoryModelAvailabilityVisibilityChains" ] = bool( p.vulkanMemoryModelAvailabilityVisibilityChains );
  j[ "shaderOutputViewportIndex" ] = bool( p.shaderOutputViewportIndex );
  j[ "shaderOutputLayer" ] = bool( p.shaderOutputLayer );
  j[ "subgroupBroadcastDynamicId" ] = bool( p.subgroupBroadcastDynamicId );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceVulkan12Features &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceVulkan12Features ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceVulkan12Features &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVulkan12Features" );
  if( j.find( "samplerMirrorClampToEdge" ) != j.end() ) {
    p.samplerMirrorClampToEdge = j[ "samplerMirrorClampToEdge" ];
  }
  if( j.find( "drawIndirectCount" ) != j.end() ) {
    p.drawIndirectCount = j[ "drawIndirectCount" ];
  }
  if( j.find( "storageBuffer8BitAccess" ) != j.end() ) {
    p.storageBuffer8BitAccess = j[ "storageBuffer8BitAccess" ];
  }
  if( j.find( "uniformAndStorageBuffer8BitAccess" ) != j.end() ) {
    p.uniformAndStorageBuffer8BitAccess = j[ "uniformAndStorageBuffer8BitAccess" ];
  }
  if( j.find( "storagePushConstant8" ) != j.end() ) {
    p.storagePushConstant8 = j[ "storagePushConstant8" ];
  }
  if( j.find( "shaderBufferInt64Atomics" ) != j.end() ) {
    p.shaderBufferInt64Atomics = j[ "shaderBufferInt64Atomics" ];
  }
  if( j.find( "shaderSharedInt64Atomics" ) != j.end() ) {
    p.shaderSharedInt64Atomics = j[ "shaderSharedInt64Atomics" ];
  }
  if( j.find( "shaderFloat16" ) != j.end() ) {
    p.shaderFloat16 = j[ "shaderFloat16" ];
  }
  if( j.find( "shaderInt8" ) != j.end() ) {
    p.shaderInt8 = j[ "shaderInt8" ];
  }
  if( j.find( "descriptorIndexing" ) != j.end() ) {
    p.descriptorIndexing = j[ "descriptorIndexing" ];
  }
  if( j.find( "shaderInputAttachmentArrayDynamicIndexing" ) != j.end() ) {
    p.shaderInputAttachmentArrayDynamicIndexing = j[ "shaderInputAttachmentArrayDynamicIndexing" ];
  }
  if( j.find( "shaderUniformTexelBufferArrayDynamicIndexing" ) != j.end() ) {
    p.shaderUniformTexelBufferArrayDynamicIndexing = j[ "shaderUniformTexelBufferArrayDynamicIndexing" ];
  }
  if( j.find( "shaderStorageTexelBufferArrayDynamicIndexing" ) != j.end() ) {
    p.shaderStorageTexelBufferArrayDynamicIndexing = j[ "shaderStorageTexelBufferArrayDynamicIndexing" ];
  }
  if( j.find( "shaderUniformBufferArrayNonUniformIndexing" ) != j.end() ) {
    p.shaderUniformBufferArrayNonUniformIndexing = j[ "shaderUniformBufferArrayNonUniformIndexing" ];
  }
  if( j.find( "shaderSampledImageArrayNonUniformIndexing" ) != j.end() ) {
    p.shaderSampledImageArrayNonUniformIndexing = j[ "shaderSampledImageArrayNonUniformIndexing" ];
  }
  if( j.find( "shaderStorageBufferArrayNonUniformIndexing" ) != j.end() ) {
    p.shaderStorageBufferArrayNonUniformIndexing = j[ "shaderStorageBufferArrayNonUniformIndexing" ];
  }
  if( j.find( "shaderStorageImageArrayNonUniformIndexing" ) != j.end() ) {
    p.shaderStorageImageArrayNonUniformIndexing = j[ "shaderStorageImageArrayNonUniformIndexing" ];
  }
  if( j.find( "shaderInputAttachmentArrayNonUniformIndexing" ) != j.end() ) {
    p.shaderInputAttachmentArrayNonUniformIndexing = j[ "shaderInputAttachmentArrayNonUniformIndexing" ];
  }
  if( j.find( "shaderUniformTexelBufferArrayNonUniformIndexing" ) != j.end() ) {
    p.shaderUniformTexelBufferArrayNonUniformIndexing = j[ "shaderUniformTexelBufferArrayNonUniformIndexing" ];
  }
  if( j.find( "shaderStorageTexelBufferArrayNonUniformIndexing" ) != j.end() ) {
    p.shaderStorageTexelBufferArrayNonUniformIndexing = j[ "shaderStorageTexelBufferArrayNonUniformIndexing" ];
  }
  if( j.find( "descriptorBindingUniformBufferUpdateAfterBind" ) != j.end() ) {
    p.descriptorBindingUniformBufferUpdateAfterBind = j[ "descriptorBindingUniformBufferUpdateAfterBind" ];
  }
  if( j.find( "descriptorBindingSampledImageUpdateAfterBind" ) != j.end() ) {
    p.descriptorBindingSampledImageUpdateAfterBind = j[ "descriptorBindingSampledImageUpdateAfterBind" ];
  }
  if( j.find( "descriptorBindingStorageImageUpdateAfterBind" ) != j.end() ) {
    p.descriptorBindingStorageImageUpdateAfterBind = j[ "descriptorBindingStorageImageUpdateAfterBind" ];
  }
  if( j.find( "descriptorBindingStorageBufferUpdateAfterBind" ) != j.end() ) {
    p.descriptorBindingStorageBufferUpdateAfterBind = j[ "descriptorBindingStorageBufferUpdateAfterBind" ];
  }
  if( j.find( "descriptorBindingUniformTexelBufferUpdateAfterBind" ) != j.end() ) {
    p.descriptorBindingUniformTexelBufferUpdateAfterBind = j[ "descriptorBindingUniformTexelBufferUpdateAfterBind" ];
  }
  if( j.find( "descriptorBindingStorageTexelBufferUpdateAfterBind" ) != j.end() ) {
    p.descriptorBindingStorageTexelBufferUpdateAfterBind = j[ "descriptorBindingStorageTexelBufferUpdateAfterBind" ];
  }
  if( j.find( "descriptorBindingUpdateUnusedWhilePending" ) != j.end() ) {
    p.descriptorBindingUpdateUnusedWhilePending = j[ "descriptorBindingUpdateUnusedWhilePending" ];
  }
  if( j.find( "descriptorBindingPartiallyBound" ) != j.end() ) {
    p.descriptorBindingPartiallyBound = j[ "descriptorBindingPartiallyBound" ];
  }
  if( j.find( "descriptorBindingVariableDescriptorCount" ) != j.end() ) {
    p.descriptorBindingVariableDescriptorCount = j[ "descriptorBindingVariableDescriptorCount" ];
  }
  if( j.find( "runtimeDescriptorArray" ) != j.end() ) {
    p.runtimeDescriptorArray = j[ "runtimeDescriptorArray" ];
  }
  if( j.find( "samplerFilterMinmax" ) != j.end() ) {
    p.samplerFilterMinmax = j[ "samplerFilterMinmax" ];
  }
  if( j.find( "scalarBlockLayout" ) != j.end() ) {
    p.scalarBlockLayout = j[ "scalarBlockLayout" ];
  }
  if( j.find( "imagelessFramebuffer" ) != j.end() ) {
    p.imagelessFramebuffer = j[ "imagelessFramebuffer" ];
  }
  if( j.find( "uniformBufferStandardLayout" ) != j.end() ) {
    p.uniformBufferStandardLayout = j[ "uniformBufferStandardLayout" ];
  }
  if( j.find( "shaderSubgroupExtendedTypes" ) != j.end() ) {
    p.shaderSubgroupExtendedTypes = j[ "shaderSubgroupExtendedTypes" ];
  }
  if( j.find( "separateDepthStencilLayouts" ) != j.end() ) {
    p.separateDepthStencilLayouts = j[ "separateDepthStencilLayouts" ];
  }
  if( j.find( "hostQueryReset" ) != j.end() ) {
    p.hostQueryReset = j[ "hostQueryReset" ];
  }
  if( j.find( "timelineSemaphore" ) != j.end() ) {
    p.timelineSemaphore = j[ "timelineSemaphore" ];
  }
  if( j.find( "bufferDeviceAddress" ) != j.end() ) {
    p.bufferDeviceAddress = j[ "bufferDeviceAddress" ];
  }
  if( j.find( "bufferDeviceAddressCaptureReplay" ) != j.end() ) {
    p.bufferDeviceAddressCaptureReplay = j[ "bufferDeviceAddressCaptureReplay" ];
  }
  if( j.find( "bufferDeviceAddressMultiDevice" ) != j.end() ) {
    p.bufferDeviceAddressMultiDevice = j[ "bufferDeviceAddressMultiDevice" ];
  }
  if( j.find( "vulkanMemoryModel" ) != j.end() ) {
    p.vulkanMemoryModel = j[ "vulkanMemoryModel" ];
  }
  if( j.find( "vulkanMemoryModelDeviceScope" ) != j.end() ) {
    p.vulkanMemoryModelDeviceScope = j[ "vulkanMemoryModelDeviceScope" ];
  }
  if( j.find( "vulkanMemoryModelAvailabilityVisibilityChains" ) != j.end() ) {
    p.vulkanMemoryModelAvailabilityVisibilityChains = j[ "vulkanMemoryModelAvailabilityVisibilityChains" ];
  }
  if( j.find( "shaderOutputViewportIndex" ) != j.end() ) {
    p.shaderOutputViewportIndex = j[ "shaderOutputViewportIndex" ];
  }
  if( j.find( "shaderOutputLayer" ) != j.end() ) {
    p.shaderOutputLayer = j[ "shaderOutputLayer" ];
  }
  if( j.find( "subgroupBroadcastDynamicId" ) != j.end() ) {
    p.subgroupBroadcastDynamicId = j[ "subgroupBroadcastDynamicId" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceVulkan12Features &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceVulkan12Features temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVulkan12Features ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DriverId.hpp>
#include <vulkan2json/ConformanceVersion.hpp>
#include <vulkan2json/ShaderFloatControlsIndependence.hpp>
#include <vulkan2json/ShaderFloatControlsIndependence.hpp>
#include <vulkan2json/ResolveModeFlags.hpp>
#include <vulkan2json/ResolveModeFlags.hpp>
#include <vulkan2json/SampleCountFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceVulkan12Properties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "driverID" ] = p.driverID;
  j[ "driverName" ] = std::string( p.driverName.begin(), std::find( p.driverName.begin(), p.driverName.end(), '\0' ) );
  j[ "driverInfo" ] = std::string( p.driverInfo.begin(), std::find( p.driverInfo.begin(), p.driverInfo.end(), '\0' ) );
  j[ "conformanceVersion" ] = p.conformanceVersion;
  j[ "denormBehaviorIndependence" ] = p.denormBehaviorIndependence;
  j[ "roundingModeIndependence" ] = p.roundingModeIndependence;
  j[ "shaderSignedZeroInfNanPreserveFloat16" ] = bool( p.shaderSignedZeroInfNanPreserveFloat16 );
  j[ "shaderSignedZeroInfNanPreserveFloat32" ] = bool( p.shaderSignedZeroInfNanPreserveFloat32 );
  j[ "shaderSignedZeroInfNanPreserveFloat64" ] = bool( p.shaderSignedZeroInfNanPreserveFloat64 );
  j[ "shaderDenormPreserveFloat16" ] = bool( p.shaderDenormPreserveFloat16 );
  j[ "shaderDenormPreserveFloat32" ] = bool( p.shaderDenormPreserveFloat32 );
  j[ "shaderDenormPreserveFloat64" ] = bool( p.shaderDenormPreserveFloat64 );
  j[ "shaderDenormFlushToZeroFloat16" ] = bool( p.shaderDenormFlushToZeroFloat16 );
  j[ "shaderDenormFlushToZeroFloat32" ] = bool( p.shaderDenormFlushToZeroFloat32 );
  j[ "shaderDenormFlushToZeroFloat64" ] = bool( p.shaderDenormFlushToZeroFloat64 );
  j[ "shaderRoundingModeRTEFloat16" ] = bool( p.shaderRoundingModeRTEFloat16 );
  j[ "shaderRoundingModeRTEFloat32" ] = bool( p.shaderRoundingModeRTEFloat32 );
  j[ "shaderRoundingModeRTEFloat64" ] = bool( p.shaderRoundingModeRTEFloat64 );
  j[ "shaderRoundingModeRTZFloat16" ] = bool( p.shaderRoundingModeRTZFloat16 );
  j[ "shaderRoundingModeRTZFloat32" ] = bool( p.shaderRoundingModeRTZFloat32 );
  j[ "shaderRoundingModeRTZFloat64" ] = bool( p.shaderRoundingModeRTZFloat64 );
  j[ "maxUpdateAfterBindDescriptorsInAllPools" ] = p.maxUpdateAfterBindDescriptorsInAllPools;
  j[ "shaderUniformBufferArrayNonUniformIndexingNative" ] = bool( p.shaderUniformBufferArrayNonUniformIndexingNative );
  j[ "shaderSampledImageArrayNonUniformIndexingNative" ] = bool( p.shaderSampledImageArrayNonUniformIndexingNative );
  j[ "shaderStorageBufferArrayNonUniformIndexingNative" ] = bool( p.shaderStorageBufferArrayNonUniformIndexingNative );
  j[ "shaderStorageImageArrayNonUniformIndexingNative" ] = bool( p.shaderStorageImageArrayNonUniformIndexingNative );
  j[ "shaderInputAttachmentArrayNonUniformIndexingNative" ] = bool( p.shaderInputAttachmentArrayNonUniformIndexingNative );
  j[ "robustBufferAccessUpdateAfterBind" ] = bool( p.robustBufferAccessUpdateAfterBind );
  j[ "quadDivergentImplicitLod" ] = bool( p.quadDivergentImplicitLod );
  j[ "maxPerStageDescriptorUpdateAfterBindSamplers" ] = p.maxPerStageDescriptorUpdateAfterBindSamplers;
  j[ "maxPerStageDescriptorUpdateAfterBindUniformBuffers" ] = p.maxPerStageDescriptorUpdateAfterBindUniformBuffers;
  j[ "maxPerStageDescriptorUpdateAfterBindStorageBuffers" ] = p.maxPerStageDescriptorUpdateAfterBindStorageBuffers;
  j[ "maxPerStageDescriptorUpdateAfterBindSampledImages" ] = p.maxPerStageDescriptorUpdateAfterBindSampledImages;
  j[ "maxPerStageDescriptorUpdateAfterBindStorageImages" ] = p.maxPerStageDescriptorUpdateAfterBindStorageImages;
  j[ "maxPerStageDescriptorUpdateAfterBindInputAttachments" ] = p.maxPerStageDescriptorUpdateAfterBindInputAttachments;
  j[ "maxPerStageUpdateAfterBindResources" ] = p.maxPerStageUpdateAfterBindResources;
  j[ "maxDescriptorSetUpdateAfterBindSamplers" ] = p.maxDescriptorSetUpdateAfterBindSamplers;
  j[ "maxDescriptorSetUpdateAfterBindUniformBuffers" ] = p.maxDescriptorSetUpdateAfterBindUniformBuffers;
  j[ "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic" ] = p.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
  j[ "maxDescriptorSetUpdateAfterBindStorageBuffers" ] = p.maxDescriptorSetUpdateAfterBindStorageBuffers;
  j[ "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic" ] = p.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
  j[ "maxDescriptorSetUpdateAfterBindSampledImages" ] = p.maxDescriptorSetUpdateAfterBindSampledImages;
  j[ "maxDescriptorSetUpdateAfterBindStorageImages" ] = p.maxDescriptorSetUpdateAfterBindStorageImages;
  j[ "maxDescriptorSetUpdateAfterBindInputAttachments" ] = p.maxDescriptorSetUpdateAfterBindInputAttachments;
  j[ "supportedDepthResolveModes" ] = p.supportedDepthResolveModes;
  j[ "supportedStencilResolveModes" ] = p.supportedStencilResolveModes;
  j[ "independentResolveNone" ] = bool( p.independentResolveNone );
  j[ "independentResolve" ] = bool( p.independentResolve );
  j[ "filterMinmaxSingleComponentFormats" ] = bool( p.filterMinmaxSingleComponentFormats );
  j[ "filterMinmaxImageComponentMapping" ] = bool( p.filterMinmaxImageComponentMapping );
  j[ "maxTimelineSemaphoreValueDifference" ] = p.maxTimelineSemaphoreValueDifference;
  j[ "framebufferIntegerColorSampleCounts" ] = p.framebufferIntegerColorSampleCounts;
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceVulkan12Properties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceVulkan12Properties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceVulkan12Properties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVulkan12Properties" );
  if( j.find( "driverID" ) != j.end() ) {
    p.driverID = DriverId ( j[ "driverID" ] );
  }
  if( j.find( "driverName" ) != j.end() ) {
    {
      std::string s = j[ "driverName" ];
      if( !p.driverName.empty() ) {
        p.driverName[ p.driverName.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.driverName.size() - 1u ) ), p.driverName.begin() );
      }
    }
  }
  if( j.find( "driverInfo" ) != j.end() ) {
    {
      std::string s = j[ "driverInfo" ];
      if( !p.driverInfo.empty() ) {
        p.driverInfo[ p.driverInfo.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.driverInfo.size() - 1u ) ), p.driverInfo.begin() );
      }
    }
  }
  if( j.find( "conformanceVersion" ) != j.end() ) {
    p.conformanceVersion = ConformanceVersion ( j[ "conformanceVersion" ] );
  }
  if( j.find( "denormBehaviorIndependence" ) != j.end() ) {
    p.denormBehaviorIndependence = ShaderFloatControlsIndependence ( j[ "denormBehaviorIndependence" ] );
  }
  if( j.find( "roundingModeIndependence" ) != j.end() ) {
    p.roundingModeIndependence = ShaderFloatControlsIndependence ( j[ "roundingModeIndependence" ] );
  }
  if( j.find( "shaderSignedZeroInfNanPreserveFloat16" ) != j.end() ) {
    p.shaderSignedZeroInfNanPreserveFloat16 = j[ "shaderSignedZeroInfNanPreserveFloat16" ];
  }
  if( j.find( "shaderSignedZeroInfNanPreserveFloat32" ) != j.end() ) {
    p.shaderSignedZeroInfNanPreserveFloat32 = j[ "shaderSignedZeroInfNanPreserveFloat32" ];
  }
  if( j.find( "shaderSignedZeroInfNanPreserveFloat64" ) != j.end() ) {
    p.shaderSignedZeroInfNanPreserveFloat64 = j[ "shaderSignedZeroInfNanPreserveFloat64" ];
  }
  if( j.find( "shaderDenormPreserveFloat16" ) != j.end() ) {
    p.shaderDenormPreserveFloat16 = j[ "shaderDenormPreserveFloat16" ];
  }
  if( j.find( "shaderDenormPreserveFloat32" ) != j.end() ) {
    p.shaderDenormPreserveFloat32 = j[ "shaderDenormPreserveFloat32" ];
  }
  if( j.find( "shaderDenormPreserveFloat64" ) != j.end() ) {
    p.shaderDenormPreserveFloat64 = j[ "shaderDenormPreserveFloat64" ];
  }
  if( j.find( "shaderDenormFlushToZeroFloat16" ) != j.end() ) {
    p.shaderDenormFlushToZeroFloat16 = j[ "shaderDenormFlushToZeroFloat16" ];
  }
  if( j.find( "shaderDenormFlushToZeroFloat32" ) != j.end() ) {
    p.shaderDenormFlushToZeroFloat32 = j[ "shaderDenormFlushToZeroFloat32" ];
  }
  if( j.find( "shaderDenormFlushToZeroFloat64" ) != j.end() ) {
    p.shaderDenormFlushToZeroFloat64 = j[ "shaderDenormFlushToZeroFloat64" ];
  }
  if( j.find( "shaderRoundingModeRTEFloat16" ) != j.end() ) {
    p.shaderRoundingModeRTEFloat16 = j[ "shaderRoundingModeRTEFloat16" ];
  }
  if( j.find( "shaderRoundingModeRTEFloat32" ) != j.end() ) {
    p.shaderRoundingModeRTEFloat32 = j[ "shaderRoundingModeRTEFloat32" ];
  }
  if( j.find( "shaderRoundingModeRTEFloat64" ) != j.end() ) {
    p.shaderRoundingModeRTEFloat64 = j[ "shaderRoundingModeRTEFloat64" ];
  }
  if( j.find( "shaderRoundingModeRTZFloat16" ) != j.end() ) {
    p.shaderRoundingModeRTZFloat16 = j[ "shaderRoundingModeRTZFloat16" ];
  }
  if( j.find( "shaderRoundingModeRTZFloat32" ) != j.end() ) {
    p.shaderRoundingModeRTZFloat32 = j[ "shaderRoundingModeRTZFloat32" ];
  }
  if( j.find( "shaderRoundingModeRTZFloat64" ) != j.end() ) {
    p.shaderRoundingModeRTZFloat64 = j[ "shaderRoundingModeRTZFloat64" ];
  }
  if( j.find( "maxUpdateAfterBindDescriptorsInAllPools" ) != j.end() ) {
    p.maxUpdateAfterBindDescriptorsInAllPools = j[ "maxUpdateAfterBindDescriptorsInAllPools" ];
  }
  if( j.find( "shaderUniformBufferArrayNonUniformIndexingNative" ) != j.end() ) {
    p.shaderUniformBufferArrayNonUniformIndexingNative = j[ "shaderUniformBufferArrayNonUniformIndexingNative" ];
  }
  if( j.find( "shaderSampledImageArrayNonUniformIndexingNative" ) != j.end() ) {
    p.shaderSampledImageArrayNonUniformIndexingNative = j[ "shaderSampledImageArrayNonUniformIndexingNative" ];
  }
  if( j.find( "shaderStorageBufferArrayNonUniformIndexingNative" ) != j.end() ) {
    p.shaderStorageBufferArrayNonUniformIndexingNative = j[ "shaderStorageBufferArrayNonUniformIndexingNative" ];
  }
  if( j.find( "shaderStorageImageArrayNonUniformIndexingNative" ) != j.end() ) {
    p.shaderStorageImageArrayNonUniformIndexingNative = j[ "shaderStorageImageArrayNonUniformIndexingNative" ];
  }
  if( j.find( "shaderInputAttachmentArrayNonUniformIndexingNative" ) != j.end() ) {
    p.shaderInputAttachmentArrayNonUniformIndexingNative = j[ "shaderInputAttachmentArrayNonUniformIndexingNative" ];
  }
  if( j.find( "robustBufferAccessUpdateAfterBind" ) != j.end() ) {
    p.robustBufferAccessUpdateAfterBind = j[ "robustBufferAccessUpdateAfterBind" ];
  }
  if( j.find( "quadDivergentImplicitLod" ) != j.end() ) {
    p.quadDivergentImplicitLod = j[ "quadDivergentImplicitLod" ];
  }
  if( j.find( "maxPerStageDescriptorUpdateAfterBindSamplers" ) != j.end() ) {
    p.maxPerStageDescriptorUpdateAfterBindSamplers = j[ "maxPerStageDescriptorUpdateAfterBindSamplers" ];
  }
  if( j.find( "maxPerStageDescriptorUpdateAfterBindUniformBuffers" ) != j.end() ) {
    p.maxPerStageDescriptorUpdateAfterBindUniformBuffers = j[ "maxPerStageDescriptorUpdateAfterBindUniformBuffers" ];
  }
  if( j.find( "maxPerStageDescriptorUpdateAfterBindStorageBuffers" ) != j.end() ) {
    p.maxPerStageDescriptorUpdateAfterBindStorageBuffers = j[ "maxPerStageDescriptorUpdateAfterBindStorageBuffers" ];
  }
  if( j.find( "maxPerStageDescriptorUpdateAfterBindSampledImages" ) != j.end() ) {
    p.maxPerStageDescriptorUpdateAfterBindSampledImages = j[ "maxPerStageDescriptorUpdateAfterBindSampledImages" ];
  }
  if( j.find( "maxPerStageDescriptorUpdateAfterBindStorageImages" ) != j.end() ) {
    p.maxPerStageDescriptorUpdateAfterBindStorageImages = j[ "maxPerStageDescriptorUpdateAfterBindStorageImages" ];
  }
  if( j.find( "maxPerStageDescriptorUpdateAfterBindInputAttachments" ) != j.end() ) {
    p.maxPerStageDescriptorUpdateAfterBindInputAttachments = j[ "maxPerStageDescriptorUpdateAfterBindInputAttachments" ];
  }
  if( j.find( "maxPerStageUpdateAfterBindResources" ) != j.end() ) {
    p.maxPerStageUpdateAfterBindResources = j[ "maxPerStageUpdateAfterBindResources" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindSamplers" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindSamplers = j[ "maxDescriptorSetUpdateAfterBindSamplers" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindUniformBuffers" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindUniformBuffers = j[ "maxDescriptorSetUpdateAfterBindUniformBuffers" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = j[ "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindStorageBuffers" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindStorageBuffers = j[ "maxDescriptorSetUpdateAfterBindStorageBuffers" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = j[ "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindSampledImages" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindSampledImages = j[ "maxDescriptorSetUpdateAfterBindSampledImages" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindStorageImages" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindStorageImages = j[ "maxDescriptorSetUpdateAfterBindStorageImages" ];
  }
  if( j.find( "maxDescriptorSetUpdateAfterBindInputAttachments" ) != j.end() ) {
    p.maxDescriptorSetUpdateAfterBindInputAttachments = j[ "maxDescriptorSetUpdateAfterBindInputAttachments" ];
  }
  if( j.find( "supportedDepthResolveModes" ) != j.end() ) {
    p.supportedDepthResolveModes = ResolveModeFlags ( j[ "supportedDepthResolveModes" ] );
  }
  if( j.find( "supportedStencilResolveModes" ) != j.end() ) {
    p.supportedStencilResolveModes = ResolveModeFlags ( j[ "supportedStencilResolveModes" ] );
  }
  if( j.find( "independentResolveNone" ) != j.end() ) {
    p.independentResolveNone = j[ "independentResolveNone" ];
  }
  if( j.find( "independentResolve" ) != j.end() ) {
    p.independentResolve = j[ "independentResolve" ];
  }
  if( j.find( "filterMinmaxSingleComponentFormats" ) != j.end() ) {
    p.filterMinmaxSingleComponentFormats = j[ "filterMinmaxSingleComponentFormats" ];
  }
  if( j.find( "filterMinmaxImageComponentMapping" ) != j.end() ) {
    p.filterMinmaxImageComponentMapping = j[ "filterMinmaxImageComponentMapping" ];
  }
  if( j.find( "maxTimelineSemaphoreValueDifference" ) != j.end() ) {
    p.maxTimelineSemaphoreValueDifference = j[ "maxTimelineSemaphoreValueDifference" ];
  }
  if( j.find( "framebufferIntegerColorSampleCounts" ) != j.end() ) {
    p.framebufferIntegerColorSampleCounts = SampleCountFlags ( j[ "framebufferIntegerColorSampleCounts" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceVulkan12Properties &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceVulkan12Properties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVulkan12Properties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceVulkanMemoryModelFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "vulkanMemoryModel" ] = bool( p.vulkanMemoryModel );
  j[ "vulkanMemoryModelDeviceScope" ] = bool( p.vulkanMemoryModelDeviceScope );
  j[ "vulkanMemoryModelAvailabilityVisibilityChains" ] = bool( p.vulkanMemoryModelAvailabilityVisibilityChains );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceVulkanMemoryModelFeatures &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceVulkanMemoryModelFeatures ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceVulkanMemoryModelFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVulkanMemoryModelFeatures" );
  if( j.find( "vulkanMemoryModel" ) != j.end() ) {
    p.vulkanMemoryModel = j[ "vulkanMemoryModel" ];
  }
  if( j.find( "vulkanMemoryModelDeviceScope" ) != j.end() ) {
    p.vulkanMemoryModelDeviceScope = j[ "vulkanMemoryModelDeviceScope" ];
  }
  if( j.find( "vulkanMemoryModelAvailabilityVisibilityChains" ) != j.end() ) {
    p.vulkanMemoryModelAvailabilityVisibilityChains = j[ "vulkanMemoryModelAvailabilityVisibilityChains" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceVulkanMemoryModelFeatures &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceVulkanMemoryModelFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVulkanMemoryModelFeatures ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "workgroupMemoryExplicitLayout" ] = bool( p.workgroupMemoryExplicitLayout );
  j[ "workgroupMemoryExplicitLayoutScalarBlockLayout" ] = bool( p.workgroupMemoryExplicitLayoutScalarBlockLayout );
  j[ "workgroupMemoryExplicitLayout8BitAccess" ] = bool( p.workgroupMemoryExplicitLayout8BitAccess );
  j[ "workgroupMemoryExplicitLayout16BitAccess" ] = bool( p.workgroupMemoryExplicitLayout16BitAccess );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR" );
  if( j.find( "workgroupMemoryExplicitLayout" ) != j.end() ) {
    p.workgroupMemoryExplicitLayout = j[ "workgroupMemoryExplicitLayout" ];
  }
  if( j.find( "workgroupMemoryExplicitLayoutScalarBlockLayout" ) != j.end() ) {
    p.workgroupMemoryExplicitLayoutScalarBlockLayout = j[ "workgroupMemoryExplicitLayoutScalarBlockLayout" ];
  }
  if( j.find( "workgroupMemoryExplicitLayout8BitAccess" ) != j.end() ) {
    p.workgroupMemoryExplicitLayout8BitAccess = j[ "workgroupMemoryExplicitLayout8BitAccess" ];
  }
  if( j.find( "workgroupMemoryExplicitLayout16BitAccess" ) != j.end() ) {
    p.workgroupMemoryExplicitLayout16BitAccess = j[ "workgroupMemoryExplicitLayout16BitAccess" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "ycbcr2plane444Formats" ] = bool( p.ycbcr2plane444Formats );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT" );
  if( j.find( "ycbcr2plane444Formats" ) != j.end() ) {
    p.ycbcr2plane444Formats = j[ "ycbcr2plane444Formats" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceYcbcrImageArraysFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "ycbcrImageArrays" ] = bool( p.ycbcrImageArrays );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceYcbcrImageArraysFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceYcbcrImageArraysFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceYcbcrImageArraysFeaturesEXT" );
  if( j.find( "ycbcrImageArrays" ) != j.end() ) {
    p.ycbcrImageArrays = j[ "ycbcrImageArrays" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceYcbcrImageArraysFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceYcbcrImageArraysFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderZeroInitializeWorkgroupMemory" ] = bool( p.shaderZeroInitializeWorkgroupMemory );
}
}
void to_json( nlohmann::json &j, const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR" );
  if( j.find( "shaderZeroInitializeWorkgroupMemory" ) != j.end() ) {
    p.shaderZeroInitializeWorkgroupMemory = j[ "shaderZeroInitializeWorkgroupMemory" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineCacheCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCacheCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "initialDataSize" ] = p.initialDataSize;
  j[ "pInitialData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pInitialData ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineCacheCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineCacheCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineCacheCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineCacheCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineCacheCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "initialDataSize" ) != j.end() ) {
    p.initialDataSize = j[ "initialDataSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineCacheCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineCacheCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineCacheCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/BlendOverlapEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineColorBlendAdvancedStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcPremultiplied" ] = bool( p.srcPremultiplied );
  j[ "dstPremultiplied" ] = bool( p.dstPremultiplied );
  j[ "blendOverlap" ] = p.blendOverlap;
}
}
void to_json( nlohmann::json &j, const VkPipelineColorBlendAdvancedStateCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineColorBlendAdvancedStateCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineColorBlendAdvancedStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineColorBlendAdvancedStateCreateInfoEXT" );
  if( j.find( "srcPremultiplied" ) != j.end() ) {
    p.srcPremultiplied = j[ "srcPremultiplied" ];
  }
  if( j.find( "dstPremultiplied" ) != j.end() ) {
    p.dstPremultiplied = j[ "dstPremultiplied" ];
  }
  if( j.find( "blendOverlap" ) != j.end() ) {
    p.blendOverlap = BlendOverlapEXT ( j[ "blendOverlap" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineColorBlendAdvancedStateCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineColorBlendAdvancedStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineColorBlendAdvancedStateCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineColorWriteCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "attachmentCount" ] = p.attachmentCount;
  j[ "pColorWriteEnables" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pColorWriteEnables ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineColorWriteCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineColorWriteCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineColorWriteCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineColorWriteCreateInfoEXT" );
  if( j.find( "attachmentCount" ) != j.end() ) {
    p.attachmentCount = j[ "attachmentCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineColorWriteCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineColorWriteCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineColorWriteCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineCompilerControlFlagsAMD.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCompilerControlCreateInfoAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "compilerControlFlags" ] = p.compilerControlFlags;
}
}
void to_json( nlohmann::json &j, const VkPipelineCompilerControlCreateInfoAMD &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineCompilerControlCreateInfoAMD ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineCompilerControlCreateInfoAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineCompilerControlCreateInfoAMD" );
  if( j.find( "compilerControlFlags" ) != j.end() ) {
    p.compilerControlFlags = PipelineCompilerControlFlagsAMD ( j[ "compilerControlFlags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineCompilerControlCreateInfoAMD &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineCompilerControlCreateInfoAMD temp;
  from_json( j, temp );
  p = VkPipelineCompilerControlCreateInfoAMD ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineCoverageModulationStateCreateFlagsNV.hpp>
#include <vulkan2json/CoverageModulationModeNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCoverageModulationStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "coverageModulationMode" ] = p.coverageModulationMode;
  j[ "coverageModulationTableEnable" ] = bool( p.coverageModulationTableEnable );
  j[ "coverageModulationTableCount" ] = p.coverageModulationTableCount;
  j[ "pCoverageModulationTable" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCoverageModulationTable ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineCoverageModulationStateCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineCoverageModulationStateCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineCoverageModulationStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineCoverageModulationStateCreateInfoNV" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineCoverageModulationStateCreateFlagsNV ( j[ "flags" ] );
  }
  if( j.find( "coverageModulationMode" ) != j.end() ) {
    p.coverageModulationMode = CoverageModulationModeNV ( j[ "coverageModulationMode" ] );
  }
  if( j.find( "coverageModulationTableEnable" ) != j.end() ) {
    p.coverageModulationTableEnable = j[ "coverageModulationTableEnable" ];
  }
  if( j.find( "coverageModulationTableCount" ) != j.end() ) {
    p.coverageModulationTableCount = j[ "coverageModulationTableCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineCoverageModulationStateCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineCoverageModulationStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineCoverageModulationStateCreateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineCoverageReductionStateCreateFlagsNV.hpp>
#include <vulkan2json/CoverageReductionModeNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCoverageReductionStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "coverageReductionMode" ] = p.coverageReductionMode;
}
}
void to_json( nlohmann::json &j, const VkPipelineCoverageReductionStateCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineCoverageReductionStateCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineCoverageReductionStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineCoverageReductionStateCreateInfoNV" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineCoverageReductionStateCreateFlagsNV ( j[ "flags" ] );
  }
  if( j.find( "coverageReductionMode" ) != j.end() ) {
    p.coverageReductionMode = CoverageReductionModeNV ( j[ "coverageReductionMode" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineCoverageReductionStateCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineCoverageReductionStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineCoverageReductionStateCreateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineCoverageToColorStateCreateFlagsNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCoverageToColorStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "coverageToColorEnable" ] = bool( p.coverageToColorEnable );
  j[ "coverageToColorLocation" ] = p.coverageToColorLocation;
}
}
void to_json( nlohmann::json &j, const VkPipelineCoverageToColorStateCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineCoverageToColorStateCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineCoverageToColorStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineCoverageToColorStateCreateInfoNV" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineCoverageToColorStateCreateFlagsNV ( j[ "flags" ] );
  }
  if( j.find( "coverageToColorEnable" ) != j.end() ) {
    p.coverageToColorEnable = j[ "coverageToColorEnable" ];
  }
  if( j.find( "coverageToColorLocation" ) != j.end() ) {
    p.coverageToColorLocation = j[ "coverageToColorLocation" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineCoverageToColorStateCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineCoverageToColorStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineCoverageToColorStateCreateInfoNV ( temp );
}
#include <vulkan2json/PipelineCreationFeedbackFlagsEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCreationFeedbackEXT &p ) {
  j = nlohmann::json::object();
  j[ "flags" ] = p.flags;
  j[ "duration" ] = p.duration;
}
}
void to_json( nlohmann::json &j, const VkPipelineCreationFeedbackEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineCreationFeedbackEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineCreationFeedbackEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineCreationFeedbackEXT" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineCreationFeedbackFlagsEXT ( j[ "flags" ] );
  }
  if( j.find( "duration" ) != j.end() ) {
    p.duration = j[ "duration" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineCreationFeedbackEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineCreationFeedbackEXT temp;
  from_json( j, temp );
  p = VkPipelineCreationFeedbackEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineCreationFeedbackCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pPipelineCreationFeedback" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPipelineCreationFeedback ) );
  j[ "pipelineStageCreationFeedbackCount" ] = p.pipelineStageCreationFeedbackCount;
  j[ "pPipelineStageCreationFeedbacks" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPipelineStageCreationFeedbacks ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineCreationFeedbackCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineCreationFeedbackCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineCreationFeedbackCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineCreationFeedbackCreateInfoEXT" );
  if( j.find( "pipelineStageCreationFeedbackCount" ) != j.end() ) {
    p.pipelineStageCreationFeedbackCount = j[ "pipelineStageCreationFeedbackCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineCreationFeedbackCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineCreationFeedbackCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineCreationFeedbackCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineDiscardRectangleStateCreateFlagsEXT.hpp>
#include <vulkan2json/DiscardRectangleModeEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineDiscardRectangleStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "discardRectangleMode" ] = p.discardRectangleMode;
  j[ "discardRectangleCount" ] = p.discardRectangleCount;
  j[ "pDiscardRectangles" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDiscardRectangles ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineDiscardRectangleStateCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineDiscardRectangleStateCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineDiscardRectangleStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineDiscardRectangleStateCreateInfoEXT" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineDiscardRectangleStateCreateFlagsEXT ( j[ "flags" ] );
  }
  if( j.find( "discardRectangleMode" ) != j.end() ) {
    p.discardRectangleMode = DiscardRectangleModeEXT ( j[ "discardRectangleMode" ] );
  }
  if( j.find( "discardRectangleCount" ) != j.end() ) {
    p.discardRectangleCount = j[ "discardRectangleCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineDiscardRectangleStateCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineDiscardRectangleStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineDiscardRectangleStateCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineExecutableInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "executableIndex" ] = p.executableIndex;
}
}
void to_json( nlohmann::json &j, const VkPipelineExecutableInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineExecutableInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineExecutableInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineExecutableInfoKHR" );
  if( j.find( "executableIndex" ) != j.end() ) {
    p.executableIndex = j[ "executableIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineExecutableInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineExecutableInfoKHR temp;
  from_json( j, temp );
  p = VkPipelineExecutableInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineExecutableInternalRepresentationKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "name" ] = std::string( p.name.begin(), std::find( p.name.begin(), p.name.end(), '\0' ) );
  j[ "description" ] = std::string( p.description.begin(), std::find( p.description.begin(), p.description.end(), '\0' ) );
  j[ "isText" ] = bool( p.isText );
  j[ "dataSize" ] = p.dataSize;
  j[ "pData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pData ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineExecutableInternalRepresentationKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineExecutableInternalRepresentationKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineExecutableInternalRepresentationKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineExecutableInternalRepresentationKHR" );
  if( j.find( "name" ) != j.end() ) {
    {
      std::string s = j[ "name" ];
      if( !p.name.empty() ) {
        p.name[ p.name.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.name.size() - 1u ) ), p.name.begin() );
      }
    }
  }
  if( j.find( "description" ) != j.end() ) {
    {
      std::string s = j[ "description" ];
      if( !p.description.empty() ) {
        p.description[ p.description.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.description.size() - 1u ) ), p.description.begin() );
      }
    }
  }
  if( j.find( "isText" ) != j.end() ) {
    p.isText = j[ "isText" ];
  }
  if( j.find( "dataSize" ) != j.end() ) {
    p.dataSize = j[ "dataSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineExecutableInternalRepresentationKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineExecutableInternalRepresentationKHR temp;
  from_json( j, temp );
  p = VkPipelineExecutableInternalRepresentationKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ShaderStageFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineExecutablePropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stages" ] = p.stages;
  j[ "name" ] = std::string( p.name.begin(), std::find( p.name.begin(), p.name.end(), '\0' ) );
  j[ "description" ] = std::string( p.description.begin(), std::find( p.description.begin(), p.description.end(), '\0' ) );
  j[ "subgroupSize" ] = p.subgroupSize;
}
}
void to_json( nlohmann::json &j, const VkPipelineExecutablePropertiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineExecutablePropertiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineExecutablePropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineExecutablePropertiesKHR" );
  if( j.find( "stages" ) != j.end() ) {
    p.stages = ShaderStageFlags ( j[ "stages" ] );
  }
  if( j.find( "name" ) != j.end() ) {
    {
      std::string s = j[ "name" ];
      if( !p.name.empty() ) {
        p.name[ p.name.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.name.size() - 1u ) ), p.name.begin() );
      }
    }
  }
  if( j.find( "description" ) != j.end() ) {
    {
      std::string s = j[ "description" ];
      if( !p.description.empty() ) {
        p.description[ p.description.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.description.size() - 1u ) ), p.description.begin() );
      }
    }
  }
  if( j.find( "subgroupSize" ) != j.end() ) {
    p.subgroupSize = j[ "subgroupSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineExecutablePropertiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineExecutablePropertiesKHR temp;
  from_json( j, temp );
  p = VkPipelineExecutablePropertiesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineExecutableStatisticFormatKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineExecutableStatisticKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "name" ] = std::string( p.name.begin(), std::find( p.name.begin(), p.name.end(), '\0' ) );
  j[ "description" ] = std::string( p.description.begin(), std::find( p.description.begin(), p.description.end(), '\0' ) );
  j[ "format" ] = p.format;
}
}
void to_json( nlohmann::json &j, const VkPipelineExecutableStatisticKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineExecutableStatisticKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineExecutableStatisticKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineExecutableStatisticKHR" );
  if( j.find( "name" ) != j.end() ) {
    {
      std::string s = j[ "name" ];
      if( !p.name.empty() ) {
        p.name[ p.name.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.name.size() - 1u ) ), p.name.begin() );
      }
    }
  }
  if( j.find( "description" ) != j.end() ) {
    {
      std::string s = j[ "description" ];
      if( !p.description.empty() ) {
        p.description[ p.description.size() - 1u ] = '\0';
        std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.description.size() - 1u ) ), p.description.begin() );
      }
    }
  }
  if( j.find( "format" ) != j.end() ) {
    p.format = PipelineExecutableStatisticFormatKHR ( j[ "format" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineExecutableStatisticKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineExecutableStatisticKHR temp;
  from_json( j, temp );
  p = VkPipelineExecutableStatisticKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/FragmentShadingRateTypeNV.hpp>
#include <vulkan2json/FragmentShadingRateNV.hpp>
#include <vulkan2json/FragmentShadingRateCombinerOpKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineFragmentShadingRateEnumStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shadingRateType" ] = p.shadingRateType;
  j[ "shadingRate" ] = p.shadingRate;
  j[ "combinerOps" ] = nlohmann::json::array();
  std::copy( p.combinerOps.begin(), p.combinerOps.end(), std::back_inserter( j[ "combinerOps" ] ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineFragmentShadingRateEnumStateCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineFragmentShadingRateEnumStateCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineFragmentShadingRateEnumStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineFragmentShadingRateEnumStateCreateInfoNV" );
  if( j.find( "shadingRateType" ) != j.end() ) {
    p.shadingRateType = FragmentShadingRateTypeNV ( j[ "shadingRateType" ] );
  }
  if( j.find( "shadingRate" ) != j.end() ) {
    p.shadingRate = FragmentShadingRateNV ( j[ "shadingRate" ] );
  }
  if( j.find( "combinerOps" ) != j.end() ) {
    if( !j[ "combinerOps" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PipelineFragmentShadingRateEnumStateCreateInfoNV.combinerOps" );
    if( !j[ "combinerOps" ].size() > p.combinerOps.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for PipelineFragmentShadingRateEnumStateCreateInfoNV.combinerOps" );
    std::fill( p.combinerOps.begin(), p.combinerOps.end(), FragmentShadingRateCombinerOpKHR () );
    std::transform( j[ "combinerOps" ].begin(), j[ "combinerOps" ].end(), p.combinerOps.begin(), []( const auto &v ) { return FragmentShadingRateCombinerOpKHR ( v ); } );
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineFragmentShadingRateEnumStateCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineFragmentShadingRateEnumStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineFragmentShadingRateEnumStateCreateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/FragmentShadingRateCombinerOpKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineFragmentShadingRateStateCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fragmentSize" ] = p.fragmentSize;
  j[ "combinerOps" ] = nlohmann::json::array();
  std::copy( p.combinerOps.begin(), p.combinerOps.end(), std::back_inserter( j[ "combinerOps" ] ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineFragmentShadingRateStateCreateInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineFragmentShadingRateStateCreateInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineFragmentShadingRateStateCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineFragmentShadingRateStateCreateInfoKHR" );
  if( j.find( "fragmentSize" ) != j.end() ) {
    p.fragmentSize = Extent2D ( j[ "fragmentSize" ] );
  }
  if( j.find( "combinerOps" ) != j.end() ) {
    if( !j[ "combinerOps" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PipelineFragmentShadingRateStateCreateInfoKHR.combinerOps" );
    if( !j[ "combinerOps" ].size() > p.combinerOps.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for PipelineFragmentShadingRateStateCreateInfoKHR.combinerOps" );
    std::fill( p.combinerOps.begin(), p.combinerOps.end(), FragmentShadingRateCombinerOpKHR () );
    std::transform( j[ "combinerOps" ].begin(), j[ "combinerOps" ].end(), p.combinerOps.begin(), []( const auto &v ) { return FragmentShadingRateCombinerOpKHR ( v ); } );
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineFragmentShadingRateStateCreateInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineFragmentShadingRateStateCreateInfoKHR temp;
  from_json( j, temp );
  p = VkPipelineFragmentShadingRateStateCreateInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineInfoKHR" );
}
}
void from_json( const nlohmann::json &j, VkPipelineInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineInfoKHR temp;
  from_json( j, temp );
  p = VkPipelineInfoKHR ( temp );
}
#include <vulkan2json/ShaderStageFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PushConstantRange &p ) {
  j = nlohmann::json::object();
  j[ "stageFlags" ] = p.stageFlags;
  j[ "offset" ] = p.offset;
  j[ "size" ] = p.size;
}
}
void to_json( nlohmann::json &j, const VkPushConstantRange &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PushConstantRange ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PushConstantRange &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PushConstantRange" );
  if( j.find( "stageFlags" ) != j.end() ) {
    p.stageFlags = ShaderStageFlags ( j[ "stageFlags" ] );
  }
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPushConstantRange &p ) {
  VULKAN_HPP_NAMESPACE :: PushConstantRange temp;
  from_json( j, temp );
  p = VkPushConstantRange ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineLayoutCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineLayoutCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "setLayoutCount" ] = p.setLayoutCount;
  j[ "pSetLayouts" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSetLayouts ) );
  j[ "pushConstantRangeCount" ] = p.pushConstantRangeCount;
  j[ "pPushConstantRanges" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPushConstantRanges ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineLayoutCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineLayoutCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineLayoutCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineLayoutCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineLayoutCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "setLayoutCount" ) != j.end() ) {
    p.setLayoutCount = j[ "setLayoutCount" ];
  }
  if( j.find( "pushConstantRangeCount" ) != j.end() ) {
    p.pushConstantRangeCount = j[ "pushConstantRangeCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineLayoutCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineLayoutCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineLayoutCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineLibraryCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "libraryCount" ] = p.libraryCount;
  j[ "pLibraries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pLibraries ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineLibraryCreateInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineLibraryCreateInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineLibraryCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineLibraryCreateInfoKHR" );
  if( j.find( "libraryCount" ) != j.end() ) {
    p.libraryCount = j[ "libraryCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineLibraryCreateInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineLibraryCreateInfoKHR temp;
  from_json( j, temp );
  p = VkPipelineLibraryCreateInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineRasterizationConservativeStateCreateFlagsEXT.hpp>
#include <vulkan2json/ConservativeRasterizationModeEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineRasterizationConservativeStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "conservativeRasterizationMode" ] = p.conservativeRasterizationMode;
  j[ "extraPrimitiveOverestimationSize" ] = p.extraPrimitiveOverestimationSize;
}
}
void to_json( nlohmann::json &j, const VkPipelineRasterizationConservativeStateCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineRasterizationConservativeStateCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineRasterizationConservativeStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRasterizationConservativeStateCreateInfoEXT" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineRasterizationConservativeStateCreateFlagsEXT ( j[ "flags" ] );
  }
  if( j.find( "conservativeRasterizationMode" ) != j.end() ) {
    p.conservativeRasterizationMode = ConservativeRasterizationModeEXT ( j[ "conservativeRasterizationMode" ] );
  }
  if( j.find( "extraPrimitiveOverestimationSize" ) != j.end() ) {
    p.extraPrimitiveOverestimationSize = j[ "extraPrimitiveOverestimationSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineRasterizationConservativeStateCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineRasterizationConservativeStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineRasterizationConservativeStateCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineRasterizationDepthClipStateCreateFlagsEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineRasterizationDepthClipStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "depthClipEnable" ] = bool( p.depthClipEnable );
}
}
void to_json( nlohmann::json &j, const VkPipelineRasterizationDepthClipStateCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineRasterizationDepthClipStateCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineRasterizationDepthClipStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRasterizationDepthClipStateCreateInfoEXT" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineRasterizationDepthClipStateCreateFlagsEXT ( j[ "flags" ] );
  }
  if( j.find( "depthClipEnable" ) != j.end() ) {
    p.depthClipEnable = j[ "depthClipEnable" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineRasterizationDepthClipStateCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineRasterizationDepthClipStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineRasterizationDepthClipStateCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/LineRasterizationModeEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineRasterizationLineStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "lineRasterizationMode" ] = p.lineRasterizationMode;
  j[ "stippledLineEnable" ] = bool( p.stippledLineEnable );
  j[ "lineStippleFactor" ] = p.lineStippleFactor;
  j[ "lineStipplePattern" ] = p.lineStipplePattern;
}
}
void to_json( nlohmann::json &j, const VkPipelineRasterizationLineStateCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineRasterizationLineStateCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineRasterizationLineStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRasterizationLineStateCreateInfoEXT" );
  if( j.find( "lineRasterizationMode" ) != j.end() ) {
    p.lineRasterizationMode = LineRasterizationModeEXT ( j[ "lineRasterizationMode" ] );
  }
  if( j.find( "stippledLineEnable" ) != j.end() ) {
    p.stippledLineEnable = j[ "stippledLineEnable" ];
  }
  if( j.find( "lineStippleFactor" ) != j.end() ) {
    p.lineStippleFactor = j[ "lineStippleFactor" ];
  }
  if( j.find( "lineStipplePattern" ) != j.end() ) {
    p.lineStipplePattern = j[ "lineStipplePattern" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineRasterizationLineStateCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineRasterizationLineStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineRasterizationLineStateCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ProvokingVertexModeEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineRasterizationProvokingVertexStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "provokingVertexMode" ] = p.provokingVertexMode;
}
}
void to_json( nlohmann::json &j, const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineRasterizationProvokingVertexStateCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineRasterizationProvokingVertexStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRasterizationProvokingVertexStateCreateInfoEXT" );
  if( j.find( "provokingVertexMode" ) != j.end() ) {
    p.provokingVertexMode = ProvokingVertexModeEXT ( j[ "provokingVertexMode" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineRasterizationProvokingVertexStateCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineRasterizationProvokingVertexStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineRasterizationProvokingVertexStateCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/RasterizationOrderAMD.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineRasterizationStateRasterizationOrderAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "rasterizationOrder" ] = p.rasterizationOrder;
}
}
void to_json( nlohmann::json &j, const VkPipelineRasterizationStateRasterizationOrderAMD &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineRasterizationStateRasterizationOrderAMD ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineRasterizationStateRasterizationOrderAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRasterizationStateRasterizationOrderAMD" );
  if( j.find( "rasterizationOrder" ) != j.end() ) {
    p.rasterizationOrder = RasterizationOrderAMD ( j[ "rasterizationOrder" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineRasterizationStateRasterizationOrderAMD &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineRasterizationStateRasterizationOrderAMD temp;
  from_json( j, temp );
  p = VkPipelineRasterizationStateRasterizationOrderAMD ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineRasterizationStateStreamCreateFlagsEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineRasterizationStateStreamCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "rasterizationStream" ] = p.rasterizationStream;
}
}
void to_json( nlohmann::json &j, const VkPipelineRasterizationStateStreamCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineRasterizationStateStreamCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineRasterizationStateStreamCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRasterizationStateStreamCreateInfoEXT" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineRasterizationStateStreamCreateFlagsEXT ( j[ "flags" ] );
  }
  if( j.find( "rasterizationStream" ) != j.end() ) {
    p.rasterizationStream = j[ "rasterizationStream" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineRasterizationStateStreamCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineRasterizationStateStreamCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineRasterizationStateStreamCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineRepresentativeFragmentTestStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "representativeFragmentTestEnable" ] = bool( p.representativeFragmentTestEnable );
}
}
void to_json( nlohmann::json &j, const VkPipelineRepresentativeFragmentTestStateCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineRepresentativeFragmentTestStateCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineRepresentativeFragmentTestStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRepresentativeFragmentTestStateCreateInfoNV" );
  if( j.find( "representativeFragmentTestEnable" ) != j.end() ) {
    p.representativeFragmentTestEnable = j[ "representativeFragmentTestEnable" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineRepresentativeFragmentTestStateCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineRepresentativeFragmentTestStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineRepresentativeFragmentTestStateCreateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SampleLocationsInfoEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineSampleLocationsStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "sampleLocationsEnable" ] = bool( p.sampleLocationsEnable );
  j[ "sampleLocationsInfo" ] = p.sampleLocationsInfo;
}
}
void to_json( nlohmann::json &j, const VkPipelineSampleLocationsStateCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineSampleLocationsStateCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineSampleLocationsStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineSampleLocationsStateCreateInfoEXT" );
  if( j.find( "sampleLocationsEnable" ) != j.end() ) {
    p.sampleLocationsEnable = j[ "sampleLocationsEnable" ];
  }
  if( j.find( "sampleLocationsInfo" ) != j.end() ) {
    p.sampleLocationsInfo = SampleLocationsInfoEXT ( j[ "sampleLocationsInfo" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineSampleLocationsStateCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineSampleLocationsStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineSampleLocationsStateCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "requiredSubgroupSize" ] = p.requiredSubgroupSize;
}
}
void to_json( nlohmann::json &j, const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT" );
  if( j.find( "requiredSubgroupSize" ) != j.end() ) {
    p.requiredSubgroupSize = j[ "requiredSubgroupSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/TessellationDomainOrigin.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineTessellationDomainOriginStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "domainOrigin" ] = p.domainOrigin;
}
}
void to_json( nlohmann::json &j, const VkPipelineTessellationDomainOriginStateCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineTessellationDomainOriginStateCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineTessellationDomainOriginStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineTessellationDomainOriginStateCreateInfo" );
  if( j.find( "domainOrigin" ) != j.end() ) {
    p.domainOrigin = TessellationDomainOrigin ( j[ "domainOrigin" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineTessellationDomainOriginStateCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineTessellationDomainOriginStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineTessellationDomainOriginStateCreateInfo ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const VertexInputBindingDivisorDescriptionEXT &p ) {
  j = nlohmann::json::object();
  j[ "binding" ] = p.binding;
  j[ "divisor" ] = p.divisor;
}
}
void to_json( nlohmann::json &j, const VkVertexInputBindingDivisorDescriptionEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: VertexInputBindingDivisorDescriptionEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, VertexInputBindingDivisorDescriptionEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VertexInputBindingDivisorDescriptionEXT" );
  if( j.find( "binding" ) != j.end() ) {
    p.binding = j[ "binding" ];
  }
  if( j.find( "divisor" ) != j.end() ) {
    p.divisor = j[ "divisor" ];
  }
}
}
void from_json( const nlohmann::json &j, VkVertexInputBindingDivisorDescriptionEXT &p ) {
  VULKAN_HPP_NAMESPACE :: VertexInputBindingDivisorDescriptionEXT temp;
  from_json( j, temp );
  p = VkVertexInputBindingDivisorDescriptionEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineVertexInputDivisorStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "vertexBindingDivisorCount" ] = p.vertexBindingDivisorCount;
  j[ "pVertexBindingDivisors" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pVertexBindingDivisors ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineVertexInputDivisorStateCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineVertexInputDivisorStateCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineVertexInputDivisorStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineVertexInputDivisorStateCreateInfoEXT" );
  if( j.find( "vertexBindingDivisorCount" ) != j.end() ) {
    p.vertexBindingDivisorCount = j[ "vertexBindingDivisorCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineVertexInputDivisorStateCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineVertexInputDivisorStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineVertexInputDivisorStateCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/CoarseSampleOrderTypeNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineViewportCoarseSampleOrderStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "sampleOrderType" ] = p.sampleOrderType;
  j[ "customSampleOrderCount" ] = p.customSampleOrderCount;
  j[ "pCustomSampleOrders" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCustomSampleOrders ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineViewportCoarseSampleOrderStateCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineViewportCoarseSampleOrderStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineViewportCoarseSampleOrderStateCreateInfoNV" );
  if( j.find( "sampleOrderType" ) != j.end() ) {
    p.sampleOrderType = CoarseSampleOrderTypeNV ( j[ "sampleOrderType" ] );
  }
  if( j.find( "customSampleOrderCount" ) != j.end() ) {
    p.customSampleOrderCount = j[ "customSampleOrderCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineViewportCoarseSampleOrderStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineViewportCoarseSampleOrderStateCreateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineViewportExclusiveScissorStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "exclusiveScissorCount" ] = p.exclusiveScissorCount;
  j[ "pExclusiveScissors" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pExclusiveScissors ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineViewportExclusiveScissorStateCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineViewportExclusiveScissorStateCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineViewportExclusiveScissorStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineViewportExclusiveScissorStateCreateInfoNV" );
  if( j.find( "exclusiveScissorCount" ) != j.end() ) {
    p.exclusiveScissorCount = j[ "exclusiveScissorCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineViewportExclusiveScissorStateCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineViewportExclusiveScissorStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineViewportExclusiveScissorStateCreateInfoNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ShadingRatePaletteNV &p ) {
  j = nlohmann::json::object();
  j[ "shadingRatePaletteEntryCount" ] = p.shadingRatePaletteEntryCount;
  j[ "pShadingRatePaletteEntries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pShadingRatePaletteEntries ) );
}
}
void to_json( nlohmann::json &j, const VkShadingRatePaletteNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ShadingRatePaletteNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ShadingRatePaletteNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ShadingRatePaletteNV" );
  if( j.find( "shadingRatePaletteEntryCount" ) != j.end() ) {
    p.shadingRatePaletteEntryCount = j[ "shadingRatePaletteEntryCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkShadingRatePaletteNV &p ) {
  VULKAN_HPP_NAMESPACE :: ShadingRatePaletteNV temp;
  from_json( j, temp );
  p = VkShadingRatePaletteNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineViewportShadingRateImageStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shadingRateImageEnable" ] = bool( p.shadingRateImageEnable );
  j[ "viewportCount" ] = p.viewportCount;
  j[ "pShadingRatePalettes" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pShadingRatePalettes ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineViewportShadingRateImageStateCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineViewportShadingRateImageStateCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineViewportShadingRateImageStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineViewportShadingRateImageStateCreateInfoNV" );
  if( j.find( "shadingRateImageEnable" ) != j.end() ) {
    p.shadingRateImageEnable = j[ "shadingRateImageEnable" ];
  }
  if( j.find( "viewportCount" ) != j.end() ) {
    p.viewportCount = j[ "viewportCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineViewportShadingRateImageStateCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineViewportShadingRateImageStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineViewportShadingRateImageStateCreateInfoNV ( temp );
}
#include <vulkan2json/ViewportCoordinateSwizzleNV.hpp>
#include <vulkan2json/ViewportCoordinateSwizzleNV.hpp>
#include <vulkan2json/ViewportCoordinateSwizzleNV.hpp>
#include <vulkan2json/ViewportCoordinateSwizzleNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ViewportSwizzleNV &p ) {
  j = nlohmann::json::object();
  j[ "x" ] = p.x;
  j[ "y" ] = p.y;
  j[ "z" ] = p.z;
  j[ "w" ] = p.w;
}
}
void to_json( nlohmann::json &j, const VkViewportSwizzleNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ViewportSwizzleNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ViewportSwizzleNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ViewportSwizzleNV" );
  if( j.find( "x" ) != j.end() ) {
    p.x = ViewportCoordinateSwizzleNV ( j[ "x" ] );
  }
  if( j.find( "y" ) != j.end() ) {
    p.y = ViewportCoordinateSwizzleNV ( j[ "y" ] );
  }
  if( j.find( "z" ) != j.end() ) {
    p.z = ViewportCoordinateSwizzleNV ( j[ "z" ] );
  }
  if( j.find( "w" ) != j.end() ) {
    p.w = ViewportCoordinateSwizzleNV ( j[ "w" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkViewportSwizzleNV &p ) {
  VULKAN_HPP_NAMESPACE :: ViewportSwizzleNV temp;
  from_json( j, temp );
  p = VkViewportSwizzleNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineViewportSwizzleStateCreateFlagsNV.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineViewportSwizzleStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "viewportCount" ] = p.viewportCount;
  j[ "pViewportSwizzles" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewportSwizzles ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineViewportSwizzleStateCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineViewportSwizzleStateCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineViewportSwizzleStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineViewportSwizzleStateCreateInfoNV" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineViewportSwizzleStateCreateFlagsNV ( j[ "flags" ] );
  }
  if( j.find( "viewportCount" ) != j.end() ) {
    p.viewportCount = j[ "viewportCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineViewportSwizzleStateCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineViewportSwizzleStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineViewportSwizzleStateCreateInfoNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ViewportWScalingNV &p ) {
  j = nlohmann::json::object();
  j[ "xcoeff" ] = p.xcoeff;
  j[ "ycoeff" ] = p.ycoeff;
}
}
void to_json( nlohmann::json &j, const VkViewportWScalingNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ViewportWScalingNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ViewportWScalingNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ViewportWScalingNV" );
  if( j.find( "xcoeff" ) != j.end() ) {
    p.xcoeff = j[ "xcoeff" ];
  }
  if( j.find( "ycoeff" ) != j.end() ) {
    p.ycoeff = j[ "ycoeff" ];
  }
}
}
void from_json( const nlohmann::json &j, VkViewportWScalingNV &p ) {
  VULKAN_HPP_NAMESPACE :: ViewportWScalingNV temp;
  from_json( j, temp );
  p = VkViewportWScalingNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PipelineViewportWScalingStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "viewportWScalingEnable" ] = bool( p.viewportWScalingEnable );
  j[ "viewportCount" ] = p.viewportCount;
  j[ "pViewportWScalings" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewportWScalings ) );
}
}
void to_json( nlohmann::json &j, const VkPipelineViewportWScalingStateCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PipelineViewportWScalingStateCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PipelineViewportWScalingStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineViewportWScalingStateCreateInfoNV" );
  if( j.find( "viewportWScalingEnable" ) != j.end() ) {
    p.viewportWScalingEnable = j[ "viewportWScalingEnable" ];
  }
  if( j.find( "viewportCount" ) != j.end() ) {
    p.viewportCount = j[ "viewportCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPipelineViewportWScalingStateCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: PipelineViewportWScalingStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineViewportWScalingStateCreateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PresentInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "waitSemaphoreCount" ] = p.waitSemaphoreCount;
  j[ "pWaitSemaphores" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitSemaphores ) );
  j[ "swapchainCount" ] = p.swapchainCount;
  j[ "pSwapchains" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSwapchains ) );
  j[ "pImageIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pImageIndices ) );
  j[ "pResults" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pResults ) );
}
}
void to_json( nlohmann::json &j, const VkPresentInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PresentInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PresentInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PresentInfoKHR" );
  if( j.find( "waitSemaphoreCount" ) != j.end() ) {
    p.waitSemaphoreCount = j[ "waitSemaphoreCount" ];
  }
  if( j.find( "swapchainCount" ) != j.end() ) {
    p.swapchainCount = j[ "swapchainCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPresentInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PresentInfoKHR temp;
  from_json( j, temp );
  p = VkPresentInfoKHR ( temp );
}
#include <vulkan2json/Offset2D.hpp>
#include <vulkan2json/Extent2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RectLayerKHR &p ) {
  j = nlohmann::json::object();
  j[ "offset" ] = p.offset;
  j[ "extent" ] = p.extent;
  j[ "layer" ] = p.layer;
}
}
void to_json( nlohmann::json &j, const VkRectLayerKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RectLayerKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RectLayerKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RectLayerKHR" );
  if( j.find( "offset" ) != j.end() ) {
    p.offset = Offset2D ( j[ "offset" ] );
  }
  if( j.find( "extent" ) != j.end() ) {
    p.extent = Extent2D ( j[ "extent" ] );
  }
  if( j.find( "layer" ) != j.end() ) {
    p.layer = j[ "layer" ];
  }
}
}
void from_json( const nlohmann::json &j, VkRectLayerKHR &p ) {
  VULKAN_HPP_NAMESPACE :: RectLayerKHR temp;
  from_json( j, temp );
  p = VkRectLayerKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PresentRegionKHR &p ) {
  j = nlohmann::json::object();
  j[ "rectangleCount" ] = p.rectangleCount;
  j[ "pRectangles" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRectangles ) );
}
}
void to_json( nlohmann::json &j, const VkPresentRegionKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PresentRegionKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PresentRegionKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PresentRegionKHR" );
  if( j.find( "rectangleCount" ) != j.end() ) {
    p.rectangleCount = j[ "rectangleCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPresentRegionKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PresentRegionKHR temp;
  from_json( j, temp );
  p = VkPresentRegionKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PresentRegionsKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "swapchainCount" ] = p.swapchainCount;
  j[ "pRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRegions ) );
}
}
void to_json( nlohmann::json &j, const VkPresentRegionsKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PresentRegionsKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PresentRegionsKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PresentRegionsKHR" );
  if( j.find( "swapchainCount" ) != j.end() ) {
    p.swapchainCount = j[ "swapchainCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPresentRegionsKHR &p ) {
  VULKAN_HPP_NAMESPACE :: PresentRegionsKHR temp;
  from_json( j, temp );
  p = VkPresentRegionsKHR ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PresentTimeGOOGLE &p ) {
  j = nlohmann::json::object();
  j[ "presentID" ] = p.presentID;
  j[ "desiredPresentTime" ] = p.desiredPresentTime;
}
}
void to_json( nlohmann::json &j, const VkPresentTimeGOOGLE &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PresentTimeGOOGLE ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PresentTimeGOOGLE &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PresentTimeGOOGLE" );
  if( j.find( "presentID" ) != j.end() ) {
    p.presentID = j[ "presentID" ];
  }
  if( j.find( "desiredPresentTime" ) != j.end() ) {
    p.desiredPresentTime = j[ "desiredPresentTime" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPresentTimeGOOGLE &p ) {
  VULKAN_HPP_NAMESPACE :: PresentTimeGOOGLE temp;
  from_json( j, temp );
  p = VkPresentTimeGOOGLE ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PresentTimesInfoGOOGLE &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "swapchainCount" ] = p.swapchainCount;
  j[ "pTimes" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pTimes ) );
}
}
void to_json( nlohmann::json &j, const VkPresentTimesInfoGOOGLE &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PresentTimesInfoGOOGLE ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PresentTimesInfoGOOGLE &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PresentTimesInfoGOOGLE" );
  if( j.find( "swapchainCount" ) != j.end() ) {
    p.swapchainCount = j[ "swapchainCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkPresentTimesInfoGOOGLE &p ) {
  VULKAN_HPP_NAMESPACE :: PresentTimesInfoGOOGLE temp;
  from_json( j, temp );
  p = VkPresentTimesInfoGOOGLE ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PrivateDataSlotCreateFlagsEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const PrivateDataSlotCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkPrivateDataSlotCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: PrivateDataSlotCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, PrivateDataSlotCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PrivateDataSlotCreateInfoEXT" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PrivateDataSlotCreateFlagsEXT ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkPrivateDataSlotCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: PrivateDataSlotCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPrivateDataSlotCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ProtectedSubmitInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "protectedSubmit" ] = bool( p.protectedSubmit );
}
}
void to_json( nlohmann::json &j, const VkProtectedSubmitInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ProtectedSubmitInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ProtectedSubmitInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ProtectedSubmitInfo" );
  if( j.find( "protectedSubmit" ) != j.end() ) {
    p.protectedSubmit = j[ "protectedSubmit" ];
  }
}
}
void from_json( const nlohmann::json &j, VkProtectedSubmitInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ProtectedSubmitInfo temp;
  from_json( j, temp );
  p = VkProtectedSubmitInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/QueryPoolCreateFlags.hpp>
#include <vulkan2json/QueryType.hpp>
#include <vulkan2json/QueryPipelineStatisticFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const QueryPoolCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "queryType" ] = p.queryType;
  j[ "queryCount" ] = p.queryCount;
  j[ "pipelineStatistics" ] = p.pipelineStatistics;
}
}
void to_json( nlohmann::json &j, const VkQueryPoolCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: QueryPoolCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, QueryPoolCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueryPoolCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = QueryPoolCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "queryType" ) != j.end() ) {
    p.queryType = QueryType ( j[ "queryType" ] );
  }
  if( j.find( "queryCount" ) != j.end() ) {
    p.queryCount = j[ "queryCount" ];
  }
  if( j.find( "pipelineStatistics" ) != j.end() ) {
    p.pipelineStatistics = QueryPipelineStatisticFlags ( j[ "pipelineStatistics" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkQueryPoolCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: QueryPoolCreateInfo temp;
  from_json( j, temp );
  p = VkQueryPoolCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const QueryPoolPerformanceCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "queueFamilyIndex" ] = p.queueFamilyIndex;
  j[ "counterIndexCount" ] = p.counterIndexCount;
  j[ "pCounterIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCounterIndices ) );
}
}
void to_json( nlohmann::json &j, const VkQueryPoolPerformanceCreateInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: QueryPoolPerformanceCreateInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, QueryPoolPerformanceCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueryPoolPerformanceCreateInfoKHR" );
  if( j.find( "queueFamilyIndex" ) != j.end() ) {
    p.queueFamilyIndex = j[ "queueFamilyIndex" ];
  }
  if( j.find( "counterIndexCount" ) != j.end() ) {
    p.counterIndexCount = j[ "counterIndexCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkQueryPoolPerformanceCreateInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: QueryPoolPerformanceCreateInfoKHR temp;
  from_json( j, temp );
  p = VkQueryPoolPerformanceCreateInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/QueryPoolSamplingModeINTEL.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const QueryPoolPerformanceQueryCreateInfoINTEL &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "performanceCountersSampling" ] = p.performanceCountersSampling;
}
}
void to_json( nlohmann::json &j, const VkQueryPoolPerformanceQueryCreateInfoINTEL &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: QueryPoolPerformanceQueryCreateInfoINTEL ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, QueryPoolPerformanceQueryCreateInfoINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueryPoolPerformanceQueryCreateInfoINTEL" );
  if( j.find( "performanceCountersSampling" ) != j.end() ) {
    p.performanceCountersSampling = QueryPoolSamplingModeINTEL ( j[ "performanceCountersSampling" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkQueryPoolPerformanceQueryCreateInfoINTEL &p ) {
  VULKAN_HPP_NAMESPACE :: QueryPoolPerformanceQueryCreateInfoINTEL temp;
  from_json( j, temp );
  p = VkQueryPoolPerformanceQueryCreateInfoINTEL ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineStageFlags2KHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const QueueFamilyCheckpointProperties2NV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "checkpointExecutionStageMask" ] = p.checkpointExecutionStageMask;
}
}
void to_json( nlohmann::json &j, const VkQueueFamilyCheckpointProperties2NV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: QueueFamilyCheckpointProperties2NV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, QueueFamilyCheckpointProperties2NV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueueFamilyCheckpointProperties2NV" );
  if( j.find( "checkpointExecutionStageMask" ) != j.end() ) {
    p.checkpointExecutionStageMask = PipelineStageFlags2KHR ( j[ "checkpointExecutionStageMask" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkQueueFamilyCheckpointProperties2NV &p ) {
  VULKAN_HPP_NAMESPACE :: QueueFamilyCheckpointProperties2NV temp;
  from_json( j, temp );
  p = VkQueueFamilyCheckpointProperties2NV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineStageFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const QueueFamilyCheckpointPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "checkpointExecutionStageMask" ] = p.checkpointExecutionStageMask;
}
}
void to_json( nlohmann::json &j, const VkQueueFamilyCheckpointPropertiesNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: QueueFamilyCheckpointPropertiesNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, QueueFamilyCheckpointPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueueFamilyCheckpointPropertiesNV" );
  if( j.find( "checkpointExecutionStageMask" ) != j.end() ) {
    p.checkpointExecutionStageMask = PipelineStageFlags ( j[ "checkpointExecutionStageMask" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkQueueFamilyCheckpointPropertiesNV &p ) {
  VULKAN_HPP_NAMESPACE :: QueueFamilyCheckpointPropertiesNV temp;
  from_json( j, temp );
  p = VkQueueFamilyCheckpointPropertiesNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/QueueGlobalPriorityEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const QueueFamilyGlobalPriorityPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "priorityCount" ] = p.priorityCount;
  j[ "priorities" ] = nlohmann::json::array();
  std::copy( p.priorities.begin(), p.priorities.end(), std::back_inserter( j[ "priorities" ] ) );
}
}
void to_json( nlohmann::json &j, const VkQueueFamilyGlobalPriorityPropertiesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: QueueFamilyGlobalPriorityPropertiesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, QueueFamilyGlobalPriorityPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueueFamilyGlobalPriorityPropertiesEXT" );
  if( j.find( "priorityCount" ) != j.end() ) {
    p.priorityCount = j[ "priorityCount" ];
  }
  if( j.find( "priorities" ) != j.end() ) {
    if( !j[ "priorities" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for QueueFamilyGlobalPriorityPropertiesEXT.priorities" );
    if( !j[ "priorities" ].size() > p.priorities.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for QueueFamilyGlobalPriorityPropertiesEXT.priorities" );
    std::fill( p.priorities.begin(), p.priorities.end(), QueueGlobalPriorityEXT () );
    std::transform( j[ "priorities" ].begin(), j[ "priorities" ].end(), p.priorities.begin(), []( const auto &v ) { return QueueGlobalPriorityEXT ( v ); } );
  }
}
}
void from_json( const nlohmann::json &j, VkQueueFamilyGlobalPriorityPropertiesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: QueueFamilyGlobalPriorityPropertiesEXT temp;
  from_json( j, temp );
  p = VkQueueFamilyGlobalPriorityPropertiesEXT ( temp );
}
#include <vulkan2json/QueueFlags.hpp>
#include <vulkan2json/Extent3D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const QueueFamilyProperties &p ) {
  j = nlohmann::json::object();
  j[ "queueFlags" ] = p.queueFlags;
  j[ "queueCount" ] = p.queueCount;
  j[ "timestampValidBits" ] = p.timestampValidBits;
  j[ "minImageTransferGranularity" ] = p.minImageTransferGranularity;
}
}
void to_json( nlohmann::json &j, const VkQueueFamilyProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: QueueFamilyProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, QueueFamilyProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueueFamilyProperties" );
  if( j.find( "queueFlags" ) != j.end() ) {
    p.queueFlags = QueueFlags ( j[ "queueFlags" ] );
  }
  if( j.find( "queueCount" ) != j.end() ) {
    p.queueCount = j[ "queueCount" ];
  }
  if( j.find( "timestampValidBits" ) != j.end() ) {
    p.timestampValidBits = j[ "timestampValidBits" ];
  }
  if( j.find( "minImageTransferGranularity" ) != j.end() ) {
    p.minImageTransferGranularity = Extent3D ( j[ "minImageTransferGranularity" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkQueueFamilyProperties &p ) {
  VULKAN_HPP_NAMESPACE :: QueueFamilyProperties temp;
  from_json( j, temp );
  p = VkQueueFamilyProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/QueueFamilyProperties.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const QueueFamilyProperties2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "queueFamilyProperties" ] = p.queueFamilyProperties;
}
}
void to_json( nlohmann::json &j, const VkQueueFamilyProperties2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: QueueFamilyProperties2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, QueueFamilyProperties2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueueFamilyProperties2" );
  if( j.find( "queueFamilyProperties" ) != j.end() ) {
    p.queueFamilyProperties = QueueFamilyProperties ( j[ "queueFamilyProperties" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkQueueFamilyProperties2 &p ) {
  VULKAN_HPP_NAMESPACE :: QueueFamilyProperties2 temp;
  from_json( j, temp );
  p = VkQueueFamilyProperties2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/RayTracingShaderGroupTypeKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RayTracingShaderGroupCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "type" ] = p.type;
  j[ "generalShader" ] = p.generalShader;
  j[ "closestHitShader" ] = p.closestHitShader;
  j[ "anyHitShader" ] = p.anyHitShader;
  j[ "intersectionShader" ] = p.intersectionShader;
  j[ "pShaderGroupCaptureReplayHandle" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pShaderGroupCaptureReplayHandle ) );
}
}
void to_json( nlohmann::json &j, const VkRayTracingShaderGroupCreateInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RayTracingShaderGroupCreateInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RayTracingShaderGroupCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RayTracingShaderGroupCreateInfoKHR" );
  if( j.find( "type" ) != j.end() ) {
    p.type = RayTracingShaderGroupTypeKHR ( j[ "type" ] );
  }
  if( j.find( "generalShader" ) != j.end() ) {
    p.generalShader = j[ "generalShader" ];
  }
  if( j.find( "closestHitShader" ) != j.end() ) {
    p.closestHitShader = j[ "closestHitShader" ];
  }
  if( j.find( "anyHitShader" ) != j.end() ) {
    p.anyHitShader = j[ "anyHitShader" ];
  }
  if( j.find( "intersectionShader" ) != j.end() ) {
    p.intersectionShader = j[ "intersectionShader" ];
  }
}
}
void from_json( const nlohmann::json &j, VkRayTracingShaderGroupCreateInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: RayTracingShaderGroupCreateInfoKHR temp;
  from_json( j, temp );
  p = VkRayTracingShaderGroupCreateInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RayTracingPipelineInterfaceCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxPipelineRayPayloadSize" ] = p.maxPipelineRayPayloadSize;
  j[ "maxPipelineRayHitAttributeSize" ] = p.maxPipelineRayHitAttributeSize;
}
}
void to_json( nlohmann::json &j, const VkRayTracingPipelineInterfaceCreateInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RayTracingPipelineInterfaceCreateInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RayTracingPipelineInterfaceCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RayTracingPipelineInterfaceCreateInfoKHR" );
  if( j.find( "maxPipelineRayPayloadSize" ) != j.end() ) {
    p.maxPipelineRayPayloadSize = j[ "maxPipelineRayPayloadSize" ];
  }
  if( j.find( "maxPipelineRayHitAttributeSize" ) != j.end() ) {
    p.maxPipelineRayHitAttributeSize = j[ "maxPipelineRayHitAttributeSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkRayTracingPipelineInterfaceCreateInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: RayTracingPipelineInterfaceCreateInfoKHR temp;
  from_json( j, temp );
  p = VkRayTracingPipelineInterfaceCreateInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RayTracingPipelineCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "stageCount" ] = p.stageCount;
  j[ "pStages" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStages ) );
  j[ "groupCount" ] = p.groupCount;
  j[ "pGroups" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pGroups ) );
  j[ "maxPipelineRayRecursionDepth" ] = p.maxPipelineRayRecursionDepth;
  j[ "pLibraryInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pLibraryInfo ) );
  j[ "pLibraryInterface" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pLibraryInterface ) );
  j[ "pDynamicState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDynamicState ) );
  j[ "basePipelineIndex" ] = p.basePipelineIndex;
}
}
void to_json( nlohmann::json &j, const VkRayTracingPipelineCreateInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RayTracingPipelineCreateInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RayTracingPipelineCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RayTracingPipelineCreateInfoKHR" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "stageCount" ) != j.end() ) {
    p.stageCount = j[ "stageCount" ];
  }
  if( j.find( "groupCount" ) != j.end() ) {
    p.groupCount = j[ "groupCount" ];
  }
  if( j.find( "maxPipelineRayRecursionDepth" ) != j.end() ) {
    p.maxPipelineRayRecursionDepth = j[ "maxPipelineRayRecursionDepth" ];
  }
  if( j.find( "basePipelineIndex" ) != j.end() ) {
    p.basePipelineIndex = j[ "basePipelineIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkRayTracingPipelineCreateInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: RayTracingPipelineCreateInfoKHR temp;
  from_json( j, temp );
  p = VkRayTracingPipelineCreateInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/RayTracingShaderGroupTypeKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RayTracingShaderGroupCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "type" ] = p.type;
  j[ "generalShader" ] = p.generalShader;
  j[ "closestHitShader" ] = p.closestHitShader;
  j[ "anyHitShader" ] = p.anyHitShader;
  j[ "intersectionShader" ] = p.intersectionShader;
}
}
void to_json( nlohmann::json &j, const VkRayTracingShaderGroupCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RayTracingShaderGroupCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RayTracingShaderGroupCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RayTracingShaderGroupCreateInfoNV" );
  if( j.find( "type" ) != j.end() ) {
    p.type = RayTracingShaderGroupTypeKHR ( j[ "type" ] );
  }
  if( j.find( "generalShader" ) != j.end() ) {
    p.generalShader = j[ "generalShader" ];
  }
  if( j.find( "closestHitShader" ) != j.end() ) {
    p.closestHitShader = j[ "closestHitShader" ];
  }
  if( j.find( "anyHitShader" ) != j.end() ) {
    p.anyHitShader = j[ "anyHitShader" ];
  }
  if( j.find( "intersectionShader" ) != j.end() ) {
    p.intersectionShader = j[ "intersectionShader" ];
  }
}
}
void from_json( const nlohmann::json &j, VkRayTracingShaderGroupCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: RayTracingShaderGroupCreateInfoNV temp;
  from_json( j, temp );
  p = VkRayTracingShaderGroupCreateInfoNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RayTracingPipelineCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "stageCount" ] = p.stageCount;
  j[ "pStages" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStages ) );
  j[ "groupCount" ] = p.groupCount;
  j[ "pGroups" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pGroups ) );
  j[ "maxRecursionDepth" ] = p.maxRecursionDepth;
  j[ "basePipelineIndex" ] = p.basePipelineIndex;
}
}
void to_json( nlohmann::json &j, const VkRayTracingPipelineCreateInfoNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RayTracingPipelineCreateInfoNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RayTracingPipelineCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RayTracingPipelineCreateInfoNV" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = PipelineCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "stageCount" ) != j.end() ) {
    p.stageCount = j[ "stageCount" ];
  }
  if( j.find( "groupCount" ) != j.end() ) {
    p.groupCount = j[ "groupCount" ];
  }
  if( j.find( "maxRecursionDepth" ) != j.end() ) {
    p.maxRecursionDepth = j[ "maxRecursionDepth" ];
  }
  if( j.find( "basePipelineIndex" ) != j.end() ) {
    p.basePipelineIndex = j[ "basePipelineIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkRayTracingPipelineCreateInfoNV &p ) {
  VULKAN_HPP_NAMESPACE :: RayTracingPipelineCreateInfoNV temp;
  from_json( j, temp );
  p = VkRayTracingPipelineCreateInfoNV ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RefreshCycleDurationGOOGLE &p ) {
  j = nlohmann::json::object();
  j[ "refreshDuration" ] = p.refreshDuration;
}
}
void to_json( nlohmann::json &j, const VkRefreshCycleDurationGOOGLE &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RefreshCycleDurationGOOGLE ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RefreshCycleDurationGOOGLE &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RefreshCycleDurationGOOGLE" );
  if( j.find( "refreshDuration" ) != j.end() ) {
    p.refreshDuration = j[ "refreshDuration" ];
  }
}
}
void from_json( const nlohmann::json &j, VkRefreshCycleDurationGOOGLE &p ) {
  VULKAN_HPP_NAMESPACE :: RefreshCycleDurationGOOGLE temp;
  from_json( j, temp );
  p = VkRefreshCycleDurationGOOGLE ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RenderPassAttachmentBeginInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "attachmentCount" ] = p.attachmentCount;
  j[ "pAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttachments ) );
}
}
void to_json( nlohmann::json &j, const VkRenderPassAttachmentBeginInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RenderPassAttachmentBeginInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RenderPassAttachmentBeginInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassAttachmentBeginInfo" );
  if( j.find( "attachmentCount" ) != j.end() ) {
    p.attachmentCount = j[ "attachmentCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkRenderPassAttachmentBeginInfo &p ) {
  VULKAN_HPP_NAMESPACE :: RenderPassAttachmentBeginInfo temp;
  from_json( j, temp );
  p = VkRenderPassAttachmentBeginInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Rect2D.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RenderPassBeginInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "renderArea" ] = p.renderArea;
  j[ "clearValueCount" ] = p.clearValueCount;
  j[ "pClearValues" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pClearValues ) );
}
}
void to_json( nlohmann::json &j, const VkRenderPassBeginInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RenderPassBeginInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RenderPassBeginInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassBeginInfo" );
  if( j.find( "renderArea" ) != j.end() ) {
    p.renderArea = Rect2D ( j[ "renderArea" ] );
  }
  if( j.find( "clearValueCount" ) != j.end() ) {
    p.clearValueCount = j[ "clearValueCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkRenderPassBeginInfo &p ) {
  VULKAN_HPP_NAMESPACE :: RenderPassBeginInfo temp;
  from_json( j, temp );
  p = VkRenderPassBeginInfo ( temp );
}
#include <vulkan2json/SubpassDescriptionFlags.hpp>
#include <vulkan2json/PipelineBindPoint.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubpassDescription &p ) {
  j = nlohmann::json::object();
  j[ "flags" ] = p.flags;
  j[ "pipelineBindPoint" ] = p.pipelineBindPoint;
  j[ "inputAttachmentCount" ] = p.inputAttachmentCount;
  j[ "pInputAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pInputAttachments ) );
  j[ "colorAttachmentCount" ] = p.colorAttachmentCount;
  j[ "pColorAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pColorAttachments ) );
  j[ "pResolveAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pResolveAttachments ) );
  j[ "pDepthStencilAttachment" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDepthStencilAttachment ) );
  j[ "preserveAttachmentCount" ] = p.preserveAttachmentCount;
  j[ "pPreserveAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPreserveAttachments ) );
}
}
void to_json( nlohmann::json &j, const VkSubpassDescription &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SubpassDescription ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SubpassDescription &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassDescription" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = SubpassDescriptionFlags ( j[ "flags" ] );
  }
  if( j.find( "pipelineBindPoint" ) != j.end() ) {
    p.pipelineBindPoint = PipelineBindPoint ( j[ "pipelineBindPoint" ] );
  }
  if( j.find( "inputAttachmentCount" ) != j.end() ) {
    p.inputAttachmentCount = j[ "inputAttachmentCount" ];
  }
  if( j.find( "colorAttachmentCount" ) != j.end() ) {
    p.colorAttachmentCount = j[ "colorAttachmentCount" ];
  }
  if( j.find( "preserveAttachmentCount" ) != j.end() ) {
    p.preserveAttachmentCount = j[ "preserveAttachmentCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSubpassDescription &p ) {
  VULKAN_HPP_NAMESPACE :: SubpassDescription temp;
  from_json( j, temp );
  p = VkSubpassDescription ( temp );
}
#include <vulkan2json/PipelineStageFlags.hpp>
#include <vulkan2json/PipelineStageFlags.hpp>
#include <vulkan2json/AccessFlags.hpp>
#include <vulkan2json/AccessFlags.hpp>
#include <vulkan2json/DependencyFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubpassDependency &p ) {
  j = nlohmann::json::object();
  j[ "srcSubpass" ] = p.srcSubpass;
  j[ "dstSubpass" ] = p.dstSubpass;
  j[ "srcStageMask" ] = p.srcStageMask;
  j[ "dstStageMask" ] = p.dstStageMask;
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
  j[ "dependencyFlags" ] = p.dependencyFlags;
}
}
void to_json( nlohmann::json &j, const VkSubpassDependency &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SubpassDependency ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SubpassDependency &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassDependency" );
  if( j.find( "srcSubpass" ) != j.end() ) {
    p.srcSubpass = j[ "srcSubpass" ];
  }
  if( j.find( "dstSubpass" ) != j.end() ) {
    p.dstSubpass = j[ "dstSubpass" ];
  }
  if( j.find( "srcStageMask" ) != j.end() ) {
    p.srcStageMask = PipelineStageFlags ( j[ "srcStageMask" ] );
  }
  if( j.find( "dstStageMask" ) != j.end() ) {
    p.dstStageMask = PipelineStageFlags ( j[ "dstStageMask" ] );
  }
  if( j.find( "srcAccessMask" ) != j.end() ) {
    p.srcAccessMask = AccessFlags ( j[ "srcAccessMask" ] );
  }
  if( j.find( "dstAccessMask" ) != j.end() ) {
    p.dstAccessMask = AccessFlags ( j[ "dstAccessMask" ] );
  }
  if( j.find( "dependencyFlags" ) != j.end() ) {
    p.dependencyFlags = DependencyFlags ( j[ "dependencyFlags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSubpassDependency &p ) {
  VULKAN_HPP_NAMESPACE :: SubpassDependency temp;
  from_json( j, temp );
  p = VkSubpassDependency ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/RenderPassCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RenderPassCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "attachmentCount" ] = p.attachmentCount;
  j[ "pAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttachments ) );
  j[ "subpassCount" ] = p.subpassCount;
  j[ "pSubpasses" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSubpasses ) );
  j[ "dependencyCount" ] = p.dependencyCount;
  j[ "pDependencies" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDependencies ) );
}
}
void to_json( nlohmann::json &j, const VkRenderPassCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RenderPassCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RenderPassCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = RenderPassCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "attachmentCount" ) != j.end() ) {
    p.attachmentCount = j[ "attachmentCount" ];
  }
  if( j.find( "subpassCount" ) != j.end() ) {
    p.subpassCount = j[ "subpassCount" ];
  }
  if( j.find( "dependencyCount" ) != j.end() ) {
    p.dependencyCount = j[ "dependencyCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkRenderPassCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: RenderPassCreateInfo temp;
  from_json( j, temp );
  p = VkRenderPassCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SubpassDescriptionFlags.hpp>
#include <vulkan2json/PipelineBindPoint.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubpassDescription2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pipelineBindPoint" ] = p.pipelineBindPoint;
  j[ "viewMask" ] = p.viewMask;
  j[ "inputAttachmentCount" ] = p.inputAttachmentCount;
  j[ "pInputAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pInputAttachments ) );
  j[ "colorAttachmentCount" ] = p.colorAttachmentCount;
  j[ "pColorAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pColorAttachments ) );
  j[ "pResolveAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pResolveAttachments ) );
  j[ "pDepthStencilAttachment" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDepthStencilAttachment ) );
  j[ "preserveAttachmentCount" ] = p.preserveAttachmentCount;
  j[ "pPreserveAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPreserveAttachments ) );
}
}
void to_json( nlohmann::json &j, const VkSubpassDescription2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SubpassDescription2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SubpassDescription2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassDescription2" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = SubpassDescriptionFlags ( j[ "flags" ] );
  }
  if( j.find( "pipelineBindPoint" ) != j.end() ) {
    p.pipelineBindPoint = PipelineBindPoint ( j[ "pipelineBindPoint" ] );
  }
  if( j.find( "viewMask" ) != j.end() ) {
    p.viewMask = j[ "viewMask" ];
  }
  if( j.find( "inputAttachmentCount" ) != j.end() ) {
    p.inputAttachmentCount = j[ "inputAttachmentCount" ];
  }
  if( j.find( "colorAttachmentCount" ) != j.end() ) {
    p.colorAttachmentCount = j[ "colorAttachmentCount" ];
  }
  if( j.find( "preserveAttachmentCount" ) != j.end() ) {
    p.preserveAttachmentCount = j[ "preserveAttachmentCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSubpassDescription2 &p ) {
  VULKAN_HPP_NAMESPACE :: SubpassDescription2 temp;
  from_json( j, temp );
  p = VkSubpassDescription2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineStageFlags.hpp>
#include <vulkan2json/PipelineStageFlags.hpp>
#include <vulkan2json/AccessFlags.hpp>
#include <vulkan2json/AccessFlags.hpp>
#include <vulkan2json/DependencyFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubpassDependency2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcSubpass" ] = p.srcSubpass;
  j[ "dstSubpass" ] = p.dstSubpass;
  j[ "srcStageMask" ] = p.srcStageMask;
  j[ "dstStageMask" ] = p.dstStageMask;
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
  j[ "dependencyFlags" ] = p.dependencyFlags;
  j[ "viewOffset" ] = p.viewOffset;
}
}
void to_json( nlohmann::json &j, const VkSubpassDependency2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SubpassDependency2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SubpassDependency2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassDependency2" );
  if( j.find( "srcSubpass" ) != j.end() ) {
    p.srcSubpass = j[ "srcSubpass" ];
  }
  if( j.find( "dstSubpass" ) != j.end() ) {
    p.dstSubpass = j[ "dstSubpass" ];
  }
  if( j.find( "srcStageMask" ) != j.end() ) {
    p.srcStageMask = PipelineStageFlags ( j[ "srcStageMask" ] );
  }
  if( j.find( "dstStageMask" ) != j.end() ) {
    p.dstStageMask = PipelineStageFlags ( j[ "dstStageMask" ] );
  }
  if( j.find( "srcAccessMask" ) != j.end() ) {
    p.srcAccessMask = AccessFlags ( j[ "srcAccessMask" ] );
  }
  if( j.find( "dstAccessMask" ) != j.end() ) {
    p.dstAccessMask = AccessFlags ( j[ "dstAccessMask" ] );
  }
  if( j.find( "dependencyFlags" ) != j.end() ) {
    p.dependencyFlags = DependencyFlags ( j[ "dependencyFlags" ] );
  }
  if( j.find( "viewOffset" ) != j.end() ) {
    p.viewOffset = j[ "viewOffset" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSubpassDependency2 &p ) {
  VULKAN_HPP_NAMESPACE :: SubpassDependency2 temp;
  from_json( j, temp );
  p = VkSubpassDependency2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/RenderPassCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RenderPassCreateInfo2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "attachmentCount" ] = p.attachmentCount;
  j[ "pAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttachments ) );
  j[ "subpassCount" ] = p.subpassCount;
  j[ "pSubpasses" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSubpasses ) );
  j[ "dependencyCount" ] = p.dependencyCount;
  j[ "pDependencies" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDependencies ) );
  j[ "correlatedViewMaskCount" ] = p.correlatedViewMaskCount;
  j[ "pCorrelatedViewMasks" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCorrelatedViewMasks ) );
}
}
void to_json( nlohmann::json &j, const VkRenderPassCreateInfo2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RenderPassCreateInfo2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RenderPassCreateInfo2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassCreateInfo2" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = RenderPassCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "attachmentCount" ) != j.end() ) {
    p.attachmentCount = j[ "attachmentCount" ];
  }
  if( j.find( "subpassCount" ) != j.end() ) {
    p.subpassCount = j[ "subpassCount" ];
  }
  if( j.find( "dependencyCount" ) != j.end() ) {
    p.dependencyCount = j[ "dependencyCount" ];
  }
  if( j.find( "correlatedViewMaskCount" ) != j.end() ) {
    p.correlatedViewMaskCount = j[ "correlatedViewMaskCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkRenderPassCreateInfo2 &p ) {
  VULKAN_HPP_NAMESPACE :: RenderPassCreateInfo2 temp;
  from_json( j, temp );
  p = VkRenderPassCreateInfo2 ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/AttachmentReference.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RenderPassFragmentDensityMapCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fragmentDensityMapAttachment" ] = p.fragmentDensityMapAttachment;
}
}
void to_json( nlohmann::json &j, const VkRenderPassFragmentDensityMapCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RenderPassFragmentDensityMapCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RenderPassFragmentDensityMapCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassFragmentDensityMapCreateInfoEXT" );
  if( j.find( "fragmentDensityMapAttachment" ) != j.end() ) {
    p.fragmentDensityMapAttachment = AttachmentReference ( j[ "fragmentDensityMapAttachment" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkRenderPassFragmentDensityMapCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: RenderPassFragmentDensityMapCreateInfoEXT temp;
  from_json( j, temp );
  p = VkRenderPassFragmentDensityMapCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RenderPassInputAttachmentAspectCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "aspectReferenceCount" ] = p.aspectReferenceCount;
  j[ "pAspectReferences" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAspectReferences ) );
}
}
void to_json( nlohmann::json &j, const VkRenderPassInputAttachmentAspectCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RenderPassInputAttachmentAspectCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RenderPassInputAttachmentAspectCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassInputAttachmentAspectCreateInfo" );
  if( j.find( "aspectReferenceCount" ) != j.end() ) {
    p.aspectReferenceCount = j[ "aspectReferenceCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkRenderPassInputAttachmentAspectCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: RenderPassInputAttachmentAspectCreateInfo temp;
  from_json( j, temp );
  p = VkRenderPassInputAttachmentAspectCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RenderPassMultiviewCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "subpassCount" ] = p.subpassCount;
  j[ "pViewMasks" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewMasks ) );
  j[ "dependencyCount" ] = p.dependencyCount;
  j[ "pViewOffsets" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewOffsets ) );
  j[ "correlationMaskCount" ] = p.correlationMaskCount;
  j[ "pCorrelationMasks" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCorrelationMasks ) );
}
}
void to_json( nlohmann::json &j, const VkRenderPassMultiviewCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RenderPassMultiviewCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RenderPassMultiviewCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassMultiviewCreateInfo" );
  if( j.find( "subpassCount" ) != j.end() ) {
    p.subpassCount = j[ "subpassCount" ];
  }
  if( j.find( "dependencyCount" ) != j.end() ) {
    p.dependencyCount = j[ "dependencyCount" ];
  }
  if( j.find( "correlationMaskCount" ) != j.end() ) {
    p.correlationMaskCount = j[ "correlationMaskCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkRenderPassMultiviewCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: RenderPassMultiviewCreateInfo temp;
  from_json( j, temp );
  p = VkRenderPassMultiviewCreateInfo ( temp );
}
#include <vulkan2json/SampleLocationsInfoEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubpassSampleLocationsEXT &p ) {
  j = nlohmann::json::object();
  j[ "subpassIndex" ] = p.subpassIndex;
  j[ "sampleLocationsInfo" ] = p.sampleLocationsInfo;
}
}
void to_json( nlohmann::json &j, const VkSubpassSampleLocationsEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SubpassSampleLocationsEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SubpassSampleLocationsEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassSampleLocationsEXT" );
  if( j.find( "subpassIndex" ) != j.end() ) {
    p.subpassIndex = j[ "subpassIndex" ];
  }
  if( j.find( "sampleLocationsInfo" ) != j.end() ) {
    p.sampleLocationsInfo = SampleLocationsInfoEXT ( j[ "sampleLocationsInfo" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSubpassSampleLocationsEXT &p ) {
  VULKAN_HPP_NAMESPACE :: SubpassSampleLocationsEXT temp;
  from_json( j, temp );
  p = VkSubpassSampleLocationsEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RenderPassSampleLocationsBeginInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "attachmentInitialSampleLocationsCount" ] = p.attachmentInitialSampleLocationsCount;
  j[ "pAttachmentInitialSampleLocations" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttachmentInitialSampleLocations ) );
  j[ "postSubpassSampleLocationsCount" ] = p.postSubpassSampleLocationsCount;
  j[ "pPostSubpassSampleLocations" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPostSubpassSampleLocations ) );
}
}
void to_json( nlohmann::json &j, const VkRenderPassSampleLocationsBeginInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RenderPassSampleLocationsBeginInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RenderPassSampleLocationsBeginInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassSampleLocationsBeginInfoEXT" );
  if( j.find( "attachmentInitialSampleLocationsCount" ) != j.end() ) {
    p.attachmentInitialSampleLocationsCount = j[ "attachmentInitialSampleLocationsCount" ];
  }
  if( j.find( "postSubpassSampleLocationsCount" ) != j.end() ) {
    p.postSubpassSampleLocationsCount = j[ "postSubpassSampleLocationsCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkRenderPassSampleLocationsBeginInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: RenderPassSampleLocationsBeginInfoEXT temp;
  from_json( j, temp );
  p = VkRenderPassSampleLocationsBeginInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SurfaceTransformFlagsKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const RenderPassTransformBeginInfoQCOM &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "transform" ] = p.transform;
}
}
void to_json( nlohmann::json &j, const VkRenderPassTransformBeginInfoQCOM &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: RenderPassTransformBeginInfoQCOM ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, RenderPassTransformBeginInfoQCOM &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassTransformBeginInfoQCOM" );
  if( j.find( "transform" ) != j.end() ) {
    p.transform = SurfaceTransformFlagBitsKHR ( j[ "transform" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkRenderPassTransformBeginInfoQCOM &p ) {
  VULKAN_HPP_NAMESPACE :: RenderPassTransformBeginInfoQCOM temp;
  from_json( j, temp );
  p = VkRenderPassTransformBeginInfoQCOM ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageLayout.hpp>
#include <vulkan2json/ImageLayout.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ResolveImageInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcImageLayout" ] = p.srcImageLayout;
  j[ "dstImageLayout" ] = p.dstImageLayout;
  j[ "regionCount" ] = p.regionCount;
  j[ "pRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRegions ) );
}
}
void to_json( nlohmann::json &j, const VkResolveImageInfo2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ResolveImageInfo2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ResolveImageInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ResolveImageInfo2KHR" );
  if( j.find( "srcImageLayout" ) != j.end() ) {
    p.srcImageLayout = ImageLayout ( j[ "srcImageLayout" ] );
  }
  if( j.find( "dstImageLayout" ) != j.end() ) {
    p.dstImageLayout = ImageLayout ( j[ "dstImageLayout" ] );
  }
  if( j.find( "regionCount" ) != j.end() ) {
    p.regionCount = j[ "regionCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkResolveImageInfo2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: ResolveImageInfo2KHR temp;
  from_json( j, temp );
  p = VkResolveImageInfo2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SamplerCreateFlags.hpp>
#include <vulkan2json/Filter.hpp>
#include <vulkan2json/Filter.hpp>
#include <vulkan2json/SamplerMipmapMode.hpp>
#include <vulkan2json/SamplerAddressMode.hpp>
#include <vulkan2json/SamplerAddressMode.hpp>
#include <vulkan2json/SamplerAddressMode.hpp>
#include <vulkan2json/CompareOp.hpp>
#include <vulkan2json/BorderColor.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SamplerCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "magFilter" ] = p.magFilter;
  j[ "minFilter" ] = p.minFilter;
  j[ "mipmapMode" ] = p.mipmapMode;
  j[ "addressModeU" ] = p.addressModeU;
  j[ "addressModeV" ] = p.addressModeV;
  j[ "addressModeW" ] = p.addressModeW;
  j[ "mipLodBias" ] = p.mipLodBias;
  j[ "anisotropyEnable" ] = bool( p.anisotropyEnable );
  j[ "maxAnisotropy" ] = p.maxAnisotropy;
  j[ "compareEnable" ] = bool( p.compareEnable );
  j[ "compareOp" ] = p.compareOp;
  j[ "minLod" ] = p.minLod;
  j[ "maxLod" ] = p.maxLod;
  j[ "borderColor" ] = p.borderColor;
  j[ "unnormalizedCoordinates" ] = bool( p.unnormalizedCoordinates );
}
}
void to_json( nlohmann::json &j, const VkSamplerCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SamplerCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SamplerCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SamplerCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = SamplerCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "magFilter" ) != j.end() ) {
    p.magFilter = Filter ( j[ "magFilter" ] );
  }
  if( j.find( "minFilter" ) != j.end() ) {
    p.minFilter = Filter ( j[ "minFilter" ] );
  }
  if( j.find( "mipmapMode" ) != j.end() ) {
    p.mipmapMode = SamplerMipmapMode ( j[ "mipmapMode" ] );
  }
  if( j.find( "addressModeU" ) != j.end() ) {
    p.addressModeU = SamplerAddressMode ( j[ "addressModeU" ] );
  }
  if( j.find( "addressModeV" ) != j.end() ) {
    p.addressModeV = SamplerAddressMode ( j[ "addressModeV" ] );
  }
  if( j.find( "addressModeW" ) != j.end() ) {
    p.addressModeW = SamplerAddressMode ( j[ "addressModeW" ] );
  }
  if( j.find( "mipLodBias" ) != j.end() ) {
    p.mipLodBias = j[ "mipLodBias" ];
  }
  if( j.find( "anisotropyEnable" ) != j.end() ) {
    p.anisotropyEnable = j[ "anisotropyEnable" ];
  }
  if( j.find( "maxAnisotropy" ) != j.end() ) {
    p.maxAnisotropy = j[ "maxAnisotropy" ];
  }
  if( j.find( "compareEnable" ) != j.end() ) {
    p.compareEnable = j[ "compareEnable" ];
  }
  if( j.find( "compareOp" ) != j.end() ) {
    p.compareOp = CompareOp ( j[ "compareOp" ] );
  }
  if( j.find( "minLod" ) != j.end() ) {
    p.minLod = j[ "minLod" ];
  }
  if( j.find( "maxLod" ) != j.end() ) {
    p.maxLod = j[ "maxLod" ];
  }
  if( j.find( "borderColor" ) != j.end() ) {
    p.borderColor = BorderColor ( j[ "borderColor" ] );
  }
  if( j.find( "unnormalizedCoordinates" ) != j.end() ) {
    p.unnormalizedCoordinates = j[ "unnormalizedCoordinates" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSamplerCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SamplerCreateInfo temp;
  from_json( j, temp );
  p = VkSamplerCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Format.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SamplerCustomBorderColorCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "format" ] = p.format;
}
}
void to_json( nlohmann::json &j, const VkSamplerCustomBorderColorCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SamplerCustomBorderColorCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SamplerCustomBorderColorCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SamplerCustomBorderColorCreateInfoEXT" );
  if( j.find( "format" ) != j.end() ) {
    p.format = Format ( j[ "format" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSamplerCustomBorderColorCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: SamplerCustomBorderColorCreateInfoEXT temp;
  from_json( j, temp );
  p = VkSamplerCustomBorderColorCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SamplerReductionMode.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SamplerReductionModeCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "reductionMode" ] = p.reductionMode;
}
}
void to_json( nlohmann::json &j, const VkSamplerReductionModeCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SamplerReductionModeCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SamplerReductionModeCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SamplerReductionModeCreateInfo" );
  if( j.find( "reductionMode" ) != j.end() ) {
    p.reductionMode = SamplerReductionMode ( j[ "reductionMode" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSamplerReductionModeCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SamplerReductionModeCreateInfo temp;
  from_json( j, temp );
  p = VkSamplerReductionModeCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Format.hpp>
#include <vulkan2json/SamplerYcbcrModelConversion.hpp>
#include <vulkan2json/SamplerYcbcrRange.hpp>
#include <vulkan2json/ComponentMapping.hpp>
#include <vulkan2json/ChromaLocation.hpp>
#include <vulkan2json/ChromaLocation.hpp>
#include <vulkan2json/Filter.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SamplerYcbcrConversionCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "format" ] = p.format;
  j[ "ycbcrModel" ] = p.ycbcrModel;
  j[ "ycbcrRange" ] = p.ycbcrRange;
  j[ "components" ] = p.components;
  j[ "xChromaOffset" ] = p.xChromaOffset;
  j[ "yChromaOffset" ] = p.yChromaOffset;
  j[ "chromaFilter" ] = p.chromaFilter;
  j[ "forceExplicitReconstruction" ] = bool( p.forceExplicitReconstruction );
}
}
void to_json( nlohmann::json &j, const VkSamplerYcbcrConversionCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SamplerYcbcrConversionCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SamplerYcbcrConversionCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SamplerYcbcrConversionCreateInfo" );
  if( j.find( "format" ) != j.end() ) {
    p.format = Format ( j[ "format" ] );
  }
  if( j.find( "ycbcrModel" ) != j.end() ) {
    p.ycbcrModel = SamplerYcbcrModelConversion ( j[ "ycbcrModel" ] );
  }
  if( j.find( "ycbcrRange" ) != j.end() ) {
    p.ycbcrRange = SamplerYcbcrRange ( j[ "ycbcrRange" ] );
  }
  if( j.find( "components" ) != j.end() ) {
    p.components = ComponentMapping ( j[ "components" ] );
  }
  if( j.find( "xChromaOffset" ) != j.end() ) {
    p.xChromaOffset = ChromaLocation ( j[ "xChromaOffset" ] );
  }
  if( j.find( "yChromaOffset" ) != j.end() ) {
    p.yChromaOffset = ChromaLocation ( j[ "yChromaOffset" ] );
  }
  if( j.find( "chromaFilter" ) != j.end() ) {
    p.chromaFilter = Filter ( j[ "chromaFilter" ] );
  }
  if( j.find( "forceExplicitReconstruction" ) != j.end() ) {
    p.forceExplicitReconstruction = j[ "forceExplicitReconstruction" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSamplerYcbcrConversionCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SamplerYcbcrConversionCreateInfo temp;
  from_json( j, temp );
  p = VkSamplerYcbcrConversionCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SamplerYcbcrConversionImageFormatProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "combinedImageSamplerDescriptorCount" ] = p.combinedImageSamplerDescriptorCount;
}
}
void to_json( nlohmann::json &j, const VkSamplerYcbcrConversionImageFormatProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SamplerYcbcrConversionImageFormatProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SamplerYcbcrConversionImageFormatProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SamplerYcbcrConversionImageFormatProperties" );
  if( j.find( "combinedImageSamplerDescriptorCount" ) != j.end() ) {
    p.combinedImageSamplerDescriptorCount = j[ "combinedImageSamplerDescriptorCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSamplerYcbcrConversionImageFormatProperties &p ) {
  VULKAN_HPP_NAMESPACE :: SamplerYcbcrConversionImageFormatProperties temp;
  from_json( j, temp );
  p = VkSamplerYcbcrConversionImageFormatProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SamplerYcbcrConversionInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkSamplerYcbcrConversionInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SamplerYcbcrConversionInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SamplerYcbcrConversionInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SamplerYcbcrConversionInfo" );
}
}
void from_json( const nlohmann::json &j, VkSamplerYcbcrConversionInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SamplerYcbcrConversionInfo temp;
  from_json( j, temp );
  p = VkSamplerYcbcrConversionInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SemaphoreCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SemaphoreCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkSemaphoreCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SemaphoreCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SemaphoreCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SemaphoreCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = SemaphoreCreateFlags ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSemaphoreCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SemaphoreCreateInfo temp;
  from_json( j, temp );
  p = VkSemaphoreCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ExternalSemaphoreHandleTypeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SemaphoreGetFdInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
}
void to_json( nlohmann::json &j, const VkSemaphoreGetFdInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SemaphoreGetFdInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SemaphoreGetFdInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SemaphoreGetFdInfoKHR" );
  if( j.find( "handleType" ) != j.end() ) {
    p.handleType = ExternalSemaphoreHandleTypeFlagBits ( j[ "handleType" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSemaphoreGetFdInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: SemaphoreGetFdInfoKHR temp;
  from_json( j, temp );
  p = VkSemaphoreGetFdInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SemaphoreSignalInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "value" ] = p.value;
}
}
void to_json( nlohmann::json &j, const VkSemaphoreSignalInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SemaphoreSignalInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SemaphoreSignalInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SemaphoreSignalInfo" );
  if( j.find( "value" ) != j.end() ) {
    p.value = j[ "value" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSemaphoreSignalInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SemaphoreSignalInfo temp;
  from_json( j, temp );
  p = VkSemaphoreSignalInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/PipelineStageFlags2KHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SemaphoreSubmitInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "value" ] = p.value;
  j[ "stageMask" ] = p.stageMask;
  j[ "deviceIndex" ] = p.deviceIndex;
}
}
void to_json( nlohmann::json &j, const VkSemaphoreSubmitInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SemaphoreSubmitInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SemaphoreSubmitInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SemaphoreSubmitInfoKHR" );
  if( j.find( "value" ) != j.end() ) {
    p.value = j[ "value" ];
  }
  if( j.find( "stageMask" ) != j.end() ) {
    p.stageMask = PipelineStageFlags2KHR ( j[ "stageMask" ] );
  }
  if( j.find( "deviceIndex" ) != j.end() ) {
    p.deviceIndex = j[ "deviceIndex" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSemaphoreSubmitInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: SemaphoreSubmitInfoKHR temp;
  from_json( j, temp );
  p = VkSemaphoreSubmitInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SemaphoreType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SemaphoreTypeCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "semaphoreType" ] = p.semaphoreType;
  j[ "initialValue" ] = p.initialValue;
}
}
void to_json( nlohmann::json &j, const VkSemaphoreTypeCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SemaphoreTypeCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SemaphoreTypeCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SemaphoreTypeCreateInfo" );
  if( j.find( "semaphoreType" ) != j.end() ) {
    p.semaphoreType = SemaphoreType ( j[ "semaphoreType" ] );
  }
  if( j.find( "initialValue" ) != j.end() ) {
    p.initialValue = j[ "initialValue" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSemaphoreTypeCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SemaphoreTypeCreateInfo temp;
  from_json( j, temp );
  p = VkSemaphoreTypeCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SemaphoreWaitFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SemaphoreWaitInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "semaphoreCount" ] = p.semaphoreCount;
  j[ "pSemaphores" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSemaphores ) );
  j[ "pValues" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pValues ) );
}
}
void to_json( nlohmann::json &j, const VkSemaphoreWaitInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SemaphoreWaitInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SemaphoreWaitInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SemaphoreWaitInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = SemaphoreWaitFlags ( j[ "flags" ] );
  }
  if( j.find( "semaphoreCount" ) != j.end() ) {
    p.semaphoreCount = j[ "semaphoreCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSemaphoreWaitInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SemaphoreWaitInfo temp;
  from_json( j, temp );
  p = VkSemaphoreWaitInfo ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SetStateFlagsIndirectCommandNV &p ) {
  j = nlohmann::json::object();
  j[ "data" ] = p.data;
}
}
void to_json( nlohmann::json &j, const VkSetStateFlagsIndirectCommandNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SetStateFlagsIndirectCommandNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SetStateFlagsIndirectCommandNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SetStateFlagsIndirectCommandNV" );
  if( j.find( "data" ) != j.end() ) {
    p.data = j[ "data" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSetStateFlagsIndirectCommandNV &p ) {
  VULKAN_HPP_NAMESPACE :: SetStateFlagsIndirectCommandNV temp;
  from_json( j, temp );
  p = VkSetStateFlagsIndirectCommandNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ShaderModuleCreateFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ShaderModuleCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "codeSize" ] = p.codeSize;
  j[ "pCode" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCode ) );
}
}
void to_json( nlohmann::json &j, const VkShaderModuleCreateInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ShaderModuleCreateInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ShaderModuleCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ShaderModuleCreateInfo" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = ShaderModuleCreateFlags ( j[ "flags" ] );
  }
  if( j.find( "codeSize" ) != j.end() ) {
    p.codeSize = j[ "codeSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkShaderModuleCreateInfo &p ) {
  VULKAN_HPP_NAMESPACE :: ShaderModuleCreateInfo temp;
  from_json( j, temp );
  p = VkShaderModuleCreateInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ShaderModuleValidationCacheCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkShaderModuleValidationCacheCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ShaderModuleValidationCacheCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ShaderModuleValidationCacheCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ShaderModuleValidationCacheCreateInfoEXT" );
}
}
void from_json( const nlohmann::json &j, VkShaderModuleValidationCacheCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ShaderModuleValidationCacheCreateInfoEXT temp;
  from_json( j, temp );
  p = VkShaderModuleValidationCacheCreateInfoEXT ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ShaderResourceUsageAMD &p ) {
  j = nlohmann::json::object();
  j[ "numUsedVgprs" ] = p.numUsedVgprs;
  j[ "numUsedSgprs" ] = p.numUsedSgprs;
  j[ "ldsSizePerLocalWorkGroup" ] = p.ldsSizePerLocalWorkGroup;
  j[ "ldsUsageSizeInBytes" ] = p.ldsUsageSizeInBytes;
  j[ "scratchMemUsageInBytes" ] = p.scratchMemUsageInBytes;
}
}
void to_json( nlohmann::json &j, const VkShaderResourceUsageAMD &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ShaderResourceUsageAMD ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ShaderResourceUsageAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ShaderResourceUsageAMD" );
  if( j.find( "numUsedVgprs" ) != j.end() ) {
    p.numUsedVgprs = j[ "numUsedVgprs" ];
  }
  if( j.find( "numUsedSgprs" ) != j.end() ) {
    p.numUsedSgprs = j[ "numUsedSgprs" ];
  }
  if( j.find( "ldsSizePerLocalWorkGroup" ) != j.end() ) {
    p.ldsSizePerLocalWorkGroup = j[ "ldsSizePerLocalWorkGroup" ];
  }
  if( j.find( "ldsUsageSizeInBytes" ) != j.end() ) {
    p.ldsUsageSizeInBytes = j[ "ldsUsageSizeInBytes" ];
  }
  if( j.find( "scratchMemUsageInBytes" ) != j.end() ) {
    p.scratchMemUsageInBytes = j[ "scratchMemUsageInBytes" ];
  }
}
}
void from_json( const nlohmann::json &j, VkShaderResourceUsageAMD &p ) {
  VULKAN_HPP_NAMESPACE :: ShaderResourceUsageAMD temp;
  from_json( j, temp );
  p = VkShaderResourceUsageAMD ( temp );
}
#include <vulkan2json/ShaderStageFlags.hpp>
#include <vulkan2json/ShaderResourceUsageAMD.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ShaderStatisticsInfoAMD &p ) {
  j = nlohmann::json::object();
  j[ "shaderStageMask" ] = p.shaderStageMask;
  j[ "resourceUsage" ] = p.resourceUsage;
  j[ "numPhysicalVgprs" ] = p.numPhysicalVgprs;
  j[ "numPhysicalSgprs" ] = p.numPhysicalSgprs;
  j[ "numAvailableVgprs" ] = p.numAvailableVgprs;
  j[ "numAvailableSgprs" ] = p.numAvailableSgprs;
  j[ "computeWorkGroupSize" ] = nlohmann::json::array();
  std::copy( p.computeWorkGroupSize.begin(), p.computeWorkGroupSize.end(), std::back_inserter( j[ "computeWorkGroupSize" ] ) );
}
}
void to_json( nlohmann::json &j, const VkShaderStatisticsInfoAMD &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ShaderStatisticsInfoAMD ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ShaderStatisticsInfoAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ShaderStatisticsInfoAMD" );
  if( j.find( "shaderStageMask" ) != j.end() ) {
    p.shaderStageMask = ShaderStageFlags ( j[ "shaderStageMask" ] );
  }
  if( j.find( "resourceUsage" ) != j.end() ) {
    p.resourceUsage = ShaderResourceUsageAMD ( j[ "resourceUsage" ] );
  }
  if( j.find( "numPhysicalVgprs" ) != j.end() ) {
    p.numPhysicalVgprs = j[ "numPhysicalVgprs" ];
  }
  if( j.find( "numPhysicalSgprs" ) != j.end() ) {
    p.numPhysicalSgprs = j[ "numPhysicalSgprs" ];
  }
  if( j.find( "numAvailableVgprs" ) != j.end() ) {
    p.numAvailableVgprs = j[ "numAvailableVgprs" ];
  }
  if( j.find( "numAvailableSgprs" ) != j.end() ) {
    p.numAvailableSgprs = j[ "numAvailableSgprs" ];
  }
  if( j.find( "computeWorkGroupSize" ) != j.end() ) {
    if( !j[ "computeWorkGroupSize" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for ShaderStatisticsInfoAMD.computeWorkGroupSize" );
    if( !j[ "computeWorkGroupSize" ].size() > p.computeWorkGroupSize.size() ) throw vulkan2json::invalid_array_value( "too many values in array for ShaderStatisticsInfoAMD.computeWorkGroupSize" );
    std::fill( p.computeWorkGroupSize.begin(), p.computeWorkGroupSize.end(), 0 );
    std::copy( j[ "computeWorkGroupSize" ].begin(), j[ "computeWorkGroupSize" ].end(), p.computeWorkGroupSize.begin() );
  }
}
}
void from_json( const nlohmann::json &j, VkShaderStatisticsInfoAMD &p ) {
  VULKAN_HPP_NAMESPACE :: ShaderStatisticsInfoAMD temp;
  from_json( j, temp );
  p = VkShaderStatisticsInfoAMD ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ImageUsageFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SharedPresentSurfaceCapabilitiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "sharedPresentSupportedUsageFlags" ] = p.sharedPresentSupportedUsageFlags;
}
}
void to_json( nlohmann::json &j, const VkSharedPresentSurfaceCapabilitiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SharedPresentSurfaceCapabilitiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SharedPresentSurfaceCapabilitiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SharedPresentSurfaceCapabilitiesKHR" );
  if( j.find( "sharedPresentSupportedUsageFlags" ) != j.end() ) {
    p.sharedPresentSupportedUsageFlags = ImageUsageFlags ( j[ "sharedPresentSupportedUsageFlags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSharedPresentSurfaceCapabilitiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: SharedPresentSurfaceCapabilitiesKHR temp;
  from_json( j, temp );
  p = VkSharedPresentSurfaceCapabilitiesKHR ( temp );
}
#include <vulkan2json/ImageAspectFlags.hpp>
#include <vulkan2json/Extent3D.hpp>
#include <vulkan2json/SparseImageFormatFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SparseImageFormatProperties &p ) {
  j = nlohmann::json::object();
  j[ "aspectMask" ] = p.aspectMask;
  j[ "imageGranularity" ] = p.imageGranularity;
  j[ "flags" ] = p.flags;
}
}
void to_json( nlohmann::json &j, const VkSparseImageFormatProperties &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SparseImageFormatProperties ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SparseImageFormatProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseImageFormatProperties" );
  if( j.find( "aspectMask" ) != j.end() ) {
    p.aspectMask = ImageAspectFlags ( j[ "aspectMask" ] );
  }
  if( j.find( "imageGranularity" ) != j.end() ) {
    p.imageGranularity = Extent3D ( j[ "imageGranularity" ] );
  }
  if( j.find( "flags" ) != j.end() ) {
    p.flags = SparseImageFormatFlags ( j[ "flags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSparseImageFormatProperties &p ) {
  VULKAN_HPP_NAMESPACE :: SparseImageFormatProperties temp;
  from_json( j, temp );
  p = VkSparseImageFormatProperties ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SparseImageFormatProperties.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SparseImageFormatProperties2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "properties" ] = p.properties;
}
}
void to_json( nlohmann::json &j, const VkSparseImageFormatProperties2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SparseImageFormatProperties2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SparseImageFormatProperties2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseImageFormatProperties2" );
  if( j.find( "properties" ) != j.end() ) {
    p.properties = SparseImageFormatProperties ( j[ "properties" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSparseImageFormatProperties2 &p ) {
  VULKAN_HPP_NAMESPACE :: SparseImageFormatProperties2 temp;
  from_json( j, temp );
  p = VkSparseImageFormatProperties2 ( temp );
}
#include <vulkan2json/SparseImageFormatProperties.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SparseImageMemoryRequirements &p ) {
  j = nlohmann::json::object();
  j[ "formatProperties" ] = p.formatProperties;
  j[ "imageMipTailFirstLod" ] = p.imageMipTailFirstLod;
  j[ "imageMipTailSize" ] = p.imageMipTailSize;
  j[ "imageMipTailOffset" ] = p.imageMipTailOffset;
  j[ "imageMipTailStride" ] = p.imageMipTailStride;
}
}
void to_json( nlohmann::json &j, const VkSparseImageMemoryRequirements &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SparseImageMemoryRequirements ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SparseImageMemoryRequirements &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseImageMemoryRequirements" );
  if( j.find( "formatProperties" ) != j.end() ) {
    p.formatProperties = SparseImageFormatProperties ( j[ "formatProperties" ] );
  }
  if( j.find( "imageMipTailFirstLod" ) != j.end() ) {
    p.imageMipTailFirstLod = j[ "imageMipTailFirstLod" ];
  }
  if( j.find( "imageMipTailSize" ) != j.end() ) {
    p.imageMipTailSize = j[ "imageMipTailSize" ];
  }
  if( j.find( "imageMipTailOffset" ) != j.end() ) {
    p.imageMipTailOffset = j[ "imageMipTailOffset" ];
  }
  if( j.find( "imageMipTailStride" ) != j.end() ) {
    p.imageMipTailStride = j[ "imageMipTailStride" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSparseImageMemoryRequirements &p ) {
  VULKAN_HPP_NAMESPACE :: SparseImageMemoryRequirements temp;
  from_json( j, temp );
  p = VkSparseImageMemoryRequirements ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SparseImageMemoryRequirements.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SparseImageMemoryRequirements2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryRequirements" ] = p.memoryRequirements;
}
}
void to_json( nlohmann::json &j, const VkSparseImageMemoryRequirements2 &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SparseImageMemoryRequirements2 ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SparseImageMemoryRequirements2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseImageMemoryRequirements2" );
  if( j.find( "memoryRequirements" ) != j.end() ) {
    p.memoryRequirements = SparseImageMemoryRequirements ( j[ "memoryRequirements" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSparseImageMemoryRequirements2 &p ) {
  VULKAN_HPP_NAMESPACE :: SparseImageMemoryRequirements2 temp;
  from_json( j, temp );
  p = VkSparseImageMemoryRequirements2 ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const StridedDeviceAddressRegionKHR &p ) {
  j = nlohmann::json::object();
  j[ "stride" ] = p.stride;
  j[ "size" ] = p.size;
}
}
void to_json( nlohmann::json &j, const VkStridedDeviceAddressRegionKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: StridedDeviceAddressRegionKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, StridedDeviceAddressRegionKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for StridedDeviceAddressRegionKHR" );
  if( j.find( "stride" ) != j.end() ) {
    p.stride = j[ "stride" ];
  }
  if( j.find( "size" ) != j.end() ) {
    p.size = j[ "size" ];
  }
}
}
void from_json( const nlohmann::json &j, VkStridedDeviceAddressRegionKHR &p ) {
  VULKAN_HPP_NAMESPACE :: StridedDeviceAddressRegionKHR temp;
  from_json( j, temp );
  p = VkStridedDeviceAddressRegionKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubmitInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "waitSemaphoreCount" ] = p.waitSemaphoreCount;
  j[ "pWaitSemaphores" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitSemaphores ) );
  j[ "pWaitDstStageMask" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitDstStageMask ) );
  j[ "commandBufferCount" ] = p.commandBufferCount;
  j[ "pCommandBuffers" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCommandBuffers ) );
  j[ "signalSemaphoreCount" ] = p.signalSemaphoreCount;
  j[ "pSignalSemaphores" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSignalSemaphores ) );
}
}
void to_json( nlohmann::json &j, const VkSubmitInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SubmitInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SubmitInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubmitInfo" );
  if( j.find( "waitSemaphoreCount" ) != j.end() ) {
    p.waitSemaphoreCount = j[ "waitSemaphoreCount" ];
  }
  if( j.find( "commandBufferCount" ) != j.end() ) {
    p.commandBufferCount = j[ "commandBufferCount" ];
  }
  if( j.find( "signalSemaphoreCount" ) != j.end() ) {
    p.signalSemaphoreCount = j[ "signalSemaphoreCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSubmitInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SubmitInfo temp;
  from_json( j, temp );
  p = VkSubmitInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SubmitFlagsKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubmitInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "waitSemaphoreInfoCount" ] = p.waitSemaphoreInfoCount;
  j[ "pWaitSemaphoreInfos" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitSemaphoreInfos ) );
  j[ "commandBufferInfoCount" ] = p.commandBufferInfoCount;
  j[ "pCommandBufferInfos" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCommandBufferInfos ) );
  j[ "signalSemaphoreInfoCount" ] = p.signalSemaphoreInfoCount;
  j[ "pSignalSemaphoreInfos" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSignalSemaphoreInfos ) );
}
}
void to_json( nlohmann::json &j, const VkSubmitInfo2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SubmitInfo2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SubmitInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubmitInfo2KHR" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = SubmitFlagsKHR ( j[ "flags" ] );
  }
  if( j.find( "waitSemaphoreInfoCount" ) != j.end() ) {
    p.waitSemaphoreInfoCount = j[ "waitSemaphoreInfoCount" ];
  }
  if( j.find( "commandBufferInfoCount" ) != j.end() ) {
    p.commandBufferInfoCount = j[ "commandBufferInfoCount" ];
  }
  if( j.find( "signalSemaphoreInfoCount" ) != j.end() ) {
    p.signalSemaphoreInfoCount = j[ "signalSemaphoreInfoCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSubmitInfo2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: SubmitInfo2KHR temp;
  from_json( j, temp );
  p = VkSubmitInfo2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SubpassContents.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubpassBeginInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "contents" ] = p.contents;
}
}
void to_json( nlohmann::json &j, const VkSubpassBeginInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SubpassBeginInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SubpassBeginInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassBeginInfo" );
  if( j.find( "contents" ) != j.end() ) {
    p.contents = SubpassContents ( j[ "contents" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSubpassBeginInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SubpassBeginInfo temp;
  from_json( j, temp );
  p = VkSubpassBeginInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ResolveModeFlags.hpp>
#include <vulkan2json/ResolveModeFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubpassDescriptionDepthStencilResolve &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "depthResolveMode" ] = p.depthResolveMode;
  j[ "stencilResolveMode" ] = p.stencilResolveMode;
  j[ "pDepthStencilResolveAttachment" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDepthStencilResolveAttachment ) );
}
}
void to_json( nlohmann::json &j, const VkSubpassDescriptionDepthStencilResolve &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SubpassDescriptionDepthStencilResolve ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SubpassDescriptionDepthStencilResolve &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassDescriptionDepthStencilResolve" );
  if( j.find( "depthResolveMode" ) != j.end() ) {
    p.depthResolveMode = ResolveModeFlagBits ( j[ "depthResolveMode" ] );
  }
  if( j.find( "stencilResolveMode" ) != j.end() ) {
    p.stencilResolveMode = ResolveModeFlagBits ( j[ "stencilResolveMode" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSubpassDescriptionDepthStencilResolve &p ) {
  VULKAN_HPP_NAMESPACE :: SubpassDescriptionDepthStencilResolve temp;
  from_json( j, temp );
  p = VkSubpassDescriptionDepthStencilResolve ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubpassEndInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
}
void to_json( nlohmann::json &j, const VkSubpassEndInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SubpassEndInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SubpassEndInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassEndInfo" );
}
}
void from_json( const nlohmann::json &j, VkSubpassEndInfo &p ) {
  VULKAN_HPP_NAMESPACE :: SubpassEndInfo temp;
  from_json( j, temp );
  p = VkSubpassEndInfo ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SubpassShadingPipelineCreateInfoHUAWEI &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "subpass" ] = p.subpass;
}
}
void to_json( nlohmann::json &j, const VkSubpassShadingPipelineCreateInfoHUAWEI &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SubpassShadingPipelineCreateInfoHUAWEI ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SubpassShadingPipelineCreateInfoHUAWEI &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassShadingPipelineCreateInfoHUAWEI" );
  if( j.find( "subpass" ) != j.end() ) {
    p.subpass = j[ "subpass" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSubpassShadingPipelineCreateInfoHUAWEI &p ) {
  VULKAN_HPP_NAMESPACE :: SubpassShadingPipelineCreateInfoHUAWEI temp;
  from_json( j, temp );
  p = VkSubpassShadingPipelineCreateInfoHUAWEI ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/SurfaceTransformFlagsKHR.hpp>
#include <vulkan2json/SurfaceTransformFlagsKHR.hpp>
#include <vulkan2json/CompositeAlphaFlagsKHR.hpp>
#include <vulkan2json/ImageUsageFlags.hpp>
#include <vulkan2json/SurfaceCounterFlagsEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SurfaceCapabilities2EXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "minImageCount" ] = p.minImageCount;
  j[ "maxImageCount" ] = p.maxImageCount;
  j[ "currentExtent" ] = p.currentExtent;
  j[ "minImageExtent" ] = p.minImageExtent;
  j[ "maxImageExtent" ] = p.maxImageExtent;
  j[ "maxImageArrayLayers" ] = p.maxImageArrayLayers;
  j[ "supportedTransforms" ] = p.supportedTransforms;
  j[ "currentTransform" ] = p.currentTransform;
  j[ "supportedCompositeAlpha" ] = p.supportedCompositeAlpha;
  j[ "supportedUsageFlags" ] = p.supportedUsageFlags;
  j[ "supportedSurfaceCounters" ] = p.supportedSurfaceCounters;
}
}
void to_json( nlohmann::json &j, const VkSurfaceCapabilities2EXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SurfaceCapabilities2EXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SurfaceCapabilities2EXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceCapabilities2EXT" );
  if( j.find( "minImageCount" ) != j.end() ) {
    p.minImageCount = j[ "minImageCount" ];
  }
  if( j.find( "maxImageCount" ) != j.end() ) {
    p.maxImageCount = j[ "maxImageCount" ];
  }
  if( j.find( "currentExtent" ) != j.end() ) {
    p.currentExtent = Extent2D ( j[ "currentExtent" ] );
  }
  if( j.find( "minImageExtent" ) != j.end() ) {
    p.minImageExtent = Extent2D ( j[ "minImageExtent" ] );
  }
  if( j.find( "maxImageExtent" ) != j.end() ) {
    p.maxImageExtent = Extent2D ( j[ "maxImageExtent" ] );
  }
  if( j.find( "maxImageArrayLayers" ) != j.end() ) {
    p.maxImageArrayLayers = j[ "maxImageArrayLayers" ];
  }
  if( j.find( "supportedTransforms" ) != j.end() ) {
    p.supportedTransforms = SurfaceTransformFlagsKHR ( j[ "supportedTransforms" ] );
  }
  if( j.find( "currentTransform" ) != j.end() ) {
    p.currentTransform = SurfaceTransformFlagBitsKHR ( j[ "currentTransform" ] );
  }
  if( j.find( "supportedCompositeAlpha" ) != j.end() ) {
    p.supportedCompositeAlpha = CompositeAlphaFlagsKHR ( j[ "supportedCompositeAlpha" ] );
  }
  if( j.find( "supportedUsageFlags" ) != j.end() ) {
    p.supportedUsageFlags = ImageUsageFlags ( j[ "supportedUsageFlags" ] );
  }
  if( j.find( "supportedSurfaceCounters" ) != j.end() ) {
    p.supportedSurfaceCounters = SurfaceCounterFlagsEXT ( j[ "supportedSurfaceCounters" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSurfaceCapabilities2EXT &p ) {
  VULKAN_HPP_NAMESPACE :: SurfaceCapabilities2EXT temp;
  from_json( j, temp );
  p = VkSurfaceCapabilities2EXT ( temp );
}
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/SurfaceTransformFlagsKHR.hpp>
#include <vulkan2json/SurfaceTransformFlagsKHR.hpp>
#include <vulkan2json/CompositeAlphaFlagsKHR.hpp>
#include <vulkan2json/ImageUsageFlags.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SurfaceCapabilitiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "minImageCount" ] = p.minImageCount;
  j[ "maxImageCount" ] = p.maxImageCount;
  j[ "currentExtent" ] = p.currentExtent;
  j[ "minImageExtent" ] = p.minImageExtent;
  j[ "maxImageExtent" ] = p.maxImageExtent;
  j[ "maxImageArrayLayers" ] = p.maxImageArrayLayers;
  j[ "supportedTransforms" ] = p.supportedTransforms;
  j[ "currentTransform" ] = p.currentTransform;
  j[ "supportedCompositeAlpha" ] = p.supportedCompositeAlpha;
  j[ "supportedUsageFlags" ] = p.supportedUsageFlags;
}
}
void to_json( nlohmann::json &j, const VkSurfaceCapabilitiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SurfaceCapabilitiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SurfaceCapabilitiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceCapabilitiesKHR" );
  if( j.find( "minImageCount" ) != j.end() ) {
    p.minImageCount = j[ "minImageCount" ];
  }
  if( j.find( "maxImageCount" ) != j.end() ) {
    p.maxImageCount = j[ "maxImageCount" ];
  }
  if( j.find( "currentExtent" ) != j.end() ) {
    p.currentExtent = Extent2D ( j[ "currentExtent" ] );
  }
  if( j.find( "minImageExtent" ) != j.end() ) {
    p.minImageExtent = Extent2D ( j[ "minImageExtent" ] );
  }
  if( j.find( "maxImageExtent" ) != j.end() ) {
    p.maxImageExtent = Extent2D ( j[ "maxImageExtent" ] );
  }
  if( j.find( "maxImageArrayLayers" ) != j.end() ) {
    p.maxImageArrayLayers = j[ "maxImageArrayLayers" ];
  }
  if( j.find( "supportedTransforms" ) != j.end() ) {
    p.supportedTransforms = SurfaceTransformFlagsKHR ( j[ "supportedTransforms" ] );
  }
  if( j.find( "currentTransform" ) != j.end() ) {
    p.currentTransform = SurfaceTransformFlagBitsKHR ( j[ "currentTransform" ] );
  }
  if( j.find( "supportedCompositeAlpha" ) != j.end() ) {
    p.supportedCompositeAlpha = CompositeAlphaFlagsKHR ( j[ "supportedCompositeAlpha" ] );
  }
  if( j.find( "supportedUsageFlags" ) != j.end() ) {
    p.supportedUsageFlags = ImageUsageFlags ( j[ "supportedUsageFlags" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSurfaceCapabilitiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: SurfaceCapabilitiesKHR temp;
  from_json( j, temp );
  p = VkSurfaceCapabilitiesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SurfaceCapabilitiesKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SurfaceCapabilities2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "surfaceCapabilities" ] = p.surfaceCapabilities;
}
}
void to_json( nlohmann::json &j, const VkSurfaceCapabilities2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SurfaceCapabilities2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SurfaceCapabilities2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceCapabilities2KHR" );
  if( j.find( "surfaceCapabilities" ) != j.end() ) {
    p.surfaceCapabilities = SurfaceCapabilitiesKHR ( j[ "surfaceCapabilities" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSurfaceCapabilities2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: SurfaceCapabilities2KHR temp;
  from_json( j, temp );
  p = VkSurfaceCapabilities2KHR ( temp );
}
#include <vulkan2json/Format.hpp>
#include <vulkan2json/ColorSpaceKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SurfaceFormatKHR &p ) {
  j = nlohmann::json::object();
  j[ "format" ] = p.format;
  j[ "colorSpace" ] = p.colorSpace;
}
}
void to_json( nlohmann::json &j, const VkSurfaceFormatKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SurfaceFormatKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SurfaceFormatKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceFormatKHR" );
  if( j.find( "format" ) != j.end() ) {
    p.format = Format ( j[ "format" ] );
  }
  if( j.find( "colorSpace" ) != j.end() ) {
    p.colorSpace = ColorSpaceKHR ( j[ "colorSpace" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSurfaceFormatKHR &p ) {
  VULKAN_HPP_NAMESPACE :: SurfaceFormatKHR temp;
  from_json( j, temp );
  p = VkSurfaceFormatKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SurfaceFormatKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SurfaceFormat2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "surfaceFormat" ] = p.surfaceFormat;
}
}
void to_json( nlohmann::json &j, const VkSurfaceFormat2KHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SurfaceFormat2KHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SurfaceFormat2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceFormat2KHR" );
  if( j.find( "surfaceFormat" ) != j.end() ) {
    p.surfaceFormat = SurfaceFormatKHR ( j[ "surfaceFormat" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSurfaceFormat2KHR &p ) {
  VULKAN_HPP_NAMESPACE :: SurfaceFormat2KHR temp;
  from_json( j, temp );
  p = VkSurfaceFormat2KHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SurfaceProtectedCapabilitiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "supportsProtected" ] = bool( p.supportsProtected );
}
}
void to_json( nlohmann::json &j, const VkSurfaceProtectedCapabilitiesKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SurfaceProtectedCapabilitiesKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SurfaceProtectedCapabilitiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceProtectedCapabilitiesKHR" );
  if( j.find( "supportsProtected" ) != j.end() ) {
    p.supportsProtected = j[ "supportsProtected" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSurfaceProtectedCapabilitiesKHR &p ) {
  VULKAN_HPP_NAMESPACE :: SurfaceProtectedCapabilitiesKHR temp;
  from_json( j, temp );
  p = VkSurfaceProtectedCapabilitiesKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SurfaceCounterFlagsEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SwapchainCounterCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "surfaceCounters" ] = p.surfaceCounters;
}
}
void to_json( nlohmann::json &j, const VkSwapchainCounterCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SwapchainCounterCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SwapchainCounterCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SwapchainCounterCreateInfoEXT" );
  if( j.find( "surfaceCounters" ) != j.end() ) {
    p.surfaceCounters = SurfaceCounterFlagsEXT ( j[ "surfaceCounters" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkSwapchainCounterCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: SwapchainCounterCreateInfoEXT temp;
  from_json( j, temp );
  p = VkSwapchainCounterCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/SwapchainCreateFlagsKHR.hpp>
#include <vulkan2json/Format.hpp>
#include <vulkan2json/ColorSpaceKHR.hpp>
#include <vulkan2json/Extent2D.hpp>
#include <vulkan2json/ImageUsageFlags.hpp>
#include <vulkan2json/SharingMode.hpp>
#include <vulkan2json/SurfaceTransformFlagsKHR.hpp>
#include <vulkan2json/CompositeAlphaFlagsKHR.hpp>
#include <vulkan2json/PresentModeKHR.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SwapchainCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "minImageCount" ] = p.minImageCount;
  j[ "imageFormat" ] = p.imageFormat;
  j[ "imageColorSpace" ] = p.imageColorSpace;
  j[ "imageExtent" ] = p.imageExtent;
  j[ "imageArrayLayers" ] = p.imageArrayLayers;
  j[ "imageUsage" ] = p.imageUsage;
  j[ "imageSharingMode" ] = p.imageSharingMode;
  j[ "queueFamilyIndexCount" ] = p.queueFamilyIndexCount;
  j[ "pQueueFamilyIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pQueueFamilyIndices ) );
  j[ "preTransform" ] = p.preTransform;
  j[ "compositeAlpha" ] = p.compositeAlpha;
  j[ "presentMode" ] = p.presentMode;
  j[ "clipped" ] = bool( p.clipped );
}
}
void to_json( nlohmann::json &j, const VkSwapchainCreateInfoKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SwapchainCreateInfoKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SwapchainCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SwapchainCreateInfoKHR" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = SwapchainCreateFlagsKHR ( j[ "flags" ] );
  }
  if( j.find( "minImageCount" ) != j.end() ) {
    p.minImageCount = j[ "minImageCount" ];
  }
  if( j.find( "imageFormat" ) != j.end() ) {
    p.imageFormat = Format ( j[ "imageFormat" ] );
  }
  if( j.find( "imageColorSpace" ) != j.end() ) {
    p.imageColorSpace = ColorSpaceKHR ( j[ "imageColorSpace" ] );
  }
  if( j.find( "imageExtent" ) != j.end() ) {
    p.imageExtent = Extent2D ( j[ "imageExtent" ] );
  }
  if( j.find( "imageArrayLayers" ) != j.end() ) {
    p.imageArrayLayers = j[ "imageArrayLayers" ];
  }
  if( j.find( "imageUsage" ) != j.end() ) {
    p.imageUsage = ImageUsageFlags ( j[ "imageUsage" ] );
  }
  if( j.find( "imageSharingMode" ) != j.end() ) {
    p.imageSharingMode = SharingMode ( j[ "imageSharingMode" ] );
  }
  if( j.find( "queueFamilyIndexCount" ) != j.end() ) {
    p.queueFamilyIndexCount = j[ "queueFamilyIndexCount" ];
  }
  if( j.find( "preTransform" ) != j.end() ) {
    p.preTransform = SurfaceTransformFlagBitsKHR ( j[ "preTransform" ] );
  }
  if( j.find( "compositeAlpha" ) != j.end() ) {
    p.compositeAlpha = CompositeAlphaFlagBitsKHR ( j[ "compositeAlpha" ] );
  }
  if( j.find( "presentMode" ) != j.end() ) {
    p.presentMode = PresentModeKHR ( j[ "presentMode" ] );
  }
  if( j.find( "clipped" ) != j.end() ) {
    p.clipped = j[ "clipped" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSwapchainCreateInfoKHR &p ) {
  VULKAN_HPP_NAMESPACE :: SwapchainCreateInfoKHR temp;
  from_json( j, temp );
  p = VkSwapchainCreateInfoKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const SwapchainDisplayNativeHdrCreateInfoAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "localDimmingEnable" ] = bool( p.localDimmingEnable );
}
}
void to_json( nlohmann::json &j, const VkSwapchainDisplayNativeHdrCreateInfoAMD &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: SwapchainDisplayNativeHdrCreateInfoAMD ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, SwapchainDisplayNativeHdrCreateInfoAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SwapchainDisplayNativeHdrCreateInfoAMD" );
  if( j.find( "localDimmingEnable" ) != j.end() ) {
    p.localDimmingEnable = j[ "localDimmingEnable" ];
  }
}
}
void from_json( const nlohmann::json &j, VkSwapchainDisplayNativeHdrCreateInfoAMD &p ) {
  VULKAN_HPP_NAMESPACE :: SwapchainDisplayNativeHdrCreateInfoAMD temp;
  from_json( j, temp );
  p = VkSwapchainDisplayNativeHdrCreateInfoAMD ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const TextureLODGatherFormatPropertiesAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "supportsTextureGatherLODBiasAMD" ] = bool( p.supportsTextureGatherLODBiasAMD );
}
}
void to_json( nlohmann::json &j, const VkTextureLODGatherFormatPropertiesAMD &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: TextureLODGatherFormatPropertiesAMD ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, TextureLODGatherFormatPropertiesAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for TextureLODGatherFormatPropertiesAMD" );
  if( j.find( "supportsTextureGatherLODBiasAMD" ) != j.end() ) {
    p.supportsTextureGatherLODBiasAMD = j[ "supportsTextureGatherLODBiasAMD" ];
  }
}
}
void from_json( const nlohmann::json &j, VkTextureLODGatherFormatPropertiesAMD &p ) {
  VULKAN_HPP_NAMESPACE :: TextureLODGatherFormatPropertiesAMD temp;
  from_json( j, temp );
  p = VkTextureLODGatherFormatPropertiesAMD ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const TimelineSemaphoreSubmitInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "waitSemaphoreValueCount" ] = p.waitSemaphoreValueCount;
  j[ "pWaitSemaphoreValues" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitSemaphoreValues ) );
  j[ "signalSemaphoreValueCount" ] = p.signalSemaphoreValueCount;
  j[ "pSignalSemaphoreValues" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSignalSemaphoreValues ) );
}
}
void to_json( nlohmann::json &j, const VkTimelineSemaphoreSubmitInfo &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: TimelineSemaphoreSubmitInfo ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, TimelineSemaphoreSubmitInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for TimelineSemaphoreSubmitInfo" );
  if( j.find( "waitSemaphoreValueCount" ) != j.end() ) {
    p.waitSemaphoreValueCount = j[ "waitSemaphoreValueCount" ];
  }
  if( j.find( "signalSemaphoreValueCount" ) != j.end() ) {
    p.signalSemaphoreValueCount = j[ "signalSemaphoreValueCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkTimelineSemaphoreSubmitInfo &p ) {
  VULKAN_HPP_NAMESPACE :: TimelineSemaphoreSubmitInfo temp;
  from_json( j, temp );
  p = VkTimelineSemaphoreSubmitInfo ( temp );
}
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const TraceRaysIndirectCommandKHR &p ) {
  j = nlohmann::json::object();
  j[ "width" ] = p.width;
  j[ "height" ] = p.height;
  j[ "depth" ] = p.depth;
}
}
void to_json( nlohmann::json &j, const VkTraceRaysIndirectCommandKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: TraceRaysIndirectCommandKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, TraceRaysIndirectCommandKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for TraceRaysIndirectCommandKHR" );
  if( j.find( "width" ) != j.end() ) {
    p.width = j[ "width" ];
  }
  if( j.find( "height" ) != j.end() ) {
    p.height = j[ "height" ];
  }
  if( j.find( "depth" ) != j.end() ) {
    p.depth = j[ "depth" ];
  }
}
}
void from_json( const nlohmann::json &j, VkTraceRaysIndirectCommandKHR &p ) {
  VULKAN_HPP_NAMESPACE :: TraceRaysIndirectCommandKHR temp;
  from_json( j, temp );
  p = VkTraceRaysIndirectCommandKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/ValidationCacheCreateFlagsEXT.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ValidationCacheCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "initialDataSize" ] = p.initialDataSize;
  j[ "pInitialData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pInitialData ) );
}
}
void to_json( nlohmann::json &j, const VkValidationCacheCreateInfoEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ValidationCacheCreateInfoEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ValidationCacheCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ValidationCacheCreateInfoEXT" );
  if( j.find( "flags" ) != j.end() ) {
    p.flags = ValidationCacheCreateFlagsEXT ( j[ "flags" ] );
  }
  if( j.find( "initialDataSize" ) != j.end() ) {
    p.initialDataSize = j[ "initialDataSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkValidationCacheCreateInfoEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ValidationCacheCreateInfoEXT temp;
  from_json( j, temp );
  p = VkValidationCacheCreateInfoEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ValidationFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "enabledValidationFeatureCount" ] = p.enabledValidationFeatureCount;
  j[ "pEnabledValidationFeatures" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pEnabledValidationFeatures ) );
  j[ "disabledValidationFeatureCount" ] = p.disabledValidationFeatureCount;
  j[ "pDisabledValidationFeatures" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDisabledValidationFeatures ) );
}
}
void to_json( nlohmann::json &j, const VkValidationFeaturesEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ValidationFeaturesEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ValidationFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ValidationFeaturesEXT" );
  if( j.find( "enabledValidationFeatureCount" ) != j.end() ) {
    p.enabledValidationFeatureCount = j[ "enabledValidationFeatureCount" ];
  }
  if( j.find( "disabledValidationFeatureCount" ) != j.end() ) {
    p.disabledValidationFeatureCount = j[ "disabledValidationFeatureCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkValidationFeaturesEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ValidationFeaturesEXT temp;
  from_json( j, temp );
  p = VkValidationFeaturesEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const ValidationFlagsEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "disabledValidationCheckCount" ] = p.disabledValidationCheckCount;
  j[ "pDisabledValidationChecks" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDisabledValidationChecks ) );
}
}
void to_json( nlohmann::json &j, const VkValidationFlagsEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: ValidationFlagsEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, ValidationFlagsEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ValidationFlagsEXT" );
  if( j.find( "disabledValidationCheckCount" ) != j.end() ) {
    p.disabledValidationCheckCount = j[ "disabledValidationCheckCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkValidationFlagsEXT &p ) {
  VULKAN_HPP_NAMESPACE :: ValidationFlagsEXT temp;
  from_json( j, temp );
  p = VkValidationFlagsEXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/Format.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const VertexInputAttributeDescription2EXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "location" ] = p.location;
  j[ "binding" ] = p.binding;
  j[ "format" ] = p.format;
  j[ "offset" ] = p.offset;
}
}
void to_json( nlohmann::json &j, const VkVertexInputAttributeDescription2EXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: VertexInputAttributeDescription2EXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, VertexInputAttributeDescription2EXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VertexInputAttributeDescription2EXT" );
  if( j.find( "location" ) != j.end() ) {
    p.location = j[ "location" ];
  }
  if( j.find( "binding" ) != j.end() ) {
    p.binding = j[ "binding" ];
  }
  if( j.find( "format" ) != j.end() ) {
    p.format = Format ( j[ "format" ] );
  }
  if( j.find( "offset" ) != j.end() ) {
    p.offset = j[ "offset" ];
  }
}
}
void from_json( const nlohmann::json &j, VkVertexInputAttributeDescription2EXT &p ) {
  VULKAN_HPP_NAMESPACE :: VertexInputAttributeDescription2EXT temp;
  from_json( j, temp );
  p = VkVertexInputAttributeDescription2EXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/VertexInputRate.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const VertexInputBindingDescription2EXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "binding" ] = p.binding;
  j[ "stride" ] = p.stride;
  j[ "inputRate" ] = p.inputRate;
  j[ "divisor" ] = p.divisor;
}
}
void to_json( nlohmann::json &j, const VkVertexInputBindingDescription2EXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: VertexInputBindingDescription2EXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, VertexInputBindingDescription2EXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VertexInputBindingDescription2EXT" );
  if( j.find( "binding" ) != j.end() ) {
    p.binding = j[ "binding" ];
  }
  if( j.find( "stride" ) != j.end() ) {
    p.stride = j[ "stride" ];
  }
  if( j.find( "inputRate" ) != j.end() ) {
    p.inputRate = VertexInputRate ( j[ "inputRate" ] );
  }
  if( j.find( "divisor" ) != j.end() ) {
    p.divisor = j[ "divisor" ];
  }
}
}
void from_json( const nlohmann::json &j, VkVertexInputBindingDescription2EXT &p ) {
  VULKAN_HPP_NAMESPACE :: VertexInputBindingDescription2EXT temp;
  from_json( j, temp );
  p = VkVertexInputBindingDescription2EXT ( temp );
}
#include <vulkan2json/StructureType.hpp>
#include <vulkan2json/DescriptorType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const WriteDescriptorSet &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dstBinding" ] = p.dstBinding;
  j[ "dstArrayElement" ] = p.dstArrayElement;
  j[ "descriptorCount" ] = p.descriptorCount;
  j[ "descriptorType" ] = p.descriptorType;
  j[ "pImageInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pImageInfo ) );
  j[ "pBufferInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBufferInfo ) );
  j[ "pTexelBufferView" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pTexelBufferView ) );
}
}
void to_json( nlohmann::json &j, const VkWriteDescriptorSet &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: WriteDescriptorSet ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, WriteDescriptorSet &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for WriteDescriptorSet" );
  if( j.find( "dstBinding" ) != j.end() ) {
    p.dstBinding = j[ "dstBinding" ];
  }
  if( j.find( "dstArrayElement" ) != j.end() ) {
    p.dstArrayElement = j[ "dstArrayElement" ];
  }
  if( j.find( "descriptorCount" ) != j.end() ) {
    p.descriptorCount = j[ "descriptorCount" ];
  }
  if( j.find( "descriptorType" ) != j.end() ) {
    p.descriptorType = DescriptorType ( j[ "descriptorType" ] );
  }
}
}
void from_json( const nlohmann::json &j, VkWriteDescriptorSet &p ) {
  VULKAN_HPP_NAMESPACE :: WriteDescriptorSet temp;
  from_json( j, temp );
  p = VkWriteDescriptorSet ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const WriteDescriptorSetAccelerationStructureKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "accelerationStructureCount" ] = p.accelerationStructureCount;
  j[ "pAccelerationStructures" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAccelerationStructures ) );
}
}
void to_json( nlohmann::json &j, const VkWriteDescriptorSetAccelerationStructureKHR &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: WriteDescriptorSetAccelerationStructureKHR ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, WriteDescriptorSetAccelerationStructureKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for WriteDescriptorSetAccelerationStructureKHR" );
  if( j.find( "accelerationStructureCount" ) != j.end() ) {
    p.accelerationStructureCount = j[ "accelerationStructureCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkWriteDescriptorSetAccelerationStructureKHR &p ) {
  VULKAN_HPP_NAMESPACE :: WriteDescriptorSetAccelerationStructureKHR temp;
  from_json( j, temp );
  p = VkWriteDescriptorSetAccelerationStructureKHR ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const WriteDescriptorSetAccelerationStructureNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "accelerationStructureCount" ] = p.accelerationStructureCount;
  j[ "pAccelerationStructures" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAccelerationStructures ) );
}
}
void to_json( nlohmann::json &j, const VkWriteDescriptorSetAccelerationStructureNV &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: WriteDescriptorSetAccelerationStructureNV ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, WriteDescriptorSetAccelerationStructureNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for WriteDescriptorSetAccelerationStructureNV" );
  if( j.find( "accelerationStructureCount" ) != j.end() ) {
    p.accelerationStructureCount = j[ "accelerationStructureCount" ];
  }
}
}
void from_json( const nlohmann::json &j, VkWriteDescriptorSetAccelerationStructureNV &p ) {
  VULKAN_HPP_NAMESPACE :: WriteDescriptorSetAccelerationStructureNV temp;
  from_json( j, temp );
  p = VkWriteDescriptorSetAccelerationStructureNV ( temp );
}
#include <vulkan2json/StructureType.hpp>
namespace VULKAN_HPP_NAMESPACE {
void to_json( nlohmann::json &j, const WriteDescriptorSetInlineUniformBlockEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dataSize" ] = p.dataSize;
  j[ "pData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pData ) );
}
}
void to_json( nlohmann::json &j, const VkWriteDescriptorSetInlineUniformBlockEXT &p ) {
  to_json( j, VULKAN_HPP_NAMESPACE :: WriteDescriptorSetInlineUniformBlockEXT ( p ) );
}
namespace VULKAN_HPP_NAMESPACE {
void from_json( const nlohmann::json &j, WriteDescriptorSetInlineUniformBlockEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for WriteDescriptorSetInlineUniformBlockEXT" );
  if( j.find( "dataSize" ) != j.end() ) {
    p.dataSize = j[ "dataSize" ];
  }
}
}
void from_json( const nlohmann::json &j, VkWriteDescriptorSetInlineUniformBlockEXT &p ) {
  VULKAN_HPP_NAMESPACE :: WriteDescriptorSetInlineUniformBlockEXT temp;
  from_json( j, temp );
  p = VkWriteDescriptorSetInlineUniformBlockEXT ( temp );
}
