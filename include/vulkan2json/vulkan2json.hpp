/*
 * Copyright (c) 2021 Naomasa Matsubayashi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#ifndef VULKAN2JSON_HPP
#define VULKAN2JSON_HPP

#include <cstddef>
#include <cstdint>
#include <utility>
#include <cstring>
#include <string>
#include <algorithm>
#include <stdexcept>
#include <nlohmann/json.hpp>
#include <vulkan/vulkan.hpp>

namespace vulkan2json {
  struct invalid_enum_value : public std::invalid_argument {
    using std::invalid_argument::invalid_argument;
  };
  struct invalid_flag_value : public std::invalid_argument {
    using std::invalid_argument::invalid_argument;
  };
  struct invalid_array_value : public std::invalid_argument {
    using std::invalid_argument::invalid_argument;
  };
  struct invalid_object_value : public std::invalid_argument {
    using std::invalid_argument::invalid_argument;
  };
}
namespace VULKAN_HPP_NAMESPACE {

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const Result &p ) {
  if( Result :: eSuccess == p ) {
    j = "Success";
    return;
  }
  if( Result :: eNotReady == p ) {
    j = "NotReady";
    return;
  }
  if( Result :: eTimeout == p ) {
    j = "Timeout";
    return;
  }
  if( Result :: eEventSet == p ) {
    j = "EventSet";
    return;
  }
  if( Result :: eEventReset == p ) {
    j = "EventReset";
    return;
  }
  if( Result :: eIncomplete == p ) {
    j = "Incomplete";
    return;
  }
  if( Result :: eErrorOutOfHostMemory == p ) {
    j = "ErrorOutOfHostMemory";
    return;
  }
  if( Result :: eErrorOutOfDeviceMemory == p ) {
    j = "ErrorOutOfDeviceMemory";
    return;
  }
  if( Result :: eErrorInitializationFailed == p ) {
    j = "ErrorInitializationFailed";
    return;
  }
  if( Result :: eErrorDeviceLost == p ) {
    j = "ErrorDeviceLost";
    return;
  }
  if( Result :: eErrorMemoryMapFailed == p ) {
    j = "ErrorMemoryMapFailed";
    return;
  }
  if( Result :: eErrorLayerNotPresent == p ) {
    j = "ErrorLayerNotPresent";
    return;
  }
  if( Result :: eErrorExtensionNotPresent == p ) {
    j = "ErrorExtensionNotPresent";
    return;
  }
  if( Result :: eErrorFeatureNotPresent == p ) {
    j = "ErrorFeatureNotPresent";
    return;
  }
  if( Result :: eErrorIncompatibleDriver == p ) {
    j = "ErrorIncompatibleDriver";
    return;
  }
  if( Result :: eErrorTooManyObjects == p ) {
    j = "ErrorTooManyObjects";
    return;
  }
  if( Result :: eErrorFormatNotSupported == p ) {
    j = "ErrorFormatNotSupported";
    return;
  }
  if( Result :: eErrorFragmentedPool == p ) {
    j = "ErrorFragmentedPool";
    return;
  }
  if( Result :: eErrorUnknown == p ) {
    j = "ErrorUnknown";
    return;
  }
  if( Result :: eErrorOutOfPoolMemory == p ) {
    j = "ErrorOutOfPoolMemory";
    return;
  }
  if( Result :: eErrorInvalidExternalHandle == p ) {
    j = "ErrorInvalidExternalHandle";
    return;
  }
  if( Result :: eErrorFragmentation == p ) {
    j = "ErrorFragmentation";
    return;
  }
  if( Result :: eErrorInvalidOpaqueCaptureAddress == p ) {
    j = "ErrorInvalidOpaqueCaptureAddress";
    return;
  }
  if( Result :: eErrorSurfaceLostKHR == p ) {
    j = "ErrorSurfaceLostKHR";
    return;
  }
  if( Result :: eErrorNativeWindowInUseKHR == p ) {
    j = "ErrorNativeWindowInUseKHR";
    return;
  }
  if( Result :: eSuboptimalKHR == p ) {
    j = "SuboptimalKHR";
    return;
  }
  if( Result :: eErrorOutOfDateKHR == p ) {
    j = "ErrorOutOfDateKHR";
    return;
  }
  if( Result :: eErrorIncompatibleDisplayKHR == p ) {
    j = "ErrorIncompatibleDisplayKHR";
    return;
  }
  if( Result :: eErrorValidationFailedEXT == p ) {
    j = "ErrorValidationFailedEXT";
    return;
  }
  if( Result :: eErrorInvalidShaderNV == p ) {
    j = "ErrorInvalidShaderNV";
    return;
  }
  if( Result :: eErrorInvalidDrmFormatModifierPlaneLayoutEXT == p ) {
    j = "ErrorInvalidDrmFormatModifierPlaneLayoutEXT";
    return;
  }
  if( Result :: eErrorNotPermittedEXT == p ) {
    j = "ErrorNotPermittedEXT";
    return;
  }
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( Result :: eErrorFullScreenExclusiveModeLostEXT == p ) {
    j = "ErrorFullScreenExclusiveModeLostEXT";
    return;
  }
#endif
  if( Result :: eThreadIdleKHR == p ) {
    j = "ThreadIdleKHR";
    return;
  }
  if( Result :: eThreadDoneKHR == p ) {
    j = "ThreadDoneKHR";
    return;
  }
  if( Result :: eOperationDeferredKHR == p ) {
    j = "OperationDeferredKHR";
    return;
  }
  if( Result :: eOperationNotDeferredKHR == p ) {
    j = "OperationNotDeferredKHR";
    return;
  }
  if( Result :: ePipelineCompileRequiredEXT == p ) {
    j = "PipelineCompileRequiredEXT";
    return;
  }
  if( Result :: eErrorFragmentationEXT == p ) {
    j = "ErrorFragmentationEXT";
    return;
  }
  if( Result :: eErrorInvalidDeviceAddressEXT == p ) {
    j = "ErrorInvalidDeviceAddressEXT";
    return;
  }
  if( Result :: eErrorInvalidExternalHandleKHR == p ) {
    j = "ErrorInvalidExternalHandleKHR";
    return;
  }
  if( Result :: eErrorInvalidOpaqueCaptureAddressKHR == p ) {
    j = "ErrorInvalidOpaqueCaptureAddressKHR";
    return;
  }
  if( Result :: eErrorOutOfPoolMemoryKHR == p ) {
    j = "ErrorOutOfPoolMemoryKHR";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkResult &p ) {
  to_json( j, Result ( p ) );
}
inline void from_json( const nlohmann::json &j, Result &p ) {
  if( j.is_string() ) {
    if( "Success" == j.get< std::string >() ) {
      p = Result :: eSuccess ;
      return;
    }
    if( "eSuccess" == j.get< std::string >() ) {
      p = Result :: eSuccess ;
      return;
    }
    if( "VK_SUCCESS" == j.get< std::string >() ) {
      p = Result :: eSuccess ;
      return;
    }
    if( "NotReady" == j.get< std::string >() ) {
      p = Result :: eNotReady ;
      return;
    }
    if( "eNotReady" == j.get< std::string >() ) {
      p = Result :: eNotReady ;
      return;
    }
    if( "VK_NOT_READY" == j.get< std::string >() ) {
      p = Result :: eNotReady ;
      return;
    }
    if( "Timeout" == j.get< std::string >() ) {
      p = Result :: eTimeout ;
      return;
    }
    if( "eTimeout" == j.get< std::string >() ) {
      p = Result :: eTimeout ;
      return;
    }
    if( "VK_TIMEOUT" == j.get< std::string >() ) {
      p = Result :: eTimeout ;
      return;
    }
    if( "EventSet" == j.get< std::string >() ) {
      p = Result :: eEventSet ;
      return;
    }
    if( "eEventSet" == j.get< std::string >() ) {
      p = Result :: eEventSet ;
      return;
    }
    if( "VK_EVENT_SET" == j.get< std::string >() ) {
      p = Result :: eEventSet ;
      return;
    }
    if( "EventReset" == j.get< std::string >() ) {
      p = Result :: eEventReset ;
      return;
    }
    if( "eEventReset" == j.get< std::string >() ) {
      p = Result :: eEventReset ;
      return;
    }
    if( "VK_EVENT_RESET" == j.get< std::string >() ) {
      p = Result :: eEventReset ;
      return;
    }
    if( "Incomplete" == j.get< std::string >() ) {
      p = Result :: eIncomplete ;
      return;
    }
    if( "eIncomplete" == j.get< std::string >() ) {
      p = Result :: eIncomplete ;
      return;
    }
    if( "VK_INCOMPLETE" == j.get< std::string >() ) {
      p = Result :: eIncomplete ;
      return;
    }
    if( "ErrorOutOfHostMemory" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfHostMemory ;
      return;
    }
    if( "eErrorOutOfHostMemory" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfHostMemory ;
      return;
    }
    if( "VK_ERROR_OUT_OF_HOST_MEMORY" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfHostMemory ;
      return;
    }
    if( "ErrorOutOfDeviceMemory" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfDeviceMemory ;
      return;
    }
    if( "eErrorOutOfDeviceMemory" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfDeviceMemory ;
      return;
    }
    if( "VK_ERROR_OUT_OF_DEVICE_MEMORY" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfDeviceMemory ;
      return;
    }
    if( "ErrorInitializationFailed" == j.get< std::string >() ) {
      p = Result :: eErrorInitializationFailed ;
      return;
    }
    if( "eErrorInitializationFailed" == j.get< std::string >() ) {
      p = Result :: eErrorInitializationFailed ;
      return;
    }
    if( "VK_ERROR_INITIALIZATION_FAILED" == j.get< std::string >() ) {
      p = Result :: eErrorInitializationFailed ;
      return;
    }
    if( "ErrorDeviceLost" == j.get< std::string >() ) {
      p = Result :: eErrorDeviceLost ;
      return;
    }
    if( "eErrorDeviceLost" == j.get< std::string >() ) {
      p = Result :: eErrorDeviceLost ;
      return;
    }
    if( "VK_ERROR_DEVICE_LOST" == j.get< std::string >() ) {
      p = Result :: eErrorDeviceLost ;
      return;
    }
    if( "ErrorMemoryMapFailed" == j.get< std::string >() ) {
      p = Result :: eErrorMemoryMapFailed ;
      return;
    }
    if( "eErrorMemoryMapFailed" == j.get< std::string >() ) {
      p = Result :: eErrorMemoryMapFailed ;
      return;
    }
    if( "VK_ERROR_MEMORY_MAP_FAILED" == j.get< std::string >() ) {
      p = Result :: eErrorMemoryMapFailed ;
      return;
    }
    if( "ErrorLayerNotPresent" == j.get< std::string >() ) {
      p = Result :: eErrorLayerNotPresent ;
      return;
    }
    if( "eErrorLayerNotPresent" == j.get< std::string >() ) {
      p = Result :: eErrorLayerNotPresent ;
      return;
    }
    if( "VK_ERROR_LAYER_NOT_PRESENT" == j.get< std::string >() ) {
      p = Result :: eErrorLayerNotPresent ;
      return;
    }
    if( "ErrorExtensionNotPresent" == j.get< std::string >() ) {
      p = Result :: eErrorExtensionNotPresent ;
      return;
    }
    if( "eErrorExtensionNotPresent" == j.get< std::string >() ) {
      p = Result :: eErrorExtensionNotPresent ;
      return;
    }
    if( "VK_ERROR_EXTENSION_NOT_PRESENT" == j.get< std::string >() ) {
      p = Result :: eErrorExtensionNotPresent ;
      return;
    }
    if( "ErrorFeatureNotPresent" == j.get< std::string >() ) {
      p = Result :: eErrorFeatureNotPresent ;
      return;
    }
    if( "eErrorFeatureNotPresent" == j.get< std::string >() ) {
      p = Result :: eErrorFeatureNotPresent ;
      return;
    }
    if( "VK_ERROR_FEATURE_NOT_PRESENT" == j.get< std::string >() ) {
      p = Result :: eErrorFeatureNotPresent ;
      return;
    }
    if( "ErrorIncompatibleDriver" == j.get< std::string >() ) {
      p = Result :: eErrorIncompatibleDriver ;
      return;
    }
    if( "eErrorIncompatibleDriver" == j.get< std::string >() ) {
      p = Result :: eErrorIncompatibleDriver ;
      return;
    }
    if( "VK_ERROR_INCOMPATIBLE_DRIVER" == j.get< std::string >() ) {
      p = Result :: eErrorIncompatibleDriver ;
      return;
    }
    if( "ErrorTooManyObjects" == j.get< std::string >() ) {
      p = Result :: eErrorTooManyObjects ;
      return;
    }
    if( "eErrorTooManyObjects" == j.get< std::string >() ) {
      p = Result :: eErrorTooManyObjects ;
      return;
    }
    if( "VK_ERROR_TOO_MANY_OBJECTS" == j.get< std::string >() ) {
      p = Result :: eErrorTooManyObjects ;
      return;
    }
    if( "ErrorFormatNotSupported" == j.get< std::string >() ) {
      p = Result :: eErrorFormatNotSupported ;
      return;
    }
    if( "eErrorFormatNotSupported" == j.get< std::string >() ) {
      p = Result :: eErrorFormatNotSupported ;
      return;
    }
    if( "VK_ERROR_FORMAT_NOT_SUPPORTED" == j.get< std::string >() ) {
      p = Result :: eErrorFormatNotSupported ;
      return;
    }
    if( "ErrorFragmentedPool" == j.get< std::string >() ) {
      p = Result :: eErrorFragmentedPool ;
      return;
    }
    if( "eErrorFragmentedPool" == j.get< std::string >() ) {
      p = Result :: eErrorFragmentedPool ;
      return;
    }
    if( "VK_ERROR_FRAGMENTED_POOL" == j.get< std::string >() ) {
      p = Result :: eErrorFragmentedPool ;
      return;
    }
    if( "ErrorUnknown" == j.get< std::string >() ) {
      p = Result :: eErrorUnknown ;
      return;
    }
    if( "eErrorUnknown" == j.get< std::string >() ) {
      p = Result :: eErrorUnknown ;
      return;
    }
    if( "VK_ERROR_UNKNOWN" == j.get< std::string >() ) {
      p = Result :: eErrorUnknown ;
      return;
    }
    if( "ErrorOutOfPoolMemory" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfPoolMemory ;
      return;
    }
    if( "eErrorOutOfPoolMemory" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfPoolMemory ;
      return;
    }
    if( "VK_ERROR_OUT_OF_POOL_MEMORY" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfPoolMemory ;
      return;
    }
    if( "ErrorInvalidExternalHandle" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidExternalHandle ;
      return;
    }
    if( "eErrorInvalidExternalHandle" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidExternalHandle ;
      return;
    }
    if( "VK_ERROR_INVALID_EXTERNAL_HANDLE" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidExternalHandle ;
      return;
    }
    if( "ErrorFragmentation" == j.get< std::string >() ) {
      p = Result :: eErrorFragmentation ;
      return;
    }
    if( "eErrorFragmentation" == j.get< std::string >() ) {
      p = Result :: eErrorFragmentation ;
      return;
    }
    if( "VK_ERROR_FRAGMENTATION" == j.get< std::string >() ) {
      p = Result :: eErrorFragmentation ;
      return;
    }
    if( "ErrorInvalidOpaqueCaptureAddress" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidOpaqueCaptureAddress ;
      return;
    }
    if( "eErrorInvalidOpaqueCaptureAddress" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidOpaqueCaptureAddress ;
      return;
    }
    if( "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidOpaqueCaptureAddress ;
      return;
    }
    if( "ErrorSurfaceLostKHR" == j.get< std::string >() ) {
      p = Result :: eErrorSurfaceLostKHR ;
      return;
    }
    if( "eErrorSurfaceLostKHR" == j.get< std::string >() ) {
      p = Result :: eErrorSurfaceLostKHR ;
      return;
    }
    if( "VK_ERROR_SURFACE_LOST_KHR" == j.get< std::string >() ) {
      p = Result :: eErrorSurfaceLostKHR ;
      return;
    }
    if( "ErrorNativeWindowInUseKHR" == j.get< std::string >() ) {
      p = Result :: eErrorNativeWindowInUseKHR ;
      return;
    }
    if( "eErrorNativeWindowInUseKHR" == j.get< std::string >() ) {
      p = Result :: eErrorNativeWindowInUseKHR ;
      return;
    }
    if( "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR" == j.get< std::string >() ) {
      p = Result :: eErrorNativeWindowInUseKHR ;
      return;
    }
    if( "SuboptimalKHR" == j.get< std::string >() ) {
      p = Result :: eSuboptimalKHR ;
      return;
    }
    if( "eSuboptimalKHR" == j.get< std::string >() ) {
      p = Result :: eSuboptimalKHR ;
      return;
    }
    if( "VK_SUBOPTIMAL_KHR" == j.get< std::string >() ) {
      p = Result :: eSuboptimalKHR ;
      return;
    }
    if( "ErrorOutOfDateKHR" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfDateKHR ;
      return;
    }
    if( "eErrorOutOfDateKHR" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfDateKHR ;
      return;
    }
    if( "VK_ERROR_OUT_OF_DATE_KHR" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfDateKHR ;
      return;
    }
    if( "ErrorIncompatibleDisplayKHR" == j.get< std::string >() ) {
      p = Result :: eErrorIncompatibleDisplayKHR ;
      return;
    }
    if( "eErrorIncompatibleDisplayKHR" == j.get< std::string >() ) {
      p = Result :: eErrorIncompatibleDisplayKHR ;
      return;
    }
    if( "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR" == j.get< std::string >() ) {
      p = Result :: eErrorIncompatibleDisplayKHR ;
      return;
    }
    if( "ErrorValidationFailedEXT" == j.get< std::string >() ) {
      p = Result :: eErrorValidationFailedEXT ;
      return;
    }
    if( "eErrorValidationFailedEXT" == j.get< std::string >() ) {
      p = Result :: eErrorValidationFailedEXT ;
      return;
    }
    if( "VK_ERROR_VALIDATION_FAILED_EXT" == j.get< std::string >() ) {
      p = Result :: eErrorValidationFailedEXT ;
      return;
    }
    if( "ErrorInvalidShaderNV" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidShaderNV ;
      return;
    }
    if( "eErrorInvalidShaderNV" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidShaderNV ;
      return;
    }
    if( "VK_ERROR_INVALID_SHADER_NV" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidShaderNV ;
      return;
    }
    if( "ErrorInvalidDrmFormatModifierPlaneLayoutEXT" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidDrmFormatModifierPlaneLayoutEXT ;
      return;
    }
    if( "eErrorInvalidDrmFormatModifierPlaneLayoutEXT" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidDrmFormatModifierPlaneLayoutEXT ;
      return;
    }
    if( "VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidDrmFormatModifierPlaneLayoutEXT ;
      return;
    }
    if( "ErrorNotPermittedEXT" == j.get< std::string >() ) {
      p = Result :: eErrorNotPermittedEXT ;
      return;
    }
    if( "eErrorNotPermittedEXT" == j.get< std::string >() ) {
      p = Result :: eErrorNotPermittedEXT ;
      return;
    }
    if( "VK_ERROR_NOT_PERMITTED_EXT" == j.get< std::string >() ) {
      p = Result :: eErrorNotPermittedEXT ;
      return;
    }
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "ErrorFullScreenExclusiveModeLostEXT" == j.get< std::string >() ) {
      p = Result :: eErrorFullScreenExclusiveModeLostEXT ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eErrorFullScreenExclusiveModeLostEXT" == j.get< std::string >() ) {
      p = Result :: eErrorFullScreenExclusiveModeLostEXT ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT" == j.get< std::string >() ) {
      p = Result :: eErrorFullScreenExclusiveModeLostEXT ;
      return;
    }
#endif
    if( "ThreadIdleKHR" == j.get< std::string >() ) {
      p = Result :: eThreadIdleKHR ;
      return;
    }
    if( "eThreadIdleKHR" == j.get< std::string >() ) {
      p = Result :: eThreadIdleKHR ;
      return;
    }
    if( "VK_THREAD_IDLE_KHR" == j.get< std::string >() ) {
      p = Result :: eThreadIdleKHR ;
      return;
    }
    if( "ThreadDoneKHR" == j.get< std::string >() ) {
      p = Result :: eThreadDoneKHR ;
      return;
    }
    if( "eThreadDoneKHR" == j.get< std::string >() ) {
      p = Result :: eThreadDoneKHR ;
      return;
    }
    if( "VK_THREAD_DONE_KHR" == j.get< std::string >() ) {
      p = Result :: eThreadDoneKHR ;
      return;
    }
    if( "OperationDeferredKHR" == j.get< std::string >() ) {
      p = Result :: eOperationDeferredKHR ;
      return;
    }
    if( "eOperationDeferredKHR" == j.get< std::string >() ) {
      p = Result :: eOperationDeferredKHR ;
      return;
    }
    if( "VK_OPERATION_DEFERRED_KHR" == j.get< std::string >() ) {
      p = Result :: eOperationDeferredKHR ;
      return;
    }
    if( "OperationNotDeferredKHR" == j.get< std::string >() ) {
      p = Result :: eOperationNotDeferredKHR ;
      return;
    }
    if( "eOperationNotDeferredKHR" == j.get< std::string >() ) {
      p = Result :: eOperationNotDeferredKHR ;
      return;
    }
    if( "VK_OPERATION_NOT_DEFERRED_KHR" == j.get< std::string >() ) {
      p = Result :: eOperationNotDeferredKHR ;
      return;
    }
    if( "PipelineCompileRequiredEXT" == j.get< std::string >() ) {
      p = Result :: ePipelineCompileRequiredEXT ;
      return;
    }
    if( "ePipelineCompileRequiredEXT" == j.get< std::string >() ) {
      p = Result :: ePipelineCompileRequiredEXT ;
      return;
    }
    if( "VK_PIPELINE_COMPILE_REQUIRED_EXT" == j.get< std::string >() ) {
      p = Result :: ePipelineCompileRequiredEXT ;
      return;
    }
    if( "ErrorFragmentationEXT" == j.get< std::string >() ) {
      p = Result :: eErrorFragmentationEXT ;
      return;
    }
    if( "eErrorFragmentationEXT" == j.get< std::string >() ) {
      p = Result :: eErrorFragmentationEXT ;
      return;
    }
    if( "VK_ERROR_FRAGMENTATION_EXT" == j.get< std::string >() ) {
      p = Result :: eErrorFragmentationEXT ;
      return;
    }
    if( "ErrorInvalidDeviceAddressEXT" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidDeviceAddressEXT ;
      return;
    }
    if( "eErrorInvalidDeviceAddressEXT" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidDeviceAddressEXT ;
      return;
    }
    if( "VK_ERROR_INVALID_DEVICE_ADDRESS_EXT" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidDeviceAddressEXT ;
      return;
    }
    if( "ErrorInvalidExternalHandleKHR" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidExternalHandleKHR ;
      return;
    }
    if( "eErrorInvalidExternalHandleKHR" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidExternalHandleKHR ;
      return;
    }
    if( "VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidExternalHandleKHR ;
      return;
    }
    if( "ErrorInvalidOpaqueCaptureAddressKHR" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidOpaqueCaptureAddressKHR ;
      return;
    }
    if( "eErrorInvalidOpaqueCaptureAddressKHR" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidOpaqueCaptureAddressKHR ;
      return;
    }
    if( "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR" == j.get< std::string >() ) {
      p = Result :: eErrorInvalidOpaqueCaptureAddressKHR ;
      return;
    }
    if( "ErrorOutOfPoolMemoryKHR" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfPoolMemoryKHR ;
      return;
    }
    if( "eErrorOutOfPoolMemoryKHR" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfPoolMemoryKHR ;
      return;
    }
    if( "VK_ERROR_OUT_OF_POOL_MEMORY_KHR" == j.get< std::string >() ) {
      p = Result :: eErrorOutOfPoolMemoryKHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for Result" );
  }
  if( j.is_number() ) {
    p = Result ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for Result" );
}
inline void from_json( const nlohmann::json &j, VkResult &p ) {
  Result temp;
  from_json( j, temp );
  p = VkResult ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const StructureType &p ) {
  if( StructureType :: eApplicationInfo == p ) {
    j = "ApplicationInfo";
    return;
  }
  if( StructureType :: eInstanceCreateInfo == p ) {
    j = "InstanceCreateInfo";
    return;
  }
  if( StructureType :: eDeviceQueueCreateInfo == p ) {
    j = "DeviceQueueCreateInfo";
    return;
  }
  if( StructureType :: eDeviceCreateInfo == p ) {
    j = "DeviceCreateInfo";
    return;
  }
  if( StructureType :: eSubmitInfo == p ) {
    j = "SubmitInfo";
    return;
  }
  if( StructureType :: eMemoryAllocateInfo == p ) {
    j = "MemoryAllocateInfo";
    return;
  }
  if( StructureType :: eMappedMemoryRange == p ) {
    j = "MappedMemoryRange";
    return;
  }
  if( StructureType :: eBindSparseInfo == p ) {
    j = "BindSparseInfo";
    return;
  }
  if( StructureType :: eFenceCreateInfo == p ) {
    j = "FenceCreateInfo";
    return;
  }
  if( StructureType :: eSemaphoreCreateInfo == p ) {
    j = "SemaphoreCreateInfo";
    return;
  }
  if( StructureType :: eEventCreateInfo == p ) {
    j = "EventCreateInfo";
    return;
  }
  if( StructureType :: eQueryPoolCreateInfo == p ) {
    j = "QueryPoolCreateInfo";
    return;
  }
  if( StructureType :: eBufferCreateInfo == p ) {
    j = "BufferCreateInfo";
    return;
  }
  if( StructureType :: eBufferViewCreateInfo == p ) {
    j = "BufferViewCreateInfo";
    return;
  }
  if( StructureType :: eImageCreateInfo == p ) {
    j = "ImageCreateInfo";
    return;
  }
  if( StructureType :: eImageViewCreateInfo == p ) {
    j = "ImageViewCreateInfo";
    return;
  }
  if( StructureType :: eShaderModuleCreateInfo == p ) {
    j = "ShaderModuleCreateInfo";
    return;
  }
  if( StructureType :: ePipelineCacheCreateInfo == p ) {
    j = "PipelineCacheCreateInfo";
    return;
  }
  if( StructureType :: ePipelineShaderStageCreateInfo == p ) {
    j = "PipelineShaderStageCreateInfo";
    return;
  }
  if( StructureType :: ePipelineVertexInputStateCreateInfo == p ) {
    j = "PipelineVertexInputStateCreateInfo";
    return;
  }
  if( StructureType :: ePipelineInputAssemblyStateCreateInfo == p ) {
    j = "PipelineInputAssemblyStateCreateInfo";
    return;
  }
  if( StructureType :: ePipelineTessellationStateCreateInfo == p ) {
    j = "PipelineTessellationStateCreateInfo";
    return;
  }
  if( StructureType :: ePipelineViewportStateCreateInfo == p ) {
    j = "PipelineViewportStateCreateInfo";
    return;
  }
  if( StructureType :: ePipelineRasterizationStateCreateInfo == p ) {
    j = "PipelineRasterizationStateCreateInfo";
    return;
  }
  if( StructureType :: ePipelineMultisampleStateCreateInfo == p ) {
    j = "PipelineMultisampleStateCreateInfo";
    return;
  }
  if( StructureType :: ePipelineDepthStencilStateCreateInfo == p ) {
    j = "PipelineDepthStencilStateCreateInfo";
    return;
  }
  if( StructureType :: ePipelineColorBlendStateCreateInfo == p ) {
    j = "PipelineColorBlendStateCreateInfo";
    return;
  }
  if( StructureType :: ePipelineDynamicStateCreateInfo == p ) {
    j = "PipelineDynamicStateCreateInfo";
    return;
  }
  if( StructureType :: eGraphicsPipelineCreateInfo == p ) {
    j = "GraphicsPipelineCreateInfo";
    return;
  }
  if( StructureType :: eComputePipelineCreateInfo == p ) {
    j = "ComputePipelineCreateInfo";
    return;
  }
  if( StructureType :: ePipelineLayoutCreateInfo == p ) {
    j = "PipelineLayoutCreateInfo";
    return;
  }
  if( StructureType :: eSamplerCreateInfo == p ) {
    j = "SamplerCreateInfo";
    return;
  }
  if( StructureType :: eDescriptorSetLayoutCreateInfo == p ) {
    j = "DescriptorSetLayoutCreateInfo";
    return;
  }
  if( StructureType :: eDescriptorPoolCreateInfo == p ) {
    j = "DescriptorPoolCreateInfo";
    return;
  }
  if( StructureType :: eDescriptorSetAllocateInfo == p ) {
    j = "DescriptorSetAllocateInfo";
    return;
  }
  if( StructureType :: eWriteDescriptorSet == p ) {
    j = "WriteDescriptorSet";
    return;
  }
  if( StructureType :: eCopyDescriptorSet == p ) {
    j = "CopyDescriptorSet";
    return;
  }
  if( StructureType :: eFramebufferCreateInfo == p ) {
    j = "FramebufferCreateInfo";
    return;
  }
  if( StructureType :: eRenderPassCreateInfo == p ) {
    j = "RenderPassCreateInfo";
    return;
  }
  if( StructureType :: eCommandPoolCreateInfo == p ) {
    j = "CommandPoolCreateInfo";
    return;
  }
  if( StructureType :: eCommandBufferAllocateInfo == p ) {
    j = "CommandBufferAllocateInfo";
    return;
  }
  if( StructureType :: eCommandBufferInheritanceInfo == p ) {
    j = "CommandBufferInheritanceInfo";
    return;
  }
  if( StructureType :: eCommandBufferBeginInfo == p ) {
    j = "CommandBufferBeginInfo";
    return;
  }
  if( StructureType :: eRenderPassBeginInfo == p ) {
    j = "RenderPassBeginInfo";
    return;
  }
  if( StructureType :: eBufferMemoryBarrier == p ) {
    j = "BufferMemoryBarrier";
    return;
  }
  if( StructureType :: eImageMemoryBarrier == p ) {
    j = "ImageMemoryBarrier";
    return;
  }
  if( StructureType :: eMemoryBarrier == p ) {
    j = "MemoryBarrier";
    return;
  }
  if( StructureType :: eLoaderInstanceCreateInfo == p ) {
    j = "LoaderInstanceCreateInfo";
    return;
  }
  if( StructureType :: eLoaderDeviceCreateInfo == p ) {
    j = "LoaderDeviceCreateInfo";
    return;
  }
  if( StructureType :: ePhysicalDeviceSubgroupProperties == p ) {
    j = "PhysicalDeviceSubgroupProperties";
    return;
  }
  if( StructureType :: eBindBufferMemoryInfo == p ) {
    j = "BindBufferMemoryInfo";
    return;
  }
  if( StructureType :: eBindImageMemoryInfo == p ) {
    j = "BindImageMemoryInfo";
    return;
  }
  if( StructureType :: ePhysicalDevice16BitStorageFeatures == p ) {
    j = "PhysicalDevice16BitStorageFeatures";
    return;
  }
  if( StructureType :: eMemoryDedicatedRequirements == p ) {
    j = "MemoryDedicatedRequirements";
    return;
  }
  if( StructureType :: eMemoryDedicatedAllocateInfo == p ) {
    j = "MemoryDedicatedAllocateInfo";
    return;
  }
  if( StructureType :: eMemoryAllocateFlagsInfo == p ) {
    j = "MemoryAllocateFlagsInfo";
    return;
  }
  if( StructureType :: eDeviceGroupRenderPassBeginInfo == p ) {
    j = "DeviceGroupRenderPassBeginInfo";
    return;
  }
  if( StructureType :: eDeviceGroupCommandBufferBeginInfo == p ) {
    j = "DeviceGroupCommandBufferBeginInfo";
    return;
  }
  if( StructureType :: eDeviceGroupSubmitInfo == p ) {
    j = "DeviceGroupSubmitInfo";
    return;
  }
  if( StructureType :: eDeviceGroupBindSparseInfo == p ) {
    j = "DeviceGroupBindSparseInfo";
    return;
  }
  if( StructureType :: eBindBufferMemoryDeviceGroupInfo == p ) {
    j = "BindBufferMemoryDeviceGroupInfo";
    return;
  }
  if( StructureType :: eBindImageMemoryDeviceGroupInfo == p ) {
    j = "BindImageMemoryDeviceGroupInfo";
    return;
  }
  if( StructureType :: ePhysicalDeviceGroupProperties == p ) {
    j = "PhysicalDeviceGroupProperties";
    return;
  }
  if( StructureType :: eDeviceGroupDeviceCreateInfo == p ) {
    j = "DeviceGroupDeviceCreateInfo";
    return;
  }
  if( StructureType :: eBufferMemoryRequirementsInfo2 == p ) {
    j = "BufferMemoryRequirementsInfo2";
    return;
  }
  if( StructureType :: eImageMemoryRequirementsInfo2 == p ) {
    j = "ImageMemoryRequirementsInfo2";
    return;
  }
  if( StructureType :: eImageSparseMemoryRequirementsInfo2 == p ) {
    j = "ImageSparseMemoryRequirementsInfo2";
    return;
  }
  if( StructureType :: eMemoryRequirements2 == p ) {
    j = "MemoryRequirements2";
    return;
  }
  if( StructureType :: eSparseImageMemoryRequirements2 == p ) {
    j = "SparseImageMemoryRequirements2";
    return;
  }
  if( StructureType :: ePhysicalDeviceFeatures2 == p ) {
    j = "PhysicalDeviceFeatures2";
    return;
  }
  if( StructureType :: ePhysicalDeviceProperties2 == p ) {
    j = "PhysicalDeviceProperties2";
    return;
  }
  if( StructureType :: eFormatProperties2 == p ) {
    j = "FormatProperties2";
    return;
  }
  if( StructureType :: eImageFormatProperties2 == p ) {
    j = "ImageFormatProperties2";
    return;
  }
  if( StructureType :: ePhysicalDeviceImageFormatInfo2 == p ) {
    j = "PhysicalDeviceImageFormatInfo2";
    return;
  }
  if( StructureType :: eQueueFamilyProperties2 == p ) {
    j = "QueueFamilyProperties2";
    return;
  }
  if( StructureType :: ePhysicalDeviceMemoryProperties2 == p ) {
    j = "PhysicalDeviceMemoryProperties2";
    return;
  }
  if( StructureType :: eSparseImageFormatProperties2 == p ) {
    j = "SparseImageFormatProperties2";
    return;
  }
  if( StructureType :: ePhysicalDeviceSparseImageFormatInfo2 == p ) {
    j = "PhysicalDeviceSparseImageFormatInfo2";
    return;
  }
  if( StructureType :: ePhysicalDevicePointClippingProperties == p ) {
    j = "PhysicalDevicePointClippingProperties";
    return;
  }
  if( StructureType :: eRenderPassInputAttachmentAspectCreateInfo == p ) {
    j = "RenderPassInputAttachmentAspectCreateInfo";
    return;
  }
  if( StructureType :: eImageViewUsageCreateInfo == p ) {
    j = "ImageViewUsageCreateInfo";
    return;
  }
  if( StructureType :: eRenderPassMultiviewCreateInfo == p ) {
    j = "RenderPassMultiviewCreateInfo";
    return;
  }
  if( StructureType :: ePhysicalDeviceMultiviewFeatures == p ) {
    j = "PhysicalDeviceMultiviewFeatures";
    return;
  }
  if( StructureType :: ePhysicalDeviceMultiviewProperties == p ) {
    j = "PhysicalDeviceMultiviewProperties";
    return;
  }
  if( StructureType :: ePhysicalDeviceVariablePointersFeatures == p ) {
    j = "PhysicalDeviceVariablePointersFeatures";
    return;
  }
  if( StructureType :: eProtectedSubmitInfo == p ) {
    j = "ProtectedSubmitInfo";
    return;
  }
  if( StructureType :: ePhysicalDeviceProtectedMemoryFeatures == p ) {
    j = "PhysicalDeviceProtectedMemoryFeatures";
    return;
  }
  if( StructureType :: ePhysicalDeviceProtectedMemoryProperties == p ) {
    j = "PhysicalDeviceProtectedMemoryProperties";
    return;
  }
  if( StructureType :: eDeviceQueueInfo2 == p ) {
    j = "DeviceQueueInfo2";
    return;
  }
  if( StructureType :: eSamplerYcbcrConversionCreateInfo == p ) {
    j = "SamplerYcbcrConversionCreateInfo";
    return;
  }
  if( StructureType :: eSamplerYcbcrConversionInfo == p ) {
    j = "SamplerYcbcrConversionInfo";
    return;
  }
  if( StructureType :: eBindImagePlaneMemoryInfo == p ) {
    j = "BindImagePlaneMemoryInfo";
    return;
  }
  if( StructureType :: eImagePlaneMemoryRequirementsInfo == p ) {
    j = "ImagePlaneMemoryRequirementsInfo";
    return;
  }
  if( StructureType :: ePhysicalDeviceSamplerYcbcrConversionFeatures == p ) {
    j = "PhysicalDeviceSamplerYcbcrConversionFeatures";
    return;
  }
  if( StructureType :: eSamplerYcbcrConversionImageFormatProperties == p ) {
    j = "SamplerYcbcrConversionImageFormatProperties";
    return;
  }
  if( StructureType :: eDescriptorUpdateTemplateCreateInfo == p ) {
    j = "DescriptorUpdateTemplateCreateInfo";
    return;
  }
  if( StructureType :: ePhysicalDeviceExternalImageFormatInfo == p ) {
    j = "PhysicalDeviceExternalImageFormatInfo";
    return;
  }
  if( StructureType :: eExternalImageFormatProperties == p ) {
    j = "ExternalImageFormatProperties";
    return;
  }
  if( StructureType :: ePhysicalDeviceExternalBufferInfo == p ) {
    j = "PhysicalDeviceExternalBufferInfo";
    return;
  }
  if( StructureType :: eExternalBufferProperties == p ) {
    j = "ExternalBufferProperties";
    return;
  }
  if( StructureType :: ePhysicalDeviceIdProperties == p ) {
    j = "PhysicalDeviceIdProperties";
    return;
  }
  if( StructureType :: eExternalMemoryBufferCreateInfo == p ) {
    j = "ExternalMemoryBufferCreateInfo";
    return;
  }
  if( StructureType :: eExternalMemoryImageCreateInfo == p ) {
    j = "ExternalMemoryImageCreateInfo";
    return;
  }
  if( StructureType :: eExportMemoryAllocateInfo == p ) {
    j = "ExportMemoryAllocateInfo";
    return;
  }
  if( StructureType :: ePhysicalDeviceExternalFenceInfo == p ) {
    j = "PhysicalDeviceExternalFenceInfo";
    return;
  }
  if( StructureType :: eExternalFenceProperties == p ) {
    j = "ExternalFenceProperties";
    return;
  }
  if( StructureType :: eExportFenceCreateInfo == p ) {
    j = "ExportFenceCreateInfo";
    return;
  }
  if( StructureType :: eExportSemaphoreCreateInfo == p ) {
    j = "ExportSemaphoreCreateInfo";
    return;
  }
  if( StructureType :: ePhysicalDeviceExternalSemaphoreInfo == p ) {
    j = "PhysicalDeviceExternalSemaphoreInfo";
    return;
  }
  if( StructureType :: eExternalSemaphoreProperties == p ) {
    j = "ExternalSemaphoreProperties";
    return;
  }
  if( StructureType :: ePhysicalDeviceMaintenance3Properties == p ) {
    j = "PhysicalDeviceMaintenance3Properties";
    return;
  }
  if( StructureType :: eDescriptorSetLayoutSupport == p ) {
    j = "DescriptorSetLayoutSupport";
    return;
  }
  if( StructureType :: ePhysicalDeviceShaderDrawParametersFeatures == p ) {
    j = "PhysicalDeviceShaderDrawParametersFeatures";
    return;
  }
  if( StructureType :: ePhysicalDeviceVulkan11Features == p ) {
    j = "PhysicalDeviceVulkan11Features";
    return;
  }
  if( StructureType :: ePhysicalDeviceVulkan11Properties == p ) {
    j = "PhysicalDeviceVulkan11Properties";
    return;
  }
  if( StructureType :: ePhysicalDeviceVulkan12Features == p ) {
    j = "PhysicalDeviceVulkan12Features";
    return;
  }
  if( StructureType :: ePhysicalDeviceVulkan12Properties == p ) {
    j = "PhysicalDeviceVulkan12Properties";
    return;
  }
  if( StructureType :: eImageFormatListCreateInfo == p ) {
    j = "ImageFormatListCreateInfo";
    return;
  }
  if( StructureType :: eAttachmentDescription2 == p ) {
    j = "AttachmentDescription2";
    return;
  }
  if( StructureType :: eAttachmentReference2 == p ) {
    j = "AttachmentReference2";
    return;
  }
  if( StructureType :: eSubpassDescription2 == p ) {
    j = "SubpassDescription2";
    return;
  }
  if( StructureType :: eSubpassDependency2 == p ) {
    j = "SubpassDependency2";
    return;
  }
  if( StructureType :: eRenderPassCreateInfo2 == p ) {
    j = "RenderPassCreateInfo2";
    return;
  }
  if( StructureType :: eSubpassBeginInfo == p ) {
    j = "SubpassBeginInfo";
    return;
  }
  if( StructureType :: eSubpassEndInfo == p ) {
    j = "SubpassEndInfo";
    return;
  }
  if( StructureType :: ePhysicalDevice8BitStorageFeatures == p ) {
    j = "PhysicalDevice8BitStorageFeatures";
    return;
  }
  if( StructureType :: ePhysicalDeviceDriverProperties == p ) {
    j = "PhysicalDeviceDriverProperties";
    return;
  }
  if( StructureType :: ePhysicalDeviceShaderAtomicInt64Features == p ) {
    j = "PhysicalDeviceShaderAtomicInt64Features";
    return;
  }
  if( StructureType :: ePhysicalDeviceShaderFloat16Int8Features == p ) {
    j = "PhysicalDeviceShaderFloat16Int8Features";
    return;
  }
  if( StructureType :: ePhysicalDeviceFloatControlsProperties == p ) {
    j = "PhysicalDeviceFloatControlsProperties";
    return;
  }
  if( StructureType :: eDescriptorSetLayoutBindingFlagsCreateInfo == p ) {
    j = "DescriptorSetLayoutBindingFlagsCreateInfo";
    return;
  }
  if( StructureType :: ePhysicalDeviceDescriptorIndexingFeatures == p ) {
    j = "PhysicalDeviceDescriptorIndexingFeatures";
    return;
  }
  if( StructureType :: ePhysicalDeviceDescriptorIndexingProperties == p ) {
    j = "PhysicalDeviceDescriptorIndexingProperties";
    return;
  }
  if( StructureType :: ePhysicalDeviceDepthStencilResolveProperties == p ) {
    j = "PhysicalDeviceDepthStencilResolveProperties";
    return;
  }
  if( StructureType :: eSubpassDescriptionDepthStencilResolve == p ) {
    j = "SubpassDescriptionDepthStencilResolve";
    return;
  }
  if( StructureType :: ePhysicalDeviceScalarBlockLayoutFeatures == p ) {
    j = "PhysicalDeviceScalarBlockLayoutFeatures";
    return;
  }
  if( StructureType :: eImageStencilUsageCreateInfo == p ) {
    j = "ImageStencilUsageCreateInfo";
    return;
  }
  if( StructureType :: ePhysicalDeviceSamplerFilterMinmaxProperties == p ) {
    j = "PhysicalDeviceSamplerFilterMinmaxProperties";
    return;
  }
  if( StructureType :: eSamplerReductionModeCreateInfo == p ) {
    j = "SamplerReductionModeCreateInfo";
    return;
  }
  if( StructureType :: ePhysicalDeviceVulkanMemoryModelFeatures == p ) {
    j = "PhysicalDeviceVulkanMemoryModelFeatures";
    return;
  }
  if( StructureType :: ePhysicalDeviceImagelessFramebufferFeatures == p ) {
    j = "PhysicalDeviceImagelessFramebufferFeatures";
    return;
  }
  if( StructureType :: eFramebufferAttachmentsCreateInfo == p ) {
    j = "FramebufferAttachmentsCreateInfo";
    return;
  }
  if( StructureType :: eFramebufferAttachmentImageInfo == p ) {
    j = "FramebufferAttachmentImageInfo";
    return;
  }
  if( StructureType :: eRenderPassAttachmentBeginInfo == p ) {
    j = "RenderPassAttachmentBeginInfo";
    return;
  }
  if( StructureType :: eAttachmentReferenceStencilLayout == p ) {
    j = "AttachmentReferenceStencilLayout";
    return;
  }
  if( StructureType :: eAttachmentDescriptionStencilLayout == p ) {
    j = "AttachmentDescriptionStencilLayout";
    return;
  }
  if( StructureType :: ePhysicalDeviceHostQueryResetFeatures == p ) {
    j = "PhysicalDeviceHostQueryResetFeatures";
    return;
  }
  if( StructureType :: ePhysicalDeviceTimelineSemaphoreFeatures == p ) {
    j = "PhysicalDeviceTimelineSemaphoreFeatures";
    return;
  }
  if( StructureType :: ePhysicalDeviceTimelineSemaphoreProperties == p ) {
    j = "PhysicalDeviceTimelineSemaphoreProperties";
    return;
  }
  if( StructureType :: eSemaphoreTypeCreateInfo == p ) {
    j = "SemaphoreTypeCreateInfo";
    return;
  }
  if( StructureType :: eTimelineSemaphoreSubmitInfo == p ) {
    j = "TimelineSemaphoreSubmitInfo";
    return;
  }
  if( StructureType :: eSemaphoreWaitInfo == p ) {
    j = "SemaphoreWaitInfo";
    return;
  }
  if( StructureType :: eSemaphoreSignalInfo == p ) {
    j = "SemaphoreSignalInfo";
    return;
  }
  if( StructureType :: ePhysicalDeviceBufferDeviceAddressFeatures == p ) {
    j = "PhysicalDeviceBufferDeviceAddressFeatures";
    return;
  }
  if( StructureType :: eBufferDeviceAddressInfo == p ) {
    j = "BufferDeviceAddressInfo";
    return;
  }
  if( StructureType :: eBufferOpaqueCaptureAddressCreateInfo == p ) {
    j = "BufferOpaqueCaptureAddressCreateInfo";
    return;
  }
  if( StructureType :: eMemoryOpaqueCaptureAddressAllocateInfo == p ) {
    j = "MemoryOpaqueCaptureAddressAllocateInfo";
    return;
  }
  if( StructureType :: eDeviceMemoryOpaqueCaptureAddressInfo == p ) {
    j = "DeviceMemoryOpaqueCaptureAddressInfo";
    return;
  }
  if( StructureType :: eSwapchainCreateInfoKHR == p ) {
    j = "SwapchainCreateInfoKHR";
    return;
  }
  if( StructureType :: ePresentInfoKHR == p ) {
    j = "PresentInfoKHR";
    return;
  }
  if( StructureType :: eDeviceGroupPresentCapabilitiesKHR == p ) {
    j = "DeviceGroupPresentCapabilitiesKHR";
    return;
  }
  if( StructureType :: eImageSwapchainCreateInfoKHR == p ) {
    j = "ImageSwapchainCreateInfoKHR";
    return;
  }
  if( StructureType :: eBindImageMemorySwapchainInfoKHR == p ) {
    j = "BindImageMemorySwapchainInfoKHR";
    return;
  }
  if( StructureType :: eAcquireNextImageInfoKHR == p ) {
    j = "AcquireNextImageInfoKHR";
    return;
  }
  if( StructureType :: eDeviceGroupPresentInfoKHR == p ) {
    j = "DeviceGroupPresentInfoKHR";
    return;
  }
  if( StructureType :: eDeviceGroupSwapchainCreateInfoKHR == p ) {
    j = "DeviceGroupSwapchainCreateInfoKHR";
    return;
  }
  if( StructureType :: eDisplayModeCreateInfoKHR == p ) {
    j = "DisplayModeCreateInfoKHR";
    return;
  }
  if( StructureType :: eDisplaySurfaceCreateInfoKHR == p ) {
    j = "DisplaySurfaceCreateInfoKHR";
    return;
  }
  if( StructureType :: eDisplayPresentInfoKHR == p ) {
    j = "DisplayPresentInfoKHR";
    return;
  }
#if defined(VK_USE_PLATFORM_XLIB_KHR)
  if( StructureType :: eXlibSurfaceCreateInfoKHR == p ) {
    j = "XlibSurfaceCreateInfoKHR";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
  if( StructureType :: eXcbSurfaceCreateInfoKHR == p ) {
    j = "XcbSurfaceCreateInfoKHR";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
  if( StructureType :: eWaylandSurfaceCreateInfoKHR == p ) {
    j = "WaylandSurfaceCreateInfoKHR";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
  if( StructureType :: eAndroidSurfaceCreateInfoKHR == p ) {
    j = "AndroidSurfaceCreateInfoKHR";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eWin32SurfaceCreateInfoKHR == p ) {
    j = "Win32SurfaceCreateInfoKHR";
    return;
  }
#endif
  if( StructureType :: eDebugReportCallbackCreateInfoEXT == p ) {
    j = "DebugReportCallbackCreateInfoEXT";
    return;
  }
  if( StructureType :: eDebugMarkerObjectNameInfoEXT == p ) {
    j = "DebugMarkerObjectNameInfoEXT";
    return;
  }
  if( StructureType :: eDebugMarkerObjectTagInfoEXT == p ) {
    j = "DebugMarkerObjectTagInfoEXT";
    return;
  }
  if( StructureType :: eDebugMarkerMarkerInfoEXT == p ) {
    j = "DebugMarkerMarkerInfoEXT";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoProfileKHR == p ) {
    j = "VideoProfileKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoCapabilitiesKHR == p ) {
    j = "VideoCapabilitiesKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoPictureResourceKHR == p ) {
    j = "VideoPictureResourceKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoGetMemoryPropertiesKHR == p ) {
    j = "VideoGetMemoryPropertiesKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoBindMemoryKHR == p ) {
    j = "VideoBindMemoryKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoSessionCreateInfoKHR == p ) {
    j = "VideoSessionCreateInfoKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoSessionParametersCreateInfoKHR == p ) {
    j = "VideoSessionParametersCreateInfoKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoSessionParametersUpdateInfoKHR == p ) {
    j = "VideoSessionParametersUpdateInfoKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoBeginCodingInfoKHR == p ) {
    j = "VideoBeginCodingInfoKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoEndCodingInfoKHR == p ) {
    j = "VideoEndCodingInfoKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoCodingControlInfoKHR == p ) {
    j = "VideoCodingControlInfoKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoReferenceSlotKHR == p ) {
    j = "VideoReferenceSlotKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoQueueFamilyProperties2KHR == p ) {
    j = "VideoQueueFamilyProperties2KHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoProfilesKHR == p ) {
    j = "VideoProfilesKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: ePhysicalDeviceVideoFormatInfoKHR == p ) {
    j = "PhysicalDeviceVideoFormatInfoKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoFormatPropertiesKHR == p ) {
    j = "VideoFormatPropertiesKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoDecodeInfoKHR == p ) {
    j = "VideoDecodeInfoKHR";
    return;
  }
#endif
  if( StructureType :: eDedicatedAllocationImageCreateInfoNV == p ) {
    j = "DedicatedAllocationImageCreateInfoNV";
    return;
  }
  if( StructureType :: eDedicatedAllocationBufferCreateInfoNV == p ) {
    j = "DedicatedAllocationBufferCreateInfoNV";
    return;
  }
  if( StructureType :: eDedicatedAllocationMemoryAllocateInfoNV == p ) {
    j = "DedicatedAllocationMemoryAllocateInfoNV";
    return;
  }
  if( StructureType :: ePhysicalDeviceTransformFeedbackFeaturesEXT == p ) {
    j = "PhysicalDeviceTransformFeedbackFeaturesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceTransformFeedbackPropertiesEXT == p ) {
    j = "PhysicalDeviceTransformFeedbackPropertiesEXT";
    return;
  }
  if( StructureType :: eCuModuleCreateInfoNVX == p ) {
    j = "CuModuleCreateInfoNVX";
    return;
  }
  if( StructureType :: eCuFunctionCreateInfoNVX == p ) {
    j = "CuFunctionCreateInfoNVX";
    return;
  }
  if( StructureType :: eCuLaunchInfoNVX == p ) {
    j = "CuLaunchInfoNVX";
    return;
  }
  if( StructureType :: eImageViewHandleInfoNVX == p ) {
    j = "ImageViewHandleInfoNVX";
    return;
  }
  if( StructureType :: eImageViewAddressPropertiesNVX == p ) {
    j = "ImageViewAddressPropertiesNVX";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoEncodeH264CapabilitiesEXT == p ) {
    j = "VideoEncodeH264CapabilitiesEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoEncodeH264SessionCreateInfoEXT == p ) {
    j = "VideoEncodeH264SessionCreateInfoEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoEncodeH264SessionParametersAddInfoEXT == p ) {
    j = "VideoEncodeH264SessionParametersAddInfoEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoEncodeH264VclFrameInfoEXT == p ) {
    j = "VideoEncodeH264VclFrameInfoEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoEncodeH264DpbSlotInfoEXT == p ) {
    j = "VideoEncodeH264DpbSlotInfoEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoEncodeH264NaluSliceEXT == p ) {
    j = "VideoEncodeH264NaluSliceEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoEncodeH264EmitPictureParametersEXT == p ) {
    j = "VideoEncodeH264EmitPictureParametersEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoEncodeH264ProfileEXT == p ) {
    j = "VideoEncodeH264ProfileEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoDecodeH264CapabilitiesEXT == p ) {
    j = "VideoDecodeH264CapabilitiesEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoDecodeH264SessionCreateInfoEXT == p ) {
    j = "VideoDecodeH264SessionCreateInfoEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoDecodeH264PictureInfoEXT == p ) {
    j = "VideoDecodeH264PictureInfoEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoDecodeH264MvcEXT == p ) {
    j = "VideoDecodeH264MvcEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoDecodeH264ProfileEXT == p ) {
    j = "VideoDecodeH264ProfileEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoDecodeH264SessionParametersAddInfoEXT == p ) {
    j = "VideoDecodeH264SessionParametersAddInfoEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoDecodeH264DpbSlotInfoEXT == p ) {
    j = "VideoDecodeH264DpbSlotInfoEXT";
    return;
  }
#endif
  if( StructureType :: eTextureLodGatherFormatPropertiesAMD == p ) {
    j = "TextureLodGatherFormatPropertiesAMD";
    return;
  }
#if defined(VK_USE_PLATFORM_GGP)
  if( StructureType :: eStreamDescriptorSurfaceCreateInfoGGP == p ) {
    j = "StreamDescriptorSurfaceCreateInfoGGP";
    return;
  }
#endif
  if( StructureType :: ePhysicalDeviceCornerSampledImageFeaturesNV == p ) {
    j = "PhysicalDeviceCornerSampledImageFeaturesNV";
    return;
  }
  if( StructureType :: eExternalMemoryImageCreateInfoNV == p ) {
    j = "ExternalMemoryImageCreateInfoNV";
    return;
  }
  if( StructureType :: eExportMemoryAllocateInfoNV == p ) {
    j = "ExportMemoryAllocateInfoNV";
    return;
  }
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eImportMemoryWin32HandleInfoNV == p ) {
    j = "ImportMemoryWin32HandleInfoNV";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eExportMemoryWin32HandleInfoNV == p ) {
    j = "ExportMemoryWin32HandleInfoNV";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eWin32KeyedMutexAcquireReleaseInfoNV == p ) {
    j = "Win32KeyedMutexAcquireReleaseInfoNV";
    return;
  }
#endif
  if( StructureType :: eValidationFlagsEXT == p ) {
    j = "ValidationFlagsEXT";
    return;
  }
#if defined(VK_USE_PLATFORM_VI_NN)
  if( StructureType :: eViSurfaceCreateInfoNN == p ) {
    j = "ViSurfaceCreateInfoNN";
    return;
  }
#endif
  if( StructureType :: eImageViewAstcDecodeModeEXT == p ) {
    j = "ImageViewAstcDecodeModeEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceAstcDecodeFeaturesEXT == p ) {
    j = "PhysicalDeviceAstcDecodeFeaturesEXT";
    return;
  }
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eImportMemoryWin32HandleInfoKHR == p ) {
    j = "ImportMemoryWin32HandleInfoKHR";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eExportMemoryWin32HandleInfoKHR == p ) {
    j = "ExportMemoryWin32HandleInfoKHR";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eMemoryWin32HandlePropertiesKHR == p ) {
    j = "MemoryWin32HandlePropertiesKHR";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eMemoryGetWin32HandleInfoKHR == p ) {
    j = "MemoryGetWin32HandleInfoKHR";
    return;
  }
#endif
  if( StructureType :: eImportMemoryFdInfoKHR == p ) {
    j = "ImportMemoryFdInfoKHR";
    return;
  }
  if( StructureType :: eMemoryFdPropertiesKHR == p ) {
    j = "MemoryFdPropertiesKHR";
    return;
  }
  if( StructureType :: eMemoryGetFdInfoKHR == p ) {
    j = "MemoryGetFdInfoKHR";
    return;
  }
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eWin32KeyedMutexAcquireReleaseInfoKHR == p ) {
    j = "Win32KeyedMutexAcquireReleaseInfoKHR";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eImportSemaphoreWin32HandleInfoKHR == p ) {
    j = "ImportSemaphoreWin32HandleInfoKHR";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eExportSemaphoreWin32HandleInfoKHR == p ) {
    j = "ExportSemaphoreWin32HandleInfoKHR";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eD3D12FenceSubmitInfoKHR == p ) {
    j = "D3D12FenceSubmitInfoKHR";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eSemaphoreGetWin32HandleInfoKHR == p ) {
    j = "SemaphoreGetWin32HandleInfoKHR";
    return;
  }
#endif
  if( StructureType :: eImportSemaphoreFdInfoKHR == p ) {
    j = "ImportSemaphoreFdInfoKHR";
    return;
  }
  if( StructureType :: eSemaphoreGetFdInfoKHR == p ) {
    j = "SemaphoreGetFdInfoKHR";
    return;
  }
  if( StructureType :: ePhysicalDevicePushDescriptorPropertiesKHR == p ) {
    j = "PhysicalDevicePushDescriptorPropertiesKHR";
    return;
  }
  if( StructureType :: eConditionalRenderingBeginInfoEXT == p ) {
    j = "ConditionalRenderingBeginInfoEXT";
    return;
  }
  if( StructureType :: ePresentRegionsKHR == p ) {
    j = "PresentRegionsKHR";
    return;
  }
  if( StructureType :: ePipelineViewportWScalingStateCreateInfoNV == p ) {
    j = "PipelineViewportWScalingStateCreateInfoNV";
    return;
  }
  if( StructureType :: eSurfaceCapabilities2EXT == p ) {
    j = "SurfaceCapabilities2EXT";
    return;
  }
  if( StructureType :: eDisplayPowerInfoEXT == p ) {
    j = "DisplayPowerInfoEXT";
    return;
  }
  if( StructureType :: eDeviceEventInfoEXT == p ) {
    j = "DeviceEventInfoEXT";
    return;
  }
  if( StructureType :: eDisplayEventInfoEXT == p ) {
    j = "DisplayEventInfoEXT";
    return;
  }
  if( StructureType :: eSwapchainCounterCreateInfoEXT == p ) {
    j = "SwapchainCounterCreateInfoEXT";
    return;
  }
  if( StructureType :: ePresentTimesInfoGOOGLE == p ) {
    j = "PresentTimesInfoGOOGLE";
    return;
  }
  if( StructureType :: ePipelineViewportSwizzleStateCreateInfoNV == p ) {
    j = "PipelineViewportSwizzleStateCreateInfoNV";
    return;
  }
  if( StructureType :: ePhysicalDeviceDiscardRectanglePropertiesEXT == p ) {
    j = "PhysicalDeviceDiscardRectanglePropertiesEXT";
    return;
  }
  if( StructureType :: ePipelineDiscardRectangleStateCreateInfoEXT == p ) {
    j = "PipelineDiscardRectangleStateCreateInfoEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceDepthClipEnableFeaturesEXT == p ) {
    j = "PhysicalDeviceDepthClipEnableFeaturesEXT";
    return;
  }
  if( StructureType :: eHdrMetadataEXT == p ) {
    j = "HdrMetadataEXT";
    return;
  }
  if( StructureType :: eSharedPresentSurfaceCapabilitiesKHR == p ) {
    j = "SharedPresentSurfaceCapabilitiesKHR";
    return;
  }
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eImportFenceWin32HandleInfoKHR == p ) {
    j = "ImportFenceWin32HandleInfoKHR";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eExportFenceWin32HandleInfoKHR == p ) {
    j = "ExportFenceWin32HandleInfoKHR";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eFenceGetWin32HandleInfoKHR == p ) {
    j = "FenceGetWin32HandleInfoKHR";
    return;
  }
#endif
  if( StructureType :: eImportFenceFdInfoKHR == p ) {
    j = "ImportFenceFdInfoKHR";
    return;
  }
  if( StructureType :: eFenceGetFdInfoKHR == p ) {
    j = "FenceGetFdInfoKHR";
    return;
  }
  if( StructureType :: ePhysicalDevicePerformanceQueryFeaturesKHR == p ) {
    j = "PhysicalDevicePerformanceQueryFeaturesKHR";
    return;
  }
  if( StructureType :: ePhysicalDevicePerformanceQueryPropertiesKHR == p ) {
    j = "PhysicalDevicePerformanceQueryPropertiesKHR";
    return;
  }
  if( StructureType :: eQueryPoolPerformanceCreateInfoKHR == p ) {
    j = "QueryPoolPerformanceCreateInfoKHR";
    return;
  }
  if( StructureType :: ePerformanceQuerySubmitInfoKHR == p ) {
    j = "PerformanceQuerySubmitInfoKHR";
    return;
  }
  if( StructureType :: eAcquireProfilingLockInfoKHR == p ) {
    j = "AcquireProfilingLockInfoKHR";
    return;
  }
  if( StructureType :: ePerformanceCounterKHR == p ) {
    j = "PerformanceCounterKHR";
    return;
  }
  if( StructureType :: ePerformanceCounterDescriptionKHR == p ) {
    j = "PerformanceCounterDescriptionKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceSurfaceInfo2KHR == p ) {
    j = "PhysicalDeviceSurfaceInfo2KHR";
    return;
  }
  if( StructureType :: eSurfaceCapabilities2KHR == p ) {
    j = "SurfaceCapabilities2KHR";
    return;
  }
  if( StructureType :: eSurfaceFormat2KHR == p ) {
    j = "SurfaceFormat2KHR";
    return;
  }
  if( StructureType :: eDisplayProperties2KHR == p ) {
    j = "DisplayProperties2KHR";
    return;
  }
  if( StructureType :: eDisplayPlaneProperties2KHR == p ) {
    j = "DisplayPlaneProperties2KHR";
    return;
  }
  if( StructureType :: eDisplayModeProperties2KHR == p ) {
    j = "DisplayModeProperties2KHR";
    return;
  }
  if( StructureType :: eDisplayPlaneInfo2KHR == p ) {
    j = "DisplayPlaneInfo2KHR";
    return;
  }
  if( StructureType :: eDisplayPlaneCapabilities2KHR == p ) {
    j = "DisplayPlaneCapabilities2KHR";
    return;
  }
#if defined(VK_USE_PLATFORM_IOS_MVK)
  if( StructureType :: eIosSurfaceCreateInfoMVK == p ) {
    j = "IosSurfaceCreateInfoMVK";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_MACOS_MVK)
  if( StructureType :: eMacosSurfaceCreateInfoMVK == p ) {
    j = "MacosSurfaceCreateInfoMVK";
    return;
  }
#endif
  if( StructureType :: eDebugUtilsObjectNameInfoEXT == p ) {
    j = "DebugUtilsObjectNameInfoEXT";
    return;
  }
  if( StructureType :: eDebugUtilsObjectTagInfoEXT == p ) {
    j = "DebugUtilsObjectTagInfoEXT";
    return;
  }
  if( StructureType :: eDebugUtilsLabelEXT == p ) {
    j = "DebugUtilsLabelEXT";
    return;
  }
  if( StructureType :: eDebugUtilsMessengerCallbackDataEXT == p ) {
    j = "DebugUtilsMessengerCallbackDataEXT";
    return;
  }
  if( StructureType :: eDebugUtilsMessengerCreateInfoEXT == p ) {
    j = "DebugUtilsMessengerCreateInfoEXT";
    return;
  }
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
  if( StructureType :: eAndroidHardwareBufferUsageANDROID == p ) {
    j = "AndroidHardwareBufferUsageANDROID";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
  if( StructureType :: eAndroidHardwareBufferPropertiesANDROID == p ) {
    j = "AndroidHardwareBufferPropertiesANDROID";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
  if( StructureType :: eAndroidHardwareBufferFormatPropertiesANDROID == p ) {
    j = "AndroidHardwareBufferFormatPropertiesANDROID";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
  if( StructureType :: eImportAndroidHardwareBufferInfoANDROID == p ) {
    j = "ImportAndroidHardwareBufferInfoANDROID";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
  if( StructureType :: eMemoryGetAndroidHardwareBufferInfoANDROID == p ) {
    j = "MemoryGetAndroidHardwareBufferInfoANDROID";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
  if( StructureType :: eExternalFormatANDROID == p ) {
    j = "ExternalFormatANDROID";
    return;
  }
#endif
  if( StructureType :: ePhysicalDeviceInlineUniformBlockFeaturesEXT == p ) {
    j = "PhysicalDeviceInlineUniformBlockFeaturesEXT";
    return;
  }
  if( StructureType :: eWriteDescriptorSetInlineUniformBlockEXT == p ) {
    j = "WriteDescriptorSetInlineUniformBlockEXT";
    return;
  }
  if( StructureType :: eSampleLocationsInfoEXT == p ) {
    j = "SampleLocationsInfoEXT";
    return;
  }
  if( StructureType :: eRenderPassSampleLocationsBeginInfoEXT == p ) {
    j = "RenderPassSampleLocationsBeginInfoEXT";
    return;
  }
  if( StructureType :: ePipelineSampleLocationsStateCreateInfoEXT == p ) {
    j = "PipelineSampleLocationsStateCreateInfoEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceSampleLocationsPropertiesEXT == p ) {
    j = "PhysicalDeviceSampleLocationsPropertiesEXT";
    return;
  }
  if( StructureType :: eMultisamplePropertiesEXT == p ) {
    j = "MultisamplePropertiesEXT";
    return;
  }
  if( StructureType :: ePipelineCoverageToColorStateCreateInfoNV == p ) {
    j = "PipelineCoverageToColorStateCreateInfoNV";
    return;
  }
  if( StructureType :: eWriteDescriptorSetAccelerationStructureKHR == p ) {
    j = "WriteDescriptorSetAccelerationStructureKHR";
    return;
  }
  if( StructureType :: eAccelerationStructureBuildGeometryInfoKHR == p ) {
    j = "AccelerationStructureBuildGeometryInfoKHR";
    return;
  }
  if( StructureType :: eAccelerationStructureDeviceAddressInfoKHR == p ) {
    j = "AccelerationStructureDeviceAddressInfoKHR";
    return;
  }
  if( StructureType :: eAccelerationStructureGeometryAabbsDataKHR == p ) {
    j = "AccelerationStructureGeometryAabbsDataKHR";
    return;
  }
  if( StructureType :: eAccelerationStructureGeometryKHR == p ) {
    j = "AccelerationStructureGeometryKHR";
    return;
  }
  if( StructureType :: eAccelerationStructureVersionInfoKHR == p ) {
    j = "AccelerationStructureVersionInfoKHR";
    return;
  }
  if( StructureType :: eCopyAccelerationStructureInfoKHR == p ) {
    j = "CopyAccelerationStructureInfoKHR";
    return;
  }
  if( StructureType :: eCopyAccelerationStructureToMemoryInfoKHR == p ) {
    j = "CopyAccelerationStructureToMemoryInfoKHR";
    return;
  }
  if( StructureType :: eCopyMemoryToAccelerationStructureInfoKHR == p ) {
    j = "CopyMemoryToAccelerationStructureInfoKHR";
    return;
  }
  if( StructureType :: eAccelerationStructureCreateInfoKHR == p ) {
    j = "AccelerationStructureCreateInfoKHR";
    return;
  }
  if( StructureType :: eAccelerationStructureBuildSizesInfoKHR == p ) {
    j = "AccelerationStructureBuildSizesInfoKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceRayTracingPipelineFeaturesKHR == p ) {
    j = "PhysicalDeviceRayTracingPipelineFeaturesKHR";
    return;
  }
  if( StructureType :: eRayTracingPipelineCreateInfoKHR == p ) {
    j = "RayTracingPipelineCreateInfoKHR";
    return;
  }
  if( StructureType :: eRayTracingShaderGroupCreateInfoKHR == p ) {
    j = "RayTracingShaderGroupCreateInfoKHR";
    return;
  }
  if( StructureType :: eRayTracingPipelineInterfaceCreateInfoKHR == p ) {
    j = "RayTracingPipelineInterfaceCreateInfoKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceRayQueryFeaturesKHR == p ) {
    j = "PhysicalDeviceRayQueryFeaturesKHR";
    return;
  }
  if( StructureType :: ePipelineCoverageModulationStateCreateInfoNV == p ) {
    j = "PipelineCoverageModulationStateCreateInfoNV";
    return;
  }
  if( StructureType :: ePhysicalDeviceShaderSmBuiltinsFeaturesNV == p ) {
    j = "PhysicalDeviceShaderSmBuiltinsFeaturesNV";
    return;
  }
  if( StructureType :: ePhysicalDeviceShaderSmBuiltinsPropertiesNV == p ) {
    j = "PhysicalDeviceShaderSmBuiltinsPropertiesNV";
    return;
  }
  if( StructureType :: eDrmFormatModifierPropertiesListEXT == p ) {
    j = "DrmFormatModifierPropertiesListEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceImageDrmFormatModifierInfoEXT == p ) {
    j = "PhysicalDeviceImageDrmFormatModifierInfoEXT";
    return;
  }
  if( StructureType :: eImageDrmFormatModifierListCreateInfoEXT == p ) {
    j = "ImageDrmFormatModifierListCreateInfoEXT";
    return;
  }
  if( StructureType :: eImageDrmFormatModifierExplicitCreateInfoEXT == p ) {
    j = "ImageDrmFormatModifierExplicitCreateInfoEXT";
    return;
  }
  if( StructureType :: eImageDrmFormatModifierPropertiesEXT == p ) {
    j = "ImageDrmFormatModifierPropertiesEXT";
    return;
  }
  if( StructureType :: eValidationCacheCreateInfoEXT == p ) {
    j = "ValidationCacheCreateInfoEXT";
    return;
  }
  if( StructureType :: eShaderModuleValidationCacheCreateInfoEXT == p ) {
    j = "ShaderModuleValidationCacheCreateInfoEXT";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: ePhysicalDevicePortabilitySubsetFeaturesKHR == p ) {
    j = "PhysicalDevicePortabilitySubsetFeaturesKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: ePhysicalDevicePortabilitySubsetPropertiesKHR == p ) {
    j = "PhysicalDevicePortabilitySubsetPropertiesKHR";
    return;
  }
#endif
  if( StructureType :: ePhysicalDeviceShadingRateImageFeaturesNV == p ) {
    j = "PhysicalDeviceShadingRateImageFeaturesNV";
    return;
  }
  if( StructureType :: ePhysicalDeviceShadingRateImagePropertiesNV == p ) {
    j = "PhysicalDeviceShadingRateImagePropertiesNV";
    return;
  }
  if( StructureType :: eRayTracingPipelineCreateInfoNV == p ) {
    j = "RayTracingPipelineCreateInfoNV";
    return;
  }
  if( StructureType :: eAccelerationStructureCreateInfoNV == p ) {
    j = "AccelerationStructureCreateInfoNV";
    return;
  }
  if( StructureType :: eGeometryNV == p ) {
    j = "GeometryNV";
    return;
  }
  if( StructureType :: eGeometryTrianglesNV == p ) {
    j = "GeometryTrianglesNV";
    return;
  }
  if( StructureType :: eGeometryAabbNV == p ) {
    j = "GeometryAabbNV";
    return;
  }
  if( StructureType :: eBindAccelerationStructureMemoryInfoNV == p ) {
    j = "BindAccelerationStructureMemoryInfoNV";
    return;
  }
  if( StructureType :: eWriteDescriptorSetAccelerationStructureNV == p ) {
    j = "WriteDescriptorSetAccelerationStructureNV";
    return;
  }
  if( StructureType :: ePhysicalDeviceRayTracingPropertiesNV == p ) {
    j = "PhysicalDeviceRayTracingPropertiesNV";
    return;
  }
  if( StructureType :: eRayTracingShaderGroupCreateInfoNV == p ) {
    j = "RayTracingShaderGroupCreateInfoNV";
    return;
  }
  if( StructureType :: eAccelerationStructureInfoNV == p ) {
    j = "AccelerationStructureInfoNV";
    return;
  }
  if( StructureType :: ePhysicalDeviceImageViewImageFormatInfoEXT == p ) {
    j = "PhysicalDeviceImageViewImageFormatInfoEXT";
    return;
  }
  if( StructureType :: eDeviceQueueGlobalPriorityCreateInfoEXT == p ) {
    j = "DeviceQueueGlobalPriorityCreateInfoEXT";
    return;
  }
  if( StructureType :: eImportMemoryHostPointerInfoEXT == p ) {
    j = "ImportMemoryHostPointerInfoEXT";
    return;
  }
  if( StructureType :: eMemoryHostPointerPropertiesEXT == p ) {
    j = "MemoryHostPointerPropertiesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceShaderClockFeaturesKHR == p ) {
    j = "PhysicalDeviceShaderClockFeaturesKHR";
    return;
  }
  if( StructureType :: ePipelineCompilerControlCreateInfoAMD == p ) {
    j = "PipelineCompilerControlCreateInfoAMD";
    return;
  }
  if( StructureType :: eCalibratedTimestampInfoEXT == p ) {
    j = "CalibratedTimestampInfoEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceShaderCorePropertiesAMD == p ) {
    j = "PhysicalDeviceShaderCorePropertiesAMD";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoDecodeH265CapabilitiesEXT == p ) {
    j = "VideoDecodeH265CapabilitiesEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoDecodeH265SessionCreateInfoEXT == p ) {
    j = "VideoDecodeH265SessionCreateInfoEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoDecodeH265SessionParametersAddInfoEXT == p ) {
    j = "VideoDecodeH265SessionParametersAddInfoEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoDecodeH265ProfileEXT == p ) {
    j = "VideoDecodeH265ProfileEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoDecodeH265PictureInfoEXT == p ) {
    j = "VideoDecodeH265PictureInfoEXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoDecodeH265DpbSlotInfoEXT == p ) {
    j = "VideoDecodeH265DpbSlotInfoEXT";
    return;
  }
#endif
  if( StructureType :: eDeviceMemoryOverallocationCreateInfoAMD == p ) {
    j = "DeviceMemoryOverallocationCreateInfoAMD";
    return;
  }
#if defined(VK_USE_PLATFORM_GGP)
  if( StructureType :: ePresentFrameTokenGGP == p ) {
    j = "PresentFrameTokenGGP";
    return;
  }
#endif
  if( StructureType :: ePipelineCreationFeedbackCreateInfoEXT == p ) {
    j = "PipelineCreationFeedbackCreateInfoEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceMeshShaderFeaturesNV == p ) {
    j = "PhysicalDeviceMeshShaderFeaturesNV";
    return;
  }
  if( StructureType :: ePhysicalDeviceMeshShaderPropertiesNV == p ) {
    j = "PhysicalDeviceMeshShaderPropertiesNV";
    return;
  }
  if( StructureType :: ePhysicalDeviceExclusiveScissorFeaturesNV == p ) {
    j = "PhysicalDeviceExclusiveScissorFeaturesNV";
    return;
  }
  if( StructureType :: eCheckpointDataNV == p ) {
    j = "CheckpointDataNV";
    return;
  }
  if( StructureType :: eQueueFamilyCheckpointPropertiesNV == p ) {
    j = "QueueFamilyCheckpointPropertiesNV";
    return;
  }
  if( StructureType :: eQueryPoolPerformanceQueryCreateInfoINTEL == p ) {
    j = "QueryPoolPerformanceQueryCreateInfoINTEL";
    return;
  }
  if( StructureType :: eInitializePerformanceApiInfoINTEL == p ) {
    j = "InitializePerformanceApiInfoINTEL";
    return;
  }
  if( StructureType :: ePerformanceMarkerInfoINTEL == p ) {
    j = "PerformanceMarkerInfoINTEL";
    return;
  }
  if( StructureType :: ePerformanceStreamMarkerInfoINTEL == p ) {
    j = "PerformanceStreamMarkerInfoINTEL";
    return;
  }
  if( StructureType :: ePerformanceOverrideInfoINTEL == p ) {
    j = "PerformanceOverrideInfoINTEL";
    return;
  }
  if( StructureType :: ePerformanceConfigurationAcquireInfoINTEL == p ) {
    j = "PerformanceConfigurationAcquireInfoINTEL";
    return;
  }
  if( StructureType :: ePhysicalDevicePciBusInfoPropertiesEXT == p ) {
    j = "PhysicalDevicePciBusInfoPropertiesEXT";
    return;
  }
  if( StructureType :: eDisplayNativeHdrSurfaceCapabilitiesAMD == p ) {
    j = "DisplayNativeHdrSurfaceCapabilitiesAMD";
    return;
  }
  if( StructureType :: eSwapchainDisplayNativeHdrCreateInfoAMD == p ) {
    j = "SwapchainDisplayNativeHdrCreateInfoAMD";
    return;
  }
#if defined(VK_USE_PLATFORM_FUCHSIA)
  if( StructureType :: eImagepipeSurfaceCreateInfoFUCHSIA == p ) {
    j = "ImagepipeSurfaceCreateInfoFUCHSIA";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_METAL_EXT)
  if( StructureType :: eMetalSurfaceCreateInfoEXT == p ) {
    j = "MetalSurfaceCreateInfoEXT";
    return;
  }
#endif
  if( StructureType :: ePhysicalDeviceFragmentDensityMapFeaturesEXT == p ) {
    j = "PhysicalDeviceFragmentDensityMapFeaturesEXT";
    return;
  }
  if( StructureType :: eRenderPassFragmentDensityMapCreateInfoEXT == p ) {
    j = "RenderPassFragmentDensityMapCreateInfoEXT";
    return;
  }
  if( StructureType :: eFragmentShadingRateAttachmentInfoKHR == p ) {
    j = "FragmentShadingRateAttachmentInfoKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceFragmentShadingRateKHR == p ) {
    j = "PhysicalDeviceFragmentShadingRateKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceShaderCoreProperties2AMD == p ) {
    j = "PhysicalDeviceShaderCoreProperties2AMD";
    return;
  }
  if( StructureType :: ePhysicalDeviceCoherentMemoryFeaturesAMD == p ) {
    j = "PhysicalDeviceCoherentMemoryFeaturesAMD";
    return;
  }
  if( StructureType :: ePhysicalDeviceMemoryBudgetPropertiesEXT == p ) {
    j = "PhysicalDeviceMemoryBudgetPropertiesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceMemoryPriorityFeaturesEXT == p ) {
    j = "PhysicalDeviceMemoryPriorityFeaturesEXT";
    return;
  }
  if( StructureType :: eMemoryPriorityAllocateInfoEXT == p ) {
    j = "MemoryPriorityAllocateInfoEXT";
    return;
  }
  if( StructureType :: eSurfaceProtectedCapabilitiesKHR == p ) {
    j = "SurfaceProtectedCapabilitiesKHR";
    return;
  }
  if( StructureType :: eBufferDeviceAddressCreateInfoEXT == p ) {
    j = "BufferDeviceAddressCreateInfoEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceToolPropertiesEXT == p ) {
    j = "PhysicalDeviceToolPropertiesEXT";
    return;
  }
  if( StructureType :: eValidationFeaturesEXT == p ) {
    j = "ValidationFeaturesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceCooperativeMatrixFeaturesNV == p ) {
    j = "PhysicalDeviceCooperativeMatrixFeaturesNV";
    return;
  }
  if( StructureType :: eCooperativeMatrixPropertiesNV == p ) {
    j = "CooperativeMatrixPropertiesNV";
    return;
  }
  if( StructureType :: ePhysicalDeviceCooperativeMatrixPropertiesNV == p ) {
    j = "PhysicalDeviceCooperativeMatrixPropertiesNV";
    return;
  }
  if( StructureType :: ePipelineCoverageReductionStateCreateInfoNV == p ) {
    j = "PipelineCoverageReductionStateCreateInfoNV";
    return;
  }
  if( StructureType :: eFramebufferMixedSamplesCombinationNV == p ) {
    j = "FramebufferMixedSamplesCombinationNV";
    return;
  }
  if( StructureType :: ePhysicalDeviceYcbcrImageArraysFeaturesEXT == p ) {
    j = "PhysicalDeviceYcbcrImageArraysFeaturesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceProvokingVertexFeaturesEXT == p ) {
    j = "PhysicalDeviceProvokingVertexFeaturesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceProvokingVertexPropertiesEXT == p ) {
    j = "PhysicalDeviceProvokingVertexPropertiesEXT";
    return;
  }
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eSurfaceFullScreenExclusiveInfoEXT == p ) {
    j = "SurfaceFullScreenExclusiveInfoEXT";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eSurfaceCapabilitiesFullScreenExclusiveEXT == p ) {
    j = "SurfaceCapabilitiesFullScreenExclusiveEXT";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
  if( StructureType :: eSurfaceFullScreenExclusiveWin32InfoEXT == p ) {
    j = "SurfaceFullScreenExclusiveWin32InfoEXT";
    return;
  }
#endif
  if( StructureType :: eHeadlessSurfaceCreateInfoEXT == p ) {
    j = "HeadlessSurfaceCreateInfoEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceLineRasterizationFeaturesEXT == p ) {
    j = "PhysicalDeviceLineRasterizationFeaturesEXT";
    return;
  }
  if( StructureType :: ePipelineRasterizationLineStateCreateInfoEXT == p ) {
    j = "PipelineRasterizationLineStateCreateInfoEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceLineRasterizationPropertiesEXT == p ) {
    j = "PhysicalDeviceLineRasterizationPropertiesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceShaderAtomicFloatFeaturesEXT == p ) {
    j = "PhysicalDeviceShaderAtomicFloatFeaturesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceIndexTypeUint8FeaturesEXT == p ) {
    j = "PhysicalDeviceIndexTypeUint8FeaturesEXT";
    return;
  }
  if( StructureType :: ePipelineInfoKHR == p ) {
    j = "PipelineInfoKHR";
    return;
  }
  if( StructureType :: ePipelineExecutablePropertiesKHR == p ) {
    j = "PipelineExecutablePropertiesKHR";
    return;
  }
  if( StructureType :: ePipelineExecutableInfoKHR == p ) {
    j = "PipelineExecutableInfoKHR";
    return;
  }
  if( StructureType :: ePipelineExecutableStatisticKHR == p ) {
    j = "PipelineExecutableStatisticKHR";
    return;
  }
  if( StructureType :: ePipelineExecutableInternalRepresentationKHR == p ) {
    j = "PipelineExecutableInternalRepresentationKHR";
    return;
  }
  if( StructureType :: eGraphicsShaderGroupCreateInfoNV == p ) {
    j = "GraphicsShaderGroupCreateInfoNV";
    return;
  }
  if( StructureType :: eGraphicsPipelineShaderGroupsCreateInfoNV == p ) {
    j = "GraphicsPipelineShaderGroupsCreateInfoNV";
    return;
  }
  if( StructureType :: eIndirectCommandsLayoutTokenNV == p ) {
    j = "IndirectCommandsLayoutTokenNV";
    return;
  }
  if( StructureType :: eIndirectCommandsLayoutCreateInfoNV == p ) {
    j = "IndirectCommandsLayoutCreateInfoNV";
    return;
  }
  if( StructureType :: eGeneratedCommandsInfoNV == p ) {
    j = "GeneratedCommandsInfoNV";
    return;
  }
  if( StructureType :: eGeneratedCommandsMemoryRequirementsInfoNV == p ) {
    j = "GeneratedCommandsMemoryRequirementsInfoNV";
    return;
  }
  if( StructureType :: eRenderPassTransformBeginInfoQCOM == p ) {
    j = "RenderPassTransformBeginInfoQCOM";
    return;
  }
  if( StructureType :: ePhysicalDeviceDeviceMemoryReportFeaturesEXT == p ) {
    j = "PhysicalDeviceDeviceMemoryReportFeaturesEXT";
    return;
  }
  if( StructureType :: eDeviceDeviceMemoryReportCreateInfoEXT == p ) {
    j = "DeviceDeviceMemoryReportCreateInfoEXT";
    return;
  }
  if( StructureType :: eDeviceMemoryReportCallbackDataEXT == p ) {
    j = "DeviceMemoryReportCallbackDataEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceRobustness2FeaturesEXT == p ) {
    j = "PhysicalDeviceRobustness2FeaturesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceRobustness2PropertiesEXT == p ) {
    j = "PhysicalDeviceRobustness2PropertiesEXT";
    return;
  }
  if( StructureType :: eSamplerCustomBorderColorCreateInfoEXT == p ) {
    j = "SamplerCustomBorderColorCreateInfoEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceCustomBorderColorFeaturesEXT == p ) {
    j = "PhysicalDeviceCustomBorderColorFeaturesEXT";
    return;
  }
  if( StructureType :: ePipelineLibraryCreateInfoKHR == p ) {
    j = "PipelineLibraryCreateInfoKHR";
    return;
  }
  if( StructureType :: ePhysicalDevicePrivateDataFeaturesEXT == p ) {
    j = "PhysicalDevicePrivateDataFeaturesEXT";
    return;
  }
  if( StructureType :: eDevicePrivateDataCreateInfoEXT == p ) {
    j = "DevicePrivateDataCreateInfoEXT";
    return;
  }
  if( StructureType :: ePrivateDataSlotCreateInfoEXT == p ) {
    j = "PrivateDataSlotCreateInfoEXT";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoEncodeInfoKHR == p ) {
    j = "VideoEncodeInfoKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( StructureType :: eVideoEncodeRateControlInfoKHR == p ) {
    j = "VideoEncodeRateControlInfoKHR";
    return;
  }
#endif
  if( StructureType :: ePhysicalDeviceDiagnosticsConfigFeaturesNV == p ) {
    j = "PhysicalDeviceDiagnosticsConfigFeaturesNV";
    return;
  }
  if( StructureType :: eDeviceDiagnosticsConfigCreateInfoNV == p ) {
    j = "DeviceDiagnosticsConfigCreateInfoNV";
    return;
  }
  if( StructureType :: eMemoryBarrier2KHR == p ) {
    j = "MemoryBarrier2KHR";
    return;
  }
  if( StructureType :: eBufferMemoryBarrier2KHR == p ) {
    j = "BufferMemoryBarrier2KHR";
    return;
  }
  if( StructureType :: eImageMemoryBarrier2KHR == p ) {
    j = "ImageMemoryBarrier2KHR";
    return;
  }
  if( StructureType :: eDependencyInfoKHR == p ) {
    j = "DependencyInfoKHR";
    return;
  }
  if( StructureType :: eSubmitInfo2KHR == p ) {
    j = "SubmitInfo2KHR";
    return;
  }
  if( StructureType :: eSemaphoreSubmitInfoKHR == p ) {
    j = "SemaphoreSubmitInfoKHR";
    return;
  }
  if( StructureType :: eCommandBufferSubmitInfoKHR == p ) {
    j = "CommandBufferSubmitInfoKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceSynchronization2FeaturesKHR == p ) {
    j = "PhysicalDeviceSynchronization2FeaturesKHR";
    return;
  }
  if( StructureType :: eQueueFamilyCheckpointProperties2NV == p ) {
    j = "QueueFamilyCheckpointProperties2NV";
    return;
  }
  if( StructureType :: eCheckpointData2NV == p ) {
    j = "CheckpointData2NV";
    return;
  }
  if( StructureType :: eAccelerationStructureMotionInfoNV == p ) {
    j = "AccelerationStructureMotionInfoNV";
    return;
  }
  if( StructureType :: eCopyCommandTransformInfoQCOM == p ) {
    j = "CopyCommandTransformInfoQCOM";
    return;
  }
  if( StructureType :: ePhysicalDeviceImageRobustnessFeaturesEXT == p ) {
    j = "PhysicalDeviceImageRobustnessFeaturesEXT";
    return;
  }
  if( StructureType :: eCopyBufferInfo2KHR == p ) {
    j = "CopyBufferInfo2KHR";
    return;
  }
  if( StructureType :: eCopyImageInfo2KHR == p ) {
    j = "CopyImageInfo2KHR";
    return;
  }
  if( StructureType :: eCopyBufferToImageInfo2KHR == p ) {
    j = "CopyBufferToImageInfo2KHR";
    return;
  }
  if( StructureType :: eCopyImageToBufferInfo2KHR == p ) {
    j = "CopyImageToBufferInfo2KHR";
    return;
  }
  if( StructureType :: eBlitImageInfo2KHR == p ) {
    j = "BlitImageInfo2KHR";
    return;
  }
  if( StructureType :: eResolveImageInfo2KHR == p ) {
    j = "ResolveImageInfo2KHR";
    return;
  }
  if( StructureType :: eBufferCopy2KHR == p ) {
    j = "BufferCopy2KHR";
    return;
  }
  if( StructureType :: eImageCopy2KHR == p ) {
    j = "ImageCopy2KHR";
    return;
  }
  if( StructureType :: eImageBlit2KHR == p ) {
    j = "ImageBlit2KHR";
    return;
  }
  if( StructureType :: eBufferImageCopy2KHR == p ) {
    j = "BufferImageCopy2KHR";
    return;
  }
  if( StructureType :: eImageResolve2KHR == p ) {
    j = "ImageResolve2KHR";
    return;
  }
  if( StructureType :: ePhysicalDevice4444FormatsFeaturesEXT == p ) {
    j = "PhysicalDevice4444FormatsFeaturesEXT";
    return;
  }
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
  if( StructureType :: eDirectfbSurfaceCreateInfoEXT == p ) {
    j = "DirectfbSurfaceCreateInfoEXT";
    return;
  }
#endif
  if( StructureType :: eMutableDescriptorTypeCreateInfoVALVE == p ) {
    j = "MutableDescriptorTypeCreateInfoVALVE";
    return;
  }
  if( StructureType :: eVertexInputBindingDescription2EXT == p ) {
    j = "VertexInputBindingDescription2EXT";
    return;
  }
  if( StructureType :: eVertexInputAttributeDescription2EXT == p ) {
    j = "VertexInputAttributeDescription2EXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceDrmPropertiesEXT == p ) {
    j = "PhysicalDeviceDrmPropertiesEXT";
    return;
  }
#if defined(VK_USE_PLATFORM_FUCHSIA)
  if( StructureType :: eImportMemoryZirconHandleInfoFUCHSIA == p ) {
    j = "ImportMemoryZirconHandleInfoFUCHSIA";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
  if( StructureType :: eMemoryZirconHandlePropertiesFUCHSIA == p ) {
    j = "MemoryZirconHandlePropertiesFUCHSIA";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
  if( StructureType :: eMemoryGetZirconHandleInfoFUCHSIA == p ) {
    j = "MemoryGetZirconHandleInfoFUCHSIA";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
  if( StructureType :: eImportSemaphoreZirconHandleInfoFUCHSIA == p ) {
    j = "ImportSemaphoreZirconHandleInfoFUCHSIA";
    return;
  }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
  if( StructureType :: eSemaphoreGetZirconHandleInfoFUCHSIA == p ) {
    j = "SemaphoreGetZirconHandleInfoFUCHSIA";
    return;
  }
#endif
  if( StructureType :: eSubpasssShadingPipelineCreateInfoHUAWEI == p ) {
    j = "SubpasssShadingPipelineCreateInfoHUAWEI";
    return;
  }
  if( StructureType :: ePhysicalDeviceSubpassShadingFeaturesHUAWEI == p ) {
    j = "PhysicalDeviceSubpassShadingFeaturesHUAWEI";
    return;
  }
  if( StructureType :: ePhysicalDeviceSubpassShadingPropertiesHUAWEI == p ) {
    j = "PhysicalDeviceSubpassShadingPropertiesHUAWEI";
    return;
  }
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
  if( StructureType :: eScreenSurfaceCreateInfoQNX == p ) {
    j = "ScreenSurfaceCreateInfoQNX";
    return;
  }
#endif
  if( StructureType :: ePhysicalDeviceColorWriteEnableFeaturesEXT == p ) {
    j = "PhysicalDeviceColorWriteEnableFeaturesEXT";
    return;
  }
  if( StructureType :: ePipelineColorWriteCreateInfoEXT == p ) {
    j = "PipelineColorWriteCreateInfoEXT";
    return;
  }
  if( StructureType :: eQueueFamilyGlobalPriorityPropertiesEXT == p ) {
    j = "QueueFamilyGlobalPriorityPropertiesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceMultiDrawFeaturesEXT == p ) {
    j = "PhysicalDeviceMultiDrawFeaturesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceMultiDrawPropertiesEXT == p ) {
    j = "PhysicalDeviceMultiDrawPropertiesEXT";
    return;
  }
  if( StructureType :: eAttachmentDescription2KHR == p ) {
    j = "AttachmentDescription2KHR";
    return;
  }
  if( StructureType :: eAttachmentDescriptionStencilLayoutKHR == p ) {
    j = "AttachmentDescriptionStencilLayoutKHR";
    return;
  }
  if( StructureType :: eAttachmentReference2KHR == p ) {
    j = "AttachmentReference2KHR";
    return;
  }
  if( StructureType :: eAttachmentReferenceStencilLayoutKHR == p ) {
    j = "AttachmentReferenceStencilLayoutKHR";
    return;
  }
  if( StructureType :: eBindBufferMemoryDeviceGroupInfoKHR == p ) {
    j = "BindBufferMemoryDeviceGroupInfoKHR";
    return;
  }
  if( StructureType :: eBindBufferMemoryInfoKHR == p ) {
    j = "BindBufferMemoryInfoKHR";
    return;
  }
  if( StructureType :: eBindImageMemoryDeviceGroupInfoKHR == p ) {
    j = "BindImageMemoryDeviceGroupInfoKHR";
    return;
  }
  if( StructureType :: eBindImageMemoryInfoKHR == p ) {
    j = "BindImageMemoryInfoKHR";
    return;
  }
  if( StructureType :: eBindImagePlaneMemoryInfoKHR == p ) {
    j = "BindImagePlaneMemoryInfoKHR";
    return;
  }
  if( StructureType :: eBufferDeviceAddressInfoEXT == p ) {
    j = "BufferDeviceAddressInfoEXT";
    return;
  }
  if( StructureType :: eBufferDeviceAddressInfoKHR == p ) {
    j = "BufferDeviceAddressInfoKHR";
    return;
  }
  if( StructureType :: eBufferMemoryRequirementsInfo2KHR == p ) {
    j = "BufferMemoryRequirementsInfo2KHR";
    return;
  }
  if( StructureType :: eBufferOpaqueCaptureAddressCreateInfoKHR == p ) {
    j = "BufferOpaqueCaptureAddressCreateInfoKHR";
    return;
  }
  if( StructureType :: eDebugReportCreateInfoEXT == p ) {
    j = "DebugReportCreateInfoEXT";
    return;
  }
  if( StructureType :: eDescriptorSetLayoutSupportKHR == p ) {
    j = "DescriptorSetLayoutSupportKHR";
    return;
  }
  if( StructureType :: eDescriptorUpdateTemplateCreateInfoKHR == p ) {
    j = "DescriptorUpdateTemplateCreateInfoKHR";
    return;
  }
  if( StructureType :: eDeviceGroupBindSparseInfoKHR == p ) {
    j = "DeviceGroupBindSparseInfoKHR";
    return;
  }
  if( StructureType :: eDeviceGroupCommandBufferBeginInfoKHR == p ) {
    j = "DeviceGroupCommandBufferBeginInfoKHR";
    return;
  }
  if( StructureType :: eDeviceGroupDeviceCreateInfoKHR == p ) {
    j = "DeviceGroupDeviceCreateInfoKHR";
    return;
  }
  if( StructureType :: eDeviceGroupRenderPassBeginInfoKHR == p ) {
    j = "DeviceGroupRenderPassBeginInfoKHR";
    return;
  }
  if( StructureType :: eDeviceGroupSubmitInfoKHR == p ) {
    j = "DeviceGroupSubmitInfoKHR";
    return;
  }
  if( StructureType :: eDeviceMemoryOpaqueCaptureAddressInfoKHR == p ) {
    j = "DeviceMemoryOpaqueCaptureAddressInfoKHR";
    return;
  }
  if( StructureType :: eExportFenceCreateInfoKHR == p ) {
    j = "ExportFenceCreateInfoKHR";
    return;
  }
  if( StructureType :: eExportMemoryAllocateInfoKHR == p ) {
    j = "ExportMemoryAllocateInfoKHR";
    return;
  }
  if( StructureType :: eExportSemaphoreCreateInfoKHR == p ) {
    j = "ExportSemaphoreCreateInfoKHR";
    return;
  }
  if( StructureType :: eExternalBufferPropertiesKHR == p ) {
    j = "ExternalBufferPropertiesKHR";
    return;
  }
  if( StructureType :: eExternalFencePropertiesKHR == p ) {
    j = "ExternalFencePropertiesKHR";
    return;
  }
  if( StructureType :: eExternalImageFormatPropertiesKHR == p ) {
    j = "ExternalImageFormatPropertiesKHR";
    return;
  }
  if( StructureType :: eExternalMemoryBufferCreateInfoKHR == p ) {
    j = "ExternalMemoryBufferCreateInfoKHR";
    return;
  }
  if( StructureType :: eExternalMemoryImageCreateInfoKHR == p ) {
    j = "ExternalMemoryImageCreateInfoKHR";
    return;
  }
  if( StructureType :: eExternalSemaphorePropertiesKHR == p ) {
    j = "ExternalSemaphorePropertiesKHR";
    return;
  }
  if( StructureType :: eFormatProperties2KHR == p ) {
    j = "FormatProperties2KHR";
    return;
  }
  if( StructureType :: eFramebufferAttachmentsCreateInfoKHR == p ) {
    j = "FramebufferAttachmentsCreateInfoKHR";
    return;
  }
  if( StructureType :: eFramebufferAttachmentImageInfoKHR == p ) {
    j = "FramebufferAttachmentImageInfoKHR";
    return;
  }
  if( StructureType :: eImageFormatListCreateInfoKHR == p ) {
    j = "ImageFormatListCreateInfoKHR";
    return;
  }
  if( StructureType :: eImageFormatProperties2KHR == p ) {
    j = "ImageFormatProperties2KHR";
    return;
  }
  if( StructureType :: eImageMemoryRequirementsInfo2KHR == p ) {
    j = "ImageMemoryRequirementsInfo2KHR";
    return;
  }
  if( StructureType :: eImagePlaneMemoryRequirementsInfoKHR == p ) {
    j = "ImagePlaneMemoryRequirementsInfoKHR";
    return;
  }
  if( StructureType :: eImageSparseMemoryRequirementsInfo2KHR == p ) {
    j = "ImageSparseMemoryRequirementsInfo2KHR";
    return;
  }
  if( StructureType :: eImageStencilUsageCreateInfoEXT == p ) {
    j = "ImageStencilUsageCreateInfoEXT";
    return;
  }
  if( StructureType :: eImageViewUsageCreateInfoKHR == p ) {
    j = "ImageViewUsageCreateInfoKHR";
    return;
  }
  if( StructureType :: eMemoryAllocateFlagsInfoKHR == p ) {
    j = "MemoryAllocateFlagsInfoKHR";
    return;
  }
  if( StructureType :: eMemoryDedicatedAllocateInfoKHR == p ) {
    j = "MemoryDedicatedAllocateInfoKHR";
    return;
  }
  if( StructureType :: eMemoryDedicatedRequirementsKHR == p ) {
    j = "MemoryDedicatedRequirementsKHR";
    return;
  }
  if( StructureType :: eMemoryOpaqueCaptureAddressAllocateInfoKHR == p ) {
    j = "MemoryOpaqueCaptureAddressAllocateInfoKHR";
    return;
  }
  if( StructureType :: eMemoryRequirements2KHR == p ) {
    j = "MemoryRequirements2KHR";
    return;
  }
  if( StructureType :: ePhysicalDevice16BitStorageFeaturesKHR == p ) {
    j = "PhysicalDevice16BitStorageFeaturesKHR";
    return;
  }
  if( StructureType :: ePhysicalDevice8BitStorageFeaturesKHR == p ) {
    j = "PhysicalDevice8BitStorageFeaturesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceBufferAddressFeaturesEXT == p ) {
    j = "PhysicalDeviceBufferAddressFeaturesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceDescriptorIndexingFeaturesEXT == p ) {
    j = "PhysicalDeviceDescriptorIndexingFeaturesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceDriverPropertiesKHR == p ) {
    j = "PhysicalDeviceDriverPropertiesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceExternalBufferInfoKHR == p ) {
    j = "PhysicalDeviceExternalBufferInfoKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceExternalFenceInfoKHR == p ) {
    j = "PhysicalDeviceExternalFenceInfoKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceExternalImageFormatInfoKHR == p ) {
    j = "PhysicalDeviceExternalImageFormatInfoKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceExternalSemaphoreInfoKHR == p ) {
    j = "PhysicalDeviceExternalSemaphoreInfoKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceFeatures2KHR == p ) {
    j = "PhysicalDeviceFeatures2KHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceFloat16Int8FeaturesKHR == p ) {
    j = "PhysicalDeviceFloat16Int8FeaturesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceFloatControlsPropertiesKHR == p ) {
    j = "PhysicalDeviceFloatControlsPropertiesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceGroupPropertiesKHR == p ) {
    j = "PhysicalDeviceGroupPropertiesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceHostQueryResetFeaturesEXT == p ) {
    j = "PhysicalDeviceHostQueryResetFeaturesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceIdPropertiesKHR == p ) {
    j = "PhysicalDeviceIdPropertiesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceImageFormatInfo2KHR == p ) {
    j = "PhysicalDeviceImageFormatInfo2KHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceMaintenance3PropertiesKHR == p ) {
    j = "PhysicalDeviceMaintenance3PropertiesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceMemoryProperties2KHR == p ) {
    j = "PhysicalDeviceMemoryProperties2KHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceMultiviewFeaturesKHR == p ) {
    j = "PhysicalDeviceMultiviewFeaturesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceMultiviewPropertiesKHR == p ) {
    j = "PhysicalDeviceMultiviewPropertiesKHR";
    return;
  }
  if( StructureType :: ePhysicalDevicePointClippingPropertiesKHR == p ) {
    j = "PhysicalDevicePointClippingPropertiesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceProperties2KHR == p ) {
    j = "PhysicalDeviceProperties2KHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceScalarBlockLayoutFeaturesEXT == p ) {
    j = "PhysicalDeviceScalarBlockLayoutFeaturesEXT";
    return;
  }
  if( StructureType :: ePhysicalDeviceShaderAtomicInt64FeaturesKHR == p ) {
    j = "PhysicalDeviceShaderAtomicInt64FeaturesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceShaderDrawParameterFeatures == p ) {
    j = "PhysicalDeviceShaderDrawParameterFeatures";
    return;
  }
  if( StructureType :: ePhysicalDeviceShaderFloat16Int8FeaturesKHR == p ) {
    j = "PhysicalDeviceShaderFloat16Int8FeaturesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceSparseImageFormatInfo2KHR == p ) {
    j = "PhysicalDeviceSparseImageFormatInfo2KHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceTimelineSemaphoreFeaturesKHR == p ) {
    j = "PhysicalDeviceTimelineSemaphoreFeaturesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceTimelineSemaphorePropertiesKHR == p ) {
    j = "PhysicalDeviceTimelineSemaphorePropertiesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceVariablePointersFeaturesKHR == p ) {
    j = "PhysicalDeviceVariablePointersFeaturesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceVariablePointerFeatures == p ) {
    j = "PhysicalDeviceVariablePointerFeatures";
    return;
  }
  if( StructureType :: ePhysicalDeviceVariablePointerFeaturesKHR == p ) {
    j = "PhysicalDeviceVariablePointerFeaturesKHR";
    return;
  }
  if( StructureType :: ePhysicalDeviceVulkanMemoryModelFeaturesKHR == p ) {
    j = "PhysicalDeviceVulkanMemoryModelFeaturesKHR";
    return;
  }
  if( StructureType :: eQueryPoolCreateInfoINTEL == p ) {
    j = "QueryPoolCreateInfoINTEL";
    return;
  }
  if( StructureType :: eQueueFamilyProperties2KHR == p ) {
    j = "QueueFamilyProperties2KHR";
    return;
  }
  if( StructureType :: eRenderPassAttachmentBeginInfoKHR == p ) {
    j = "RenderPassAttachmentBeginInfoKHR";
    return;
  }
  if( StructureType :: eRenderPassCreateInfo2KHR == p ) {
    j = "RenderPassCreateInfo2KHR";
    return;
  }
  if( StructureType :: eRenderPassMultiviewCreateInfoKHR == p ) {
    j = "RenderPassMultiviewCreateInfoKHR";
    return;
  }
  if( StructureType :: eSamplerReductionModeCreateInfoEXT == p ) {
    j = "SamplerReductionModeCreateInfoEXT";
    return;
  }
  if( StructureType :: eSamplerYcbcrConversionCreateInfoKHR == p ) {
    j = "SamplerYcbcrConversionCreateInfoKHR";
    return;
  }
  if( StructureType :: eSamplerYcbcrConversionInfoKHR == p ) {
    j = "SamplerYcbcrConversionInfoKHR";
    return;
  }
  if( StructureType :: eSemaphoreSignalInfoKHR == p ) {
    j = "SemaphoreSignalInfoKHR";
    return;
  }
  if( StructureType :: eSemaphoreTypeCreateInfoKHR == p ) {
    j = "SemaphoreTypeCreateInfoKHR";
    return;
  }
  if( StructureType :: eSemaphoreWaitInfoKHR == p ) {
    j = "SemaphoreWaitInfoKHR";
    return;
  }
  if( StructureType :: eSparseImageFormatProperties2KHR == p ) {
    j = "SparseImageFormatProperties2KHR";
    return;
  }
  if( StructureType :: eSparseImageMemoryRequirements2KHR == p ) {
    j = "SparseImageMemoryRequirements2KHR";
    return;
  }
  if( StructureType :: eSubpassBeginInfoKHR == p ) {
    j = "SubpassBeginInfoKHR";
    return;
  }
  if( StructureType :: eSubpassDependency2KHR == p ) {
    j = "SubpassDependency2KHR";
    return;
  }
  if( StructureType :: eSubpassDescription2KHR == p ) {
    j = "SubpassDescription2KHR";
    return;
  }
  if( StructureType :: eSubpassDescriptionDepthStencilResolveKHR == p ) {
    j = "SubpassDescriptionDepthStencilResolveKHR";
    return;
  }
  if( StructureType :: eSubpassEndInfoKHR == p ) {
    j = "SubpassEndInfoKHR";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkStructureType &p ) {
  to_json( j, StructureType ( p ) );
}
inline void from_json( const nlohmann::json &j, StructureType &p ) {
  if( j.is_string() ) {
    if( "ApplicationInfo" == j.get< std::string >() ) {
      p = StructureType :: eApplicationInfo ;
      return;
    }
    if( "eApplicationInfo" == j.get< std::string >() ) {
      p = StructureType :: eApplicationInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_APPLICATION_INFO" == j.get< std::string >() ) {
      p = StructureType :: eApplicationInfo ;
      return;
    }
    if( "InstanceCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eInstanceCreateInfo ;
      return;
    }
    if( "eInstanceCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eInstanceCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eInstanceCreateInfo ;
      return;
    }
    if( "DeviceQueueCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceQueueCreateInfo ;
      return;
    }
    if( "eDeviceQueueCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceQueueCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eDeviceQueueCreateInfo ;
      return;
    }
    if( "DeviceCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceCreateInfo ;
      return;
    }
    if( "eDeviceCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eDeviceCreateInfo ;
      return;
    }
    if( "SubmitInfo" == j.get< std::string >() ) {
      p = StructureType :: eSubmitInfo ;
      return;
    }
    if( "eSubmitInfo" == j.get< std::string >() ) {
      p = StructureType :: eSubmitInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SUBMIT_INFO" == j.get< std::string >() ) {
      p = StructureType :: eSubmitInfo ;
      return;
    }
    if( "MemoryAllocateInfo" == j.get< std::string >() ) {
      p = StructureType :: eMemoryAllocateInfo ;
      return;
    }
    if( "eMemoryAllocateInfo" == j.get< std::string >() ) {
      p = StructureType :: eMemoryAllocateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eMemoryAllocateInfo ;
      return;
    }
    if( "MappedMemoryRange" == j.get< std::string >() ) {
      p = StructureType :: eMappedMemoryRange ;
      return;
    }
    if( "eMappedMemoryRange" == j.get< std::string >() ) {
      p = StructureType :: eMappedMemoryRange ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE" == j.get< std::string >() ) {
      p = StructureType :: eMappedMemoryRange ;
      return;
    }
    if( "BindSparseInfo" == j.get< std::string >() ) {
      p = StructureType :: eBindSparseInfo ;
      return;
    }
    if( "eBindSparseInfo" == j.get< std::string >() ) {
      p = StructureType :: eBindSparseInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eBindSparseInfo ;
      return;
    }
    if( "FenceCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eFenceCreateInfo ;
      return;
    }
    if( "eFenceCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eFenceCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eFenceCreateInfo ;
      return;
    }
    if( "SemaphoreCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreCreateInfo ;
      return;
    }
    if( "eSemaphoreCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreCreateInfo ;
      return;
    }
    if( "EventCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eEventCreateInfo ;
      return;
    }
    if( "eEventCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eEventCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eEventCreateInfo ;
      return;
    }
    if( "QueryPoolCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eQueryPoolCreateInfo ;
      return;
    }
    if( "eQueryPoolCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eQueryPoolCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eQueryPoolCreateInfo ;
      return;
    }
    if( "BufferCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eBufferCreateInfo ;
      return;
    }
    if( "eBufferCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eBufferCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eBufferCreateInfo ;
      return;
    }
    if( "BufferViewCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eBufferViewCreateInfo ;
      return;
    }
    if( "eBufferViewCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eBufferViewCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eBufferViewCreateInfo ;
      return;
    }
    if( "ImageCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eImageCreateInfo ;
      return;
    }
    if( "eImageCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eImageCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eImageCreateInfo ;
      return;
    }
    if( "ImageViewCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eImageViewCreateInfo ;
      return;
    }
    if( "eImageViewCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eImageViewCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eImageViewCreateInfo ;
      return;
    }
    if( "ShaderModuleCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eShaderModuleCreateInfo ;
      return;
    }
    if( "eShaderModuleCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eShaderModuleCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eShaderModuleCreateInfo ;
      return;
    }
    if( "PipelineCacheCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCacheCreateInfo ;
      return;
    }
    if( "ePipelineCacheCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCacheCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCacheCreateInfo ;
      return;
    }
    if( "PipelineShaderStageCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineShaderStageCreateInfo ;
      return;
    }
    if( "ePipelineShaderStageCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineShaderStageCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePipelineShaderStageCreateInfo ;
      return;
    }
    if( "PipelineVertexInputStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineVertexInputStateCreateInfo ;
      return;
    }
    if( "ePipelineVertexInputStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineVertexInputStateCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePipelineVertexInputStateCreateInfo ;
      return;
    }
    if( "PipelineInputAssemblyStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineInputAssemblyStateCreateInfo ;
      return;
    }
    if( "ePipelineInputAssemblyStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineInputAssemblyStateCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePipelineInputAssemblyStateCreateInfo ;
      return;
    }
    if( "PipelineTessellationStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineTessellationStateCreateInfo ;
      return;
    }
    if( "ePipelineTessellationStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineTessellationStateCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePipelineTessellationStateCreateInfo ;
      return;
    }
    if( "PipelineViewportStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineViewportStateCreateInfo ;
      return;
    }
    if( "ePipelineViewportStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineViewportStateCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePipelineViewportStateCreateInfo ;
      return;
    }
    if( "PipelineRasterizationStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineRasterizationStateCreateInfo ;
      return;
    }
    if( "ePipelineRasterizationStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineRasterizationStateCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePipelineRasterizationStateCreateInfo ;
      return;
    }
    if( "PipelineMultisampleStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineMultisampleStateCreateInfo ;
      return;
    }
    if( "ePipelineMultisampleStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineMultisampleStateCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePipelineMultisampleStateCreateInfo ;
      return;
    }
    if( "PipelineDepthStencilStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineDepthStencilStateCreateInfo ;
      return;
    }
    if( "ePipelineDepthStencilStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineDepthStencilStateCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePipelineDepthStencilStateCreateInfo ;
      return;
    }
    if( "PipelineColorBlendStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineColorBlendStateCreateInfo ;
      return;
    }
    if( "ePipelineColorBlendStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineColorBlendStateCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePipelineColorBlendStateCreateInfo ;
      return;
    }
    if( "PipelineDynamicStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineDynamicStateCreateInfo ;
      return;
    }
    if( "ePipelineDynamicStateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineDynamicStateCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePipelineDynamicStateCreateInfo ;
      return;
    }
    if( "GraphicsPipelineCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eGraphicsPipelineCreateInfo ;
      return;
    }
    if( "eGraphicsPipelineCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eGraphicsPipelineCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eGraphicsPipelineCreateInfo ;
      return;
    }
    if( "ComputePipelineCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eComputePipelineCreateInfo ;
      return;
    }
    if( "eComputePipelineCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eComputePipelineCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eComputePipelineCreateInfo ;
      return;
    }
    if( "PipelineLayoutCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineLayoutCreateInfo ;
      return;
    }
    if( "ePipelineLayoutCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: ePipelineLayoutCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePipelineLayoutCreateInfo ;
      return;
    }
    if( "SamplerCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eSamplerCreateInfo ;
      return;
    }
    if( "eSamplerCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eSamplerCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eSamplerCreateInfo ;
      return;
    }
    if( "DescriptorSetLayoutCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetLayoutCreateInfo ;
      return;
    }
    if( "eDescriptorSetLayoutCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetLayoutCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetLayoutCreateInfo ;
      return;
    }
    if( "DescriptorPoolCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorPoolCreateInfo ;
      return;
    }
    if( "eDescriptorPoolCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorPoolCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorPoolCreateInfo ;
      return;
    }
    if( "DescriptorSetAllocateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetAllocateInfo ;
      return;
    }
    if( "eDescriptorSetAllocateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetAllocateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetAllocateInfo ;
      return;
    }
    if( "WriteDescriptorSet" == j.get< std::string >() ) {
      p = StructureType :: eWriteDescriptorSet ;
      return;
    }
    if( "eWriteDescriptorSet" == j.get< std::string >() ) {
      p = StructureType :: eWriteDescriptorSet ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET" == j.get< std::string >() ) {
      p = StructureType :: eWriteDescriptorSet ;
      return;
    }
    if( "CopyDescriptorSet" == j.get< std::string >() ) {
      p = StructureType :: eCopyDescriptorSet ;
      return;
    }
    if( "eCopyDescriptorSet" == j.get< std::string >() ) {
      p = StructureType :: eCopyDescriptorSet ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET" == j.get< std::string >() ) {
      p = StructureType :: eCopyDescriptorSet ;
      return;
    }
    if( "FramebufferCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferCreateInfo ;
      return;
    }
    if( "eFramebufferCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferCreateInfo ;
      return;
    }
    if( "RenderPassCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassCreateInfo ;
      return;
    }
    if( "eRenderPassCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassCreateInfo ;
      return;
    }
    if( "CommandPoolCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eCommandPoolCreateInfo ;
      return;
    }
    if( "eCommandPoolCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eCommandPoolCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eCommandPoolCreateInfo ;
      return;
    }
    if( "CommandBufferAllocateInfo" == j.get< std::string >() ) {
      p = StructureType :: eCommandBufferAllocateInfo ;
      return;
    }
    if( "eCommandBufferAllocateInfo" == j.get< std::string >() ) {
      p = StructureType :: eCommandBufferAllocateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eCommandBufferAllocateInfo ;
      return;
    }
    if( "CommandBufferInheritanceInfo" == j.get< std::string >() ) {
      p = StructureType :: eCommandBufferInheritanceInfo ;
      return;
    }
    if( "eCommandBufferInheritanceInfo" == j.get< std::string >() ) {
      p = StructureType :: eCommandBufferInheritanceInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eCommandBufferInheritanceInfo ;
      return;
    }
    if( "CommandBufferBeginInfo" == j.get< std::string >() ) {
      p = StructureType :: eCommandBufferBeginInfo ;
      return;
    }
    if( "eCommandBufferBeginInfo" == j.get< std::string >() ) {
      p = StructureType :: eCommandBufferBeginInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO" == j.get< std::string >() ) {
      p = StructureType :: eCommandBufferBeginInfo ;
      return;
    }
    if( "RenderPassBeginInfo" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassBeginInfo ;
      return;
    }
    if( "eRenderPassBeginInfo" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassBeginInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassBeginInfo ;
      return;
    }
    if( "BufferMemoryBarrier" == j.get< std::string >() ) {
      p = StructureType :: eBufferMemoryBarrier ;
      return;
    }
    if( "eBufferMemoryBarrier" == j.get< std::string >() ) {
      p = StructureType :: eBufferMemoryBarrier ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER" == j.get< std::string >() ) {
      p = StructureType :: eBufferMemoryBarrier ;
      return;
    }
    if( "ImageMemoryBarrier" == j.get< std::string >() ) {
      p = StructureType :: eImageMemoryBarrier ;
      return;
    }
    if( "eImageMemoryBarrier" == j.get< std::string >() ) {
      p = StructureType :: eImageMemoryBarrier ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER" == j.get< std::string >() ) {
      p = StructureType :: eImageMemoryBarrier ;
      return;
    }
    if( "MemoryBarrier" == j.get< std::string >() ) {
      p = StructureType :: eMemoryBarrier ;
      return;
    }
    if( "eMemoryBarrier" == j.get< std::string >() ) {
      p = StructureType :: eMemoryBarrier ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_BARRIER" == j.get< std::string >() ) {
      p = StructureType :: eMemoryBarrier ;
      return;
    }
    if( "LoaderInstanceCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eLoaderInstanceCreateInfo ;
      return;
    }
    if( "eLoaderInstanceCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eLoaderInstanceCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eLoaderInstanceCreateInfo ;
      return;
    }
    if( "LoaderDeviceCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eLoaderDeviceCreateInfo ;
      return;
    }
    if( "eLoaderDeviceCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eLoaderDeviceCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eLoaderDeviceCreateInfo ;
      return;
    }
    if( "PhysicalDeviceSubgroupProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSubgroupProperties ;
      return;
    }
    if( "ePhysicalDeviceSubgroupProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSubgroupProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSubgroupProperties ;
      return;
    }
    if( "BindBufferMemoryInfo" == j.get< std::string >() ) {
      p = StructureType :: eBindBufferMemoryInfo ;
      return;
    }
    if( "eBindBufferMemoryInfo" == j.get< std::string >() ) {
      p = StructureType :: eBindBufferMemoryInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO" == j.get< std::string >() ) {
      p = StructureType :: eBindBufferMemoryInfo ;
      return;
    }
    if( "BindImageMemoryInfo" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemoryInfo ;
      return;
    }
    if( "eBindImageMemoryInfo" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemoryInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemoryInfo ;
      return;
    }
    if( "PhysicalDevice16BitStorageFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice16BitStorageFeatures ;
      return;
    }
    if( "ePhysicalDevice16BitStorageFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice16BitStorageFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice16BitStorageFeatures ;
      return;
    }
    if( "MemoryDedicatedRequirements" == j.get< std::string >() ) {
      p = StructureType :: eMemoryDedicatedRequirements ;
      return;
    }
    if( "eMemoryDedicatedRequirements" == j.get< std::string >() ) {
      p = StructureType :: eMemoryDedicatedRequirements ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS" == j.get< std::string >() ) {
      p = StructureType :: eMemoryDedicatedRequirements ;
      return;
    }
    if( "MemoryDedicatedAllocateInfo" == j.get< std::string >() ) {
      p = StructureType :: eMemoryDedicatedAllocateInfo ;
      return;
    }
    if( "eMemoryDedicatedAllocateInfo" == j.get< std::string >() ) {
      p = StructureType :: eMemoryDedicatedAllocateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eMemoryDedicatedAllocateInfo ;
      return;
    }
    if( "MemoryAllocateFlagsInfo" == j.get< std::string >() ) {
      p = StructureType :: eMemoryAllocateFlagsInfo ;
      return;
    }
    if( "eMemoryAllocateFlagsInfo" == j.get< std::string >() ) {
      p = StructureType :: eMemoryAllocateFlagsInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO" == j.get< std::string >() ) {
      p = StructureType :: eMemoryAllocateFlagsInfo ;
      return;
    }
    if( "DeviceGroupRenderPassBeginInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupRenderPassBeginInfo ;
      return;
    }
    if( "eDeviceGroupRenderPassBeginInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupRenderPassBeginInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupRenderPassBeginInfo ;
      return;
    }
    if( "DeviceGroupCommandBufferBeginInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupCommandBufferBeginInfo ;
      return;
    }
    if( "eDeviceGroupCommandBufferBeginInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupCommandBufferBeginInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupCommandBufferBeginInfo ;
      return;
    }
    if( "DeviceGroupSubmitInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupSubmitInfo ;
      return;
    }
    if( "eDeviceGroupSubmitInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupSubmitInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupSubmitInfo ;
      return;
    }
    if( "DeviceGroupBindSparseInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupBindSparseInfo ;
      return;
    }
    if( "eDeviceGroupBindSparseInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupBindSparseInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupBindSparseInfo ;
      return;
    }
    if( "BindBufferMemoryDeviceGroupInfo" == j.get< std::string >() ) {
      p = StructureType :: eBindBufferMemoryDeviceGroupInfo ;
      return;
    }
    if( "eBindBufferMemoryDeviceGroupInfo" == j.get< std::string >() ) {
      p = StructureType :: eBindBufferMemoryDeviceGroupInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO" == j.get< std::string >() ) {
      p = StructureType :: eBindBufferMemoryDeviceGroupInfo ;
      return;
    }
    if( "BindImageMemoryDeviceGroupInfo" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemoryDeviceGroupInfo ;
      return;
    }
    if( "eBindImageMemoryDeviceGroupInfo" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemoryDeviceGroupInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemoryDeviceGroupInfo ;
      return;
    }
    if( "PhysicalDeviceGroupProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceGroupProperties ;
      return;
    }
    if( "ePhysicalDeviceGroupProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceGroupProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceGroupProperties ;
      return;
    }
    if( "DeviceGroupDeviceCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupDeviceCreateInfo ;
      return;
    }
    if( "eDeviceGroupDeviceCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupDeviceCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupDeviceCreateInfo ;
      return;
    }
    if( "BufferMemoryRequirementsInfo2" == j.get< std::string >() ) {
      p = StructureType :: eBufferMemoryRequirementsInfo2 ;
      return;
    }
    if( "eBufferMemoryRequirementsInfo2" == j.get< std::string >() ) {
      p = StructureType :: eBufferMemoryRequirementsInfo2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2" == j.get< std::string >() ) {
      p = StructureType :: eBufferMemoryRequirementsInfo2 ;
      return;
    }
    if( "ImageMemoryRequirementsInfo2" == j.get< std::string >() ) {
      p = StructureType :: eImageMemoryRequirementsInfo2 ;
      return;
    }
    if( "eImageMemoryRequirementsInfo2" == j.get< std::string >() ) {
      p = StructureType :: eImageMemoryRequirementsInfo2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2" == j.get< std::string >() ) {
      p = StructureType :: eImageMemoryRequirementsInfo2 ;
      return;
    }
    if( "ImageSparseMemoryRequirementsInfo2" == j.get< std::string >() ) {
      p = StructureType :: eImageSparseMemoryRequirementsInfo2 ;
      return;
    }
    if( "eImageSparseMemoryRequirementsInfo2" == j.get< std::string >() ) {
      p = StructureType :: eImageSparseMemoryRequirementsInfo2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2" == j.get< std::string >() ) {
      p = StructureType :: eImageSparseMemoryRequirementsInfo2 ;
      return;
    }
    if( "MemoryRequirements2" == j.get< std::string >() ) {
      p = StructureType :: eMemoryRequirements2 ;
      return;
    }
    if( "eMemoryRequirements2" == j.get< std::string >() ) {
      p = StructureType :: eMemoryRequirements2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2" == j.get< std::string >() ) {
      p = StructureType :: eMemoryRequirements2 ;
      return;
    }
    if( "SparseImageMemoryRequirements2" == j.get< std::string >() ) {
      p = StructureType :: eSparseImageMemoryRequirements2 ;
      return;
    }
    if( "eSparseImageMemoryRequirements2" == j.get< std::string >() ) {
      p = StructureType :: eSparseImageMemoryRequirements2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2" == j.get< std::string >() ) {
      p = StructureType :: eSparseImageMemoryRequirements2 ;
      return;
    }
    if( "PhysicalDeviceFeatures2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFeatures2 ;
      return;
    }
    if( "ePhysicalDeviceFeatures2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFeatures2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFeatures2 ;
      return;
    }
    if( "PhysicalDeviceProperties2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProperties2 ;
      return;
    }
    if( "ePhysicalDeviceProperties2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProperties2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProperties2 ;
      return;
    }
    if( "FormatProperties2" == j.get< std::string >() ) {
      p = StructureType :: eFormatProperties2 ;
      return;
    }
    if( "eFormatProperties2" == j.get< std::string >() ) {
      p = StructureType :: eFormatProperties2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2" == j.get< std::string >() ) {
      p = StructureType :: eFormatProperties2 ;
      return;
    }
    if( "ImageFormatProperties2" == j.get< std::string >() ) {
      p = StructureType :: eImageFormatProperties2 ;
      return;
    }
    if( "eImageFormatProperties2" == j.get< std::string >() ) {
      p = StructureType :: eImageFormatProperties2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2" == j.get< std::string >() ) {
      p = StructureType :: eImageFormatProperties2 ;
      return;
    }
    if( "PhysicalDeviceImageFormatInfo2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageFormatInfo2 ;
      return;
    }
    if( "ePhysicalDeviceImageFormatInfo2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageFormatInfo2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageFormatInfo2 ;
      return;
    }
    if( "QueueFamilyProperties2" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyProperties2 ;
      return;
    }
    if( "eQueueFamilyProperties2" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyProperties2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyProperties2 ;
      return;
    }
    if( "PhysicalDeviceMemoryProperties2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMemoryProperties2 ;
      return;
    }
    if( "ePhysicalDeviceMemoryProperties2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMemoryProperties2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMemoryProperties2 ;
      return;
    }
    if( "SparseImageFormatProperties2" == j.get< std::string >() ) {
      p = StructureType :: eSparseImageFormatProperties2 ;
      return;
    }
    if( "eSparseImageFormatProperties2" == j.get< std::string >() ) {
      p = StructureType :: eSparseImageFormatProperties2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2" == j.get< std::string >() ) {
      p = StructureType :: eSparseImageFormatProperties2 ;
      return;
    }
    if( "PhysicalDeviceSparseImageFormatInfo2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSparseImageFormatInfo2 ;
      return;
    }
    if( "ePhysicalDeviceSparseImageFormatInfo2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSparseImageFormatInfo2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSparseImageFormatInfo2 ;
      return;
    }
    if( "PhysicalDevicePointClippingProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePointClippingProperties ;
      return;
    }
    if( "ePhysicalDevicePointClippingProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePointClippingProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePointClippingProperties ;
      return;
    }
    if( "RenderPassInputAttachmentAspectCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassInputAttachmentAspectCreateInfo ;
      return;
    }
    if( "eRenderPassInputAttachmentAspectCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassInputAttachmentAspectCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassInputAttachmentAspectCreateInfo ;
      return;
    }
    if( "ImageViewUsageCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eImageViewUsageCreateInfo ;
      return;
    }
    if( "eImageViewUsageCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eImageViewUsageCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eImageViewUsageCreateInfo ;
      return;
    }
    if( "RenderPassMultiviewCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassMultiviewCreateInfo ;
      return;
    }
    if( "eRenderPassMultiviewCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassMultiviewCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassMultiviewCreateInfo ;
      return;
    }
    if( "PhysicalDeviceMultiviewFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiviewFeatures ;
      return;
    }
    if( "ePhysicalDeviceMultiviewFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiviewFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiviewFeatures ;
      return;
    }
    if( "PhysicalDeviceMultiviewProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiviewProperties ;
      return;
    }
    if( "ePhysicalDeviceMultiviewProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiviewProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiviewProperties ;
      return;
    }
    if( "PhysicalDeviceVariablePointersFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVariablePointersFeatures ;
      return;
    }
    if( "ePhysicalDeviceVariablePointersFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVariablePointersFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVariablePointersFeatures ;
      return;
    }
    if( "ProtectedSubmitInfo" == j.get< std::string >() ) {
      p = StructureType :: eProtectedSubmitInfo ;
      return;
    }
    if( "eProtectedSubmitInfo" == j.get< std::string >() ) {
      p = StructureType :: eProtectedSubmitInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO" == j.get< std::string >() ) {
      p = StructureType :: eProtectedSubmitInfo ;
      return;
    }
    if( "PhysicalDeviceProtectedMemoryFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProtectedMemoryFeatures ;
      return;
    }
    if( "ePhysicalDeviceProtectedMemoryFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProtectedMemoryFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProtectedMemoryFeatures ;
      return;
    }
    if( "PhysicalDeviceProtectedMemoryProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProtectedMemoryProperties ;
      return;
    }
    if( "ePhysicalDeviceProtectedMemoryProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProtectedMemoryProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProtectedMemoryProperties ;
      return;
    }
    if( "DeviceQueueInfo2" == j.get< std::string >() ) {
      p = StructureType :: eDeviceQueueInfo2 ;
      return;
    }
    if( "eDeviceQueueInfo2" == j.get< std::string >() ) {
      p = StructureType :: eDeviceQueueInfo2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2" == j.get< std::string >() ) {
      p = StructureType :: eDeviceQueueInfo2 ;
      return;
    }
    if( "SamplerYcbcrConversionCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionCreateInfo ;
      return;
    }
    if( "eSamplerYcbcrConversionCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionCreateInfo ;
      return;
    }
    if( "SamplerYcbcrConversionInfo" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionInfo ;
      return;
    }
    if( "eSamplerYcbcrConversionInfo" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionInfo ;
      return;
    }
    if( "BindImagePlaneMemoryInfo" == j.get< std::string >() ) {
      p = StructureType :: eBindImagePlaneMemoryInfo ;
      return;
    }
    if( "eBindImagePlaneMemoryInfo" == j.get< std::string >() ) {
      p = StructureType :: eBindImagePlaneMemoryInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO" == j.get< std::string >() ) {
      p = StructureType :: eBindImagePlaneMemoryInfo ;
      return;
    }
    if( "ImagePlaneMemoryRequirementsInfo" == j.get< std::string >() ) {
      p = StructureType :: eImagePlaneMemoryRequirementsInfo ;
      return;
    }
    if( "eImagePlaneMemoryRequirementsInfo" == j.get< std::string >() ) {
      p = StructureType :: eImagePlaneMemoryRequirementsInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO" == j.get< std::string >() ) {
      p = StructureType :: eImagePlaneMemoryRequirementsInfo ;
      return;
    }
    if( "PhysicalDeviceSamplerYcbcrConversionFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSamplerYcbcrConversionFeatures ;
      return;
    }
    if( "ePhysicalDeviceSamplerYcbcrConversionFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSamplerYcbcrConversionFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSamplerYcbcrConversionFeatures ;
      return;
    }
    if( "SamplerYcbcrConversionImageFormatProperties" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionImageFormatProperties ;
      return;
    }
    if( "eSamplerYcbcrConversionImageFormatProperties" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionImageFormatProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionImageFormatProperties ;
      return;
    }
    if( "DescriptorUpdateTemplateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorUpdateTemplateCreateInfo ;
      return;
    }
    if( "eDescriptorUpdateTemplateCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorUpdateTemplateCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorUpdateTemplateCreateInfo ;
      return;
    }
    if( "PhysicalDeviceExternalImageFormatInfo" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalImageFormatInfo ;
      return;
    }
    if( "ePhysicalDeviceExternalImageFormatInfo" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalImageFormatInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalImageFormatInfo ;
      return;
    }
    if( "ExternalImageFormatProperties" == j.get< std::string >() ) {
      p = StructureType :: eExternalImageFormatProperties ;
      return;
    }
    if( "eExternalImageFormatProperties" == j.get< std::string >() ) {
      p = StructureType :: eExternalImageFormatProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: eExternalImageFormatProperties ;
      return;
    }
    if( "PhysicalDeviceExternalBufferInfo" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalBufferInfo ;
      return;
    }
    if( "ePhysicalDeviceExternalBufferInfo" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalBufferInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalBufferInfo ;
      return;
    }
    if( "ExternalBufferProperties" == j.get< std::string >() ) {
      p = StructureType :: eExternalBufferProperties ;
      return;
    }
    if( "eExternalBufferProperties" == j.get< std::string >() ) {
      p = StructureType :: eExternalBufferProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: eExternalBufferProperties ;
      return;
    }
    if( "PhysicalDeviceIdProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceIdProperties ;
      return;
    }
    if( "ePhysicalDeviceIdProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceIdProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceIdProperties ;
      return;
    }
    if( "ExternalMemoryBufferCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryBufferCreateInfo ;
      return;
    }
    if( "eExternalMemoryBufferCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryBufferCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryBufferCreateInfo ;
      return;
    }
    if( "ExternalMemoryImageCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryImageCreateInfo ;
      return;
    }
    if( "eExternalMemoryImageCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryImageCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryImageCreateInfo ;
      return;
    }
    if( "ExportMemoryAllocateInfo" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryAllocateInfo ;
      return;
    }
    if( "eExportMemoryAllocateInfo" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryAllocateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryAllocateInfo ;
      return;
    }
    if( "PhysicalDeviceExternalFenceInfo" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalFenceInfo ;
      return;
    }
    if( "ePhysicalDeviceExternalFenceInfo" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalFenceInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalFenceInfo ;
      return;
    }
    if( "ExternalFenceProperties" == j.get< std::string >() ) {
      p = StructureType :: eExternalFenceProperties ;
      return;
    }
    if( "eExternalFenceProperties" == j.get< std::string >() ) {
      p = StructureType :: eExternalFenceProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: eExternalFenceProperties ;
      return;
    }
    if( "ExportFenceCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eExportFenceCreateInfo ;
      return;
    }
    if( "eExportFenceCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eExportFenceCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eExportFenceCreateInfo ;
      return;
    }
    if( "ExportSemaphoreCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eExportSemaphoreCreateInfo ;
      return;
    }
    if( "eExportSemaphoreCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eExportSemaphoreCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eExportSemaphoreCreateInfo ;
      return;
    }
    if( "PhysicalDeviceExternalSemaphoreInfo" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalSemaphoreInfo ;
      return;
    }
    if( "ePhysicalDeviceExternalSemaphoreInfo" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalSemaphoreInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalSemaphoreInfo ;
      return;
    }
    if( "ExternalSemaphoreProperties" == j.get< std::string >() ) {
      p = StructureType :: eExternalSemaphoreProperties ;
      return;
    }
    if( "eExternalSemaphoreProperties" == j.get< std::string >() ) {
      p = StructureType :: eExternalSemaphoreProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: eExternalSemaphoreProperties ;
      return;
    }
    if( "PhysicalDeviceMaintenance3Properties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMaintenance3Properties ;
      return;
    }
    if( "ePhysicalDeviceMaintenance3Properties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMaintenance3Properties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMaintenance3Properties ;
      return;
    }
    if( "DescriptorSetLayoutSupport" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetLayoutSupport ;
      return;
    }
    if( "eDescriptorSetLayoutSupport" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetLayoutSupport ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetLayoutSupport ;
      return;
    }
    if( "PhysicalDeviceShaderDrawParametersFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderDrawParametersFeatures ;
      return;
    }
    if( "ePhysicalDeviceShaderDrawParametersFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderDrawParametersFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderDrawParametersFeatures ;
      return;
    }
    if( "PhysicalDeviceVulkan11Features" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkan11Features ;
      return;
    }
    if( "ePhysicalDeviceVulkan11Features" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkan11Features ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkan11Features ;
      return;
    }
    if( "PhysicalDeviceVulkan11Properties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkan11Properties ;
      return;
    }
    if( "ePhysicalDeviceVulkan11Properties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkan11Properties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkan11Properties ;
      return;
    }
    if( "PhysicalDeviceVulkan12Features" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkan12Features ;
      return;
    }
    if( "ePhysicalDeviceVulkan12Features" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkan12Features ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkan12Features ;
      return;
    }
    if( "PhysicalDeviceVulkan12Properties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkan12Properties ;
      return;
    }
    if( "ePhysicalDeviceVulkan12Properties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkan12Properties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkan12Properties ;
      return;
    }
    if( "ImageFormatListCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eImageFormatListCreateInfo ;
      return;
    }
    if( "eImageFormatListCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eImageFormatListCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eImageFormatListCreateInfo ;
      return;
    }
    if( "AttachmentDescription2" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentDescription2 ;
      return;
    }
    if( "eAttachmentDescription2" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentDescription2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentDescription2 ;
      return;
    }
    if( "AttachmentReference2" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentReference2 ;
      return;
    }
    if( "eAttachmentReference2" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentReference2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentReference2 ;
      return;
    }
    if( "SubpassDescription2" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDescription2 ;
      return;
    }
    if( "eSubpassDescription2" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDescription2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDescription2 ;
      return;
    }
    if( "SubpassDependency2" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDependency2 ;
      return;
    }
    if( "eSubpassDependency2" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDependency2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDependency2 ;
      return;
    }
    if( "RenderPassCreateInfo2" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassCreateInfo2 ;
      return;
    }
    if( "eRenderPassCreateInfo2" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassCreateInfo2 ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassCreateInfo2 ;
      return;
    }
    if( "SubpassBeginInfo" == j.get< std::string >() ) {
      p = StructureType :: eSubpassBeginInfo ;
      return;
    }
    if( "eSubpassBeginInfo" == j.get< std::string >() ) {
      p = StructureType :: eSubpassBeginInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO" == j.get< std::string >() ) {
      p = StructureType :: eSubpassBeginInfo ;
      return;
    }
    if( "SubpassEndInfo" == j.get< std::string >() ) {
      p = StructureType :: eSubpassEndInfo ;
      return;
    }
    if( "eSubpassEndInfo" == j.get< std::string >() ) {
      p = StructureType :: eSubpassEndInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SUBPASS_END_INFO" == j.get< std::string >() ) {
      p = StructureType :: eSubpassEndInfo ;
      return;
    }
    if( "PhysicalDevice8BitStorageFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice8BitStorageFeatures ;
      return;
    }
    if( "ePhysicalDevice8BitStorageFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice8BitStorageFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice8BitStorageFeatures ;
      return;
    }
    if( "PhysicalDeviceDriverProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDriverProperties ;
      return;
    }
    if( "ePhysicalDeviceDriverProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDriverProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDriverProperties ;
      return;
    }
    if( "PhysicalDeviceShaderAtomicInt64Features" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderAtomicInt64Features ;
      return;
    }
    if( "ePhysicalDeviceShaderAtomicInt64Features" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderAtomicInt64Features ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderAtomicInt64Features ;
      return;
    }
    if( "PhysicalDeviceShaderFloat16Int8Features" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderFloat16Int8Features ;
      return;
    }
    if( "ePhysicalDeviceShaderFloat16Int8Features" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderFloat16Int8Features ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderFloat16Int8Features ;
      return;
    }
    if( "PhysicalDeviceFloatControlsProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFloatControlsProperties ;
      return;
    }
    if( "ePhysicalDeviceFloatControlsProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFloatControlsProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFloatControlsProperties ;
      return;
    }
    if( "DescriptorSetLayoutBindingFlagsCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetLayoutBindingFlagsCreateInfo ;
      return;
    }
    if( "eDescriptorSetLayoutBindingFlagsCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetLayoutBindingFlagsCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetLayoutBindingFlagsCreateInfo ;
      return;
    }
    if( "PhysicalDeviceDescriptorIndexingFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDescriptorIndexingFeatures ;
      return;
    }
    if( "ePhysicalDeviceDescriptorIndexingFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDescriptorIndexingFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDescriptorIndexingFeatures ;
      return;
    }
    if( "PhysicalDeviceDescriptorIndexingProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDescriptorIndexingProperties ;
      return;
    }
    if( "ePhysicalDeviceDescriptorIndexingProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDescriptorIndexingProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDescriptorIndexingProperties ;
      return;
    }
    if( "PhysicalDeviceDepthStencilResolveProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDepthStencilResolveProperties ;
      return;
    }
    if( "ePhysicalDeviceDepthStencilResolveProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDepthStencilResolveProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDepthStencilResolveProperties ;
      return;
    }
    if( "SubpassDescriptionDepthStencilResolve" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDescriptionDepthStencilResolve ;
      return;
    }
    if( "eSubpassDescriptionDepthStencilResolve" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDescriptionDepthStencilResolve ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDescriptionDepthStencilResolve ;
      return;
    }
    if( "PhysicalDeviceScalarBlockLayoutFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceScalarBlockLayoutFeatures ;
      return;
    }
    if( "ePhysicalDeviceScalarBlockLayoutFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceScalarBlockLayoutFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceScalarBlockLayoutFeatures ;
      return;
    }
    if( "ImageStencilUsageCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eImageStencilUsageCreateInfo ;
      return;
    }
    if( "eImageStencilUsageCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eImageStencilUsageCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eImageStencilUsageCreateInfo ;
      return;
    }
    if( "PhysicalDeviceSamplerFilterMinmaxProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSamplerFilterMinmaxProperties ;
      return;
    }
    if( "ePhysicalDeviceSamplerFilterMinmaxProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSamplerFilterMinmaxProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSamplerFilterMinmaxProperties ;
      return;
    }
    if( "SamplerReductionModeCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eSamplerReductionModeCreateInfo ;
      return;
    }
    if( "eSamplerReductionModeCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eSamplerReductionModeCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eSamplerReductionModeCreateInfo ;
      return;
    }
    if( "PhysicalDeviceVulkanMemoryModelFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkanMemoryModelFeatures ;
      return;
    }
    if( "ePhysicalDeviceVulkanMemoryModelFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkanMemoryModelFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkanMemoryModelFeatures ;
      return;
    }
    if( "PhysicalDeviceImagelessFramebufferFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImagelessFramebufferFeatures ;
      return;
    }
    if( "ePhysicalDeviceImagelessFramebufferFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImagelessFramebufferFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImagelessFramebufferFeatures ;
      return;
    }
    if( "FramebufferAttachmentsCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferAttachmentsCreateInfo ;
      return;
    }
    if( "eFramebufferAttachmentsCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferAttachmentsCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferAttachmentsCreateInfo ;
      return;
    }
    if( "FramebufferAttachmentImageInfo" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferAttachmentImageInfo ;
      return;
    }
    if( "eFramebufferAttachmentImageInfo" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferAttachmentImageInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferAttachmentImageInfo ;
      return;
    }
    if( "RenderPassAttachmentBeginInfo" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassAttachmentBeginInfo ;
      return;
    }
    if( "eRenderPassAttachmentBeginInfo" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassAttachmentBeginInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassAttachmentBeginInfo ;
      return;
    }
    if( "AttachmentReferenceStencilLayout" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentReferenceStencilLayout ;
      return;
    }
    if( "eAttachmentReferenceStencilLayout" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentReferenceStencilLayout ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentReferenceStencilLayout ;
      return;
    }
    if( "AttachmentDescriptionStencilLayout" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentDescriptionStencilLayout ;
      return;
    }
    if( "eAttachmentDescriptionStencilLayout" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentDescriptionStencilLayout ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentDescriptionStencilLayout ;
      return;
    }
    if( "PhysicalDeviceHostQueryResetFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceHostQueryResetFeatures ;
      return;
    }
    if( "ePhysicalDeviceHostQueryResetFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceHostQueryResetFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceHostQueryResetFeatures ;
      return;
    }
    if( "PhysicalDeviceTimelineSemaphoreFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTimelineSemaphoreFeatures ;
      return;
    }
    if( "ePhysicalDeviceTimelineSemaphoreFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTimelineSemaphoreFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTimelineSemaphoreFeatures ;
      return;
    }
    if( "PhysicalDeviceTimelineSemaphoreProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTimelineSemaphoreProperties ;
      return;
    }
    if( "ePhysicalDeviceTimelineSemaphoreProperties" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTimelineSemaphoreProperties ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTimelineSemaphoreProperties ;
      return;
    }
    if( "SemaphoreTypeCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreTypeCreateInfo ;
      return;
    }
    if( "eSemaphoreTypeCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreTypeCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreTypeCreateInfo ;
      return;
    }
    if( "TimelineSemaphoreSubmitInfo" == j.get< std::string >() ) {
      p = StructureType :: eTimelineSemaphoreSubmitInfo ;
      return;
    }
    if( "eTimelineSemaphoreSubmitInfo" == j.get< std::string >() ) {
      p = StructureType :: eTimelineSemaphoreSubmitInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO" == j.get< std::string >() ) {
      p = StructureType :: eTimelineSemaphoreSubmitInfo ;
      return;
    }
    if( "SemaphoreWaitInfo" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreWaitInfo ;
      return;
    }
    if( "eSemaphoreWaitInfo" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreWaitInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreWaitInfo ;
      return;
    }
    if( "SemaphoreSignalInfo" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreSignalInfo ;
      return;
    }
    if( "eSemaphoreSignalInfo" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreSignalInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreSignalInfo ;
      return;
    }
    if( "PhysicalDeviceBufferDeviceAddressFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceBufferDeviceAddressFeatures ;
      return;
    }
    if( "ePhysicalDeviceBufferDeviceAddressFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceBufferDeviceAddressFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceBufferDeviceAddressFeatures ;
      return;
    }
    if( "BufferDeviceAddressInfo" == j.get< std::string >() ) {
      p = StructureType :: eBufferDeviceAddressInfo ;
      return;
    }
    if( "eBufferDeviceAddressInfo" == j.get< std::string >() ) {
      p = StructureType :: eBufferDeviceAddressInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO" == j.get< std::string >() ) {
      p = StructureType :: eBufferDeviceAddressInfo ;
      return;
    }
    if( "BufferOpaqueCaptureAddressCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eBufferOpaqueCaptureAddressCreateInfo ;
      return;
    }
    if( "eBufferOpaqueCaptureAddressCreateInfo" == j.get< std::string >() ) {
      p = StructureType :: eBufferOpaqueCaptureAddressCreateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eBufferOpaqueCaptureAddressCreateInfo ;
      return;
    }
    if( "MemoryOpaqueCaptureAddressAllocateInfo" == j.get< std::string >() ) {
      p = StructureType :: eMemoryOpaqueCaptureAddressAllocateInfo ;
      return;
    }
    if( "eMemoryOpaqueCaptureAddressAllocateInfo" == j.get< std::string >() ) {
      p = StructureType :: eMemoryOpaqueCaptureAddressAllocateInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO" == j.get< std::string >() ) {
      p = StructureType :: eMemoryOpaqueCaptureAddressAllocateInfo ;
      return;
    }
    if( "DeviceMemoryOpaqueCaptureAddressInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceMemoryOpaqueCaptureAddressInfo ;
      return;
    }
    if( "eDeviceMemoryOpaqueCaptureAddressInfo" == j.get< std::string >() ) {
      p = StructureType :: eDeviceMemoryOpaqueCaptureAddressInfo ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO" == j.get< std::string >() ) {
      p = StructureType :: eDeviceMemoryOpaqueCaptureAddressInfo ;
      return;
    }
    if( "SwapchainCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSwapchainCreateInfoKHR ;
      return;
    }
    if( "eSwapchainCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSwapchainCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSwapchainCreateInfoKHR ;
      return;
    }
    if( "PresentInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePresentInfoKHR ;
      return;
    }
    if( "ePresentInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePresentInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePresentInfoKHR ;
      return;
    }
    if( "DeviceGroupPresentCapabilitiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupPresentCapabilitiesKHR ;
      return;
    }
    if( "eDeviceGroupPresentCapabilitiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupPresentCapabilitiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupPresentCapabilitiesKHR ;
      return;
    }
    if( "ImageSwapchainCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImageSwapchainCreateInfoKHR ;
      return;
    }
    if( "eImageSwapchainCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImageSwapchainCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageSwapchainCreateInfoKHR ;
      return;
    }
    if( "BindImageMemorySwapchainInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemorySwapchainInfoKHR ;
      return;
    }
    if( "eBindImageMemorySwapchainInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemorySwapchainInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemorySwapchainInfoKHR ;
      return;
    }
    if( "AcquireNextImageInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAcquireNextImageInfoKHR ;
      return;
    }
    if( "eAcquireNextImageInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAcquireNextImageInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eAcquireNextImageInfoKHR ;
      return;
    }
    if( "DeviceGroupPresentInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupPresentInfoKHR ;
      return;
    }
    if( "eDeviceGroupPresentInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupPresentInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupPresentInfoKHR ;
      return;
    }
    if( "DeviceGroupSwapchainCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupSwapchainCreateInfoKHR ;
      return;
    }
    if( "eDeviceGroupSwapchainCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupSwapchainCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupSwapchainCreateInfoKHR ;
      return;
    }
    if( "DisplayModeCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayModeCreateInfoKHR ;
      return;
    }
    if( "eDisplayModeCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayModeCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayModeCreateInfoKHR ;
      return;
    }
    if( "DisplaySurfaceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplaySurfaceCreateInfoKHR ;
      return;
    }
    if( "eDisplaySurfaceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplaySurfaceCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplaySurfaceCreateInfoKHR ;
      return;
    }
    if( "DisplayPresentInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPresentInfoKHR ;
      return;
    }
    if( "eDisplayPresentInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPresentInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPresentInfoKHR ;
      return;
    }
#if defined(VK_USE_PLATFORM_XLIB_KHR)
    if( "XlibSurfaceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eXlibSurfaceCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
    if( "eXlibSurfaceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eXlibSurfaceCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
    if( "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eXlibSurfaceCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
    if( "XcbSurfaceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eXcbSurfaceCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
    if( "eXcbSurfaceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eXcbSurfaceCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
    if( "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eXcbSurfaceCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
    if( "WaylandSurfaceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eWaylandSurfaceCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
    if( "eWaylandSurfaceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eWaylandSurfaceCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
    if( "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eWaylandSurfaceCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "AndroidSurfaceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAndroidSurfaceCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "eAndroidSurfaceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAndroidSurfaceCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eAndroidSurfaceCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "Win32SurfaceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eWin32SurfaceCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eWin32SurfaceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eWin32SurfaceCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eWin32SurfaceCreateInfoKHR ;
      return;
    }
#endif
    if( "DebugReportCallbackCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugReportCallbackCreateInfoEXT ;
      return;
    }
    if( "eDebugReportCallbackCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugReportCallbackCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugReportCallbackCreateInfoEXT ;
      return;
    }
    if( "DebugMarkerObjectNameInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugMarkerObjectNameInfoEXT ;
      return;
    }
    if( "eDebugMarkerObjectNameInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugMarkerObjectNameInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugMarkerObjectNameInfoEXT ;
      return;
    }
    if( "DebugMarkerObjectTagInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugMarkerObjectTagInfoEXT ;
      return;
    }
    if( "eDebugMarkerObjectTagInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugMarkerObjectTagInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugMarkerObjectTagInfoEXT ;
      return;
    }
    if( "DebugMarkerMarkerInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugMarkerMarkerInfoEXT ;
      return;
    }
    if( "eDebugMarkerMarkerInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugMarkerMarkerInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugMarkerMarkerInfoEXT ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoProfileKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoProfileKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoProfileKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoProfileKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_PROFILE_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoProfileKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoCapabilitiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoCapabilitiesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoCapabilitiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoCapabilitiesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoCapabilitiesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoPictureResourceKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoPictureResourceKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoPictureResourceKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoPictureResourceKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoPictureResourceKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoGetMemoryPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoGetMemoryPropertiesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoGetMemoryPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoGetMemoryPropertiesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_GET_MEMORY_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoGetMemoryPropertiesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoBindMemoryKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoBindMemoryKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoBindMemoryKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoBindMemoryKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_BIND_MEMORY_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoBindMemoryKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoSessionCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoSessionCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoSessionCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoSessionCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoSessionCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoSessionParametersCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoSessionParametersCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoSessionParametersCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoSessionParametersCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoSessionParametersCreateInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoSessionParametersUpdateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoSessionParametersUpdateInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoSessionParametersUpdateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoSessionParametersUpdateInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoSessionParametersUpdateInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoBeginCodingInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoBeginCodingInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoBeginCodingInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoBeginCodingInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoBeginCodingInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEndCodingInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoEndCodingInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEndCodingInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoEndCodingInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoEndCodingInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoCodingControlInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoCodingControlInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoCodingControlInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoCodingControlInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoCodingControlInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoReferenceSlotKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoReferenceSlotKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoReferenceSlotKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoReferenceSlotKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoReferenceSlotKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoQueueFamilyProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoQueueFamilyProperties2KHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoQueueFamilyProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoQueueFamilyProperties2KHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_QUEUE_FAMILY_PROPERTIES_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoQueueFamilyProperties2KHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoProfilesKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoProfilesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoProfilesKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoProfilesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_PROFILES_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoProfilesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "PhysicalDeviceVideoFormatInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVideoFormatInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "ePhysicalDeviceVideoFormatInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVideoFormatInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVideoFormatInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoFormatPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoFormatPropertiesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoFormatPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoFormatPropertiesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoFormatPropertiesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeInfoKHR ;
      return;
    }
#endif
    if( "DedicatedAllocationImageCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eDedicatedAllocationImageCreateInfoNV ;
      return;
    }
    if( "eDedicatedAllocationImageCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eDedicatedAllocationImageCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eDedicatedAllocationImageCreateInfoNV ;
      return;
    }
    if( "DedicatedAllocationBufferCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eDedicatedAllocationBufferCreateInfoNV ;
      return;
    }
    if( "eDedicatedAllocationBufferCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eDedicatedAllocationBufferCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eDedicatedAllocationBufferCreateInfoNV ;
      return;
    }
    if( "DedicatedAllocationMemoryAllocateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eDedicatedAllocationMemoryAllocateInfoNV ;
      return;
    }
    if( "eDedicatedAllocationMemoryAllocateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eDedicatedAllocationMemoryAllocateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eDedicatedAllocationMemoryAllocateInfoNV ;
      return;
    }
    if( "PhysicalDeviceTransformFeedbackFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTransformFeedbackFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceTransformFeedbackFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTransformFeedbackFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTransformFeedbackFeaturesEXT ;
      return;
    }
    if( "PhysicalDeviceTransformFeedbackPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTransformFeedbackPropertiesEXT ;
      return;
    }
    if( "ePhysicalDeviceTransformFeedbackPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTransformFeedbackPropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTransformFeedbackPropertiesEXT ;
      return;
    }
    if( "CuModuleCreateInfoNVX" == j.get< std::string >() ) {
      p = StructureType :: eCuModuleCreateInfoNVX ;
      return;
    }
    if( "eCuModuleCreateInfoNVX" == j.get< std::string >() ) {
      p = StructureType :: eCuModuleCreateInfoNVX ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX" == j.get< std::string >() ) {
      p = StructureType :: eCuModuleCreateInfoNVX ;
      return;
    }
    if( "CuFunctionCreateInfoNVX" == j.get< std::string >() ) {
      p = StructureType :: eCuFunctionCreateInfoNVX ;
      return;
    }
    if( "eCuFunctionCreateInfoNVX" == j.get< std::string >() ) {
      p = StructureType :: eCuFunctionCreateInfoNVX ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX" == j.get< std::string >() ) {
      p = StructureType :: eCuFunctionCreateInfoNVX ;
      return;
    }
    if( "CuLaunchInfoNVX" == j.get< std::string >() ) {
      p = StructureType :: eCuLaunchInfoNVX ;
      return;
    }
    if( "eCuLaunchInfoNVX" == j.get< std::string >() ) {
      p = StructureType :: eCuLaunchInfoNVX ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX" == j.get< std::string >() ) {
      p = StructureType :: eCuLaunchInfoNVX ;
      return;
    }
    if( "ImageViewHandleInfoNVX" == j.get< std::string >() ) {
      p = StructureType :: eImageViewHandleInfoNVX ;
      return;
    }
    if( "eImageViewHandleInfoNVX" == j.get< std::string >() ) {
      p = StructureType :: eImageViewHandleInfoNVX ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX" == j.get< std::string >() ) {
      p = StructureType :: eImageViewHandleInfoNVX ;
      return;
    }
    if( "ImageViewAddressPropertiesNVX" == j.get< std::string >() ) {
      p = StructureType :: eImageViewAddressPropertiesNVX ;
      return;
    }
    if( "eImageViewAddressPropertiesNVX" == j.get< std::string >() ) {
      p = StructureType :: eImageViewAddressPropertiesNVX ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX" == j.get< std::string >() ) {
      p = StructureType :: eImageViewAddressPropertiesNVX ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeH264CapabilitiesEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264CapabilitiesEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeH264CapabilitiesEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264CapabilitiesEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264CapabilitiesEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeH264SessionCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264SessionCreateInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeH264SessionCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264SessionCreateInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264SessionCreateInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeH264SessionParametersAddInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264SessionParametersAddInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeH264SessionParametersAddInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264SessionParametersAddInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264SessionParametersAddInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeH264VclFrameInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264VclFrameInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeH264VclFrameInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264VclFrameInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264VclFrameInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeH264DpbSlotInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264DpbSlotInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeH264DpbSlotInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264DpbSlotInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264DpbSlotInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeH264NaluSliceEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264NaluSliceEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeH264NaluSliceEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264NaluSliceEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264NaluSliceEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeH264EmitPictureParametersEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264EmitPictureParametersEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeH264EmitPictureParametersEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264EmitPictureParametersEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264EmitPictureParametersEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeH264ProfileEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264ProfileEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeH264ProfileEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264ProfileEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeH264ProfileEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeH264CapabilitiesEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264CapabilitiesEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeH264CapabilitiesEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264CapabilitiesEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264CapabilitiesEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeH264SessionCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264SessionCreateInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeH264SessionCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264SessionCreateInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264SessionCreateInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeH264PictureInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264PictureInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeH264PictureInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264PictureInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264PictureInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeH264MvcEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264MvcEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeH264MvcEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264MvcEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_MVC_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264MvcEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeH264ProfileEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264ProfileEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeH264ProfileEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264ProfileEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264ProfileEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeH264SessionParametersAddInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264SessionParametersAddInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeH264SessionParametersAddInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264SessionParametersAddInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264SessionParametersAddInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeH264DpbSlotInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264DpbSlotInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeH264DpbSlotInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264DpbSlotInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH264DpbSlotInfoEXT ;
      return;
    }
#endif
    if( "TextureLodGatherFormatPropertiesAMD" == j.get< std::string >() ) {
      p = StructureType :: eTextureLodGatherFormatPropertiesAMD ;
      return;
    }
    if( "eTextureLodGatherFormatPropertiesAMD" == j.get< std::string >() ) {
      p = StructureType :: eTextureLodGatherFormatPropertiesAMD ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD" == j.get< std::string >() ) {
      p = StructureType :: eTextureLodGatherFormatPropertiesAMD ;
      return;
    }
#if defined(VK_USE_PLATFORM_GGP)
    if( "StreamDescriptorSurfaceCreateInfoGGP" == j.get< std::string >() ) {
      p = StructureType :: eStreamDescriptorSurfaceCreateInfoGGP ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_GGP)
    if( "eStreamDescriptorSurfaceCreateInfoGGP" == j.get< std::string >() ) {
      p = StructureType :: eStreamDescriptorSurfaceCreateInfoGGP ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_GGP)
    if( "VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP" == j.get< std::string >() ) {
      p = StructureType :: eStreamDescriptorSurfaceCreateInfoGGP ;
      return;
    }
#endif
    if( "PhysicalDeviceCornerSampledImageFeaturesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCornerSampledImageFeaturesNV ;
      return;
    }
    if( "ePhysicalDeviceCornerSampledImageFeaturesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCornerSampledImageFeaturesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCornerSampledImageFeaturesNV ;
      return;
    }
    if( "ExternalMemoryImageCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryImageCreateInfoNV ;
      return;
    }
    if( "eExternalMemoryImageCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryImageCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryImageCreateInfoNV ;
      return;
    }
    if( "ExportMemoryAllocateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryAllocateInfoNV ;
      return;
    }
    if( "eExportMemoryAllocateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryAllocateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryAllocateInfoNV ;
      return;
    }
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "ImportMemoryWin32HandleInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryWin32HandleInfoNV ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eImportMemoryWin32HandleInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryWin32HandleInfoNV ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryWin32HandleInfoNV ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "ExportMemoryWin32HandleInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryWin32HandleInfoNV ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eExportMemoryWin32HandleInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryWin32HandleInfoNV ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryWin32HandleInfoNV ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "Win32KeyedMutexAcquireReleaseInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eWin32KeyedMutexAcquireReleaseInfoNV ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eWin32KeyedMutexAcquireReleaseInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eWin32KeyedMutexAcquireReleaseInfoNV ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eWin32KeyedMutexAcquireReleaseInfoNV ;
      return;
    }
#endif
    if( "ValidationFlagsEXT" == j.get< std::string >() ) {
      p = StructureType :: eValidationFlagsEXT ;
      return;
    }
    if( "eValidationFlagsEXT" == j.get< std::string >() ) {
      p = StructureType :: eValidationFlagsEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT" == j.get< std::string >() ) {
      p = StructureType :: eValidationFlagsEXT ;
      return;
    }
#if defined(VK_USE_PLATFORM_VI_NN)
    if( "ViSurfaceCreateInfoNN" == j.get< std::string >() ) {
      p = StructureType :: eViSurfaceCreateInfoNN ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_VI_NN)
    if( "eViSurfaceCreateInfoNN" == j.get< std::string >() ) {
      p = StructureType :: eViSurfaceCreateInfoNN ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_VI_NN)
    if( "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN" == j.get< std::string >() ) {
      p = StructureType :: eViSurfaceCreateInfoNN ;
      return;
    }
#endif
    if( "ImageViewAstcDecodeModeEXT" == j.get< std::string >() ) {
      p = StructureType :: eImageViewAstcDecodeModeEXT ;
      return;
    }
    if( "eImageViewAstcDecodeModeEXT" == j.get< std::string >() ) {
      p = StructureType :: eImageViewAstcDecodeModeEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT" == j.get< std::string >() ) {
      p = StructureType :: eImageViewAstcDecodeModeEXT ;
      return;
    }
    if( "PhysicalDeviceAstcDecodeFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceAstcDecodeFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceAstcDecodeFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceAstcDecodeFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceAstcDecodeFeaturesEXT ;
      return;
    }
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "ImportMemoryWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eImportMemoryWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "ExportMemoryWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eExportMemoryWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "MemoryWin32HandlePropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryWin32HandlePropertiesKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eMemoryWin32HandlePropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryWin32HandlePropertiesKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryWin32HandlePropertiesKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "MemoryGetWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryGetWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eMemoryGetWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryGetWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryGetWin32HandleInfoKHR ;
      return;
    }
#endif
    if( "ImportMemoryFdInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryFdInfoKHR ;
      return;
    }
    if( "eImportMemoryFdInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryFdInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryFdInfoKHR ;
      return;
    }
    if( "MemoryFdPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryFdPropertiesKHR ;
      return;
    }
    if( "eMemoryFdPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryFdPropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryFdPropertiesKHR ;
      return;
    }
    if( "MemoryGetFdInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryGetFdInfoKHR ;
      return;
    }
    if( "eMemoryGetFdInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryGetFdInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryGetFdInfoKHR ;
      return;
    }
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "Win32KeyedMutexAcquireReleaseInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eWin32KeyedMutexAcquireReleaseInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eWin32KeyedMutexAcquireReleaseInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eWin32KeyedMutexAcquireReleaseInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eWin32KeyedMutexAcquireReleaseInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "ImportSemaphoreWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImportSemaphoreWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eImportSemaphoreWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImportSemaphoreWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImportSemaphoreWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "ExportSemaphoreWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExportSemaphoreWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eExportSemaphoreWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExportSemaphoreWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eExportSemaphoreWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "D3D12FenceSubmitInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eD3D12FenceSubmitInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eD3D12FenceSubmitInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eD3D12FenceSubmitInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eD3D12FenceSubmitInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "SemaphoreGetWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreGetWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eSemaphoreGetWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreGetWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreGetWin32HandleInfoKHR ;
      return;
    }
#endif
    if( "ImportSemaphoreFdInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImportSemaphoreFdInfoKHR ;
      return;
    }
    if( "eImportSemaphoreFdInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImportSemaphoreFdInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImportSemaphoreFdInfoKHR ;
      return;
    }
    if( "SemaphoreGetFdInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreGetFdInfoKHR ;
      return;
    }
    if( "eSemaphoreGetFdInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreGetFdInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreGetFdInfoKHR ;
      return;
    }
    if( "PhysicalDevicePushDescriptorPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePushDescriptorPropertiesKHR ;
      return;
    }
    if( "ePhysicalDevicePushDescriptorPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePushDescriptorPropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePushDescriptorPropertiesKHR ;
      return;
    }
    if( "ConditionalRenderingBeginInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eConditionalRenderingBeginInfoEXT ;
      return;
    }
    if( "eConditionalRenderingBeginInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eConditionalRenderingBeginInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eConditionalRenderingBeginInfoEXT ;
      return;
    }
    if( "PresentRegionsKHR" == j.get< std::string >() ) {
      p = StructureType :: ePresentRegionsKHR ;
      return;
    }
    if( "ePresentRegionsKHR" == j.get< std::string >() ) {
      p = StructureType :: ePresentRegionsKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePresentRegionsKHR ;
      return;
    }
    if( "PipelineViewportWScalingStateCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineViewportWScalingStateCreateInfoNV ;
      return;
    }
    if( "ePipelineViewportWScalingStateCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineViewportWScalingStateCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineViewportWScalingStateCreateInfoNV ;
      return;
    }
    if( "SurfaceCapabilities2EXT" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceCapabilities2EXT ;
      return;
    }
    if( "eSurfaceCapabilities2EXT" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceCapabilities2EXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceCapabilities2EXT ;
      return;
    }
    if( "DisplayPowerInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPowerInfoEXT ;
      return;
    }
    if( "eDisplayPowerInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPowerInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPowerInfoEXT ;
      return;
    }
    if( "DeviceEventInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDeviceEventInfoEXT ;
      return;
    }
    if( "eDeviceEventInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDeviceEventInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDeviceEventInfoEXT ;
      return;
    }
    if( "DisplayEventInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDisplayEventInfoEXT ;
      return;
    }
    if( "eDisplayEventInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDisplayEventInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDisplayEventInfoEXT ;
      return;
    }
    if( "SwapchainCounterCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eSwapchainCounterCreateInfoEXT ;
      return;
    }
    if( "eSwapchainCounterCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eSwapchainCounterCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eSwapchainCounterCreateInfoEXT ;
      return;
    }
    if( "PresentTimesInfoGOOGLE" == j.get< std::string >() ) {
      p = StructureType :: ePresentTimesInfoGOOGLE ;
      return;
    }
    if( "ePresentTimesInfoGOOGLE" == j.get< std::string >() ) {
      p = StructureType :: ePresentTimesInfoGOOGLE ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE" == j.get< std::string >() ) {
      p = StructureType :: ePresentTimesInfoGOOGLE ;
      return;
    }
    if( "PipelineViewportSwizzleStateCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineViewportSwizzleStateCreateInfoNV ;
      return;
    }
    if( "ePipelineViewportSwizzleStateCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineViewportSwizzleStateCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineViewportSwizzleStateCreateInfoNV ;
      return;
    }
    if( "PhysicalDeviceDiscardRectanglePropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDiscardRectanglePropertiesEXT ;
      return;
    }
    if( "ePhysicalDeviceDiscardRectanglePropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDiscardRectanglePropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDiscardRectanglePropertiesEXT ;
      return;
    }
    if( "PipelineDiscardRectangleStateCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineDiscardRectangleStateCreateInfoEXT ;
      return;
    }
    if( "ePipelineDiscardRectangleStateCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineDiscardRectangleStateCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineDiscardRectangleStateCreateInfoEXT ;
      return;
    }
    if( "PhysicalDeviceDepthClipEnableFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDepthClipEnableFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceDepthClipEnableFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDepthClipEnableFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDepthClipEnableFeaturesEXT ;
      return;
    }
    if( "HdrMetadataEXT" == j.get< std::string >() ) {
      p = StructureType :: eHdrMetadataEXT ;
      return;
    }
    if( "eHdrMetadataEXT" == j.get< std::string >() ) {
      p = StructureType :: eHdrMetadataEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_HDR_METADATA_EXT" == j.get< std::string >() ) {
      p = StructureType :: eHdrMetadataEXT ;
      return;
    }
    if( "SharedPresentSurfaceCapabilitiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eSharedPresentSurfaceCapabilitiesKHR ;
      return;
    }
    if( "eSharedPresentSurfaceCapabilitiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eSharedPresentSurfaceCapabilitiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSharedPresentSurfaceCapabilitiesKHR ;
      return;
    }
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "ImportFenceWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImportFenceWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eImportFenceWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImportFenceWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImportFenceWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "ExportFenceWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExportFenceWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eExportFenceWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExportFenceWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eExportFenceWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "FenceGetWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eFenceGetWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eFenceGetWin32HandleInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eFenceGetWin32HandleInfoKHR ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eFenceGetWin32HandleInfoKHR ;
      return;
    }
#endif
    if( "ImportFenceFdInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImportFenceFdInfoKHR ;
      return;
    }
    if( "eImportFenceFdInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImportFenceFdInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImportFenceFdInfoKHR ;
      return;
    }
    if( "FenceGetFdInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eFenceGetFdInfoKHR ;
      return;
    }
    if( "eFenceGetFdInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eFenceGetFdInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eFenceGetFdInfoKHR ;
      return;
    }
    if( "PhysicalDevicePerformanceQueryFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePerformanceQueryFeaturesKHR ;
      return;
    }
    if( "ePhysicalDevicePerformanceQueryFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePerformanceQueryFeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePerformanceQueryFeaturesKHR ;
      return;
    }
    if( "PhysicalDevicePerformanceQueryPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePerformanceQueryPropertiesKHR ;
      return;
    }
    if( "ePhysicalDevicePerformanceQueryPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePerformanceQueryPropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePerformanceQueryPropertiesKHR ;
      return;
    }
    if( "QueryPoolPerformanceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eQueryPoolPerformanceCreateInfoKHR ;
      return;
    }
    if( "eQueryPoolPerformanceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eQueryPoolPerformanceCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eQueryPoolPerformanceCreateInfoKHR ;
      return;
    }
    if( "PerformanceQuerySubmitInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceQuerySubmitInfoKHR ;
      return;
    }
    if( "ePerformanceQuerySubmitInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceQuerySubmitInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceQuerySubmitInfoKHR ;
      return;
    }
    if( "AcquireProfilingLockInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAcquireProfilingLockInfoKHR ;
      return;
    }
    if( "eAcquireProfilingLockInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAcquireProfilingLockInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eAcquireProfilingLockInfoKHR ;
      return;
    }
    if( "PerformanceCounterKHR" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceCounterKHR ;
      return;
    }
    if( "ePerformanceCounterKHR" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceCounterKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceCounterKHR ;
      return;
    }
    if( "PerformanceCounterDescriptionKHR" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceCounterDescriptionKHR ;
      return;
    }
    if( "ePerformanceCounterDescriptionKHR" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceCounterDescriptionKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceCounterDescriptionKHR ;
      return;
    }
    if( "PhysicalDeviceSurfaceInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSurfaceInfo2KHR ;
      return;
    }
    if( "ePhysicalDeviceSurfaceInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSurfaceInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSurfaceInfo2KHR ;
      return;
    }
    if( "SurfaceCapabilities2KHR" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceCapabilities2KHR ;
      return;
    }
    if( "eSurfaceCapabilities2KHR" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceCapabilities2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceCapabilities2KHR ;
      return;
    }
    if( "SurfaceFormat2KHR" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceFormat2KHR ;
      return;
    }
    if( "eSurfaceFormat2KHR" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceFormat2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceFormat2KHR ;
      return;
    }
    if( "DisplayProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayProperties2KHR ;
      return;
    }
    if( "eDisplayProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayProperties2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayProperties2KHR ;
      return;
    }
    if( "DisplayPlaneProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPlaneProperties2KHR ;
      return;
    }
    if( "eDisplayPlaneProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPlaneProperties2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPlaneProperties2KHR ;
      return;
    }
    if( "DisplayModeProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayModeProperties2KHR ;
      return;
    }
    if( "eDisplayModeProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayModeProperties2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayModeProperties2KHR ;
      return;
    }
    if( "DisplayPlaneInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPlaneInfo2KHR ;
      return;
    }
    if( "eDisplayPlaneInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPlaneInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPlaneInfo2KHR ;
      return;
    }
    if( "DisplayPlaneCapabilities2KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPlaneCapabilities2KHR ;
      return;
    }
    if( "eDisplayPlaneCapabilities2KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPlaneCapabilities2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDisplayPlaneCapabilities2KHR ;
      return;
    }
#if defined(VK_USE_PLATFORM_IOS_MVK)
    if( "IosSurfaceCreateInfoMVK" == j.get< std::string >() ) {
      p = StructureType :: eIosSurfaceCreateInfoMVK ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_IOS_MVK)
    if( "eIosSurfaceCreateInfoMVK" == j.get< std::string >() ) {
      p = StructureType :: eIosSurfaceCreateInfoMVK ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_IOS_MVK)
    if( "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK" == j.get< std::string >() ) {
      p = StructureType :: eIosSurfaceCreateInfoMVK ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_MACOS_MVK)
    if( "MacosSurfaceCreateInfoMVK" == j.get< std::string >() ) {
      p = StructureType :: eMacosSurfaceCreateInfoMVK ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_MACOS_MVK)
    if( "eMacosSurfaceCreateInfoMVK" == j.get< std::string >() ) {
      p = StructureType :: eMacosSurfaceCreateInfoMVK ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_MACOS_MVK)
    if( "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK" == j.get< std::string >() ) {
      p = StructureType :: eMacosSurfaceCreateInfoMVK ;
      return;
    }
#endif
    if( "DebugUtilsObjectNameInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsObjectNameInfoEXT ;
      return;
    }
    if( "eDebugUtilsObjectNameInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsObjectNameInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsObjectNameInfoEXT ;
      return;
    }
    if( "DebugUtilsObjectTagInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsObjectTagInfoEXT ;
      return;
    }
    if( "eDebugUtilsObjectTagInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsObjectTagInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsObjectTagInfoEXT ;
      return;
    }
    if( "DebugUtilsLabelEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsLabelEXT ;
      return;
    }
    if( "eDebugUtilsLabelEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsLabelEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsLabelEXT ;
      return;
    }
    if( "DebugUtilsMessengerCallbackDataEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsMessengerCallbackDataEXT ;
      return;
    }
    if( "eDebugUtilsMessengerCallbackDataEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsMessengerCallbackDataEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsMessengerCallbackDataEXT ;
      return;
    }
    if( "DebugUtilsMessengerCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsMessengerCreateInfoEXT ;
      return;
    }
    if( "eDebugUtilsMessengerCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsMessengerCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugUtilsMessengerCreateInfoEXT ;
      return;
    }
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "AndroidHardwareBufferUsageANDROID" == j.get< std::string >() ) {
      p = StructureType :: eAndroidHardwareBufferUsageANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "eAndroidHardwareBufferUsageANDROID" == j.get< std::string >() ) {
      p = StructureType :: eAndroidHardwareBufferUsageANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID" == j.get< std::string >() ) {
      p = StructureType :: eAndroidHardwareBufferUsageANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "AndroidHardwareBufferPropertiesANDROID" == j.get< std::string >() ) {
      p = StructureType :: eAndroidHardwareBufferPropertiesANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "eAndroidHardwareBufferPropertiesANDROID" == j.get< std::string >() ) {
      p = StructureType :: eAndroidHardwareBufferPropertiesANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID" == j.get< std::string >() ) {
      p = StructureType :: eAndroidHardwareBufferPropertiesANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "AndroidHardwareBufferFormatPropertiesANDROID" == j.get< std::string >() ) {
      p = StructureType :: eAndroidHardwareBufferFormatPropertiesANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "eAndroidHardwareBufferFormatPropertiesANDROID" == j.get< std::string >() ) {
      p = StructureType :: eAndroidHardwareBufferFormatPropertiesANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID" == j.get< std::string >() ) {
      p = StructureType :: eAndroidHardwareBufferFormatPropertiesANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "ImportAndroidHardwareBufferInfoANDROID" == j.get< std::string >() ) {
      p = StructureType :: eImportAndroidHardwareBufferInfoANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "eImportAndroidHardwareBufferInfoANDROID" == j.get< std::string >() ) {
      p = StructureType :: eImportAndroidHardwareBufferInfoANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID" == j.get< std::string >() ) {
      p = StructureType :: eImportAndroidHardwareBufferInfoANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "MemoryGetAndroidHardwareBufferInfoANDROID" == j.get< std::string >() ) {
      p = StructureType :: eMemoryGetAndroidHardwareBufferInfoANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "eMemoryGetAndroidHardwareBufferInfoANDROID" == j.get< std::string >() ) {
      p = StructureType :: eMemoryGetAndroidHardwareBufferInfoANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID" == j.get< std::string >() ) {
      p = StructureType :: eMemoryGetAndroidHardwareBufferInfoANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "ExternalFormatANDROID" == j.get< std::string >() ) {
      p = StructureType :: eExternalFormatANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "eExternalFormatANDROID" == j.get< std::string >() ) {
      p = StructureType :: eExternalFormatANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID" == j.get< std::string >() ) {
      p = StructureType :: eExternalFormatANDROID ;
      return;
    }
#endif
    if( "PhysicalDeviceInlineUniformBlockFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceInlineUniformBlockFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceInlineUniformBlockFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceInlineUniformBlockFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceInlineUniformBlockFeaturesEXT ;
      return;
    }
    if( "WriteDescriptorSetInlineUniformBlockEXT" == j.get< std::string >() ) {
      p = StructureType :: eWriteDescriptorSetInlineUniformBlockEXT ;
      return;
    }
    if( "eWriteDescriptorSetInlineUniformBlockEXT" == j.get< std::string >() ) {
      p = StructureType :: eWriteDescriptorSetInlineUniformBlockEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT" == j.get< std::string >() ) {
      p = StructureType :: eWriteDescriptorSetInlineUniformBlockEXT ;
      return;
    }
    if( "SampleLocationsInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eSampleLocationsInfoEXT ;
      return;
    }
    if( "eSampleLocationsInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eSampleLocationsInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eSampleLocationsInfoEXT ;
      return;
    }
    if( "RenderPassSampleLocationsBeginInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassSampleLocationsBeginInfoEXT ;
      return;
    }
    if( "eRenderPassSampleLocationsBeginInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassSampleLocationsBeginInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassSampleLocationsBeginInfoEXT ;
      return;
    }
    if( "PipelineSampleLocationsStateCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineSampleLocationsStateCreateInfoEXT ;
      return;
    }
    if( "ePipelineSampleLocationsStateCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineSampleLocationsStateCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineSampleLocationsStateCreateInfoEXT ;
      return;
    }
    if( "PhysicalDeviceSampleLocationsPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSampleLocationsPropertiesEXT ;
      return;
    }
    if( "ePhysicalDeviceSampleLocationsPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSampleLocationsPropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSampleLocationsPropertiesEXT ;
      return;
    }
    if( "MultisamplePropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: eMultisamplePropertiesEXT ;
      return;
    }
    if( "eMultisamplePropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: eMultisamplePropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: eMultisamplePropertiesEXT ;
      return;
    }
    if( "PipelineCoverageToColorStateCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCoverageToColorStateCreateInfoNV ;
      return;
    }
    if( "ePipelineCoverageToColorStateCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCoverageToColorStateCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCoverageToColorStateCreateInfoNV ;
      return;
    }
    if( "WriteDescriptorSetAccelerationStructureKHR" == j.get< std::string >() ) {
      p = StructureType :: eWriteDescriptorSetAccelerationStructureKHR ;
      return;
    }
    if( "eWriteDescriptorSetAccelerationStructureKHR" == j.get< std::string >() ) {
      p = StructureType :: eWriteDescriptorSetAccelerationStructureKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR" == j.get< std::string >() ) {
      p = StructureType :: eWriteDescriptorSetAccelerationStructureKHR ;
      return;
    }
    if( "AccelerationStructureBuildGeometryInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureBuildGeometryInfoKHR ;
      return;
    }
    if( "eAccelerationStructureBuildGeometryInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureBuildGeometryInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureBuildGeometryInfoKHR ;
      return;
    }
    if( "AccelerationStructureDeviceAddressInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureDeviceAddressInfoKHR ;
      return;
    }
    if( "eAccelerationStructureDeviceAddressInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureDeviceAddressInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureDeviceAddressInfoKHR ;
      return;
    }
    if( "AccelerationStructureGeometryAabbsDataKHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureGeometryAabbsDataKHR ;
      return;
    }
    if( "eAccelerationStructureGeometryAabbsDataKHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureGeometryAabbsDataKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureGeometryAabbsDataKHR ;
      return;
    }
    if( "AccelerationStructureGeometryKHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureGeometryKHR ;
      return;
    }
    if( "eAccelerationStructureGeometryKHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureGeometryKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureGeometryKHR ;
      return;
    }
    if( "AccelerationStructureVersionInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureVersionInfoKHR ;
      return;
    }
    if( "eAccelerationStructureVersionInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureVersionInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureVersionInfoKHR ;
      return;
    }
    if( "CopyAccelerationStructureInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyAccelerationStructureInfoKHR ;
      return;
    }
    if( "eCopyAccelerationStructureInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyAccelerationStructureInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyAccelerationStructureInfoKHR ;
      return;
    }
    if( "CopyAccelerationStructureToMemoryInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyAccelerationStructureToMemoryInfoKHR ;
      return;
    }
    if( "eCopyAccelerationStructureToMemoryInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyAccelerationStructureToMemoryInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyAccelerationStructureToMemoryInfoKHR ;
      return;
    }
    if( "CopyMemoryToAccelerationStructureInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyMemoryToAccelerationStructureInfoKHR ;
      return;
    }
    if( "eCopyMemoryToAccelerationStructureInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyMemoryToAccelerationStructureInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyMemoryToAccelerationStructureInfoKHR ;
      return;
    }
    if( "AccelerationStructureCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureCreateInfoKHR ;
      return;
    }
    if( "eAccelerationStructureCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureCreateInfoKHR ;
      return;
    }
    if( "AccelerationStructureBuildSizesInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureBuildSizesInfoKHR ;
      return;
    }
    if( "eAccelerationStructureBuildSizesInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureBuildSizesInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureBuildSizesInfoKHR ;
      return;
    }
    if( "PhysicalDeviceRayTracingPipelineFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRayTracingPipelineFeaturesKHR ;
      return;
    }
    if( "ePhysicalDeviceRayTracingPipelineFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRayTracingPipelineFeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRayTracingPipelineFeaturesKHR ;
      return;
    }
    if( "RayTracingPipelineCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingPipelineCreateInfoKHR ;
      return;
    }
    if( "eRayTracingPipelineCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingPipelineCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingPipelineCreateInfoKHR ;
      return;
    }
    if( "RayTracingShaderGroupCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingShaderGroupCreateInfoKHR ;
      return;
    }
    if( "eRayTracingShaderGroupCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingShaderGroupCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingShaderGroupCreateInfoKHR ;
      return;
    }
    if( "RayTracingPipelineInterfaceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingPipelineInterfaceCreateInfoKHR ;
      return;
    }
    if( "eRayTracingPipelineInterfaceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingPipelineInterfaceCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingPipelineInterfaceCreateInfoKHR ;
      return;
    }
    if( "PhysicalDeviceRayQueryFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRayQueryFeaturesKHR ;
      return;
    }
    if( "ePhysicalDeviceRayQueryFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRayQueryFeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRayQueryFeaturesKHR ;
      return;
    }
    if( "PipelineCoverageModulationStateCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCoverageModulationStateCreateInfoNV ;
      return;
    }
    if( "ePipelineCoverageModulationStateCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCoverageModulationStateCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCoverageModulationStateCreateInfoNV ;
      return;
    }
    if( "PhysicalDeviceShaderSmBuiltinsFeaturesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderSmBuiltinsFeaturesNV ;
      return;
    }
    if( "ePhysicalDeviceShaderSmBuiltinsFeaturesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderSmBuiltinsFeaturesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderSmBuiltinsFeaturesNV ;
      return;
    }
    if( "PhysicalDeviceShaderSmBuiltinsPropertiesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderSmBuiltinsPropertiesNV ;
      return;
    }
    if( "ePhysicalDeviceShaderSmBuiltinsPropertiesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderSmBuiltinsPropertiesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderSmBuiltinsPropertiesNV ;
      return;
    }
    if( "DrmFormatModifierPropertiesListEXT" == j.get< std::string >() ) {
      p = StructureType :: eDrmFormatModifierPropertiesListEXT ;
      return;
    }
    if( "eDrmFormatModifierPropertiesListEXT" == j.get< std::string >() ) {
      p = StructureType :: eDrmFormatModifierPropertiesListEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDrmFormatModifierPropertiesListEXT ;
      return;
    }
    if( "PhysicalDeviceImageDrmFormatModifierInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageDrmFormatModifierInfoEXT ;
      return;
    }
    if( "ePhysicalDeviceImageDrmFormatModifierInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageDrmFormatModifierInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageDrmFormatModifierInfoEXT ;
      return;
    }
    if( "ImageDrmFormatModifierListCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eImageDrmFormatModifierListCreateInfoEXT ;
      return;
    }
    if( "eImageDrmFormatModifierListCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eImageDrmFormatModifierListCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eImageDrmFormatModifierListCreateInfoEXT ;
      return;
    }
    if( "ImageDrmFormatModifierExplicitCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eImageDrmFormatModifierExplicitCreateInfoEXT ;
      return;
    }
    if( "eImageDrmFormatModifierExplicitCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eImageDrmFormatModifierExplicitCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eImageDrmFormatModifierExplicitCreateInfoEXT ;
      return;
    }
    if( "ImageDrmFormatModifierPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: eImageDrmFormatModifierPropertiesEXT ;
      return;
    }
    if( "eImageDrmFormatModifierPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: eImageDrmFormatModifierPropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: eImageDrmFormatModifierPropertiesEXT ;
      return;
    }
    if( "ValidationCacheCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eValidationCacheCreateInfoEXT ;
      return;
    }
    if( "eValidationCacheCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eValidationCacheCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eValidationCacheCreateInfoEXT ;
      return;
    }
    if( "ShaderModuleValidationCacheCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eShaderModuleValidationCacheCreateInfoEXT ;
      return;
    }
    if( "eShaderModuleValidationCacheCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eShaderModuleValidationCacheCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eShaderModuleValidationCacheCreateInfoEXT ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "PhysicalDevicePortabilitySubsetFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePortabilitySubsetFeaturesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "ePhysicalDevicePortabilitySubsetFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePortabilitySubsetFeaturesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePortabilitySubsetFeaturesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "PhysicalDevicePortabilitySubsetPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePortabilitySubsetPropertiesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "ePhysicalDevicePortabilitySubsetPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePortabilitySubsetPropertiesKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePortabilitySubsetPropertiesKHR ;
      return;
    }
#endif
    if( "PhysicalDeviceShadingRateImageFeaturesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShadingRateImageFeaturesNV ;
      return;
    }
    if( "ePhysicalDeviceShadingRateImageFeaturesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShadingRateImageFeaturesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShadingRateImageFeaturesNV ;
      return;
    }
    if( "PhysicalDeviceShadingRateImagePropertiesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShadingRateImagePropertiesNV ;
      return;
    }
    if( "ePhysicalDeviceShadingRateImagePropertiesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShadingRateImagePropertiesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShadingRateImagePropertiesNV ;
      return;
    }
    if( "RayTracingPipelineCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingPipelineCreateInfoNV ;
      return;
    }
    if( "eRayTracingPipelineCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingPipelineCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingPipelineCreateInfoNV ;
      return;
    }
    if( "AccelerationStructureCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureCreateInfoNV ;
      return;
    }
    if( "eAccelerationStructureCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureCreateInfoNV ;
      return;
    }
    if( "GeometryNV" == j.get< std::string >() ) {
      p = StructureType :: eGeometryNV ;
      return;
    }
    if( "eGeometryNV" == j.get< std::string >() ) {
      p = StructureType :: eGeometryNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_GEOMETRY_NV" == j.get< std::string >() ) {
      p = StructureType :: eGeometryNV ;
      return;
    }
    if( "GeometryTrianglesNV" == j.get< std::string >() ) {
      p = StructureType :: eGeometryTrianglesNV ;
      return;
    }
    if( "eGeometryTrianglesNV" == j.get< std::string >() ) {
      p = StructureType :: eGeometryTrianglesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV" == j.get< std::string >() ) {
      p = StructureType :: eGeometryTrianglesNV ;
      return;
    }
    if( "GeometryAabbNV" == j.get< std::string >() ) {
      p = StructureType :: eGeometryAabbNV ;
      return;
    }
    if( "eGeometryAabbNV" == j.get< std::string >() ) {
      p = StructureType :: eGeometryAabbNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV" == j.get< std::string >() ) {
      p = StructureType :: eGeometryAabbNV ;
      return;
    }
    if( "BindAccelerationStructureMemoryInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eBindAccelerationStructureMemoryInfoNV ;
      return;
    }
    if( "eBindAccelerationStructureMemoryInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eBindAccelerationStructureMemoryInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eBindAccelerationStructureMemoryInfoNV ;
      return;
    }
    if( "WriteDescriptorSetAccelerationStructureNV" == j.get< std::string >() ) {
      p = StructureType :: eWriteDescriptorSetAccelerationStructureNV ;
      return;
    }
    if( "eWriteDescriptorSetAccelerationStructureNV" == j.get< std::string >() ) {
      p = StructureType :: eWriteDescriptorSetAccelerationStructureNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV" == j.get< std::string >() ) {
      p = StructureType :: eWriteDescriptorSetAccelerationStructureNV ;
      return;
    }
    if( "PhysicalDeviceRayTracingPropertiesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRayTracingPropertiesNV ;
      return;
    }
    if( "ePhysicalDeviceRayTracingPropertiesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRayTracingPropertiesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRayTracingPropertiesNV ;
      return;
    }
    if( "RayTracingShaderGroupCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingShaderGroupCreateInfoNV ;
      return;
    }
    if( "eRayTracingShaderGroupCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingShaderGroupCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eRayTracingShaderGroupCreateInfoNV ;
      return;
    }
    if( "AccelerationStructureInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureInfoNV ;
      return;
    }
    if( "eAccelerationStructureInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureInfoNV ;
      return;
    }
    if( "PhysicalDeviceImageViewImageFormatInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageViewImageFormatInfoEXT ;
      return;
    }
    if( "ePhysicalDeviceImageViewImageFormatInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageViewImageFormatInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageViewImageFormatInfoEXT ;
      return;
    }
    if( "DeviceQueueGlobalPriorityCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDeviceQueueGlobalPriorityCreateInfoEXT ;
      return;
    }
    if( "eDeviceQueueGlobalPriorityCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDeviceQueueGlobalPriorityCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDeviceQueueGlobalPriorityCreateInfoEXT ;
      return;
    }
    if( "ImportMemoryHostPointerInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryHostPointerInfoEXT ;
      return;
    }
    if( "eImportMemoryHostPointerInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryHostPointerInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryHostPointerInfoEXT ;
      return;
    }
    if( "MemoryHostPointerPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: eMemoryHostPointerPropertiesEXT ;
      return;
    }
    if( "eMemoryHostPointerPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: eMemoryHostPointerPropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: eMemoryHostPointerPropertiesEXT ;
      return;
    }
    if( "PhysicalDeviceShaderClockFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderClockFeaturesKHR ;
      return;
    }
    if( "ePhysicalDeviceShaderClockFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderClockFeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderClockFeaturesKHR ;
      return;
    }
    if( "PipelineCompilerControlCreateInfoAMD" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCompilerControlCreateInfoAMD ;
      return;
    }
    if( "ePipelineCompilerControlCreateInfoAMD" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCompilerControlCreateInfoAMD ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCompilerControlCreateInfoAMD ;
      return;
    }
    if( "CalibratedTimestampInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eCalibratedTimestampInfoEXT ;
      return;
    }
    if( "eCalibratedTimestampInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eCalibratedTimestampInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eCalibratedTimestampInfoEXT ;
      return;
    }
    if( "PhysicalDeviceShaderCorePropertiesAMD" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderCorePropertiesAMD ;
      return;
    }
    if( "ePhysicalDeviceShaderCorePropertiesAMD" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderCorePropertiesAMD ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderCorePropertiesAMD ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeH265CapabilitiesEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265CapabilitiesEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeH265CapabilitiesEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265CapabilitiesEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265CapabilitiesEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeH265SessionCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265SessionCreateInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeH265SessionCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265SessionCreateInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265SessionCreateInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeH265SessionParametersAddInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265SessionParametersAddInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeH265SessionParametersAddInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265SessionParametersAddInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265SessionParametersAddInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeH265ProfileEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265ProfileEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeH265ProfileEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265ProfileEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265ProfileEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeH265PictureInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265PictureInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeH265PictureInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265PictureInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265PictureInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeH265DpbSlotInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265DpbSlotInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeH265DpbSlotInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265DpbSlotInfoEXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVideoDecodeH265DpbSlotInfoEXT ;
      return;
    }
#endif
    if( "DeviceMemoryOverallocationCreateInfoAMD" == j.get< std::string >() ) {
      p = StructureType :: eDeviceMemoryOverallocationCreateInfoAMD ;
      return;
    }
    if( "eDeviceMemoryOverallocationCreateInfoAMD" == j.get< std::string >() ) {
      p = StructureType :: eDeviceMemoryOverallocationCreateInfoAMD ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD" == j.get< std::string >() ) {
      p = StructureType :: eDeviceMemoryOverallocationCreateInfoAMD ;
      return;
    }
#if defined(VK_USE_PLATFORM_GGP)
    if( "PresentFrameTokenGGP" == j.get< std::string >() ) {
      p = StructureType :: ePresentFrameTokenGGP ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_GGP)
    if( "ePresentFrameTokenGGP" == j.get< std::string >() ) {
      p = StructureType :: ePresentFrameTokenGGP ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_GGP)
    if( "VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP" == j.get< std::string >() ) {
      p = StructureType :: ePresentFrameTokenGGP ;
      return;
    }
#endif
    if( "PipelineCreationFeedbackCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCreationFeedbackCreateInfoEXT ;
      return;
    }
    if( "ePipelineCreationFeedbackCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCreationFeedbackCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCreationFeedbackCreateInfoEXT ;
      return;
    }
    if( "PhysicalDeviceMeshShaderFeaturesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMeshShaderFeaturesNV ;
      return;
    }
    if( "ePhysicalDeviceMeshShaderFeaturesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMeshShaderFeaturesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMeshShaderFeaturesNV ;
      return;
    }
    if( "PhysicalDeviceMeshShaderPropertiesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMeshShaderPropertiesNV ;
      return;
    }
    if( "ePhysicalDeviceMeshShaderPropertiesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMeshShaderPropertiesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMeshShaderPropertiesNV ;
      return;
    }
    if( "PhysicalDeviceExclusiveScissorFeaturesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExclusiveScissorFeaturesNV ;
      return;
    }
    if( "ePhysicalDeviceExclusiveScissorFeaturesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExclusiveScissorFeaturesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExclusiveScissorFeaturesNV ;
      return;
    }
    if( "CheckpointDataNV" == j.get< std::string >() ) {
      p = StructureType :: eCheckpointDataNV ;
      return;
    }
    if( "eCheckpointDataNV" == j.get< std::string >() ) {
      p = StructureType :: eCheckpointDataNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV" == j.get< std::string >() ) {
      p = StructureType :: eCheckpointDataNV ;
      return;
    }
    if( "QueueFamilyCheckpointPropertiesNV" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyCheckpointPropertiesNV ;
      return;
    }
    if( "eQueueFamilyCheckpointPropertiesNV" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyCheckpointPropertiesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyCheckpointPropertiesNV ;
      return;
    }
    if( "QueryPoolPerformanceQueryCreateInfoINTEL" == j.get< std::string >() ) {
      p = StructureType :: eQueryPoolPerformanceQueryCreateInfoINTEL ;
      return;
    }
    if( "eQueryPoolPerformanceQueryCreateInfoINTEL" == j.get< std::string >() ) {
      p = StructureType :: eQueryPoolPerformanceQueryCreateInfoINTEL ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL" == j.get< std::string >() ) {
      p = StructureType :: eQueryPoolPerformanceQueryCreateInfoINTEL ;
      return;
    }
    if( "InitializePerformanceApiInfoINTEL" == j.get< std::string >() ) {
      p = StructureType :: eInitializePerformanceApiInfoINTEL ;
      return;
    }
    if( "eInitializePerformanceApiInfoINTEL" == j.get< std::string >() ) {
      p = StructureType :: eInitializePerformanceApiInfoINTEL ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL" == j.get< std::string >() ) {
      p = StructureType :: eInitializePerformanceApiInfoINTEL ;
      return;
    }
    if( "PerformanceMarkerInfoINTEL" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceMarkerInfoINTEL ;
      return;
    }
    if( "ePerformanceMarkerInfoINTEL" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceMarkerInfoINTEL ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceMarkerInfoINTEL ;
      return;
    }
    if( "PerformanceStreamMarkerInfoINTEL" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceStreamMarkerInfoINTEL ;
      return;
    }
    if( "ePerformanceStreamMarkerInfoINTEL" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceStreamMarkerInfoINTEL ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceStreamMarkerInfoINTEL ;
      return;
    }
    if( "PerformanceOverrideInfoINTEL" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceOverrideInfoINTEL ;
      return;
    }
    if( "ePerformanceOverrideInfoINTEL" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceOverrideInfoINTEL ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceOverrideInfoINTEL ;
      return;
    }
    if( "PerformanceConfigurationAcquireInfoINTEL" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceConfigurationAcquireInfoINTEL ;
      return;
    }
    if( "ePerformanceConfigurationAcquireInfoINTEL" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceConfigurationAcquireInfoINTEL ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL" == j.get< std::string >() ) {
      p = StructureType :: ePerformanceConfigurationAcquireInfoINTEL ;
      return;
    }
    if( "PhysicalDevicePciBusInfoPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePciBusInfoPropertiesEXT ;
      return;
    }
    if( "ePhysicalDevicePciBusInfoPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePciBusInfoPropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePciBusInfoPropertiesEXT ;
      return;
    }
    if( "DisplayNativeHdrSurfaceCapabilitiesAMD" == j.get< std::string >() ) {
      p = StructureType :: eDisplayNativeHdrSurfaceCapabilitiesAMD ;
      return;
    }
    if( "eDisplayNativeHdrSurfaceCapabilitiesAMD" == j.get< std::string >() ) {
      p = StructureType :: eDisplayNativeHdrSurfaceCapabilitiesAMD ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD" == j.get< std::string >() ) {
      p = StructureType :: eDisplayNativeHdrSurfaceCapabilitiesAMD ;
      return;
    }
    if( "SwapchainDisplayNativeHdrCreateInfoAMD" == j.get< std::string >() ) {
      p = StructureType :: eSwapchainDisplayNativeHdrCreateInfoAMD ;
      return;
    }
    if( "eSwapchainDisplayNativeHdrCreateInfoAMD" == j.get< std::string >() ) {
      p = StructureType :: eSwapchainDisplayNativeHdrCreateInfoAMD ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD" == j.get< std::string >() ) {
      p = StructureType :: eSwapchainDisplayNativeHdrCreateInfoAMD ;
      return;
    }
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "ImagepipeSurfaceCreateInfoFUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eImagepipeSurfaceCreateInfoFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "eImagepipeSurfaceCreateInfoFUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eImagepipeSurfaceCreateInfoFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eImagepipeSurfaceCreateInfoFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_METAL_EXT)
    if( "MetalSurfaceCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eMetalSurfaceCreateInfoEXT ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_METAL_EXT)
    if( "eMetalSurfaceCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eMetalSurfaceCreateInfoEXT ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_METAL_EXT)
    if( "VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eMetalSurfaceCreateInfoEXT ;
      return;
    }
#endif
    if( "PhysicalDeviceFragmentDensityMapFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFragmentDensityMapFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceFragmentDensityMapFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFragmentDensityMapFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFragmentDensityMapFeaturesEXT ;
      return;
    }
    if( "RenderPassFragmentDensityMapCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassFragmentDensityMapCreateInfoEXT ;
      return;
    }
    if( "eRenderPassFragmentDensityMapCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassFragmentDensityMapCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassFragmentDensityMapCreateInfoEXT ;
      return;
    }
    if( "FragmentShadingRateAttachmentInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eFragmentShadingRateAttachmentInfoKHR ;
      return;
    }
    if( "eFragmentShadingRateAttachmentInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eFragmentShadingRateAttachmentInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eFragmentShadingRateAttachmentInfoKHR ;
      return;
    }
    if( "PhysicalDeviceFragmentShadingRateKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFragmentShadingRateKHR ;
      return;
    }
    if( "ePhysicalDeviceFragmentShadingRateKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFragmentShadingRateKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFragmentShadingRateKHR ;
      return;
    }
    if( "PhysicalDeviceShaderCoreProperties2AMD" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderCoreProperties2AMD ;
      return;
    }
    if( "ePhysicalDeviceShaderCoreProperties2AMD" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderCoreProperties2AMD ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderCoreProperties2AMD ;
      return;
    }
    if( "PhysicalDeviceCoherentMemoryFeaturesAMD" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCoherentMemoryFeaturesAMD ;
      return;
    }
    if( "ePhysicalDeviceCoherentMemoryFeaturesAMD" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCoherentMemoryFeaturesAMD ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCoherentMemoryFeaturesAMD ;
      return;
    }
    if( "PhysicalDeviceMemoryBudgetPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMemoryBudgetPropertiesEXT ;
      return;
    }
    if( "ePhysicalDeviceMemoryBudgetPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMemoryBudgetPropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMemoryBudgetPropertiesEXT ;
      return;
    }
    if( "PhysicalDeviceMemoryPriorityFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMemoryPriorityFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceMemoryPriorityFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMemoryPriorityFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMemoryPriorityFeaturesEXT ;
      return;
    }
    if( "MemoryPriorityAllocateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eMemoryPriorityAllocateInfoEXT ;
      return;
    }
    if( "eMemoryPriorityAllocateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eMemoryPriorityAllocateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eMemoryPriorityAllocateInfoEXT ;
      return;
    }
    if( "SurfaceProtectedCapabilitiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceProtectedCapabilitiesKHR ;
      return;
    }
    if( "eSurfaceProtectedCapabilitiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceProtectedCapabilitiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceProtectedCapabilitiesKHR ;
      return;
    }
    if( "BufferDeviceAddressCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eBufferDeviceAddressCreateInfoEXT ;
      return;
    }
    if( "eBufferDeviceAddressCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eBufferDeviceAddressCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eBufferDeviceAddressCreateInfoEXT ;
      return;
    }
    if( "PhysicalDeviceToolPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceToolPropertiesEXT ;
      return;
    }
    if( "ePhysicalDeviceToolPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceToolPropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceToolPropertiesEXT ;
      return;
    }
    if( "ValidationFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: eValidationFeaturesEXT ;
      return;
    }
    if( "eValidationFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: eValidationFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: eValidationFeaturesEXT ;
      return;
    }
    if( "PhysicalDeviceCooperativeMatrixFeaturesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCooperativeMatrixFeaturesNV ;
      return;
    }
    if( "ePhysicalDeviceCooperativeMatrixFeaturesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCooperativeMatrixFeaturesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCooperativeMatrixFeaturesNV ;
      return;
    }
    if( "CooperativeMatrixPropertiesNV" == j.get< std::string >() ) {
      p = StructureType :: eCooperativeMatrixPropertiesNV ;
      return;
    }
    if( "eCooperativeMatrixPropertiesNV" == j.get< std::string >() ) {
      p = StructureType :: eCooperativeMatrixPropertiesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV" == j.get< std::string >() ) {
      p = StructureType :: eCooperativeMatrixPropertiesNV ;
      return;
    }
    if( "PhysicalDeviceCooperativeMatrixPropertiesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCooperativeMatrixPropertiesNV ;
      return;
    }
    if( "ePhysicalDeviceCooperativeMatrixPropertiesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCooperativeMatrixPropertiesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCooperativeMatrixPropertiesNV ;
      return;
    }
    if( "PipelineCoverageReductionStateCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCoverageReductionStateCreateInfoNV ;
      return;
    }
    if( "ePipelineCoverageReductionStateCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCoverageReductionStateCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: ePipelineCoverageReductionStateCreateInfoNV ;
      return;
    }
    if( "FramebufferMixedSamplesCombinationNV" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferMixedSamplesCombinationNV ;
      return;
    }
    if( "eFramebufferMixedSamplesCombinationNV" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferMixedSamplesCombinationNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferMixedSamplesCombinationNV ;
      return;
    }
    if( "PhysicalDeviceYcbcrImageArraysFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceYcbcrImageArraysFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceYcbcrImageArraysFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceYcbcrImageArraysFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceYcbcrImageArraysFeaturesEXT ;
      return;
    }
    if( "PhysicalDeviceProvokingVertexFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProvokingVertexFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceProvokingVertexFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProvokingVertexFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProvokingVertexFeaturesEXT ;
      return;
    }
    if( "PhysicalDeviceProvokingVertexPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProvokingVertexPropertiesEXT ;
      return;
    }
    if( "ePhysicalDeviceProvokingVertexPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProvokingVertexPropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProvokingVertexPropertiesEXT ;
      return;
    }
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "SurfaceFullScreenExclusiveInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceFullScreenExclusiveInfoEXT ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eSurfaceFullScreenExclusiveInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceFullScreenExclusiveInfoEXT ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceFullScreenExclusiveInfoEXT ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "SurfaceCapabilitiesFullScreenExclusiveEXT" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceCapabilitiesFullScreenExclusiveEXT ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eSurfaceCapabilitiesFullScreenExclusiveEXT" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceCapabilitiesFullScreenExclusiveEXT ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceCapabilitiesFullScreenExclusiveEXT ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "SurfaceFullScreenExclusiveWin32InfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceFullScreenExclusiveWin32InfoEXT ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "eSurfaceFullScreenExclusiveWin32InfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceFullScreenExclusiveWin32InfoEXT ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if( "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eSurfaceFullScreenExclusiveWin32InfoEXT ;
      return;
    }
#endif
    if( "HeadlessSurfaceCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eHeadlessSurfaceCreateInfoEXT ;
      return;
    }
    if( "eHeadlessSurfaceCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eHeadlessSurfaceCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eHeadlessSurfaceCreateInfoEXT ;
      return;
    }
    if( "PhysicalDeviceLineRasterizationFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceLineRasterizationFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceLineRasterizationFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceLineRasterizationFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceLineRasterizationFeaturesEXT ;
      return;
    }
    if( "PipelineRasterizationLineStateCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineRasterizationLineStateCreateInfoEXT ;
      return;
    }
    if( "ePipelineRasterizationLineStateCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineRasterizationLineStateCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineRasterizationLineStateCreateInfoEXT ;
      return;
    }
    if( "PhysicalDeviceLineRasterizationPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceLineRasterizationPropertiesEXT ;
      return;
    }
    if( "ePhysicalDeviceLineRasterizationPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceLineRasterizationPropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceLineRasterizationPropertiesEXT ;
      return;
    }
    if( "PhysicalDeviceShaderAtomicFloatFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderAtomicFloatFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceShaderAtomicFloatFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderAtomicFloatFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderAtomicFloatFeaturesEXT ;
      return;
    }
    if( "PhysicalDeviceIndexTypeUint8FeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceIndexTypeUint8FeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceIndexTypeUint8FeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceIndexTypeUint8FeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceIndexTypeUint8FeaturesEXT ;
      return;
    }
    if( "PipelineInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineInfoKHR ;
      return;
    }
    if( "ePipelineInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineInfoKHR ;
      return;
    }
    if( "PipelineExecutablePropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineExecutablePropertiesKHR ;
      return;
    }
    if( "ePipelineExecutablePropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineExecutablePropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineExecutablePropertiesKHR ;
      return;
    }
    if( "PipelineExecutableInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineExecutableInfoKHR ;
      return;
    }
    if( "ePipelineExecutableInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineExecutableInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineExecutableInfoKHR ;
      return;
    }
    if( "PipelineExecutableStatisticKHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineExecutableStatisticKHR ;
      return;
    }
    if( "ePipelineExecutableStatisticKHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineExecutableStatisticKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineExecutableStatisticKHR ;
      return;
    }
    if( "PipelineExecutableInternalRepresentationKHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineExecutableInternalRepresentationKHR ;
      return;
    }
    if( "ePipelineExecutableInternalRepresentationKHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineExecutableInternalRepresentationKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineExecutableInternalRepresentationKHR ;
      return;
    }
    if( "GraphicsShaderGroupCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eGraphicsShaderGroupCreateInfoNV ;
      return;
    }
    if( "eGraphicsShaderGroupCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eGraphicsShaderGroupCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eGraphicsShaderGroupCreateInfoNV ;
      return;
    }
    if( "GraphicsPipelineShaderGroupsCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eGraphicsPipelineShaderGroupsCreateInfoNV ;
      return;
    }
    if( "eGraphicsPipelineShaderGroupsCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eGraphicsPipelineShaderGroupsCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eGraphicsPipelineShaderGroupsCreateInfoNV ;
      return;
    }
    if( "IndirectCommandsLayoutTokenNV" == j.get< std::string >() ) {
      p = StructureType :: eIndirectCommandsLayoutTokenNV ;
      return;
    }
    if( "eIndirectCommandsLayoutTokenNV" == j.get< std::string >() ) {
      p = StructureType :: eIndirectCommandsLayoutTokenNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV" == j.get< std::string >() ) {
      p = StructureType :: eIndirectCommandsLayoutTokenNV ;
      return;
    }
    if( "IndirectCommandsLayoutCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eIndirectCommandsLayoutCreateInfoNV ;
      return;
    }
    if( "eIndirectCommandsLayoutCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eIndirectCommandsLayoutCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eIndirectCommandsLayoutCreateInfoNV ;
      return;
    }
    if( "GeneratedCommandsInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eGeneratedCommandsInfoNV ;
      return;
    }
    if( "eGeneratedCommandsInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eGeneratedCommandsInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eGeneratedCommandsInfoNV ;
      return;
    }
    if( "GeneratedCommandsMemoryRequirementsInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eGeneratedCommandsMemoryRequirementsInfoNV ;
      return;
    }
    if( "eGeneratedCommandsMemoryRequirementsInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eGeneratedCommandsMemoryRequirementsInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eGeneratedCommandsMemoryRequirementsInfoNV ;
      return;
    }
    if( "RenderPassTransformBeginInfoQCOM" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassTransformBeginInfoQCOM ;
      return;
    }
    if( "eRenderPassTransformBeginInfoQCOM" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassTransformBeginInfoQCOM ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassTransformBeginInfoQCOM ;
      return;
    }
    if( "PhysicalDeviceDeviceMemoryReportFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDeviceMemoryReportFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceDeviceMemoryReportFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDeviceMemoryReportFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDeviceMemoryReportFeaturesEXT ;
      return;
    }
    if( "DeviceDeviceMemoryReportCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDeviceDeviceMemoryReportCreateInfoEXT ;
      return;
    }
    if( "eDeviceDeviceMemoryReportCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDeviceDeviceMemoryReportCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDeviceDeviceMemoryReportCreateInfoEXT ;
      return;
    }
    if( "DeviceMemoryReportCallbackDataEXT" == j.get< std::string >() ) {
      p = StructureType :: eDeviceMemoryReportCallbackDataEXT ;
      return;
    }
    if( "eDeviceMemoryReportCallbackDataEXT" == j.get< std::string >() ) {
      p = StructureType :: eDeviceMemoryReportCallbackDataEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDeviceMemoryReportCallbackDataEXT ;
      return;
    }
    if( "PhysicalDeviceRobustness2FeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRobustness2FeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceRobustness2FeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRobustness2FeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRobustness2FeaturesEXT ;
      return;
    }
    if( "PhysicalDeviceRobustness2PropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRobustness2PropertiesEXT ;
      return;
    }
    if( "ePhysicalDeviceRobustness2PropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRobustness2PropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceRobustness2PropertiesEXT ;
      return;
    }
    if( "SamplerCustomBorderColorCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eSamplerCustomBorderColorCreateInfoEXT ;
      return;
    }
    if( "eSamplerCustomBorderColorCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eSamplerCustomBorderColorCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eSamplerCustomBorderColorCreateInfoEXT ;
      return;
    }
    if( "PhysicalDeviceCustomBorderColorFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCustomBorderColorFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceCustomBorderColorFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCustomBorderColorFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceCustomBorderColorFeaturesEXT ;
      return;
    }
    if( "PipelineLibraryCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineLibraryCreateInfoKHR ;
      return;
    }
    if( "ePipelineLibraryCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineLibraryCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePipelineLibraryCreateInfoKHR ;
      return;
    }
    if( "PhysicalDevicePrivateDataFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePrivateDataFeaturesEXT ;
      return;
    }
    if( "ePhysicalDevicePrivateDataFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePrivateDataFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePrivateDataFeaturesEXT ;
      return;
    }
    if( "DevicePrivateDataCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDevicePrivateDataCreateInfoEXT ;
      return;
    }
    if( "eDevicePrivateDataCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDevicePrivateDataCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDevicePrivateDataCreateInfoEXT ;
      return;
    }
    if( "PrivateDataSlotCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePrivateDataSlotCreateInfoEXT ;
      return;
    }
    if( "ePrivateDataSlotCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePrivateDataSlotCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePrivateDataSlotCreateInfoEXT ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeRateControlInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeRateControlInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeRateControlInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeRateControlInfoKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eVideoEncodeRateControlInfoKHR ;
      return;
    }
#endif
    if( "PhysicalDeviceDiagnosticsConfigFeaturesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDiagnosticsConfigFeaturesNV ;
      return;
    }
    if( "ePhysicalDeviceDiagnosticsConfigFeaturesNV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDiagnosticsConfigFeaturesNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDiagnosticsConfigFeaturesNV ;
      return;
    }
    if( "DeviceDiagnosticsConfigCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eDeviceDiagnosticsConfigCreateInfoNV ;
      return;
    }
    if( "eDeviceDiagnosticsConfigCreateInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eDeviceDiagnosticsConfigCreateInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eDeviceDiagnosticsConfigCreateInfoNV ;
      return;
    }
    if( "MemoryBarrier2KHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryBarrier2KHR ;
      return;
    }
    if( "eMemoryBarrier2KHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryBarrier2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryBarrier2KHR ;
      return;
    }
    if( "BufferMemoryBarrier2KHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferMemoryBarrier2KHR ;
      return;
    }
    if( "eBufferMemoryBarrier2KHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferMemoryBarrier2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferMemoryBarrier2KHR ;
      return;
    }
    if( "ImageMemoryBarrier2KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageMemoryBarrier2KHR ;
      return;
    }
    if( "eImageMemoryBarrier2KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageMemoryBarrier2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageMemoryBarrier2KHR ;
      return;
    }
    if( "DependencyInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDependencyInfoKHR ;
      return;
    }
    if( "eDependencyInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDependencyInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDependencyInfoKHR ;
      return;
    }
    if( "SubmitInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eSubmitInfo2KHR ;
      return;
    }
    if( "eSubmitInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eSubmitInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSubmitInfo2KHR ;
      return;
    }
    if( "SemaphoreSubmitInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreSubmitInfoKHR ;
      return;
    }
    if( "eSemaphoreSubmitInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreSubmitInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreSubmitInfoKHR ;
      return;
    }
    if( "CommandBufferSubmitInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eCommandBufferSubmitInfoKHR ;
      return;
    }
    if( "eCommandBufferSubmitInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eCommandBufferSubmitInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eCommandBufferSubmitInfoKHR ;
      return;
    }
    if( "PhysicalDeviceSynchronization2FeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSynchronization2FeaturesKHR ;
      return;
    }
    if( "ePhysicalDeviceSynchronization2FeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSynchronization2FeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSynchronization2FeaturesKHR ;
      return;
    }
    if( "QueueFamilyCheckpointProperties2NV" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyCheckpointProperties2NV ;
      return;
    }
    if( "eQueueFamilyCheckpointProperties2NV" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyCheckpointProperties2NV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyCheckpointProperties2NV ;
      return;
    }
    if( "CheckpointData2NV" == j.get< std::string >() ) {
      p = StructureType :: eCheckpointData2NV ;
      return;
    }
    if( "eCheckpointData2NV" == j.get< std::string >() ) {
      p = StructureType :: eCheckpointData2NV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV" == j.get< std::string >() ) {
      p = StructureType :: eCheckpointData2NV ;
      return;
    }
    if( "AccelerationStructureMotionInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureMotionInfoNV ;
      return;
    }
    if( "eAccelerationStructureMotionInfoNV" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureMotionInfoNV ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV" == j.get< std::string >() ) {
      p = StructureType :: eAccelerationStructureMotionInfoNV ;
      return;
    }
    if( "CopyCommandTransformInfoQCOM" == j.get< std::string >() ) {
      p = StructureType :: eCopyCommandTransformInfoQCOM ;
      return;
    }
    if( "eCopyCommandTransformInfoQCOM" == j.get< std::string >() ) {
      p = StructureType :: eCopyCommandTransformInfoQCOM ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM" == j.get< std::string >() ) {
      p = StructureType :: eCopyCommandTransformInfoQCOM ;
      return;
    }
    if( "PhysicalDeviceImageRobustnessFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageRobustnessFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceImageRobustnessFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageRobustnessFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageRobustnessFeaturesEXT ;
      return;
    }
    if( "CopyBufferInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyBufferInfo2KHR ;
      return;
    }
    if( "eCopyBufferInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyBufferInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyBufferInfo2KHR ;
      return;
    }
    if( "CopyImageInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyImageInfo2KHR ;
      return;
    }
    if( "eCopyImageInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyImageInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyImageInfo2KHR ;
      return;
    }
    if( "CopyBufferToImageInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyBufferToImageInfo2KHR ;
      return;
    }
    if( "eCopyBufferToImageInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyBufferToImageInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyBufferToImageInfo2KHR ;
      return;
    }
    if( "CopyImageToBufferInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyImageToBufferInfo2KHR ;
      return;
    }
    if( "eCopyImageToBufferInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyImageToBufferInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eCopyImageToBufferInfo2KHR ;
      return;
    }
    if( "BlitImageInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eBlitImageInfo2KHR ;
      return;
    }
    if( "eBlitImageInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eBlitImageInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eBlitImageInfo2KHR ;
      return;
    }
    if( "ResolveImageInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eResolveImageInfo2KHR ;
      return;
    }
    if( "eResolveImageInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eResolveImageInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eResolveImageInfo2KHR ;
      return;
    }
    if( "BufferCopy2KHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferCopy2KHR ;
      return;
    }
    if( "eBufferCopy2KHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferCopy2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferCopy2KHR ;
      return;
    }
    if( "ImageCopy2KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageCopy2KHR ;
      return;
    }
    if( "eImageCopy2KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageCopy2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageCopy2KHR ;
      return;
    }
    if( "ImageBlit2KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageBlit2KHR ;
      return;
    }
    if( "eImageBlit2KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageBlit2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageBlit2KHR ;
      return;
    }
    if( "BufferImageCopy2KHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferImageCopy2KHR ;
      return;
    }
    if( "eBufferImageCopy2KHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferImageCopy2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferImageCopy2KHR ;
      return;
    }
    if( "ImageResolve2KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageResolve2KHR ;
      return;
    }
    if( "eImageResolve2KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageResolve2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageResolve2KHR ;
      return;
    }
    if( "PhysicalDevice4444FormatsFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice4444FormatsFeaturesEXT ;
      return;
    }
    if( "ePhysicalDevice4444FormatsFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice4444FormatsFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice4444FormatsFeaturesEXT ;
      return;
    }
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
    if( "DirectfbSurfaceCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDirectfbSurfaceCreateInfoEXT ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
    if( "eDirectfbSurfaceCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDirectfbSurfaceCreateInfoEXT ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
    if( "VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDirectfbSurfaceCreateInfoEXT ;
      return;
    }
#endif
    if( "MutableDescriptorTypeCreateInfoVALVE" == j.get< std::string >() ) {
      p = StructureType :: eMutableDescriptorTypeCreateInfoVALVE ;
      return;
    }
    if( "eMutableDescriptorTypeCreateInfoVALVE" == j.get< std::string >() ) {
      p = StructureType :: eMutableDescriptorTypeCreateInfoVALVE ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE" == j.get< std::string >() ) {
      p = StructureType :: eMutableDescriptorTypeCreateInfoVALVE ;
      return;
    }
    if( "VertexInputBindingDescription2EXT" == j.get< std::string >() ) {
      p = StructureType :: eVertexInputBindingDescription2EXT ;
      return;
    }
    if( "eVertexInputBindingDescription2EXT" == j.get< std::string >() ) {
      p = StructureType :: eVertexInputBindingDescription2EXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVertexInputBindingDescription2EXT ;
      return;
    }
    if( "VertexInputAttributeDescription2EXT" == j.get< std::string >() ) {
      p = StructureType :: eVertexInputAttributeDescription2EXT ;
      return;
    }
    if( "eVertexInputAttributeDescription2EXT" == j.get< std::string >() ) {
      p = StructureType :: eVertexInputAttributeDescription2EXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT" == j.get< std::string >() ) {
      p = StructureType :: eVertexInputAttributeDescription2EXT ;
      return;
    }
    if( "PhysicalDeviceDrmPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDrmPropertiesEXT ;
      return;
    }
    if( "ePhysicalDeviceDrmPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDrmPropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDrmPropertiesEXT ;
      return;
    }
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "ImportMemoryZirconHandleInfoFUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryZirconHandleInfoFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "eImportMemoryZirconHandleInfoFUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryZirconHandleInfoFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eImportMemoryZirconHandleInfoFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "MemoryZirconHandlePropertiesFUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eMemoryZirconHandlePropertiesFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "eMemoryZirconHandlePropertiesFUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eMemoryZirconHandlePropertiesFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eMemoryZirconHandlePropertiesFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "MemoryGetZirconHandleInfoFUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eMemoryGetZirconHandleInfoFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "eMemoryGetZirconHandleInfoFUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eMemoryGetZirconHandleInfoFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eMemoryGetZirconHandleInfoFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "ImportSemaphoreZirconHandleInfoFUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eImportSemaphoreZirconHandleInfoFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "eImportSemaphoreZirconHandleInfoFUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eImportSemaphoreZirconHandleInfoFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eImportSemaphoreZirconHandleInfoFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "SemaphoreGetZirconHandleInfoFUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreGetZirconHandleInfoFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "eSemaphoreGetZirconHandleInfoFUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreGetZirconHandleInfoFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreGetZirconHandleInfoFUCHSIA ;
      return;
    }
#endif
    if( "SubpasssShadingPipelineCreateInfoHUAWEI" == j.get< std::string >() ) {
      p = StructureType :: eSubpasssShadingPipelineCreateInfoHUAWEI ;
      return;
    }
    if( "eSubpasssShadingPipelineCreateInfoHUAWEI" == j.get< std::string >() ) {
      p = StructureType :: eSubpasssShadingPipelineCreateInfoHUAWEI ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SUBPASSS_SHADING_PIPELINE_CREATE_INFO_HUAWEI" == j.get< std::string >() ) {
      p = StructureType :: eSubpasssShadingPipelineCreateInfoHUAWEI ;
      return;
    }
    if( "PhysicalDeviceSubpassShadingFeaturesHUAWEI" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSubpassShadingFeaturesHUAWEI ;
      return;
    }
    if( "ePhysicalDeviceSubpassShadingFeaturesHUAWEI" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSubpassShadingFeaturesHUAWEI ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSubpassShadingFeaturesHUAWEI ;
      return;
    }
    if( "PhysicalDeviceSubpassShadingPropertiesHUAWEI" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSubpassShadingPropertiesHUAWEI ;
      return;
    }
    if( "ePhysicalDeviceSubpassShadingPropertiesHUAWEI" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSubpassShadingPropertiesHUAWEI ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSubpassShadingPropertiesHUAWEI ;
      return;
    }
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
    if( "ScreenSurfaceCreateInfoQNX" == j.get< std::string >() ) {
      p = StructureType :: eScreenSurfaceCreateInfoQNX ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
    if( "eScreenSurfaceCreateInfoQNX" == j.get< std::string >() ) {
      p = StructureType :: eScreenSurfaceCreateInfoQNX ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
    if( "VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX" == j.get< std::string >() ) {
      p = StructureType :: eScreenSurfaceCreateInfoQNX ;
      return;
    }
#endif
    if( "PhysicalDeviceColorWriteEnableFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceColorWriteEnableFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceColorWriteEnableFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceColorWriteEnableFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceColorWriteEnableFeaturesEXT ;
      return;
    }
    if( "PipelineColorWriteCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineColorWriteCreateInfoEXT ;
      return;
    }
    if( "ePipelineColorWriteCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineColorWriteCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePipelineColorWriteCreateInfoEXT ;
      return;
    }
    if( "QueueFamilyGlobalPriorityPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyGlobalPriorityPropertiesEXT ;
      return;
    }
    if( "eQueueFamilyGlobalPriorityPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyGlobalPriorityPropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyGlobalPriorityPropertiesEXT ;
      return;
    }
    if( "PhysicalDeviceMultiDrawFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiDrawFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceMultiDrawFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiDrawFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiDrawFeaturesEXT ;
      return;
    }
    if( "PhysicalDeviceMultiDrawPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiDrawPropertiesEXT ;
      return;
    }
    if( "ePhysicalDeviceMultiDrawPropertiesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiDrawPropertiesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiDrawPropertiesEXT ;
      return;
    }
    if( "AttachmentDescription2KHR" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentDescription2KHR ;
      return;
    }
    if( "eAttachmentDescription2KHR" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentDescription2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentDescription2KHR ;
      return;
    }
    if( "AttachmentDescriptionStencilLayoutKHR" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentDescriptionStencilLayoutKHR ;
      return;
    }
    if( "eAttachmentDescriptionStencilLayoutKHR" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentDescriptionStencilLayoutKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentDescriptionStencilLayoutKHR ;
      return;
    }
    if( "AttachmentReference2KHR" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentReference2KHR ;
      return;
    }
    if( "eAttachmentReference2KHR" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentReference2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentReference2KHR ;
      return;
    }
    if( "AttachmentReferenceStencilLayoutKHR" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentReferenceStencilLayoutKHR ;
      return;
    }
    if( "eAttachmentReferenceStencilLayoutKHR" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentReferenceStencilLayoutKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR" == j.get< std::string >() ) {
      p = StructureType :: eAttachmentReferenceStencilLayoutKHR ;
      return;
    }
    if( "BindBufferMemoryDeviceGroupInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBindBufferMemoryDeviceGroupInfoKHR ;
      return;
    }
    if( "eBindBufferMemoryDeviceGroupInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBindBufferMemoryDeviceGroupInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eBindBufferMemoryDeviceGroupInfoKHR ;
      return;
    }
    if( "BindBufferMemoryInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBindBufferMemoryInfoKHR ;
      return;
    }
    if( "eBindBufferMemoryInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBindBufferMemoryInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eBindBufferMemoryInfoKHR ;
      return;
    }
    if( "BindImageMemoryDeviceGroupInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemoryDeviceGroupInfoKHR ;
      return;
    }
    if( "eBindImageMemoryDeviceGroupInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemoryDeviceGroupInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemoryDeviceGroupInfoKHR ;
      return;
    }
    if( "BindImageMemoryInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemoryInfoKHR ;
      return;
    }
    if( "eBindImageMemoryInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemoryInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eBindImageMemoryInfoKHR ;
      return;
    }
    if( "BindImagePlaneMemoryInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBindImagePlaneMemoryInfoKHR ;
      return;
    }
    if( "eBindImagePlaneMemoryInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBindImagePlaneMemoryInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eBindImagePlaneMemoryInfoKHR ;
      return;
    }
    if( "BufferDeviceAddressInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eBufferDeviceAddressInfoEXT ;
      return;
    }
    if( "eBufferDeviceAddressInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eBufferDeviceAddressInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eBufferDeviceAddressInfoEXT ;
      return;
    }
    if( "BufferDeviceAddressInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferDeviceAddressInfoKHR ;
      return;
    }
    if( "eBufferDeviceAddressInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferDeviceAddressInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferDeviceAddressInfoKHR ;
      return;
    }
    if( "BufferMemoryRequirementsInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferMemoryRequirementsInfo2KHR ;
      return;
    }
    if( "eBufferMemoryRequirementsInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferMemoryRequirementsInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferMemoryRequirementsInfo2KHR ;
      return;
    }
    if( "BufferOpaqueCaptureAddressCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferOpaqueCaptureAddressCreateInfoKHR ;
      return;
    }
    if( "eBufferOpaqueCaptureAddressCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferOpaqueCaptureAddressCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eBufferOpaqueCaptureAddressCreateInfoKHR ;
      return;
    }
    if( "DebugReportCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugReportCreateInfoEXT ;
      return;
    }
    if( "eDebugReportCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugReportCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eDebugReportCreateInfoEXT ;
      return;
    }
    if( "DescriptorSetLayoutSupportKHR" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetLayoutSupportKHR ;
      return;
    }
    if( "eDescriptorSetLayoutSupportKHR" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetLayoutSupportKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorSetLayoutSupportKHR ;
      return;
    }
    if( "DescriptorUpdateTemplateCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorUpdateTemplateCreateInfoKHR ;
      return;
    }
    if( "eDescriptorUpdateTemplateCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorUpdateTemplateCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDescriptorUpdateTemplateCreateInfoKHR ;
      return;
    }
    if( "DeviceGroupBindSparseInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupBindSparseInfoKHR ;
      return;
    }
    if( "eDeviceGroupBindSparseInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupBindSparseInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupBindSparseInfoKHR ;
      return;
    }
    if( "DeviceGroupCommandBufferBeginInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupCommandBufferBeginInfoKHR ;
      return;
    }
    if( "eDeviceGroupCommandBufferBeginInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupCommandBufferBeginInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupCommandBufferBeginInfoKHR ;
      return;
    }
    if( "DeviceGroupDeviceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupDeviceCreateInfoKHR ;
      return;
    }
    if( "eDeviceGroupDeviceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupDeviceCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupDeviceCreateInfoKHR ;
      return;
    }
    if( "DeviceGroupRenderPassBeginInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupRenderPassBeginInfoKHR ;
      return;
    }
    if( "eDeviceGroupRenderPassBeginInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupRenderPassBeginInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupRenderPassBeginInfoKHR ;
      return;
    }
    if( "DeviceGroupSubmitInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupSubmitInfoKHR ;
      return;
    }
    if( "eDeviceGroupSubmitInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupSubmitInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceGroupSubmitInfoKHR ;
      return;
    }
    if( "DeviceMemoryOpaqueCaptureAddressInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceMemoryOpaqueCaptureAddressInfoKHR ;
      return;
    }
    if( "eDeviceMemoryOpaqueCaptureAddressInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceMemoryOpaqueCaptureAddressInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eDeviceMemoryOpaqueCaptureAddressInfoKHR ;
      return;
    }
    if( "ExportFenceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExportFenceCreateInfoKHR ;
      return;
    }
    if( "eExportFenceCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExportFenceCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eExportFenceCreateInfoKHR ;
      return;
    }
    if( "ExportMemoryAllocateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryAllocateInfoKHR ;
      return;
    }
    if( "eExportMemoryAllocateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryAllocateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eExportMemoryAllocateInfoKHR ;
      return;
    }
    if( "ExportSemaphoreCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExportSemaphoreCreateInfoKHR ;
      return;
    }
    if( "eExportSemaphoreCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExportSemaphoreCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eExportSemaphoreCreateInfoKHR ;
      return;
    }
    if( "ExternalBufferPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalBufferPropertiesKHR ;
      return;
    }
    if( "eExternalBufferPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalBufferPropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalBufferPropertiesKHR ;
      return;
    }
    if( "ExternalFencePropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalFencePropertiesKHR ;
      return;
    }
    if( "eExternalFencePropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalFencePropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalFencePropertiesKHR ;
      return;
    }
    if( "ExternalImageFormatPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalImageFormatPropertiesKHR ;
      return;
    }
    if( "eExternalImageFormatPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalImageFormatPropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalImageFormatPropertiesKHR ;
      return;
    }
    if( "ExternalMemoryBufferCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryBufferCreateInfoKHR ;
      return;
    }
    if( "eExternalMemoryBufferCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryBufferCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryBufferCreateInfoKHR ;
      return;
    }
    if( "ExternalMemoryImageCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryImageCreateInfoKHR ;
      return;
    }
    if( "eExternalMemoryImageCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryImageCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalMemoryImageCreateInfoKHR ;
      return;
    }
    if( "ExternalSemaphorePropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalSemaphorePropertiesKHR ;
      return;
    }
    if( "eExternalSemaphorePropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalSemaphorePropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: eExternalSemaphorePropertiesKHR ;
      return;
    }
    if( "FormatProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eFormatProperties2KHR ;
      return;
    }
    if( "eFormatProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eFormatProperties2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eFormatProperties2KHR ;
      return;
    }
    if( "FramebufferAttachmentsCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferAttachmentsCreateInfoKHR ;
      return;
    }
    if( "eFramebufferAttachmentsCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferAttachmentsCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferAttachmentsCreateInfoKHR ;
      return;
    }
    if( "FramebufferAttachmentImageInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferAttachmentImageInfoKHR ;
      return;
    }
    if( "eFramebufferAttachmentImageInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferAttachmentImageInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eFramebufferAttachmentImageInfoKHR ;
      return;
    }
    if( "ImageFormatListCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImageFormatListCreateInfoKHR ;
      return;
    }
    if( "eImageFormatListCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImageFormatListCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageFormatListCreateInfoKHR ;
      return;
    }
    if( "ImageFormatProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageFormatProperties2KHR ;
      return;
    }
    if( "eImageFormatProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageFormatProperties2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageFormatProperties2KHR ;
      return;
    }
    if( "ImageMemoryRequirementsInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageMemoryRequirementsInfo2KHR ;
      return;
    }
    if( "eImageMemoryRequirementsInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageMemoryRequirementsInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageMemoryRequirementsInfo2KHR ;
      return;
    }
    if( "ImagePlaneMemoryRequirementsInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImagePlaneMemoryRequirementsInfoKHR ;
      return;
    }
    if( "eImagePlaneMemoryRequirementsInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImagePlaneMemoryRequirementsInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImagePlaneMemoryRequirementsInfoKHR ;
      return;
    }
    if( "ImageSparseMemoryRequirementsInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageSparseMemoryRequirementsInfo2KHR ;
      return;
    }
    if( "eImageSparseMemoryRequirementsInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageSparseMemoryRequirementsInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageSparseMemoryRequirementsInfo2KHR ;
      return;
    }
    if( "ImageStencilUsageCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eImageStencilUsageCreateInfoEXT ;
      return;
    }
    if( "eImageStencilUsageCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eImageStencilUsageCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eImageStencilUsageCreateInfoEXT ;
      return;
    }
    if( "ImageViewUsageCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImageViewUsageCreateInfoKHR ;
      return;
    }
    if( "eImageViewUsageCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eImageViewUsageCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eImageViewUsageCreateInfoKHR ;
      return;
    }
    if( "MemoryAllocateFlagsInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryAllocateFlagsInfoKHR ;
      return;
    }
    if( "eMemoryAllocateFlagsInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryAllocateFlagsInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryAllocateFlagsInfoKHR ;
      return;
    }
    if( "MemoryDedicatedAllocateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryDedicatedAllocateInfoKHR ;
      return;
    }
    if( "eMemoryDedicatedAllocateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryDedicatedAllocateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryDedicatedAllocateInfoKHR ;
      return;
    }
    if( "MemoryDedicatedRequirementsKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryDedicatedRequirementsKHR ;
      return;
    }
    if( "eMemoryDedicatedRequirementsKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryDedicatedRequirementsKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryDedicatedRequirementsKHR ;
      return;
    }
    if( "MemoryOpaqueCaptureAddressAllocateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryOpaqueCaptureAddressAllocateInfoKHR ;
      return;
    }
    if( "eMemoryOpaqueCaptureAddressAllocateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryOpaqueCaptureAddressAllocateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryOpaqueCaptureAddressAllocateInfoKHR ;
      return;
    }
    if( "MemoryRequirements2KHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryRequirements2KHR ;
      return;
    }
    if( "eMemoryRequirements2KHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryRequirements2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eMemoryRequirements2KHR ;
      return;
    }
    if( "PhysicalDevice16BitStorageFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice16BitStorageFeaturesKHR ;
      return;
    }
    if( "ePhysicalDevice16BitStorageFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice16BitStorageFeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice16BitStorageFeaturesKHR ;
      return;
    }
    if( "PhysicalDevice8BitStorageFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice8BitStorageFeaturesKHR ;
      return;
    }
    if( "ePhysicalDevice8BitStorageFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice8BitStorageFeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevice8BitStorageFeaturesKHR ;
      return;
    }
    if( "PhysicalDeviceBufferAddressFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceBufferAddressFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceBufferAddressFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceBufferAddressFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceBufferAddressFeaturesEXT ;
      return;
    }
    if( "PhysicalDeviceDescriptorIndexingFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDescriptorIndexingFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceDescriptorIndexingFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDescriptorIndexingFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDescriptorIndexingFeaturesEXT ;
      return;
    }
    if( "PhysicalDeviceDriverPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDriverPropertiesKHR ;
      return;
    }
    if( "ePhysicalDeviceDriverPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDriverPropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceDriverPropertiesKHR ;
      return;
    }
    if( "PhysicalDeviceExternalBufferInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalBufferInfoKHR ;
      return;
    }
    if( "ePhysicalDeviceExternalBufferInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalBufferInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalBufferInfoKHR ;
      return;
    }
    if( "PhysicalDeviceExternalFenceInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalFenceInfoKHR ;
      return;
    }
    if( "ePhysicalDeviceExternalFenceInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalFenceInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalFenceInfoKHR ;
      return;
    }
    if( "PhysicalDeviceExternalImageFormatInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalImageFormatInfoKHR ;
      return;
    }
    if( "ePhysicalDeviceExternalImageFormatInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalImageFormatInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalImageFormatInfoKHR ;
      return;
    }
    if( "PhysicalDeviceExternalSemaphoreInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalSemaphoreInfoKHR ;
      return;
    }
    if( "ePhysicalDeviceExternalSemaphoreInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalSemaphoreInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceExternalSemaphoreInfoKHR ;
      return;
    }
    if( "PhysicalDeviceFeatures2KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFeatures2KHR ;
      return;
    }
    if( "ePhysicalDeviceFeatures2KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFeatures2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFeatures2KHR ;
      return;
    }
    if( "PhysicalDeviceFloat16Int8FeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFloat16Int8FeaturesKHR ;
      return;
    }
    if( "ePhysicalDeviceFloat16Int8FeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFloat16Int8FeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFloat16Int8FeaturesKHR ;
      return;
    }
    if( "PhysicalDeviceFloatControlsPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFloatControlsPropertiesKHR ;
      return;
    }
    if( "ePhysicalDeviceFloatControlsPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFloatControlsPropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceFloatControlsPropertiesKHR ;
      return;
    }
    if( "PhysicalDeviceGroupPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceGroupPropertiesKHR ;
      return;
    }
    if( "ePhysicalDeviceGroupPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceGroupPropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceGroupPropertiesKHR ;
      return;
    }
    if( "PhysicalDeviceHostQueryResetFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceHostQueryResetFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceHostQueryResetFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceHostQueryResetFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceHostQueryResetFeaturesEXT ;
      return;
    }
    if( "PhysicalDeviceIdPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceIdPropertiesKHR ;
      return;
    }
    if( "ePhysicalDeviceIdPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceIdPropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceIdPropertiesKHR ;
      return;
    }
    if( "PhysicalDeviceImageFormatInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageFormatInfo2KHR ;
      return;
    }
    if( "ePhysicalDeviceImageFormatInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageFormatInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceImageFormatInfo2KHR ;
      return;
    }
    if( "PhysicalDeviceMaintenance3PropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMaintenance3PropertiesKHR ;
      return;
    }
    if( "ePhysicalDeviceMaintenance3PropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMaintenance3PropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMaintenance3PropertiesKHR ;
      return;
    }
    if( "PhysicalDeviceMemoryProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMemoryProperties2KHR ;
      return;
    }
    if( "ePhysicalDeviceMemoryProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMemoryProperties2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMemoryProperties2KHR ;
      return;
    }
    if( "PhysicalDeviceMultiviewFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiviewFeaturesKHR ;
      return;
    }
    if( "ePhysicalDeviceMultiviewFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiviewFeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiviewFeaturesKHR ;
      return;
    }
    if( "PhysicalDeviceMultiviewPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiviewPropertiesKHR ;
      return;
    }
    if( "ePhysicalDeviceMultiviewPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiviewPropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceMultiviewPropertiesKHR ;
      return;
    }
    if( "PhysicalDevicePointClippingPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePointClippingPropertiesKHR ;
      return;
    }
    if( "ePhysicalDevicePointClippingPropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePointClippingPropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDevicePointClippingPropertiesKHR ;
      return;
    }
    if( "PhysicalDeviceProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProperties2KHR ;
      return;
    }
    if( "ePhysicalDeviceProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProperties2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceProperties2KHR ;
      return;
    }
    if( "PhysicalDeviceScalarBlockLayoutFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceScalarBlockLayoutFeaturesEXT ;
      return;
    }
    if( "ePhysicalDeviceScalarBlockLayoutFeaturesEXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceScalarBlockLayoutFeaturesEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceScalarBlockLayoutFeaturesEXT ;
      return;
    }
    if( "PhysicalDeviceShaderAtomicInt64FeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderAtomicInt64FeaturesKHR ;
      return;
    }
    if( "ePhysicalDeviceShaderAtomicInt64FeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderAtomicInt64FeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderAtomicInt64FeaturesKHR ;
      return;
    }
    if( "PhysicalDeviceShaderDrawParameterFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderDrawParameterFeatures ;
      return;
    }
    if( "ePhysicalDeviceShaderDrawParameterFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderDrawParameterFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderDrawParameterFeatures ;
      return;
    }
    if( "PhysicalDeviceShaderFloat16Int8FeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderFloat16Int8FeaturesKHR ;
      return;
    }
    if( "ePhysicalDeviceShaderFloat16Int8FeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderFloat16Int8FeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceShaderFloat16Int8FeaturesKHR ;
      return;
    }
    if( "PhysicalDeviceSparseImageFormatInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSparseImageFormatInfo2KHR ;
      return;
    }
    if( "ePhysicalDeviceSparseImageFormatInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSparseImageFormatInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceSparseImageFormatInfo2KHR ;
      return;
    }
    if( "PhysicalDeviceTimelineSemaphoreFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTimelineSemaphoreFeaturesKHR ;
      return;
    }
    if( "ePhysicalDeviceTimelineSemaphoreFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTimelineSemaphoreFeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTimelineSemaphoreFeaturesKHR ;
      return;
    }
    if( "PhysicalDeviceTimelineSemaphorePropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTimelineSemaphorePropertiesKHR ;
      return;
    }
    if( "ePhysicalDeviceTimelineSemaphorePropertiesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTimelineSemaphorePropertiesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceTimelineSemaphorePropertiesKHR ;
      return;
    }
    if( "PhysicalDeviceVariablePointersFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVariablePointersFeaturesKHR ;
      return;
    }
    if( "ePhysicalDeviceVariablePointersFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVariablePointersFeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVariablePointersFeaturesKHR ;
      return;
    }
    if( "PhysicalDeviceVariablePointerFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVariablePointerFeatures ;
      return;
    }
    if( "ePhysicalDeviceVariablePointerFeatures" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVariablePointerFeatures ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVariablePointerFeatures ;
      return;
    }
    if( "PhysicalDeviceVariablePointerFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVariablePointerFeaturesKHR ;
      return;
    }
    if( "ePhysicalDeviceVariablePointerFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVariablePointerFeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVariablePointerFeaturesKHR ;
      return;
    }
    if( "PhysicalDeviceVulkanMemoryModelFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkanMemoryModelFeaturesKHR ;
      return;
    }
    if( "ePhysicalDeviceVulkanMemoryModelFeaturesKHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkanMemoryModelFeaturesKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR" == j.get< std::string >() ) {
      p = StructureType :: ePhysicalDeviceVulkanMemoryModelFeaturesKHR ;
      return;
    }
    if( "QueryPoolCreateInfoINTEL" == j.get< std::string >() ) {
      p = StructureType :: eQueryPoolCreateInfoINTEL ;
      return;
    }
    if( "eQueryPoolCreateInfoINTEL" == j.get< std::string >() ) {
      p = StructureType :: eQueryPoolCreateInfoINTEL ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL" == j.get< std::string >() ) {
      p = StructureType :: eQueryPoolCreateInfoINTEL ;
      return;
    }
    if( "QueueFamilyProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyProperties2KHR ;
      return;
    }
    if( "eQueueFamilyProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyProperties2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eQueueFamilyProperties2KHR ;
      return;
    }
    if( "RenderPassAttachmentBeginInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassAttachmentBeginInfoKHR ;
      return;
    }
    if( "eRenderPassAttachmentBeginInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassAttachmentBeginInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassAttachmentBeginInfoKHR ;
      return;
    }
    if( "RenderPassCreateInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassCreateInfo2KHR ;
      return;
    }
    if( "eRenderPassCreateInfo2KHR" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassCreateInfo2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassCreateInfo2KHR ;
      return;
    }
    if( "RenderPassMultiviewCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassMultiviewCreateInfoKHR ;
      return;
    }
    if( "eRenderPassMultiviewCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassMultiviewCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eRenderPassMultiviewCreateInfoKHR ;
      return;
    }
    if( "SamplerReductionModeCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eSamplerReductionModeCreateInfoEXT ;
      return;
    }
    if( "eSamplerReductionModeCreateInfoEXT" == j.get< std::string >() ) {
      p = StructureType :: eSamplerReductionModeCreateInfoEXT ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT" == j.get< std::string >() ) {
      p = StructureType :: eSamplerReductionModeCreateInfoEXT ;
      return;
    }
    if( "SamplerYcbcrConversionCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionCreateInfoKHR ;
      return;
    }
    if( "eSamplerYcbcrConversionCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionCreateInfoKHR ;
      return;
    }
    if( "SamplerYcbcrConversionInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionInfoKHR ;
      return;
    }
    if( "eSamplerYcbcrConversionInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSamplerYcbcrConversionInfoKHR ;
      return;
    }
    if( "SemaphoreSignalInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreSignalInfoKHR ;
      return;
    }
    if( "eSemaphoreSignalInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreSignalInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreSignalInfoKHR ;
      return;
    }
    if( "SemaphoreTypeCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreTypeCreateInfoKHR ;
      return;
    }
    if( "eSemaphoreTypeCreateInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreTypeCreateInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreTypeCreateInfoKHR ;
      return;
    }
    if( "SemaphoreWaitInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreWaitInfoKHR ;
      return;
    }
    if( "eSemaphoreWaitInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreWaitInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSemaphoreWaitInfoKHR ;
      return;
    }
    if( "SparseImageFormatProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eSparseImageFormatProperties2KHR ;
      return;
    }
    if( "eSparseImageFormatProperties2KHR" == j.get< std::string >() ) {
      p = StructureType :: eSparseImageFormatProperties2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSparseImageFormatProperties2KHR ;
      return;
    }
    if( "SparseImageMemoryRequirements2KHR" == j.get< std::string >() ) {
      p = StructureType :: eSparseImageMemoryRequirements2KHR ;
      return;
    }
    if( "eSparseImageMemoryRequirements2KHR" == j.get< std::string >() ) {
      p = StructureType :: eSparseImageMemoryRequirements2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSparseImageMemoryRequirements2KHR ;
      return;
    }
    if( "SubpassBeginInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassBeginInfoKHR ;
      return;
    }
    if( "eSubpassBeginInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassBeginInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassBeginInfoKHR ;
      return;
    }
    if( "SubpassDependency2KHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDependency2KHR ;
      return;
    }
    if( "eSubpassDependency2KHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDependency2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDependency2KHR ;
      return;
    }
    if( "SubpassDescription2KHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDescription2KHR ;
      return;
    }
    if( "eSubpassDescription2KHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDescription2KHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDescription2KHR ;
      return;
    }
    if( "SubpassDescriptionDepthStencilResolveKHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDescriptionDepthStencilResolveKHR ;
      return;
    }
    if( "eSubpassDescriptionDepthStencilResolveKHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDescriptionDepthStencilResolveKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassDescriptionDepthStencilResolveKHR ;
      return;
    }
    if( "SubpassEndInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassEndInfoKHR ;
      return;
    }
    if( "eSubpassEndInfoKHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassEndInfoKHR ;
      return;
    }
    if( "VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR" == j.get< std::string >() ) {
      p = StructureType :: eSubpassEndInfoKHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for StructureType" );
  }
  if( j.is_number() ) {
    p = StructureType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for StructureType" );
}
inline void from_json( const nlohmann::json &j, VkStructureType &p ) {
  StructureType temp;
  from_json( j, temp );
  p = VkStructureType ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const ObjectType &p ) {
  if( ObjectType :: eUnknown == p ) {
    j = "Unknown";
    return;
  }
  if( ObjectType :: eInstance == p ) {
    j = "Instance";
    return;
  }
  if( ObjectType :: ePhysicalDevice == p ) {
    j = "PhysicalDevice";
    return;
  }
  if( ObjectType :: eDevice == p ) {
    j = "Device";
    return;
  }
  if( ObjectType :: eQueue == p ) {
    j = "Queue";
    return;
  }
  if( ObjectType :: eSemaphore == p ) {
    j = "Semaphore";
    return;
  }
  if( ObjectType :: eCommandBuffer == p ) {
    j = "CommandBuffer";
    return;
  }
  if( ObjectType :: eFence == p ) {
    j = "Fence";
    return;
  }
  if( ObjectType :: eDeviceMemory == p ) {
    j = "DeviceMemory";
    return;
  }
  if( ObjectType :: eBuffer == p ) {
    j = "Buffer";
    return;
  }
  if( ObjectType :: eImage == p ) {
    j = "Image";
    return;
  }
  if( ObjectType :: eEvent == p ) {
    j = "Event";
    return;
  }
  if( ObjectType :: eQueryPool == p ) {
    j = "QueryPool";
    return;
  }
  if( ObjectType :: eBufferView == p ) {
    j = "BufferView";
    return;
  }
  if( ObjectType :: eImageView == p ) {
    j = "ImageView";
    return;
  }
  if( ObjectType :: eShaderModule == p ) {
    j = "ShaderModule";
    return;
  }
  if( ObjectType :: ePipelineCache == p ) {
    j = "PipelineCache";
    return;
  }
  if( ObjectType :: ePipelineLayout == p ) {
    j = "PipelineLayout";
    return;
  }
  if( ObjectType :: eRenderPass == p ) {
    j = "RenderPass";
    return;
  }
  if( ObjectType :: ePipeline == p ) {
    j = "Pipeline";
    return;
  }
  if( ObjectType :: eDescriptorSetLayout == p ) {
    j = "DescriptorSetLayout";
    return;
  }
  if( ObjectType :: eSampler == p ) {
    j = "Sampler";
    return;
  }
  if( ObjectType :: eDescriptorPool == p ) {
    j = "DescriptorPool";
    return;
  }
  if( ObjectType :: eDescriptorSet == p ) {
    j = "DescriptorSet";
    return;
  }
  if( ObjectType :: eFramebuffer == p ) {
    j = "Framebuffer";
    return;
  }
  if( ObjectType :: eCommandPool == p ) {
    j = "CommandPool";
    return;
  }
  if( ObjectType :: eSamplerYcbcrConversion == p ) {
    j = "SamplerYcbcrConversion";
    return;
  }
  if( ObjectType :: eDescriptorUpdateTemplate == p ) {
    j = "DescriptorUpdateTemplate";
    return;
  }
  if( ObjectType :: eSurfaceKHR == p ) {
    j = "SurfaceKHR";
    return;
  }
  if( ObjectType :: eSwapchainKHR == p ) {
    j = "SwapchainKHR";
    return;
  }
  if( ObjectType :: eDisplayKHR == p ) {
    j = "DisplayKHR";
    return;
  }
  if( ObjectType :: eDisplayModeKHR == p ) {
    j = "DisplayModeKHR";
    return;
  }
  if( ObjectType :: eDebugReportCallbackEXT == p ) {
    j = "DebugReportCallbackEXT";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( ObjectType :: eVideoSessionKHR == p ) {
    j = "VideoSessionKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( ObjectType :: eVideoSessionParametersKHR == p ) {
    j = "VideoSessionParametersKHR";
    return;
  }
#endif
  if( ObjectType :: eCuModuleNVX == p ) {
    j = "CuModuleNVX";
    return;
  }
  if( ObjectType :: eCuFunctionNVX == p ) {
    j = "CuFunctionNVX";
    return;
  }
  if( ObjectType :: eDebugUtilsMessengerEXT == p ) {
    j = "DebugUtilsMessengerEXT";
    return;
  }
  if( ObjectType :: eAccelerationStructureKHR == p ) {
    j = "AccelerationStructureKHR";
    return;
  }
  if( ObjectType :: eValidationCacheEXT == p ) {
    j = "ValidationCacheEXT";
    return;
  }
  if( ObjectType :: eAccelerationStructureNV == p ) {
    j = "AccelerationStructureNV";
    return;
  }
  if( ObjectType :: ePerformanceConfigurationINTEL == p ) {
    j = "PerformanceConfigurationINTEL";
    return;
  }
  if( ObjectType :: eDeferredOperationKHR == p ) {
    j = "DeferredOperationKHR";
    return;
  }
  if( ObjectType :: eIndirectCommandsLayoutNV == p ) {
    j = "IndirectCommandsLayoutNV";
    return;
  }
  if( ObjectType :: ePrivateDataSlotEXT == p ) {
    j = "PrivateDataSlotEXT";
    return;
  }
  if( ObjectType :: eDescriptorUpdateTemplateKHR == p ) {
    j = "DescriptorUpdateTemplateKHR";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkObjectType &p ) {
  to_json( j, ObjectType ( p ) );
}
inline void from_json( const nlohmann::json &j, ObjectType &p ) {
  if( j.is_string() ) {
    if( "Unknown" == j.get< std::string >() ) {
      p = ObjectType :: eUnknown ;
      return;
    }
    if( "eUnknown" == j.get< std::string >() ) {
      p = ObjectType :: eUnknown ;
      return;
    }
    if( "VK_OBJECT_TYPE_UNKNOWN" == j.get< std::string >() ) {
      p = ObjectType :: eUnknown ;
      return;
    }
    if( "Instance" == j.get< std::string >() ) {
      p = ObjectType :: eInstance ;
      return;
    }
    if( "eInstance" == j.get< std::string >() ) {
      p = ObjectType :: eInstance ;
      return;
    }
    if( "VK_OBJECT_TYPE_INSTANCE" == j.get< std::string >() ) {
      p = ObjectType :: eInstance ;
      return;
    }
    if( "PhysicalDevice" == j.get< std::string >() ) {
      p = ObjectType :: ePhysicalDevice ;
      return;
    }
    if( "ePhysicalDevice" == j.get< std::string >() ) {
      p = ObjectType :: ePhysicalDevice ;
      return;
    }
    if( "VK_OBJECT_TYPE_PHYSICAL_DEVICE" == j.get< std::string >() ) {
      p = ObjectType :: ePhysicalDevice ;
      return;
    }
    if( "Device" == j.get< std::string >() ) {
      p = ObjectType :: eDevice ;
      return;
    }
    if( "eDevice" == j.get< std::string >() ) {
      p = ObjectType :: eDevice ;
      return;
    }
    if( "VK_OBJECT_TYPE_DEVICE" == j.get< std::string >() ) {
      p = ObjectType :: eDevice ;
      return;
    }
    if( "Queue" == j.get< std::string >() ) {
      p = ObjectType :: eQueue ;
      return;
    }
    if( "eQueue" == j.get< std::string >() ) {
      p = ObjectType :: eQueue ;
      return;
    }
    if( "VK_OBJECT_TYPE_QUEUE" == j.get< std::string >() ) {
      p = ObjectType :: eQueue ;
      return;
    }
    if( "Semaphore" == j.get< std::string >() ) {
      p = ObjectType :: eSemaphore ;
      return;
    }
    if( "eSemaphore" == j.get< std::string >() ) {
      p = ObjectType :: eSemaphore ;
      return;
    }
    if( "VK_OBJECT_TYPE_SEMAPHORE" == j.get< std::string >() ) {
      p = ObjectType :: eSemaphore ;
      return;
    }
    if( "CommandBuffer" == j.get< std::string >() ) {
      p = ObjectType :: eCommandBuffer ;
      return;
    }
    if( "eCommandBuffer" == j.get< std::string >() ) {
      p = ObjectType :: eCommandBuffer ;
      return;
    }
    if( "VK_OBJECT_TYPE_COMMAND_BUFFER" == j.get< std::string >() ) {
      p = ObjectType :: eCommandBuffer ;
      return;
    }
    if( "Fence" == j.get< std::string >() ) {
      p = ObjectType :: eFence ;
      return;
    }
    if( "eFence" == j.get< std::string >() ) {
      p = ObjectType :: eFence ;
      return;
    }
    if( "VK_OBJECT_TYPE_FENCE" == j.get< std::string >() ) {
      p = ObjectType :: eFence ;
      return;
    }
    if( "DeviceMemory" == j.get< std::string >() ) {
      p = ObjectType :: eDeviceMemory ;
      return;
    }
    if( "eDeviceMemory" == j.get< std::string >() ) {
      p = ObjectType :: eDeviceMemory ;
      return;
    }
    if( "VK_OBJECT_TYPE_DEVICE_MEMORY" == j.get< std::string >() ) {
      p = ObjectType :: eDeviceMemory ;
      return;
    }
    if( "Buffer" == j.get< std::string >() ) {
      p = ObjectType :: eBuffer ;
      return;
    }
    if( "eBuffer" == j.get< std::string >() ) {
      p = ObjectType :: eBuffer ;
      return;
    }
    if( "VK_OBJECT_TYPE_BUFFER" == j.get< std::string >() ) {
      p = ObjectType :: eBuffer ;
      return;
    }
    if( "Image" == j.get< std::string >() ) {
      p = ObjectType :: eImage ;
      return;
    }
    if( "eImage" == j.get< std::string >() ) {
      p = ObjectType :: eImage ;
      return;
    }
    if( "VK_OBJECT_TYPE_IMAGE" == j.get< std::string >() ) {
      p = ObjectType :: eImage ;
      return;
    }
    if( "Event" == j.get< std::string >() ) {
      p = ObjectType :: eEvent ;
      return;
    }
    if( "eEvent" == j.get< std::string >() ) {
      p = ObjectType :: eEvent ;
      return;
    }
    if( "VK_OBJECT_TYPE_EVENT" == j.get< std::string >() ) {
      p = ObjectType :: eEvent ;
      return;
    }
    if( "QueryPool" == j.get< std::string >() ) {
      p = ObjectType :: eQueryPool ;
      return;
    }
    if( "eQueryPool" == j.get< std::string >() ) {
      p = ObjectType :: eQueryPool ;
      return;
    }
    if( "VK_OBJECT_TYPE_QUERY_POOL" == j.get< std::string >() ) {
      p = ObjectType :: eQueryPool ;
      return;
    }
    if( "BufferView" == j.get< std::string >() ) {
      p = ObjectType :: eBufferView ;
      return;
    }
    if( "eBufferView" == j.get< std::string >() ) {
      p = ObjectType :: eBufferView ;
      return;
    }
    if( "VK_OBJECT_TYPE_BUFFER_VIEW" == j.get< std::string >() ) {
      p = ObjectType :: eBufferView ;
      return;
    }
    if( "ImageView" == j.get< std::string >() ) {
      p = ObjectType :: eImageView ;
      return;
    }
    if( "eImageView" == j.get< std::string >() ) {
      p = ObjectType :: eImageView ;
      return;
    }
    if( "VK_OBJECT_TYPE_IMAGE_VIEW" == j.get< std::string >() ) {
      p = ObjectType :: eImageView ;
      return;
    }
    if( "ShaderModule" == j.get< std::string >() ) {
      p = ObjectType :: eShaderModule ;
      return;
    }
    if( "eShaderModule" == j.get< std::string >() ) {
      p = ObjectType :: eShaderModule ;
      return;
    }
    if( "VK_OBJECT_TYPE_SHADER_MODULE" == j.get< std::string >() ) {
      p = ObjectType :: eShaderModule ;
      return;
    }
    if( "PipelineCache" == j.get< std::string >() ) {
      p = ObjectType :: ePipelineCache ;
      return;
    }
    if( "ePipelineCache" == j.get< std::string >() ) {
      p = ObjectType :: ePipelineCache ;
      return;
    }
    if( "VK_OBJECT_TYPE_PIPELINE_CACHE" == j.get< std::string >() ) {
      p = ObjectType :: ePipelineCache ;
      return;
    }
    if( "PipelineLayout" == j.get< std::string >() ) {
      p = ObjectType :: ePipelineLayout ;
      return;
    }
    if( "ePipelineLayout" == j.get< std::string >() ) {
      p = ObjectType :: ePipelineLayout ;
      return;
    }
    if( "VK_OBJECT_TYPE_PIPELINE_LAYOUT" == j.get< std::string >() ) {
      p = ObjectType :: ePipelineLayout ;
      return;
    }
    if( "RenderPass" == j.get< std::string >() ) {
      p = ObjectType :: eRenderPass ;
      return;
    }
    if( "eRenderPass" == j.get< std::string >() ) {
      p = ObjectType :: eRenderPass ;
      return;
    }
    if( "VK_OBJECT_TYPE_RENDER_PASS" == j.get< std::string >() ) {
      p = ObjectType :: eRenderPass ;
      return;
    }
    if( "Pipeline" == j.get< std::string >() ) {
      p = ObjectType :: ePipeline ;
      return;
    }
    if( "ePipeline" == j.get< std::string >() ) {
      p = ObjectType :: ePipeline ;
      return;
    }
    if( "VK_OBJECT_TYPE_PIPELINE" == j.get< std::string >() ) {
      p = ObjectType :: ePipeline ;
      return;
    }
    if( "DescriptorSetLayout" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorSetLayout ;
      return;
    }
    if( "eDescriptorSetLayout" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorSetLayout ;
      return;
    }
    if( "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorSetLayout ;
      return;
    }
    if( "Sampler" == j.get< std::string >() ) {
      p = ObjectType :: eSampler ;
      return;
    }
    if( "eSampler" == j.get< std::string >() ) {
      p = ObjectType :: eSampler ;
      return;
    }
    if( "VK_OBJECT_TYPE_SAMPLER" == j.get< std::string >() ) {
      p = ObjectType :: eSampler ;
      return;
    }
    if( "DescriptorPool" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorPool ;
      return;
    }
    if( "eDescriptorPool" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorPool ;
      return;
    }
    if( "VK_OBJECT_TYPE_DESCRIPTOR_POOL" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorPool ;
      return;
    }
    if( "DescriptorSet" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorSet ;
      return;
    }
    if( "eDescriptorSet" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorSet ;
      return;
    }
    if( "VK_OBJECT_TYPE_DESCRIPTOR_SET" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorSet ;
      return;
    }
    if( "Framebuffer" == j.get< std::string >() ) {
      p = ObjectType :: eFramebuffer ;
      return;
    }
    if( "eFramebuffer" == j.get< std::string >() ) {
      p = ObjectType :: eFramebuffer ;
      return;
    }
    if( "VK_OBJECT_TYPE_FRAMEBUFFER" == j.get< std::string >() ) {
      p = ObjectType :: eFramebuffer ;
      return;
    }
    if( "CommandPool" == j.get< std::string >() ) {
      p = ObjectType :: eCommandPool ;
      return;
    }
    if( "eCommandPool" == j.get< std::string >() ) {
      p = ObjectType :: eCommandPool ;
      return;
    }
    if( "VK_OBJECT_TYPE_COMMAND_POOL" == j.get< std::string >() ) {
      p = ObjectType :: eCommandPool ;
      return;
    }
    if( "SamplerYcbcrConversion" == j.get< std::string >() ) {
      p = ObjectType :: eSamplerYcbcrConversion ;
      return;
    }
    if( "eSamplerYcbcrConversion" == j.get< std::string >() ) {
      p = ObjectType :: eSamplerYcbcrConversion ;
      return;
    }
    if( "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION" == j.get< std::string >() ) {
      p = ObjectType :: eSamplerYcbcrConversion ;
      return;
    }
    if( "DescriptorUpdateTemplate" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorUpdateTemplate ;
      return;
    }
    if( "eDescriptorUpdateTemplate" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorUpdateTemplate ;
      return;
    }
    if( "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorUpdateTemplate ;
      return;
    }
    if( "SurfaceKHR" == j.get< std::string >() ) {
      p = ObjectType :: eSurfaceKHR ;
      return;
    }
    if( "eSurfaceKHR" == j.get< std::string >() ) {
      p = ObjectType :: eSurfaceKHR ;
      return;
    }
    if( "VK_OBJECT_TYPE_SURFACE_KHR" == j.get< std::string >() ) {
      p = ObjectType :: eSurfaceKHR ;
      return;
    }
    if( "SwapchainKHR" == j.get< std::string >() ) {
      p = ObjectType :: eSwapchainKHR ;
      return;
    }
    if( "eSwapchainKHR" == j.get< std::string >() ) {
      p = ObjectType :: eSwapchainKHR ;
      return;
    }
    if( "VK_OBJECT_TYPE_SWAPCHAIN_KHR" == j.get< std::string >() ) {
      p = ObjectType :: eSwapchainKHR ;
      return;
    }
    if( "DisplayKHR" == j.get< std::string >() ) {
      p = ObjectType :: eDisplayKHR ;
      return;
    }
    if( "eDisplayKHR" == j.get< std::string >() ) {
      p = ObjectType :: eDisplayKHR ;
      return;
    }
    if( "VK_OBJECT_TYPE_DISPLAY_KHR" == j.get< std::string >() ) {
      p = ObjectType :: eDisplayKHR ;
      return;
    }
    if( "DisplayModeKHR" == j.get< std::string >() ) {
      p = ObjectType :: eDisplayModeKHR ;
      return;
    }
    if( "eDisplayModeKHR" == j.get< std::string >() ) {
      p = ObjectType :: eDisplayModeKHR ;
      return;
    }
    if( "VK_OBJECT_TYPE_DISPLAY_MODE_KHR" == j.get< std::string >() ) {
      p = ObjectType :: eDisplayModeKHR ;
      return;
    }
    if( "DebugReportCallbackEXT" == j.get< std::string >() ) {
      p = ObjectType :: eDebugReportCallbackEXT ;
      return;
    }
    if( "eDebugReportCallbackEXT" == j.get< std::string >() ) {
      p = ObjectType :: eDebugReportCallbackEXT ;
      return;
    }
    if( "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT" == j.get< std::string >() ) {
      p = ObjectType :: eDebugReportCallbackEXT ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoSessionKHR" == j.get< std::string >() ) {
      p = ObjectType :: eVideoSessionKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoSessionKHR" == j.get< std::string >() ) {
      p = ObjectType :: eVideoSessionKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_OBJECT_TYPE_VIDEO_SESSION_KHR" == j.get< std::string >() ) {
      p = ObjectType :: eVideoSessionKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoSessionParametersKHR" == j.get< std::string >() ) {
      p = ObjectType :: eVideoSessionParametersKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoSessionParametersKHR" == j.get< std::string >() ) {
      p = ObjectType :: eVideoSessionParametersKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR" == j.get< std::string >() ) {
      p = ObjectType :: eVideoSessionParametersKHR ;
      return;
    }
#endif
    if( "CuModuleNVX" == j.get< std::string >() ) {
      p = ObjectType :: eCuModuleNVX ;
      return;
    }
    if( "eCuModuleNVX" == j.get< std::string >() ) {
      p = ObjectType :: eCuModuleNVX ;
      return;
    }
    if( "VK_OBJECT_TYPE_CU_MODULE_NVX" == j.get< std::string >() ) {
      p = ObjectType :: eCuModuleNVX ;
      return;
    }
    if( "CuFunctionNVX" == j.get< std::string >() ) {
      p = ObjectType :: eCuFunctionNVX ;
      return;
    }
    if( "eCuFunctionNVX" == j.get< std::string >() ) {
      p = ObjectType :: eCuFunctionNVX ;
      return;
    }
    if( "VK_OBJECT_TYPE_CU_FUNCTION_NVX" == j.get< std::string >() ) {
      p = ObjectType :: eCuFunctionNVX ;
      return;
    }
    if( "DebugUtilsMessengerEXT" == j.get< std::string >() ) {
      p = ObjectType :: eDebugUtilsMessengerEXT ;
      return;
    }
    if( "eDebugUtilsMessengerEXT" == j.get< std::string >() ) {
      p = ObjectType :: eDebugUtilsMessengerEXT ;
      return;
    }
    if( "VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT" == j.get< std::string >() ) {
      p = ObjectType :: eDebugUtilsMessengerEXT ;
      return;
    }
    if( "AccelerationStructureKHR" == j.get< std::string >() ) {
      p = ObjectType :: eAccelerationStructureKHR ;
      return;
    }
    if( "eAccelerationStructureKHR" == j.get< std::string >() ) {
      p = ObjectType :: eAccelerationStructureKHR ;
      return;
    }
    if( "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR" == j.get< std::string >() ) {
      p = ObjectType :: eAccelerationStructureKHR ;
      return;
    }
    if( "ValidationCacheEXT" == j.get< std::string >() ) {
      p = ObjectType :: eValidationCacheEXT ;
      return;
    }
    if( "eValidationCacheEXT" == j.get< std::string >() ) {
      p = ObjectType :: eValidationCacheEXT ;
      return;
    }
    if( "VK_OBJECT_TYPE_VALIDATION_CACHE_EXT" == j.get< std::string >() ) {
      p = ObjectType :: eValidationCacheEXT ;
      return;
    }
    if( "AccelerationStructureNV" == j.get< std::string >() ) {
      p = ObjectType :: eAccelerationStructureNV ;
      return;
    }
    if( "eAccelerationStructureNV" == j.get< std::string >() ) {
      p = ObjectType :: eAccelerationStructureNV ;
      return;
    }
    if( "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV" == j.get< std::string >() ) {
      p = ObjectType :: eAccelerationStructureNV ;
      return;
    }
    if( "PerformanceConfigurationINTEL" == j.get< std::string >() ) {
      p = ObjectType :: ePerformanceConfigurationINTEL ;
      return;
    }
    if( "ePerformanceConfigurationINTEL" == j.get< std::string >() ) {
      p = ObjectType :: ePerformanceConfigurationINTEL ;
      return;
    }
    if( "VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL" == j.get< std::string >() ) {
      p = ObjectType :: ePerformanceConfigurationINTEL ;
      return;
    }
    if( "DeferredOperationKHR" == j.get< std::string >() ) {
      p = ObjectType :: eDeferredOperationKHR ;
      return;
    }
    if( "eDeferredOperationKHR" == j.get< std::string >() ) {
      p = ObjectType :: eDeferredOperationKHR ;
      return;
    }
    if( "VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR" == j.get< std::string >() ) {
      p = ObjectType :: eDeferredOperationKHR ;
      return;
    }
    if( "IndirectCommandsLayoutNV" == j.get< std::string >() ) {
      p = ObjectType :: eIndirectCommandsLayoutNV ;
      return;
    }
    if( "eIndirectCommandsLayoutNV" == j.get< std::string >() ) {
      p = ObjectType :: eIndirectCommandsLayoutNV ;
      return;
    }
    if( "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV" == j.get< std::string >() ) {
      p = ObjectType :: eIndirectCommandsLayoutNV ;
      return;
    }
    if( "PrivateDataSlotEXT" == j.get< std::string >() ) {
      p = ObjectType :: ePrivateDataSlotEXT ;
      return;
    }
    if( "ePrivateDataSlotEXT" == j.get< std::string >() ) {
      p = ObjectType :: ePrivateDataSlotEXT ;
      return;
    }
    if( "VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT" == j.get< std::string >() ) {
      p = ObjectType :: ePrivateDataSlotEXT ;
      return;
    }
    if( "DescriptorUpdateTemplateKHR" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorUpdateTemplateKHR ;
      return;
    }
    if( "eDescriptorUpdateTemplateKHR" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorUpdateTemplateKHR ;
      return;
    }
    if( "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR" == j.get< std::string >() ) {
      p = ObjectType :: eDescriptorUpdateTemplateKHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ObjectType" );
  }
  if( j.is_number() ) {
    p = ObjectType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ObjectType" );
}
inline void from_json( const nlohmann::json &j, VkObjectType &p ) {
  ObjectType temp;
  from_json( j, temp );
  p = VkObjectType ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const VendorId &p ) {
  if( VendorId :: eVIV == p ) {
    j = "VIV";
    return;
  }
  if( VendorId :: eVSI == p ) {
    j = "VSI";
    return;
  }
  if( VendorId :: eKazan == p ) {
    j = "Kazan";
    return;
  }
  if( VendorId :: eCodeplay == p ) {
    j = "Codeplay";
    return;
  }
  if( VendorId :: eMESA == p ) {
    j = "MESA";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkVendorId &p ) {
  to_json( j, VendorId ( p ) );
}
inline void from_json( const nlohmann::json &j, VendorId &p ) {
  if( j.is_string() ) {
    if( "VIV" == j.get< std::string >() ) {
      p = VendorId :: eVIV ;
      return;
    }
    if( "eVIV" == j.get< std::string >() ) {
      p = VendorId :: eVIV ;
      return;
    }
    if( "VK_VENDOR_ID_VIV" == j.get< std::string >() ) {
      p = VendorId :: eVIV ;
      return;
    }
    if( "VSI" == j.get< std::string >() ) {
      p = VendorId :: eVSI ;
      return;
    }
    if( "eVSI" == j.get< std::string >() ) {
      p = VendorId :: eVSI ;
      return;
    }
    if( "VK_VENDOR_ID_VSI" == j.get< std::string >() ) {
      p = VendorId :: eVSI ;
      return;
    }
    if( "Kazan" == j.get< std::string >() ) {
      p = VendorId :: eKazan ;
      return;
    }
    if( "eKazan" == j.get< std::string >() ) {
      p = VendorId :: eKazan ;
      return;
    }
    if( "VK_VENDOR_ID_KAZAN" == j.get< std::string >() ) {
      p = VendorId :: eKazan ;
      return;
    }
    if( "Codeplay" == j.get< std::string >() ) {
      p = VendorId :: eCodeplay ;
      return;
    }
    if( "eCodeplay" == j.get< std::string >() ) {
      p = VendorId :: eCodeplay ;
      return;
    }
    if( "VK_VENDOR_ID_CODEPLAY" == j.get< std::string >() ) {
      p = VendorId :: eCodeplay ;
      return;
    }
    if( "MESA" == j.get< std::string >() ) {
      p = VendorId :: eMESA ;
      return;
    }
    if( "eMESA" == j.get< std::string >() ) {
      p = VendorId :: eMESA ;
      return;
    }
    if( "VK_VENDOR_ID_MESA" == j.get< std::string >() ) {
      p = VendorId :: eMESA ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for VendorId" );
  }
  if( j.is_number() ) {
    p = VendorId ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VendorId" );
}
inline void from_json( const nlohmann::json &j, VkVendorId &p ) {
  VendorId temp;
  from_json( j, temp );
  p = VkVendorId ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineCacheHeaderVersion &p ) {
}
inline void to_json( nlohmann::json &j, const VkPipelineCacheHeaderVersion &p ) {
  to_json( j, PipelineCacheHeaderVersion ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineCacheHeaderVersion &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCacheHeaderVersion" );
  }
  if( j.is_number() ) {
    p = PipelineCacheHeaderVersion ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCacheHeaderVersion" );
}
inline void from_json( const nlohmann::json &j, VkPipelineCacheHeaderVersion &p ) {
  PipelineCacheHeaderVersion temp;
  from_json( j, temp );
  p = VkPipelineCacheHeaderVersion ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const Format &p ) {
  if( Format :: eUndefined == p ) {
    j = "Undefined";
    return;
  }
  if( Format :: eR4G4UnormPack8 == p ) {
    j = "R4G4UnormPack8";
    return;
  }
  if( Format :: eR4G4B4A4UnormPack16 == p ) {
    j = "R4G4B4A4UnormPack16";
    return;
  }
  if( Format :: eB4G4R4A4UnormPack16 == p ) {
    j = "B4G4R4A4UnormPack16";
    return;
  }
  if( Format :: eR5G6B5UnormPack16 == p ) {
    j = "R5G6B5UnormPack16";
    return;
  }
  if( Format :: eB5G6R5UnormPack16 == p ) {
    j = "B5G6R5UnormPack16";
    return;
  }
  if( Format :: eR5G5B5A1UnormPack16 == p ) {
    j = "R5G5B5A1UnormPack16";
    return;
  }
  if( Format :: eB5G5R5A1UnormPack16 == p ) {
    j = "B5G5R5A1UnormPack16";
    return;
  }
  if( Format :: eA1R5G5B5UnormPack16 == p ) {
    j = "A1R5G5B5UnormPack16";
    return;
  }
  if( Format :: eR8Unorm == p ) {
    j = "R8Unorm";
    return;
  }
  if( Format :: eR8Snorm == p ) {
    j = "R8Snorm";
    return;
  }
  if( Format :: eR8Uscaled == p ) {
    j = "R8Uscaled";
    return;
  }
  if( Format :: eR8Sscaled == p ) {
    j = "R8Sscaled";
    return;
  }
  if( Format :: eR8Uint == p ) {
    j = "R8Uint";
    return;
  }
  if( Format :: eR8Sint == p ) {
    j = "R8Sint";
    return;
  }
  if( Format :: eR8Srgb == p ) {
    j = "R8Srgb";
    return;
  }
  if( Format :: eR8G8Unorm == p ) {
    j = "R8G8Unorm";
    return;
  }
  if( Format :: eR8G8Snorm == p ) {
    j = "R8G8Snorm";
    return;
  }
  if( Format :: eR8G8Uscaled == p ) {
    j = "R8G8Uscaled";
    return;
  }
  if( Format :: eR8G8Sscaled == p ) {
    j = "R8G8Sscaled";
    return;
  }
  if( Format :: eR8G8Uint == p ) {
    j = "R8G8Uint";
    return;
  }
  if( Format :: eR8G8Sint == p ) {
    j = "R8G8Sint";
    return;
  }
  if( Format :: eR8G8Srgb == p ) {
    j = "R8G8Srgb";
    return;
  }
  if( Format :: eR8G8B8Unorm == p ) {
    j = "R8G8B8Unorm";
    return;
  }
  if( Format :: eR8G8B8Snorm == p ) {
    j = "R8G8B8Snorm";
    return;
  }
  if( Format :: eR8G8B8Uscaled == p ) {
    j = "R8G8B8Uscaled";
    return;
  }
  if( Format :: eR8G8B8Sscaled == p ) {
    j = "R8G8B8Sscaled";
    return;
  }
  if( Format :: eR8G8B8Uint == p ) {
    j = "R8G8B8Uint";
    return;
  }
  if( Format :: eR8G8B8Sint == p ) {
    j = "R8G8B8Sint";
    return;
  }
  if( Format :: eR8G8B8Srgb == p ) {
    j = "R8G8B8Srgb";
    return;
  }
  if( Format :: eB8G8R8Unorm == p ) {
    j = "B8G8R8Unorm";
    return;
  }
  if( Format :: eB8G8R8Snorm == p ) {
    j = "B8G8R8Snorm";
    return;
  }
  if( Format :: eB8G8R8Uscaled == p ) {
    j = "B8G8R8Uscaled";
    return;
  }
  if( Format :: eB8G8R8Sscaled == p ) {
    j = "B8G8R8Sscaled";
    return;
  }
  if( Format :: eB8G8R8Uint == p ) {
    j = "B8G8R8Uint";
    return;
  }
  if( Format :: eB8G8R8Sint == p ) {
    j = "B8G8R8Sint";
    return;
  }
  if( Format :: eB8G8R8Srgb == p ) {
    j = "B8G8R8Srgb";
    return;
  }
  if( Format :: eR8G8B8A8Unorm == p ) {
    j = "R8G8B8A8Unorm";
    return;
  }
  if( Format :: eR8G8B8A8Snorm == p ) {
    j = "R8G8B8A8Snorm";
    return;
  }
  if( Format :: eR8G8B8A8Uscaled == p ) {
    j = "R8G8B8A8Uscaled";
    return;
  }
  if( Format :: eR8G8B8A8Sscaled == p ) {
    j = "R8G8B8A8Sscaled";
    return;
  }
  if( Format :: eR8G8B8A8Uint == p ) {
    j = "R8G8B8A8Uint";
    return;
  }
  if( Format :: eR8G8B8A8Sint == p ) {
    j = "R8G8B8A8Sint";
    return;
  }
  if( Format :: eR8G8B8A8Srgb == p ) {
    j = "R8G8B8A8Srgb";
    return;
  }
  if( Format :: eB8G8R8A8Unorm == p ) {
    j = "B8G8R8A8Unorm";
    return;
  }
  if( Format :: eB8G8R8A8Snorm == p ) {
    j = "B8G8R8A8Snorm";
    return;
  }
  if( Format :: eB8G8R8A8Uscaled == p ) {
    j = "B8G8R8A8Uscaled";
    return;
  }
  if( Format :: eB8G8R8A8Sscaled == p ) {
    j = "B8G8R8A8Sscaled";
    return;
  }
  if( Format :: eB8G8R8A8Uint == p ) {
    j = "B8G8R8A8Uint";
    return;
  }
  if( Format :: eB8G8R8A8Sint == p ) {
    j = "B8G8R8A8Sint";
    return;
  }
  if( Format :: eB8G8R8A8Srgb == p ) {
    j = "B8G8R8A8Srgb";
    return;
  }
  if( Format :: eA8B8G8R8UnormPack32 == p ) {
    j = "A8B8G8R8UnormPack32";
    return;
  }
  if( Format :: eA8B8G8R8SnormPack32 == p ) {
    j = "A8B8G8R8SnormPack32";
    return;
  }
  if( Format :: eA8B8G8R8UscaledPack32 == p ) {
    j = "A8B8G8R8UscaledPack32";
    return;
  }
  if( Format :: eA8B8G8R8SscaledPack32 == p ) {
    j = "A8B8G8R8SscaledPack32";
    return;
  }
  if( Format :: eA8B8G8R8UintPack32 == p ) {
    j = "A8B8G8R8UintPack32";
    return;
  }
  if( Format :: eA8B8G8R8SintPack32 == p ) {
    j = "A8B8G8R8SintPack32";
    return;
  }
  if( Format :: eA8B8G8R8SrgbPack32 == p ) {
    j = "A8B8G8R8SrgbPack32";
    return;
  }
  if( Format :: eA2R10G10B10UnormPack32 == p ) {
    j = "A2R10G10B10UnormPack32";
    return;
  }
  if( Format :: eA2R10G10B10SnormPack32 == p ) {
    j = "A2R10G10B10SnormPack32";
    return;
  }
  if( Format :: eA2R10G10B10UscaledPack32 == p ) {
    j = "A2R10G10B10UscaledPack32";
    return;
  }
  if( Format :: eA2R10G10B10SscaledPack32 == p ) {
    j = "A2R10G10B10SscaledPack32";
    return;
  }
  if( Format :: eA2R10G10B10UintPack32 == p ) {
    j = "A2R10G10B10UintPack32";
    return;
  }
  if( Format :: eA2R10G10B10SintPack32 == p ) {
    j = "A2R10G10B10SintPack32";
    return;
  }
  if( Format :: eA2B10G10R10UnormPack32 == p ) {
    j = "A2B10G10R10UnormPack32";
    return;
  }
  if( Format :: eA2B10G10R10SnormPack32 == p ) {
    j = "A2B10G10R10SnormPack32";
    return;
  }
  if( Format :: eA2B10G10R10UscaledPack32 == p ) {
    j = "A2B10G10R10UscaledPack32";
    return;
  }
  if( Format :: eA2B10G10R10SscaledPack32 == p ) {
    j = "A2B10G10R10SscaledPack32";
    return;
  }
  if( Format :: eA2B10G10R10UintPack32 == p ) {
    j = "A2B10G10R10UintPack32";
    return;
  }
  if( Format :: eA2B10G10R10SintPack32 == p ) {
    j = "A2B10G10R10SintPack32";
    return;
  }
  if( Format :: eR16Unorm == p ) {
    j = "R16Unorm";
    return;
  }
  if( Format :: eR16Snorm == p ) {
    j = "R16Snorm";
    return;
  }
  if( Format :: eR16Uscaled == p ) {
    j = "R16Uscaled";
    return;
  }
  if( Format :: eR16Sscaled == p ) {
    j = "R16Sscaled";
    return;
  }
  if( Format :: eR16Uint == p ) {
    j = "R16Uint";
    return;
  }
  if( Format :: eR16Sint == p ) {
    j = "R16Sint";
    return;
  }
  if( Format :: eR16Sfloat == p ) {
    j = "R16Sfloat";
    return;
  }
  if( Format :: eR16G16Unorm == p ) {
    j = "R16G16Unorm";
    return;
  }
  if( Format :: eR16G16Snorm == p ) {
    j = "R16G16Snorm";
    return;
  }
  if( Format :: eR16G16Uscaled == p ) {
    j = "R16G16Uscaled";
    return;
  }
  if( Format :: eR16G16Sscaled == p ) {
    j = "R16G16Sscaled";
    return;
  }
  if( Format :: eR16G16Uint == p ) {
    j = "R16G16Uint";
    return;
  }
  if( Format :: eR16G16Sint == p ) {
    j = "R16G16Sint";
    return;
  }
  if( Format :: eR16G16Sfloat == p ) {
    j = "R16G16Sfloat";
    return;
  }
  if( Format :: eR16G16B16Unorm == p ) {
    j = "R16G16B16Unorm";
    return;
  }
  if( Format :: eR16G16B16Snorm == p ) {
    j = "R16G16B16Snorm";
    return;
  }
  if( Format :: eR16G16B16Uscaled == p ) {
    j = "R16G16B16Uscaled";
    return;
  }
  if( Format :: eR16G16B16Sscaled == p ) {
    j = "R16G16B16Sscaled";
    return;
  }
  if( Format :: eR16G16B16Uint == p ) {
    j = "R16G16B16Uint";
    return;
  }
  if( Format :: eR16G16B16Sint == p ) {
    j = "R16G16B16Sint";
    return;
  }
  if( Format :: eR16G16B16Sfloat == p ) {
    j = "R16G16B16Sfloat";
    return;
  }
  if( Format :: eR16G16B16A16Unorm == p ) {
    j = "R16G16B16A16Unorm";
    return;
  }
  if( Format :: eR16G16B16A16Snorm == p ) {
    j = "R16G16B16A16Snorm";
    return;
  }
  if( Format :: eR16G16B16A16Uscaled == p ) {
    j = "R16G16B16A16Uscaled";
    return;
  }
  if( Format :: eR16G16B16A16Sscaled == p ) {
    j = "R16G16B16A16Sscaled";
    return;
  }
  if( Format :: eR16G16B16A16Uint == p ) {
    j = "R16G16B16A16Uint";
    return;
  }
  if( Format :: eR16G16B16A16Sint == p ) {
    j = "R16G16B16A16Sint";
    return;
  }
  if( Format :: eR16G16B16A16Sfloat == p ) {
    j = "R16G16B16A16Sfloat";
    return;
  }
  if( Format :: eR32Uint == p ) {
    j = "R32Uint";
    return;
  }
  if( Format :: eR32Sint == p ) {
    j = "R32Sint";
    return;
  }
  if( Format :: eR32Sfloat == p ) {
    j = "R32Sfloat";
    return;
  }
  if( Format :: eR32G32Uint == p ) {
    j = "R32G32Uint";
    return;
  }
  if( Format :: eR32G32Sint == p ) {
    j = "R32G32Sint";
    return;
  }
  if( Format :: eR32G32Sfloat == p ) {
    j = "R32G32Sfloat";
    return;
  }
  if( Format :: eR32G32B32Uint == p ) {
    j = "R32G32B32Uint";
    return;
  }
  if( Format :: eR32G32B32Sint == p ) {
    j = "R32G32B32Sint";
    return;
  }
  if( Format :: eR32G32B32Sfloat == p ) {
    j = "R32G32B32Sfloat";
    return;
  }
  if( Format :: eR32G32B32A32Uint == p ) {
    j = "R32G32B32A32Uint";
    return;
  }
  if( Format :: eR32G32B32A32Sint == p ) {
    j = "R32G32B32A32Sint";
    return;
  }
  if( Format :: eR32G32B32A32Sfloat == p ) {
    j = "R32G32B32A32Sfloat";
    return;
  }
  if( Format :: eR64Uint == p ) {
    j = "R64Uint";
    return;
  }
  if( Format :: eR64Sint == p ) {
    j = "R64Sint";
    return;
  }
  if( Format :: eR64Sfloat == p ) {
    j = "R64Sfloat";
    return;
  }
  if( Format :: eR64G64Uint == p ) {
    j = "R64G64Uint";
    return;
  }
  if( Format :: eR64G64Sint == p ) {
    j = "R64G64Sint";
    return;
  }
  if( Format :: eR64G64Sfloat == p ) {
    j = "R64G64Sfloat";
    return;
  }
  if( Format :: eR64G64B64Uint == p ) {
    j = "R64G64B64Uint";
    return;
  }
  if( Format :: eR64G64B64Sint == p ) {
    j = "R64G64B64Sint";
    return;
  }
  if( Format :: eR64G64B64Sfloat == p ) {
    j = "R64G64B64Sfloat";
    return;
  }
  if( Format :: eR64G64B64A64Uint == p ) {
    j = "R64G64B64A64Uint";
    return;
  }
  if( Format :: eR64G64B64A64Sint == p ) {
    j = "R64G64B64A64Sint";
    return;
  }
  if( Format :: eR64G64B64A64Sfloat == p ) {
    j = "R64G64B64A64Sfloat";
    return;
  }
  if( Format :: eB10G11R11UfloatPack32 == p ) {
    j = "B10G11R11UfloatPack32";
    return;
  }
  if( Format :: eE5B9G9R9UfloatPack32 == p ) {
    j = "E5B9G9R9UfloatPack32";
    return;
  }
  if( Format :: eD16Unorm == p ) {
    j = "D16Unorm";
    return;
  }
  if( Format :: eX8D24UnormPack32 == p ) {
    j = "X8D24UnormPack32";
    return;
  }
  if( Format :: eD32Sfloat == p ) {
    j = "D32Sfloat";
    return;
  }
  if( Format :: eS8Uint == p ) {
    j = "S8Uint";
    return;
  }
  if( Format :: eD16UnormS8Uint == p ) {
    j = "D16UnormS8Uint";
    return;
  }
  if( Format :: eD24UnormS8Uint == p ) {
    j = "D24UnormS8Uint";
    return;
  }
  if( Format :: eD32SfloatS8Uint == p ) {
    j = "D32SfloatS8Uint";
    return;
  }
  if( Format :: eBc1RgbUnormBlock == p ) {
    j = "Bc1RgbUnormBlock";
    return;
  }
  if( Format :: eBc1RgbSrgbBlock == p ) {
    j = "Bc1RgbSrgbBlock";
    return;
  }
  if( Format :: eBc1RgbaUnormBlock == p ) {
    j = "Bc1RgbaUnormBlock";
    return;
  }
  if( Format :: eBc1RgbaSrgbBlock == p ) {
    j = "Bc1RgbaSrgbBlock";
    return;
  }
  if( Format :: eBc2UnormBlock == p ) {
    j = "Bc2UnormBlock";
    return;
  }
  if( Format :: eBc2SrgbBlock == p ) {
    j = "Bc2SrgbBlock";
    return;
  }
  if( Format :: eBc3UnormBlock == p ) {
    j = "Bc3UnormBlock";
    return;
  }
  if( Format :: eBc3SrgbBlock == p ) {
    j = "Bc3SrgbBlock";
    return;
  }
  if( Format :: eBc4UnormBlock == p ) {
    j = "Bc4UnormBlock";
    return;
  }
  if( Format :: eBc4SnormBlock == p ) {
    j = "Bc4SnormBlock";
    return;
  }
  if( Format :: eBc5UnormBlock == p ) {
    j = "Bc5UnormBlock";
    return;
  }
  if( Format :: eBc5SnormBlock == p ) {
    j = "Bc5SnormBlock";
    return;
  }
  if( Format :: eBc6HUfloatBlock == p ) {
    j = "Bc6HUfloatBlock";
    return;
  }
  if( Format :: eBc6HSfloatBlock == p ) {
    j = "Bc6HSfloatBlock";
    return;
  }
  if( Format :: eBc7UnormBlock == p ) {
    j = "Bc7UnormBlock";
    return;
  }
  if( Format :: eBc7SrgbBlock == p ) {
    j = "Bc7SrgbBlock";
    return;
  }
  if( Format :: eEtc2R8G8B8UnormBlock == p ) {
    j = "Etc2R8G8B8UnormBlock";
    return;
  }
  if( Format :: eEtc2R8G8B8SrgbBlock == p ) {
    j = "Etc2R8G8B8SrgbBlock";
    return;
  }
  if( Format :: eEtc2R8G8B8A1UnormBlock == p ) {
    j = "Etc2R8G8B8A1UnormBlock";
    return;
  }
  if( Format :: eEtc2R8G8B8A1SrgbBlock == p ) {
    j = "Etc2R8G8B8A1SrgbBlock";
    return;
  }
  if( Format :: eEtc2R8G8B8A8UnormBlock == p ) {
    j = "Etc2R8G8B8A8UnormBlock";
    return;
  }
  if( Format :: eEtc2R8G8B8A8SrgbBlock == p ) {
    j = "Etc2R8G8B8A8SrgbBlock";
    return;
  }
  if( Format :: eEacR11UnormBlock == p ) {
    j = "EacR11UnormBlock";
    return;
  }
  if( Format :: eEacR11SnormBlock == p ) {
    j = "EacR11SnormBlock";
    return;
  }
  if( Format :: eEacR11G11UnormBlock == p ) {
    j = "EacR11G11UnormBlock";
    return;
  }
  if( Format :: eEacR11G11SnormBlock == p ) {
    j = "EacR11G11SnormBlock";
    return;
  }
  if( Format :: eAstc4x4UnormBlock == p ) {
    j = "Astc4x4UnormBlock";
    return;
  }
  if( Format :: eAstc4x4SrgbBlock == p ) {
    j = "Astc4x4SrgbBlock";
    return;
  }
  if( Format :: eAstc5x4UnormBlock == p ) {
    j = "Astc5x4UnormBlock";
    return;
  }
  if( Format :: eAstc5x4SrgbBlock == p ) {
    j = "Astc5x4SrgbBlock";
    return;
  }
  if( Format :: eAstc5x5UnormBlock == p ) {
    j = "Astc5x5UnormBlock";
    return;
  }
  if( Format :: eAstc5x5SrgbBlock == p ) {
    j = "Astc5x5SrgbBlock";
    return;
  }
  if( Format :: eAstc6x5UnormBlock == p ) {
    j = "Astc6x5UnormBlock";
    return;
  }
  if( Format :: eAstc6x5SrgbBlock == p ) {
    j = "Astc6x5SrgbBlock";
    return;
  }
  if( Format :: eAstc6x6UnormBlock == p ) {
    j = "Astc6x6UnormBlock";
    return;
  }
  if( Format :: eAstc6x6SrgbBlock == p ) {
    j = "Astc6x6SrgbBlock";
    return;
  }
  if( Format :: eAstc8x5UnormBlock == p ) {
    j = "Astc8x5UnormBlock";
    return;
  }
  if( Format :: eAstc8x5SrgbBlock == p ) {
    j = "Astc8x5SrgbBlock";
    return;
  }
  if( Format :: eAstc8x6UnormBlock == p ) {
    j = "Astc8x6UnormBlock";
    return;
  }
  if( Format :: eAstc8x6SrgbBlock == p ) {
    j = "Astc8x6SrgbBlock";
    return;
  }
  if( Format :: eAstc8x8UnormBlock == p ) {
    j = "Astc8x8UnormBlock";
    return;
  }
  if( Format :: eAstc8x8SrgbBlock == p ) {
    j = "Astc8x8SrgbBlock";
    return;
  }
  if( Format :: eAstc10x5UnormBlock == p ) {
    j = "Astc10x5UnormBlock";
    return;
  }
  if( Format :: eAstc10x5SrgbBlock == p ) {
    j = "Astc10x5SrgbBlock";
    return;
  }
  if( Format :: eAstc10x6UnormBlock == p ) {
    j = "Astc10x6UnormBlock";
    return;
  }
  if( Format :: eAstc10x6SrgbBlock == p ) {
    j = "Astc10x6SrgbBlock";
    return;
  }
  if( Format :: eAstc10x8UnormBlock == p ) {
    j = "Astc10x8UnormBlock";
    return;
  }
  if( Format :: eAstc10x8SrgbBlock == p ) {
    j = "Astc10x8SrgbBlock";
    return;
  }
  if( Format :: eAstc10x10UnormBlock == p ) {
    j = "Astc10x10UnormBlock";
    return;
  }
  if( Format :: eAstc10x10SrgbBlock == p ) {
    j = "Astc10x10SrgbBlock";
    return;
  }
  if( Format :: eAstc12x10UnormBlock == p ) {
    j = "Astc12x10UnormBlock";
    return;
  }
  if( Format :: eAstc12x10SrgbBlock == p ) {
    j = "Astc12x10SrgbBlock";
    return;
  }
  if( Format :: eAstc12x12UnormBlock == p ) {
    j = "Astc12x12UnormBlock";
    return;
  }
  if( Format :: eAstc12x12SrgbBlock == p ) {
    j = "Astc12x12SrgbBlock";
    return;
  }
  if( Format :: eG8B8G8R8422Unorm == p ) {
    j = "G8B8G8R8422Unorm";
    return;
  }
  if( Format :: eB8G8R8G8422Unorm == p ) {
    j = "B8G8R8G8422Unorm";
    return;
  }
  if( Format :: eG8B8R83Plane420Unorm == p ) {
    j = "G8B8R83Plane420Unorm";
    return;
  }
  if( Format :: eG8B8R82Plane420Unorm == p ) {
    j = "G8B8R82Plane420Unorm";
    return;
  }
  if( Format :: eG8B8R83Plane422Unorm == p ) {
    j = "G8B8R83Plane422Unorm";
    return;
  }
  if( Format :: eG8B8R82Plane422Unorm == p ) {
    j = "G8B8R82Plane422Unorm";
    return;
  }
  if( Format :: eG8B8R83Plane444Unorm == p ) {
    j = "G8B8R83Plane444Unorm";
    return;
  }
  if( Format :: eR10X6UnormPack16 == p ) {
    j = "R10X6UnormPack16";
    return;
  }
  if( Format :: eR10X6G10X6Unorm2Pack16 == p ) {
    j = "R10X6G10X6Unorm2Pack16";
    return;
  }
  if( Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16 == p ) {
    j = "R10X6G10X6B10X6A10X6Unorm4Pack16";
    return;
  }
  if( Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16 == p ) {
    j = "G10X6B10X6G10X6R10X6422Unorm4Pack16";
    return;
  }
  if( Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16 == p ) {
    j = "B10X6G10X6R10X6G10X6422Unorm4Pack16";
    return;
  }
  if( Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16 == p ) {
    j = "G10X6B10X6R10X63Plane420Unorm3Pack16";
    return;
  }
  if( Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16 == p ) {
    j = "G10X6B10X6R10X62Plane420Unorm3Pack16";
    return;
  }
  if( Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16 == p ) {
    j = "G10X6B10X6R10X63Plane422Unorm3Pack16";
    return;
  }
  if( Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16 == p ) {
    j = "G10X6B10X6R10X62Plane422Unorm3Pack16";
    return;
  }
  if( Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16 == p ) {
    j = "G10X6B10X6R10X63Plane444Unorm3Pack16";
    return;
  }
  if( Format :: eR12X4UnormPack16 == p ) {
    j = "R12X4UnormPack16";
    return;
  }
  if( Format :: eR12X4G12X4Unorm2Pack16 == p ) {
    j = "R12X4G12X4Unorm2Pack16";
    return;
  }
  if( Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16 == p ) {
    j = "R12X4G12X4B12X4A12X4Unorm4Pack16";
    return;
  }
  if( Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16 == p ) {
    j = "G12X4B12X4G12X4R12X4422Unorm4Pack16";
    return;
  }
  if( Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16 == p ) {
    j = "B12X4G12X4R12X4G12X4422Unorm4Pack16";
    return;
  }
  if( Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16 == p ) {
    j = "G12X4B12X4R12X43Plane420Unorm3Pack16";
    return;
  }
  if( Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16 == p ) {
    j = "G12X4B12X4R12X42Plane420Unorm3Pack16";
    return;
  }
  if( Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16 == p ) {
    j = "G12X4B12X4R12X43Plane422Unorm3Pack16";
    return;
  }
  if( Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16 == p ) {
    j = "G12X4B12X4R12X42Plane422Unorm3Pack16";
    return;
  }
  if( Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16 == p ) {
    j = "G12X4B12X4R12X43Plane444Unorm3Pack16";
    return;
  }
  if( Format :: eG16B16G16R16422Unorm == p ) {
    j = "G16B16G16R16422Unorm";
    return;
  }
  if( Format :: eB16G16R16G16422Unorm == p ) {
    j = "B16G16R16G16422Unorm";
    return;
  }
  if( Format :: eG16B16R163Plane420Unorm == p ) {
    j = "G16B16R163Plane420Unorm";
    return;
  }
  if( Format :: eG16B16R162Plane420Unorm == p ) {
    j = "G16B16R162Plane420Unorm";
    return;
  }
  if( Format :: eG16B16R163Plane422Unorm == p ) {
    j = "G16B16R163Plane422Unorm";
    return;
  }
  if( Format :: eG16B16R162Plane422Unorm == p ) {
    j = "G16B16R162Plane422Unorm";
    return;
  }
  if( Format :: eG16B16R163Plane444Unorm == p ) {
    j = "G16B16R163Plane444Unorm";
    return;
  }
  if( Format :: ePvrtc12BppUnormBlockIMG == p ) {
    j = "Pvrtc12BppUnormBlockIMG";
    return;
  }
  if( Format :: ePvrtc14BppUnormBlockIMG == p ) {
    j = "Pvrtc14BppUnormBlockIMG";
    return;
  }
  if( Format :: ePvrtc22BppUnormBlockIMG == p ) {
    j = "Pvrtc22BppUnormBlockIMG";
    return;
  }
  if( Format :: ePvrtc24BppUnormBlockIMG == p ) {
    j = "Pvrtc24BppUnormBlockIMG";
    return;
  }
  if( Format :: ePvrtc12BppSrgbBlockIMG == p ) {
    j = "Pvrtc12BppSrgbBlockIMG";
    return;
  }
  if( Format :: ePvrtc14BppSrgbBlockIMG == p ) {
    j = "Pvrtc14BppSrgbBlockIMG";
    return;
  }
  if( Format :: ePvrtc22BppSrgbBlockIMG == p ) {
    j = "Pvrtc22BppSrgbBlockIMG";
    return;
  }
  if( Format :: ePvrtc24BppSrgbBlockIMG == p ) {
    j = "Pvrtc24BppSrgbBlockIMG";
    return;
  }
  if( Format :: eAstc4x4SfloatBlockEXT == p ) {
    j = "Astc4x4SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc5x4SfloatBlockEXT == p ) {
    j = "Astc5x4SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc5x5SfloatBlockEXT == p ) {
    j = "Astc5x5SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc6x5SfloatBlockEXT == p ) {
    j = "Astc6x5SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc6x6SfloatBlockEXT == p ) {
    j = "Astc6x6SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc8x5SfloatBlockEXT == p ) {
    j = "Astc8x5SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc8x6SfloatBlockEXT == p ) {
    j = "Astc8x6SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc8x8SfloatBlockEXT == p ) {
    j = "Astc8x8SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc10x5SfloatBlockEXT == p ) {
    j = "Astc10x5SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc10x6SfloatBlockEXT == p ) {
    j = "Astc10x6SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc10x8SfloatBlockEXT == p ) {
    j = "Astc10x8SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc10x10SfloatBlockEXT == p ) {
    j = "Astc10x10SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc12x10SfloatBlockEXT == p ) {
    j = "Astc12x10SfloatBlockEXT";
    return;
  }
  if( Format :: eAstc12x12SfloatBlockEXT == p ) {
    j = "Astc12x12SfloatBlockEXT";
    return;
  }
  if( Format :: eG8B8R82Plane444UnormEXT == p ) {
    j = "G8B8R82Plane444UnormEXT";
    return;
  }
  if( Format :: eG10X6B10X6R10X62Plane444Unorm3Pack16EXT == p ) {
    j = "G10X6B10X6R10X62Plane444Unorm3Pack16EXT";
    return;
  }
  if( Format :: eG12X4B12X4R12X42Plane444Unorm3Pack16EXT == p ) {
    j = "G12X4B12X4R12X42Plane444Unorm3Pack16EXT";
    return;
  }
  if( Format :: eG16B16R162Plane444UnormEXT == p ) {
    j = "G16B16R162Plane444UnormEXT";
    return;
  }
  if( Format :: eA4R4G4B4UnormPack16EXT == p ) {
    j = "A4R4G4B4UnormPack16EXT";
    return;
  }
  if( Format :: eA4B4G4R4UnormPack16EXT == p ) {
    j = "A4B4G4R4UnormPack16EXT";
    return;
  }
  if( Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16KHR == p ) {
    j = "B10X6G10X6R10X6G10X6422Unorm4Pack16KHR";
    return;
  }
  if( Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16KHR == p ) {
    j = "B12X4G12X4R12X4G12X4422Unorm4Pack16KHR";
    return;
  }
  if( Format :: eB16G16R16G16422UnormKHR == p ) {
    j = "B16G16R16G16422UnormKHR";
    return;
  }
  if( Format :: eB8G8R8G8422UnormKHR == p ) {
    j = "B8G8R8G8422UnormKHR";
    return;
  }
  if( Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16KHR == p ) {
    j = "G10X6B10X6G10X6R10X6422Unorm4Pack16KHR";
    return;
  }
  if( Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16KHR == p ) {
    j = "G10X6B10X6R10X62Plane420Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16KHR == p ) {
    j = "G10X6B10X6R10X62Plane422Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16KHR == p ) {
    j = "G10X6B10X6R10X63Plane420Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16KHR == p ) {
    j = "G10X6B10X6R10X63Plane422Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16KHR == p ) {
    j = "G10X6B10X6R10X63Plane444Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16KHR == p ) {
    j = "G12X4B12X4G12X4R12X4422Unorm4Pack16KHR";
    return;
  }
  if( Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16KHR == p ) {
    j = "G12X4B12X4R12X42Plane420Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16KHR == p ) {
    j = "G12X4B12X4R12X42Plane422Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16KHR == p ) {
    j = "G12X4B12X4R12X43Plane420Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16KHR == p ) {
    j = "G12X4B12X4R12X43Plane422Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16KHR == p ) {
    j = "G12X4B12X4R12X43Plane444Unorm3Pack16KHR";
    return;
  }
  if( Format :: eG16B16G16R16422UnormKHR == p ) {
    j = "G16B16G16R16422UnormKHR";
    return;
  }
  if( Format :: eG16B16R162Plane420UnormKHR == p ) {
    j = "G16B16R162Plane420UnormKHR";
    return;
  }
  if( Format :: eG16B16R162Plane422UnormKHR == p ) {
    j = "G16B16R162Plane422UnormKHR";
    return;
  }
  if( Format :: eG16B16R163Plane420UnormKHR == p ) {
    j = "G16B16R163Plane420UnormKHR";
    return;
  }
  if( Format :: eG16B16R163Plane422UnormKHR == p ) {
    j = "G16B16R163Plane422UnormKHR";
    return;
  }
  if( Format :: eG16B16R163Plane444UnormKHR == p ) {
    j = "G16B16R163Plane444UnormKHR";
    return;
  }
  if( Format :: eG8B8G8R8422UnormKHR == p ) {
    j = "G8B8G8R8422UnormKHR";
    return;
  }
  if( Format :: eG8B8R82Plane420UnormKHR == p ) {
    j = "G8B8R82Plane420UnormKHR";
    return;
  }
  if( Format :: eG8B8R82Plane422UnormKHR == p ) {
    j = "G8B8R82Plane422UnormKHR";
    return;
  }
  if( Format :: eG8B8R83Plane420UnormKHR == p ) {
    j = "G8B8R83Plane420UnormKHR";
    return;
  }
  if( Format :: eG8B8R83Plane422UnormKHR == p ) {
    j = "G8B8R83Plane422UnormKHR";
    return;
  }
  if( Format :: eG8B8R83Plane444UnormKHR == p ) {
    j = "G8B8R83Plane444UnormKHR";
    return;
  }
  if( Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16KHR == p ) {
    j = "R10X6G10X6B10X6A10X6Unorm4Pack16KHR";
    return;
  }
  if( Format :: eR10X6G10X6Unorm2Pack16KHR == p ) {
    j = "R10X6G10X6Unorm2Pack16KHR";
    return;
  }
  if( Format :: eR10X6UnormPack16KHR == p ) {
    j = "R10X6UnormPack16KHR";
    return;
  }
  if( Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16KHR == p ) {
    j = "R12X4G12X4B12X4A12X4Unorm4Pack16KHR";
    return;
  }
  if( Format :: eR12X4G12X4Unorm2Pack16KHR == p ) {
    j = "R12X4G12X4Unorm2Pack16KHR";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkFormat &p ) {
  to_json( j, Format ( p ) );
}
inline void from_json( const nlohmann::json &j, Format &p ) {
  if( j.is_string() ) {
    if( "Undefined" == j.get< std::string >() ) {
      p = Format :: eUndefined ;
      return;
    }
    if( "eUndefined" == j.get< std::string >() ) {
      p = Format :: eUndefined ;
      return;
    }
    if( "VK_FORMAT_UNDEFINED" == j.get< std::string >() ) {
      p = Format :: eUndefined ;
      return;
    }
    if( "R4G4UnormPack8" == j.get< std::string >() ) {
      p = Format :: eR4G4UnormPack8 ;
      return;
    }
    if( "eR4G4UnormPack8" == j.get< std::string >() ) {
      p = Format :: eR4G4UnormPack8 ;
      return;
    }
    if( "VK_FORMAT_R4G4_UNORM_PACK8" == j.get< std::string >() ) {
      p = Format :: eR4G4UnormPack8 ;
      return;
    }
    if( "R4G4B4A4UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR4G4B4A4UnormPack16 ;
      return;
    }
    if( "eR4G4B4A4UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR4G4B4A4UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_R4G4B4A4_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eR4G4B4A4UnormPack16 ;
      return;
    }
    if( "B4G4R4A4UnormPack16" == j.get< std::string >() ) {
      p = Format :: eB4G4R4A4UnormPack16 ;
      return;
    }
    if( "eB4G4R4A4UnormPack16" == j.get< std::string >() ) {
      p = Format :: eB4G4R4A4UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_B4G4R4A4_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eB4G4R4A4UnormPack16 ;
      return;
    }
    if( "R5G6B5UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR5G6B5UnormPack16 ;
      return;
    }
    if( "eR5G6B5UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR5G6B5UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_R5G6B5_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eR5G6B5UnormPack16 ;
      return;
    }
    if( "B5G6R5UnormPack16" == j.get< std::string >() ) {
      p = Format :: eB5G6R5UnormPack16 ;
      return;
    }
    if( "eB5G6R5UnormPack16" == j.get< std::string >() ) {
      p = Format :: eB5G6R5UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_B5G6R5_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eB5G6R5UnormPack16 ;
      return;
    }
    if( "R5G5B5A1UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR5G5B5A1UnormPack16 ;
      return;
    }
    if( "eR5G5B5A1UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR5G5B5A1UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_R5G5B5A1_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eR5G5B5A1UnormPack16 ;
      return;
    }
    if( "B5G5R5A1UnormPack16" == j.get< std::string >() ) {
      p = Format :: eB5G5R5A1UnormPack16 ;
      return;
    }
    if( "eB5G5R5A1UnormPack16" == j.get< std::string >() ) {
      p = Format :: eB5G5R5A1UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_B5G5R5A1_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eB5G5R5A1UnormPack16 ;
      return;
    }
    if( "A1R5G5B5UnormPack16" == j.get< std::string >() ) {
      p = Format :: eA1R5G5B5UnormPack16 ;
      return;
    }
    if( "eA1R5G5B5UnormPack16" == j.get< std::string >() ) {
      p = Format :: eA1R5G5B5UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_A1R5G5B5_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eA1R5G5B5UnormPack16 ;
      return;
    }
    if( "R8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8Unorm ;
      return;
    }
    if( "eR8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8Unorm ;
      return;
    }
    if( "VK_FORMAT_R8_UNORM" == j.get< std::string >() ) {
      p = Format :: eR8Unorm ;
      return;
    }
    if( "R8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8Snorm ;
      return;
    }
    if( "eR8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8Snorm ;
      return;
    }
    if( "VK_FORMAT_R8_SNORM" == j.get< std::string >() ) {
      p = Format :: eR8Snorm ;
      return;
    }
    if( "R8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8Uscaled ;
      return;
    }
    if( "eR8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8Uscaled ;
      return;
    }
    if( "VK_FORMAT_R8_USCALED" == j.get< std::string >() ) {
      p = Format :: eR8Uscaled ;
      return;
    }
    if( "R8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8Sscaled ;
      return;
    }
    if( "eR8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8Sscaled ;
      return;
    }
    if( "VK_FORMAT_R8_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR8Sscaled ;
      return;
    }
    if( "R8Uint" == j.get< std::string >() ) {
      p = Format :: eR8Uint ;
      return;
    }
    if( "eR8Uint" == j.get< std::string >() ) {
      p = Format :: eR8Uint ;
      return;
    }
    if( "VK_FORMAT_R8_UINT" == j.get< std::string >() ) {
      p = Format :: eR8Uint ;
      return;
    }
    if( "R8Sint" == j.get< std::string >() ) {
      p = Format :: eR8Sint ;
      return;
    }
    if( "eR8Sint" == j.get< std::string >() ) {
      p = Format :: eR8Sint ;
      return;
    }
    if( "VK_FORMAT_R8_SINT" == j.get< std::string >() ) {
      p = Format :: eR8Sint ;
      return;
    }
    if( "R8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8Srgb ;
      return;
    }
    if( "eR8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8Srgb ;
      return;
    }
    if( "VK_FORMAT_R8_SRGB" == j.get< std::string >() ) {
      p = Format :: eR8Srgb ;
      return;
    }
    if( "R8G8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8G8Unorm ;
      return;
    }
    if( "eR8G8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8G8Unorm ;
      return;
    }
    if( "VK_FORMAT_R8G8_UNORM" == j.get< std::string >() ) {
      p = Format :: eR8G8Unorm ;
      return;
    }
    if( "R8G8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8G8Snorm ;
      return;
    }
    if( "eR8G8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8G8Snorm ;
      return;
    }
    if( "VK_FORMAT_R8G8_SNORM" == j.get< std::string >() ) {
      p = Format :: eR8G8Snorm ;
      return;
    }
    if( "R8G8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8Uscaled ;
      return;
    }
    if( "eR8G8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8Uscaled ;
      return;
    }
    if( "VK_FORMAT_R8G8_USCALED" == j.get< std::string >() ) {
      p = Format :: eR8G8Uscaled ;
      return;
    }
    if( "R8G8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8Sscaled ;
      return;
    }
    if( "eR8G8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8Sscaled ;
      return;
    }
    if( "VK_FORMAT_R8G8_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR8G8Sscaled ;
      return;
    }
    if( "R8G8Uint" == j.get< std::string >() ) {
      p = Format :: eR8G8Uint ;
      return;
    }
    if( "eR8G8Uint" == j.get< std::string >() ) {
      p = Format :: eR8G8Uint ;
      return;
    }
    if( "VK_FORMAT_R8G8_UINT" == j.get< std::string >() ) {
      p = Format :: eR8G8Uint ;
      return;
    }
    if( "R8G8Sint" == j.get< std::string >() ) {
      p = Format :: eR8G8Sint ;
      return;
    }
    if( "eR8G8Sint" == j.get< std::string >() ) {
      p = Format :: eR8G8Sint ;
      return;
    }
    if( "VK_FORMAT_R8G8_SINT" == j.get< std::string >() ) {
      p = Format :: eR8G8Sint ;
      return;
    }
    if( "R8G8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8G8Srgb ;
      return;
    }
    if( "eR8G8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8G8Srgb ;
      return;
    }
    if( "VK_FORMAT_R8G8_SRGB" == j.get< std::string >() ) {
      p = Format :: eR8G8Srgb ;
      return;
    }
    if( "R8G8B8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Unorm ;
      return;
    }
    if( "eR8G8B8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Unorm ;
      return;
    }
    if( "VK_FORMAT_R8G8B8_UNORM" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Unorm ;
      return;
    }
    if( "R8G8B8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Snorm ;
      return;
    }
    if( "eR8G8B8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Snorm ;
      return;
    }
    if( "VK_FORMAT_R8G8B8_SNORM" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Snorm ;
      return;
    }
    if( "R8G8B8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Uscaled ;
      return;
    }
    if( "eR8G8B8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Uscaled ;
      return;
    }
    if( "VK_FORMAT_R8G8B8_USCALED" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Uscaled ;
      return;
    }
    if( "R8G8B8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Sscaled ;
      return;
    }
    if( "eR8G8B8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Sscaled ;
      return;
    }
    if( "VK_FORMAT_R8G8B8_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Sscaled ;
      return;
    }
    if( "R8G8B8Uint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Uint ;
      return;
    }
    if( "eR8G8B8Uint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Uint ;
      return;
    }
    if( "VK_FORMAT_R8G8B8_UINT" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Uint ;
      return;
    }
    if( "R8G8B8Sint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Sint ;
      return;
    }
    if( "eR8G8B8Sint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Sint ;
      return;
    }
    if( "VK_FORMAT_R8G8B8_SINT" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Sint ;
      return;
    }
    if( "R8G8B8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Srgb ;
      return;
    }
    if( "eR8G8B8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Srgb ;
      return;
    }
    if( "VK_FORMAT_R8G8B8_SRGB" == j.get< std::string >() ) {
      p = Format :: eR8G8B8Srgb ;
      return;
    }
    if( "B8G8R8Unorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Unorm ;
      return;
    }
    if( "eB8G8R8Unorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Unorm ;
      return;
    }
    if( "VK_FORMAT_B8G8R8_UNORM" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Unorm ;
      return;
    }
    if( "B8G8R8Snorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Snorm ;
      return;
    }
    if( "eB8G8R8Snorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Snorm ;
      return;
    }
    if( "VK_FORMAT_B8G8R8_SNORM" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Snorm ;
      return;
    }
    if( "B8G8R8Uscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Uscaled ;
      return;
    }
    if( "eB8G8R8Uscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Uscaled ;
      return;
    }
    if( "VK_FORMAT_B8G8R8_USCALED" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Uscaled ;
      return;
    }
    if( "B8G8R8Sscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Sscaled ;
      return;
    }
    if( "eB8G8R8Sscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Sscaled ;
      return;
    }
    if( "VK_FORMAT_B8G8R8_SSCALED" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Sscaled ;
      return;
    }
    if( "B8G8R8Uint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Uint ;
      return;
    }
    if( "eB8G8R8Uint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Uint ;
      return;
    }
    if( "VK_FORMAT_B8G8R8_UINT" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Uint ;
      return;
    }
    if( "B8G8R8Sint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Sint ;
      return;
    }
    if( "eB8G8R8Sint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Sint ;
      return;
    }
    if( "VK_FORMAT_B8G8R8_SINT" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Sint ;
      return;
    }
    if( "B8G8R8Srgb" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Srgb ;
      return;
    }
    if( "eB8G8R8Srgb" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Srgb ;
      return;
    }
    if( "VK_FORMAT_B8G8R8_SRGB" == j.get< std::string >() ) {
      p = Format :: eB8G8R8Srgb ;
      return;
    }
    if( "R8G8B8A8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Unorm ;
      return;
    }
    if( "eR8G8B8A8Unorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Unorm ;
      return;
    }
    if( "VK_FORMAT_R8G8B8A8_UNORM" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Unorm ;
      return;
    }
    if( "R8G8B8A8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Snorm ;
      return;
    }
    if( "eR8G8B8A8Snorm" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Snorm ;
      return;
    }
    if( "VK_FORMAT_R8G8B8A8_SNORM" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Snorm ;
      return;
    }
    if( "R8G8B8A8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Uscaled ;
      return;
    }
    if( "eR8G8B8A8Uscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Uscaled ;
      return;
    }
    if( "VK_FORMAT_R8G8B8A8_USCALED" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Uscaled ;
      return;
    }
    if( "R8G8B8A8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Sscaled ;
      return;
    }
    if( "eR8G8B8A8Sscaled" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Sscaled ;
      return;
    }
    if( "VK_FORMAT_R8G8B8A8_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Sscaled ;
      return;
    }
    if( "R8G8B8A8Uint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Uint ;
      return;
    }
    if( "eR8G8B8A8Uint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Uint ;
      return;
    }
    if( "VK_FORMAT_R8G8B8A8_UINT" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Uint ;
      return;
    }
    if( "R8G8B8A8Sint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Sint ;
      return;
    }
    if( "eR8G8B8A8Sint" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Sint ;
      return;
    }
    if( "VK_FORMAT_R8G8B8A8_SINT" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Sint ;
      return;
    }
    if( "R8G8B8A8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Srgb ;
      return;
    }
    if( "eR8G8B8A8Srgb" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Srgb ;
      return;
    }
    if( "VK_FORMAT_R8G8B8A8_SRGB" == j.get< std::string >() ) {
      p = Format :: eR8G8B8A8Srgb ;
      return;
    }
    if( "B8G8R8A8Unorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Unorm ;
      return;
    }
    if( "eB8G8R8A8Unorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Unorm ;
      return;
    }
    if( "VK_FORMAT_B8G8R8A8_UNORM" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Unorm ;
      return;
    }
    if( "B8G8R8A8Snorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Snorm ;
      return;
    }
    if( "eB8G8R8A8Snorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Snorm ;
      return;
    }
    if( "VK_FORMAT_B8G8R8A8_SNORM" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Snorm ;
      return;
    }
    if( "B8G8R8A8Uscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Uscaled ;
      return;
    }
    if( "eB8G8R8A8Uscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Uscaled ;
      return;
    }
    if( "VK_FORMAT_B8G8R8A8_USCALED" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Uscaled ;
      return;
    }
    if( "B8G8R8A8Sscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Sscaled ;
      return;
    }
    if( "eB8G8R8A8Sscaled" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Sscaled ;
      return;
    }
    if( "VK_FORMAT_B8G8R8A8_SSCALED" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Sscaled ;
      return;
    }
    if( "B8G8R8A8Uint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Uint ;
      return;
    }
    if( "eB8G8R8A8Uint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Uint ;
      return;
    }
    if( "VK_FORMAT_B8G8R8A8_UINT" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Uint ;
      return;
    }
    if( "B8G8R8A8Sint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Sint ;
      return;
    }
    if( "eB8G8R8A8Sint" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Sint ;
      return;
    }
    if( "VK_FORMAT_B8G8R8A8_SINT" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Sint ;
      return;
    }
    if( "B8G8R8A8Srgb" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Srgb ;
      return;
    }
    if( "eB8G8R8A8Srgb" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Srgb ;
      return;
    }
    if( "VK_FORMAT_B8G8R8A8_SRGB" == j.get< std::string >() ) {
      p = Format :: eB8G8R8A8Srgb ;
      return;
    }
    if( "A8B8G8R8UnormPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UnormPack32 ;
      return;
    }
    if( "eA8B8G8R8UnormPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UnormPack32 ;
      return;
    }
    if( "VK_FORMAT_A8B8G8R8_UNORM_PACK32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UnormPack32 ;
      return;
    }
    if( "A8B8G8R8SnormPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SnormPack32 ;
      return;
    }
    if( "eA8B8G8R8SnormPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SnormPack32 ;
      return;
    }
    if( "VK_FORMAT_A8B8G8R8_SNORM_PACK32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SnormPack32 ;
      return;
    }
    if( "A8B8G8R8UscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UscaledPack32 ;
      return;
    }
    if( "eA8B8G8R8UscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UscaledPack32 ;
      return;
    }
    if( "VK_FORMAT_A8B8G8R8_USCALED_PACK32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UscaledPack32 ;
      return;
    }
    if( "A8B8G8R8SscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SscaledPack32 ;
      return;
    }
    if( "eA8B8G8R8SscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SscaledPack32 ;
      return;
    }
    if( "VK_FORMAT_A8B8G8R8_SSCALED_PACK32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SscaledPack32 ;
      return;
    }
    if( "A8B8G8R8UintPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UintPack32 ;
      return;
    }
    if( "eA8B8G8R8UintPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UintPack32 ;
      return;
    }
    if( "VK_FORMAT_A8B8G8R8_UINT_PACK32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8UintPack32 ;
      return;
    }
    if( "A8B8G8R8SintPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SintPack32 ;
      return;
    }
    if( "eA8B8G8R8SintPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SintPack32 ;
      return;
    }
    if( "VK_FORMAT_A8B8G8R8_SINT_PACK32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SintPack32 ;
      return;
    }
    if( "A8B8G8R8SrgbPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SrgbPack32 ;
      return;
    }
    if( "eA8B8G8R8SrgbPack32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SrgbPack32 ;
      return;
    }
    if( "VK_FORMAT_A8B8G8R8_SRGB_PACK32" == j.get< std::string >() ) {
      p = Format :: eA8B8G8R8SrgbPack32 ;
      return;
    }
    if( "A2R10G10B10UnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UnormPack32 ;
      return;
    }
    if( "eA2R10G10B10UnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UnormPack32 ;
      return;
    }
    if( "VK_FORMAT_A2R10G10B10_UNORM_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UnormPack32 ;
      return;
    }
    if( "A2R10G10B10SnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SnormPack32 ;
      return;
    }
    if( "eA2R10G10B10SnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SnormPack32 ;
      return;
    }
    if( "VK_FORMAT_A2R10G10B10_SNORM_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SnormPack32 ;
      return;
    }
    if( "A2R10G10B10UscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UscaledPack32 ;
      return;
    }
    if( "eA2R10G10B10UscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UscaledPack32 ;
      return;
    }
    if( "VK_FORMAT_A2R10G10B10_USCALED_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UscaledPack32 ;
      return;
    }
    if( "A2R10G10B10SscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SscaledPack32 ;
      return;
    }
    if( "eA2R10G10B10SscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SscaledPack32 ;
      return;
    }
    if( "VK_FORMAT_A2R10G10B10_SSCALED_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SscaledPack32 ;
      return;
    }
    if( "A2R10G10B10UintPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UintPack32 ;
      return;
    }
    if( "eA2R10G10B10UintPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UintPack32 ;
      return;
    }
    if( "VK_FORMAT_A2R10G10B10_UINT_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10UintPack32 ;
      return;
    }
    if( "A2R10G10B10SintPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SintPack32 ;
      return;
    }
    if( "eA2R10G10B10SintPack32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SintPack32 ;
      return;
    }
    if( "VK_FORMAT_A2R10G10B10_SINT_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2R10G10B10SintPack32 ;
      return;
    }
    if( "A2B10G10R10UnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UnormPack32 ;
      return;
    }
    if( "eA2B10G10R10UnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UnormPack32 ;
      return;
    }
    if( "VK_FORMAT_A2B10G10R10_UNORM_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UnormPack32 ;
      return;
    }
    if( "A2B10G10R10SnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SnormPack32 ;
      return;
    }
    if( "eA2B10G10R10SnormPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SnormPack32 ;
      return;
    }
    if( "VK_FORMAT_A2B10G10R10_SNORM_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SnormPack32 ;
      return;
    }
    if( "A2B10G10R10UscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UscaledPack32 ;
      return;
    }
    if( "eA2B10G10R10UscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UscaledPack32 ;
      return;
    }
    if( "VK_FORMAT_A2B10G10R10_USCALED_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UscaledPack32 ;
      return;
    }
    if( "A2B10G10R10SscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SscaledPack32 ;
      return;
    }
    if( "eA2B10G10R10SscaledPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SscaledPack32 ;
      return;
    }
    if( "VK_FORMAT_A2B10G10R10_SSCALED_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SscaledPack32 ;
      return;
    }
    if( "A2B10G10R10UintPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UintPack32 ;
      return;
    }
    if( "eA2B10G10R10UintPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UintPack32 ;
      return;
    }
    if( "VK_FORMAT_A2B10G10R10_UINT_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10UintPack32 ;
      return;
    }
    if( "A2B10G10R10SintPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SintPack32 ;
      return;
    }
    if( "eA2B10G10R10SintPack32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SintPack32 ;
      return;
    }
    if( "VK_FORMAT_A2B10G10R10_SINT_PACK32" == j.get< std::string >() ) {
      p = Format :: eA2B10G10R10SintPack32 ;
      return;
    }
    if( "R16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16Unorm ;
      return;
    }
    if( "eR16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16Unorm ;
      return;
    }
    if( "VK_FORMAT_R16_UNORM" == j.get< std::string >() ) {
      p = Format :: eR16Unorm ;
      return;
    }
    if( "R16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16Snorm ;
      return;
    }
    if( "eR16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16Snorm ;
      return;
    }
    if( "VK_FORMAT_R16_SNORM" == j.get< std::string >() ) {
      p = Format :: eR16Snorm ;
      return;
    }
    if( "R16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16Uscaled ;
      return;
    }
    if( "eR16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16Uscaled ;
      return;
    }
    if( "VK_FORMAT_R16_USCALED" == j.get< std::string >() ) {
      p = Format :: eR16Uscaled ;
      return;
    }
    if( "R16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16Sscaled ;
      return;
    }
    if( "eR16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16Sscaled ;
      return;
    }
    if( "VK_FORMAT_R16_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR16Sscaled ;
      return;
    }
    if( "R16Uint" == j.get< std::string >() ) {
      p = Format :: eR16Uint ;
      return;
    }
    if( "eR16Uint" == j.get< std::string >() ) {
      p = Format :: eR16Uint ;
      return;
    }
    if( "VK_FORMAT_R16_UINT" == j.get< std::string >() ) {
      p = Format :: eR16Uint ;
      return;
    }
    if( "R16Sint" == j.get< std::string >() ) {
      p = Format :: eR16Sint ;
      return;
    }
    if( "eR16Sint" == j.get< std::string >() ) {
      p = Format :: eR16Sint ;
      return;
    }
    if( "VK_FORMAT_R16_SINT" == j.get< std::string >() ) {
      p = Format :: eR16Sint ;
      return;
    }
    if( "R16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16Sfloat ;
      return;
    }
    if( "eR16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16Sfloat ;
      return;
    }
    if( "VK_FORMAT_R16_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR16Sfloat ;
      return;
    }
    if( "R16G16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16G16Unorm ;
      return;
    }
    if( "eR16G16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16G16Unorm ;
      return;
    }
    if( "VK_FORMAT_R16G16_UNORM" == j.get< std::string >() ) {
      p = Format :: eR16G16Unorm ;
      return;
    }
    if( "R16G16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16G16Snorm ;
      return;
    }
    if( "eR16G16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16G16Snorm ;
      return;
    }
    if( "VK_FORMAT_R16G16_SNORM" == j.get< std::string >() ) {
      p = Format :: eR16G16Snorm ;
      return;
    }
    if( "R16G16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16Uscaled ;
      return;
    }
    if( "eR16G16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16Uscaled ;
      return;
    }
    if( "VK_FORMAT_R16G16_USCALED" == j.get< std::string >() ) {
      p = Format :: eR16G16Uscaled ;
      return;
    }
    if( "R16G16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16Sscaled ;
      return;
    }
    if( "eR16G16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16Sscaled ;
      return;
    }
    if( "VK_FORMAT_R16G16_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR16G16Sscaled ;
      return;
    }
    if( "R16G16Uint" == j.get< std::string >() ) {
      p = Format :: eR16G16Uint ;
      return;
    }
    if( "eR16G16Uint" == j.get< std::string >() ) {
      p = Format :: eR16G16Uint ;
      return;
    }
    if( "VK_FORMAT_R16G16_UINT" == j.get< std::string >() ) {
      p = Format :: eR16G16Uint ;
      return;
    }
    if( "R16G16Sint" == j.get< std::string >() ) {
      p = Format :: eR16G16Sint ;
      return;
    }
    if( "eR16G16Sint" == j.get< std::string >() ) {
      p = Format :: eR16G16Sint ;
      return;
    }
    if( "VK_FORMAT_R16G16_SINT" == j.get< std::string >() ) {
      p = Format :: eR16G16Sint ;
      return;
    }
    if( "R16G16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16G16Sfloat ;
      return;
    }
    if( "eR16G16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16G16Sfloat ;
      return;
    }
    if( "VK_FORMAT_R16G16_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR16G16Sfloat ;
      return;
    }
    if( "R16G16B16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Unorm ;
      return;
    }
    if( "eR16G16B16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Unorm ;
      return;
    }
    if( "VK_FORMAT_R16G16B16_UNORM" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Unorm ;
      return;
    }
    if( "R16G16B16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Snorm ;
      return;
    }
    if( "eR16G16B16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Snorm ;
      return;
    }
    if( "VK_FORMAT_R16G16B16_SNORM" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Snorm ;
      return;
    }
    if( "R16G16B16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Uscaled ;
      return;
    }
    if( "eR16G16B16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Uscaled ;
      return;
    }
    if( "VK_FORMAT_R16G16B16_USCALED" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Uscaled ;
      return;
    }
    if( "R16G16B16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sscaled ;
      return;
    }
    if( "eR16G16B16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sscaled ;
      return;
    }
    if( "VK_FORMAT_R16G16B16_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sscaled ;
      return;
    }
    if( "R16G16B16Uint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Uint ;
      return;
    }
    if( "eR16G16B16Uint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Uint ;
      return;
    }
    if( "VK_FORMAT_R16G16B16_UINT" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Uint ;
      return;
    }
    if( "R16G16B16Sint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sint ;
      return;
    }
    if( "eR16G16B16Sint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sint ;
      return;
    }
    if( "VK_FORMAT_R16G16B16_SINT" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sint ;
      return;
    }
    if( "R16G16B16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sfloat ;
      return;
    }
    if( "eR16G16B16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sfloat ;
      return;
    }
    if( "VK_FORMAT_R16G16B16_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR16G16B16Sfloat ;
      return;
    }
    if( "R16G16B16A16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Unorm ;
      return;
    }
    if( "eR16G16B16A16Unorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Unorm ;
      return;
    }
    if( "VK_FORMAT_R16G16B16A16_UNORM" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Unorm ;
      return;
    }
    if( "R16G16B16A16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Snorm ;
      return;
    }
    if( "eR16G16B16A16Snorm" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Snorm ;
      return;
    }
    if( "VK_FORMAT_R16G16B16A16_SNORM" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Snorm ;
      return;
    }
    if( "R16G16B16A16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Uscaled ;
      return;
    }
    if( "eR16G16B16A16Uscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Uscaled ;
      return;
    }
    if( "VK_FORMAT_R16G16B16A16_USCALED" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Uscaled ;
      return;
    }
    if( "R16G16B16A16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sscaled ;
      return;
    }
    if( "eR16G16B16A16Sscaled" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sscaled ;
      return;
    }
    if( "VK_FORMAT_R16G16B16A16_SSCALED" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sscaled ;
      return;
    }
    if( "R16G16B16A16Uint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Uint ;
      return;
    }
    if( "eR16G16B16A16Uint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Uint ;
      return;
    }
    if( "VK_FORMAT_R16G16B16A16_UINT" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Uint ;
      return;
    }
    if( "R16G16B16A16Sint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sint ;
      return;
    }
    if( "eR16G16B16A16Sint" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sint ;
      return;
    }
    if( "VK_FORMAT_R16G16B16A16_SINT" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sint ;
      return;
    }
    if( "R16G16B16A16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sfloat ;
      return;
    }
    if( "eR16G16B16A16Sfloat" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sfloat ;
      return;
    }
    if( "VK_FORMAT_R16G16B16A16_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR16G16B16A16Sfloat ;
      return;
    }
    if( "R32Uint" == j.get< std::string >() ) {
      p = Format :: eR32Uint ;
      return;
    }
    if( "eR32Uint" == j.get< std::string >() ) {
      p = Format :: eR32Uint ;
      return;
    }
    if( "VK_FORMAT_R32_UINT" == j.get< std::string >() ) {
      p = Format :: eR32Uint ;
      return;
    }
    if( "R32Sint" == j.get< std::string >() ) {
      p = Format :: eR32Sint ;
      return;
    }
    if( "eR32Sint" == j.get< std::string >() ) {
      p = Format :: eR32Sint ;
      return;
    }
    if( "VK_FORMAT_R32_SINT" == j.get< std::string >() ) {
      p = Format :: eR32Sint ;
      return;
    }
    if( "R32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32Sfloat ;
      return;
    }
    if( "eR32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32Sfloat ;
      return;
    }
    if( "VK_FORMAT_R32_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR32Sfloat ;
      return;
    }
    if( "R32G32Uint" == j.get< std::string >() ) {
      p = Format :: eR32G32Uint ;
      return;
    }
    if( "eR32G32Uint" == j.get< std::string >() ) {
      p = Format :: eR32G32Uint ;
      return;
    }
    if( "VK_FORMAT_R32G32_UINT" == j.get< std::string >() ) {
      p = Format :: eR32G32Uint ;
      return;
    }
    if( "R32G32Sint" == j.get< std::string >() ) {
      p = Format :: eR32G32Sint ;
      return;
    }
    if( "eR32G32Sint" == j.get< std::string >() ) {
      p = Format :: eR32G32Sint ;
      return;
    }
    if( "VK_FORMAT_R32G32_SINT" == j.get< std::string >() ) {
      p = Format :: eR32G32Sint ;
      return;
    }
    if( "R32G32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32G32Sfloat ;
      return;
    }
    if( "eR32G32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32G32Sfloat ;
      return;
    }
    if( "VK_FORMAT_R32G32_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR32G32Sfloat ;
      return;
    }
    if( "R32G32B32Uint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Uint ;
      return;
    }
    if( "eR32G32B32Uint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Uint ;
      return;
    }
    if( "VK_FORMAT_R32G32B32_UINT" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Uint ;
      return;
    }
    if( "R32G32B32Sint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Sint ;
      return;
    }
    if( "eR32G32B32Sint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Sint ;
      return;
    }
    if( "VK_FORMAT_R32G32B32_SINT" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Sint ;
      return;
    }
    if( "R32G32B32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Sfloat ;
      return;
    }
    if( "eR32G32B32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Sfloat ;
      return;
    }
    if( "VK_FORMAT_R32G32B32_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR32G32B32Sfloat ;
      return;
    }
    if( "R32G32B32A32Uint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Uint ;
      return;
    }
    if( "eR32G32B32A32Uint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Uint ;
      return;
    }
    if( "VK_FORMAT_R32G32B32A32_UINT" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Uint ;
      return;
    }
    if( "R32G32B32A32Sint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Sint ;
      return;
    }
    if( "eR32G32B32A32Sint" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Sint ;
      return;
    }
    if( "VK_FORMAT_R32G32B32A32_SINT" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Sint ;
      return;
    }
    if( "R32G32B32A32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Sfloat ;
      return;
    }
    if( "eR32G32B32A32Sfloat" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Sfloat ;
      return;
    }
    if( "VK_FORMAT_R32G32B32A32_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR32G32B32A32Sfloat ;
      return;
    }
    if( "R64Uint" == j.get< std::string >() ) {
      p = Format :: eR64Uint ;
      return;
    }
    if( "eR64Uint" == j.get< std::string >() ) {
      p = Format :: eR64Uint ;
      return;
    }
    if( "VK_FORMAT_R64_UINT" == j.get< std::string >() ) {
      p = Format :: eR64Uint ;
      return;
    }
    if( "R64Sint" == j.get< std::string >() ) {
      p = Format :: eR64Sint ;
      return;
    }
    if( "eR64Sint" == j.get< std::string >() ) {
      p = Format :: eR64Sint ;
      return;
    }
    if( "VK_FORMAT_R64_SINT" == j.get< std::string >() ) {
      p = Format :: eR64Sint ;
      return;
    }
    if( "R64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64Sfloat ;
      return;
    }
    if( "eR64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64Sfloat ;
      return;
    }
    if( "VK_FORMAT_R64_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR64Sfloat ;
      return;
    }
    if( "R64G64Uint" == j.get< std::string >() ) {
      p = Format :: eR64G64Uint ;
      return;
    }
    if( "eR64G64Uint" == j.get< std::string >() ) {
      p = Format :: eR64G64Uint ;
      return;
    }
    if( "VK_FORMAT_R64G64_UINT" == j.get< std::string >() ) {
      p = Format :: eR64G64Uint ;
      return;
    }
    if( "R64G64Sint" == j.get< std::string >() ) {
      p = Format :: eR64G64Sint ;
      return;
    }
    if( "eR64G64Sint" == j.get< std::string >() ) {
      p = Format :: eR64G64Sint ;
      return;
    }
    if( "VK_FORMAT_R64G64_SINT" == j.get< std::string >() ) {
      p = Format :: eR64G64Sint ;
      return;
    }
    if( "R64G64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64G64Sfloat ;
      return;
    }
    if( "eR64G64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64G64Sfloat ;
      return;
    }
    if( "VK_FORMAT_R64G64_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR64G64Sfloat ;
      return;
    }
    if( "R64G64B64Uint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Uint ;
      return;
    }
    if( "eR64G64B64Uint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Uint ;
      return;
    }
    if( "VK_FORMAT_R64G64B64_UINT" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Uint ;
      return;
    }
    if( "R64G64B64Sint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Sint ;
      return;
    }
    if( "eR64G64B64Sint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Sint ;
      return;
    }
    if( "VK_FORMAT_R64G64B64_SINT" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Sint ;
      return;
    }
    if( "R64G64B64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Sfloat ;
      return;
    }
    if( "eR64G64B64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Sfloat ;
      return;
    }
    if( "VK_FORMAT_R64G64B64_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR64G64B64Sfloat ;
      return;
    }
    if( "R64G64B64A64Uint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Uint ;
      return;
    }
    if( "eR64G64B64A64Uint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Uint ;
      return;
    }
    if( "VK_FORMAT_R64G64B64A64_UINT" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Uint ;
      return;
    }
    if( "R64G64B64A64Sint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Sint ;
      return;
    }
    if( "eR64G64B64A64Sint" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Sint ;
      return;
    }
    if( "VK_FORMAT_R64G64B64A64_SINT" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Sint ;
      return;
    }
    if( "R64G64B64A64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Sfloat ;
      return;
    }
    if( "eR64G64B64A64Sfloat" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Sfloat ;
      return;
    }
    if( "VK_FORMAT_R64G64B64A64_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eR64G64B64A64Sfloat ;
      return;
    }
    if( "B10G11R11UfloatPack32" == j.get< std::string >() ) {
      p = Format :: eB10G11R11UfloatPack32 ;
      return;
    }
    if( "eB10G11R11UfloatPack32" == j.get< std::string >() ) {
      p = Format :: eB10G11R11UfloatPack32 ;
      return;
    }
    if( "VK_FORMAT_B10G11R11_UFLOAT_PACK32" == j.get< std::string >() ) {
      p = Format :: eB10G11R11UfloatPack32 ;
      return;
    }
    if( "E5B9G9R9UfloatPack32" == j.get< std::string >() ) {
      p = Format :: eE5B9G9R9UfloatPack32 ;
      return;
    }
    if( "eE5B9G9R9UfloatPack32" == j.get< std::string >() ) {
      p = Format :: eE5B9G9R9UfloatPack32 ;
      return;
    }
    if( "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32" == j.get< std::string >() ) {
      p = Format :: eE5B9G9R9UfloatPack32 ;
      return;
    }
    if( "D16Unorm" == j.get< std::string >() ) {
      p = Format :: eD16Unorm ;
      return;
    }
    if( "eD16Unorm" == j.get< std::string >() ) {
      p = Format :: eD16Unorm ;
      return;
    }
    if( "VK_FORMAT_D16_UNORM" == j.get< std::string >() ) {
      p = Format :: eD16Unorm ;
      return;
    }
    if( "X8D24UnormPack32" == j.get< std::string >() ) {
      p = Format :: eX8D24UnormPack32 ;
      return;
    }
    if( "eX8D24UnormPack32" == j.get< std::string >() ) {
      p = Format :: eX8D24UnormPack32 ;
      return;
    }
    if( "VK_FORMAT_X8_D24_UNORM_PACK32" == j.get< std::string >() ) {
      p = Format :: eX8D24UnormPack32 ;
      return;
    }
    if( "D32Sfloat" == j.get< std::string >() ) {
      p = Format :: eD32Sfloat ;
      return;
    }
    if( "eD32Sfloat" == j.get< std::string >() ) {
      p = Format :: eD32Sfloat ;
      return;
    }
    if( "VK_FORMAT_D32_SFLOAT" == j.get< std::string >() ) {
      p = Format :: eD32Sfloat ;
      return;
    }
    if( "S8Uint" == j.get< std::string >() ) {
      p = Format :: eS8Uint ;
      return;
    }
    if( "eS8Uint" == j.get< std::string >() ) {
      p = Format :: eS8Uint ;
      return;
    }
    if( "VK_FORMAT_S8_UINT" == j.get< std::string >() ) {
      p = Format :: eS8Uint ;
      return;
    }
    if( "D16UnormS8Uint" == j.get< std::string >() ) {
      p = Format :: eD16UnormS8Uint ;
      return;
    }
    if( "eD16UnormS8Uint" == j.get< std::string >() ) {
      p = Format :: eD16UnormS8Uint ;
      return;
    }
    if( "VK_FORMAT_D16_UNORM_S8_UINT" == j.get< std::string >() ) {
      p = Format :: eD16UnormS8Uint ;
      return;
    }
    if( "D24UnormS8Uint" == j.get< std::string >() ) {
      p = Format :: eD24UnormS8Uint ;
      return;
    }
    if( "eD24UnormS8Uint" == j.get< std::string >() ) {
      p = Format :: eD24UnormS8Uint ;
      return;
    }
    if( "VK_FORMAT_D24_UNORM_S8_UINT" == j.get< std::string >() ) {
      p = Format :: eD24UnormS8Uint ;
      return;
    }
    if( "D32SfloatS8Uint" == j.get< std::string >() ) {
      p = Format :: eD32SfloatS8Uint ;
      return;
    }
    if( "eD32SfloatS8Uint" == j.get< std::string >() ) {
      p = Format :: eD32SfloatS8Uint ;
      return;
    }
    if( "VK_FORMAT_D32_SFLOAT_S8_UINT" == j.get< std::string >() ) {
      p = Format :: eD32SfloatS8Uint ;
      return;
    }
    if( "Bc1RgbUnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbUnormBlock ;
      return;
    }
    if( "eBc1RgbUnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbUnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC1_RGB_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc1RgbUnormBlock ;
      return;
    }
    if( "Bc1RgbSrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbSrgbBlock ;
      return;
    }
    if( "eBc1RgbSrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbSrgbBlock ;
      return;
    }
    if( "VK_FORMAT_BC1_RGB_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc1RgbSrgbBlock ;
      return;
    }
    if( "Bc1RgbaUnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbaUnormBlock ;
      return;
    }
    if( "eBc1RgbaUnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbaUnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC1_RGBA_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc1RgbaUnormBlock ;
      return;
    }
    if( "Bc1RgbaSrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbaSrgbBlock ;
      return;
    }
    if( "eBc1RgbaSrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc1RgbaSrgbBlock ;
      return;
    }
    if( "VK_FORMAT_BC1_RGBA_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc1RgbaSrgbBlock ;
      return;
    }
    if( "Bc2UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc2UnormBlock ;
      return;
    }
    if( "eBc2UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc2UnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC2_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc2UnormBlock ;
      return;
    }
    if( "Bc2SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc2SrgbBlock ;
      return;
    }
    if( "eBc2SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc2SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_BC2_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc2SrgbBlock ;
      return;
    }
    if( "Bc3UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc3UnormBlock ;
      return;
    }
    if( "eBc3UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc3UnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC3_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc3UnormBlock ;
      return;
    }
    if( "Bc3SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc3SrgbBlock ;
      return;
    }
    if( "eBc3SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc3SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_BC3_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc3SrgbBlock ;
      return;
    }
    if( "Bc4UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc4UnormBlock ;
      return;
    }
    if( "eBc4UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc4UnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC4_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc4UnormBlock ;
      return;
    }
    if( "Bc4SnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc4SnormBlock ;
      return;
    }
    if( "eBc4SnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc4SnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC4_SNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc4SnormBlock ;
      return;
    }
    if( "Bc5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc5UnormBlock ;
      return;
    }
    if( "eBc5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc5UnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC5_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc5UnormBlock ;
      return;
    }
    if( "Bc5SnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc5SnormBlock ;
      return;
    }
    if( "eBc5SnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc5SnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC5_SNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc5SnormBlock ;
      return;
    }
    if( "Bc6HUfloatBlock" == j.get< std::string >() ) {
      p = Format :: eBc6HUfloatBlock ;
      return;
    }
    if( "eBc6HUfloatBlock" == j.get< std::string >() ) {
      p = Format :: eBc6HUfloatBlock ;
      return;
    }
    if( "VK_FORMAT_BC6H_UFLOAT_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc6HUfloatBlock ;
      return;
    }
    if( "Bc6HSfloatBlock" == j.get< std::string >() ) {
      p = Format :: eBc6HSfloatBlock ;
      return;
    }
    if( "eBc6HSfloatBlock" == j.get< std::string >() ) {
      p = Format :: eBc6HSfloatBlock ;
      return;
    }
    if( "VK_FORMAT_BC6H_SFLOAT_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc6HSfloatBlock ;
      return;
    }
    if( "Bc7UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc7UnormBlock ;
      return;
    }
    if( "eBc7UnormBlock" == j.get< std::string >() ) {
      p = Format :: eBc7UnormBlock ;
      return;
    }
    if( "VK_FORMAT_BC7_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc7UnormBlock ;
      return;
    }
    if( "Bc7SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc7SrgbBlock ;
      return;
    }
    if( "eBc7SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eBc7SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_BC7_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eBc7SrgbBlock ;
      return;
    }
    if( "Etc2R8G8B8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8UnormBlock ;
      return;
    }
    if( "eEtc2R8G8B8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8UnormBlock ;
      return;
    }
    if( "Etc2R8G8B8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8SrgbBlock ;
      return;
    }
    if( "eEtc2R8G8B8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8SrgbBlock ;
      return;
    }
    if( "Etc2R8G8B8A1UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A1UnormBlock ;
      return;
    }
    if( "eEtc2R8G8B8A1UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A1UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A1UnormBlock ;
      return;
    }
    if( "Etc2R8G8B8A1SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A1SrgbBlock ;
      return;
    }
    if( "eEtc2R8G8B8A1SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A1SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A1SrgbBlock ;
      return;
    }
    if( "Etc2R8G8B8A8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A8UnormBlock ;
      return;
    }
    if( "eEtc2R8G8B8A8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A8UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A8UnormBlock ;
      return;
    }
    if( "Etc2R8G8B8A8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A8SrgbBlock ;
      return;
    }
    if( "eEtc2R8G8B8A8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A8SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEtc2R8G8B8A8SrgbBlock ;
      return;
    }
    if( "EacR11UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11UnormBlock ;
      return;
    }
    if( "eEacR11UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11UnormBlock ;
      return;
    }
    if( "VK_FORMAT_EAC_R11_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEacR11UnormBlock ;
      return;
    }
    if( "EacR11SnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11SnormBlock ;
      return;
    }
    if( "eEacR11SnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11SnormBlock ;
      return;
    }
    if( "VK_FORMAT_EAC_R11_SNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEacR11SnormBlock ;
      return;
    }
    if( "EacR11G11UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11G11UnormBlock ;
      return;
    }
    if( "eEacR11G11UnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11G11UnormBlock ;
      return;
    }
    if( "VK_FORMAT_EAC_R11G11_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEacR11G11UnormBlock ;
      return;
    }
    if( "EacR11G11SnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11G11SnormBlock ;
      return;
    }
    if( "eEacR11G11SnormBlock" == j.get< std::string >() ) {
      p = Format :: eEacR11G11SnormBlock ;
      return;
    }
    if( "VK_FORMAT_EAC_R11G11_SNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eEacR11G11SnormBlock ;
      return;
    }
    if( "Astc4x4UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc4x4UnormBlock ;
      return;
    }
    if( "eAstc4x4UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc4x4UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_4x4_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc4x4UnormBlock ;
      return;
    }
    if( "Astc4x4SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc4x4SrgbBlock ;
      return;
    }
    if( "eAstc4x4SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc4x4SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_4x4_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc4x4SrgbBlock ;
      return;
    }
    if( "Astc5x4UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x4UnormBlock ;
      return;
    }
    if( "eAstc5x4UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x4UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_5x4_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc5x4UnormBlock ;
      return;
    }
    if( "Astc5x4SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x4SrgbBlock ;
      return;
    }
    if( "eAstc5x4SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x4SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_5x4_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc5x4SrgbBlock ;
      return;
    }
    if( "Astc5x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x5UnormBlock ;
      return;
    }
    if( "eAstc5x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x5UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_5x5_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc5x5UnormBlock ;
      return;
    }
    if( "Astc5x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x5SrgbBlock ;
      return;
    }
    if( "eAstc5x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc5x5SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_5x5_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc5x5SrgbBlock ;
      return;
    }
    if( "Astc6x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x5UnormBlock ;
      return;
    }
    if( "eAstc6x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x5UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_6x5_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc6x5UnormBlock ;
      return;
    }
    if( "Astc6x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x5SrgbBlock ;
      return;
    }
    if( "eAstc6x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x5SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_6x5_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc6x5SrgbBlock ;
      return;
    }
    if( "Astc6x6UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x6UnormBlock ;
      return;
    }
    if( "eAstc6x6UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x6UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_6x6_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc6x6UnormBlock ;
      return;
    }
    if( "Astc6x6SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x6SrgbBlock ;
      return;
    }
    if( "eAstc6x6SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc6x6SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_6x6_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc6x6SrgbBlock ;
      return;
    }
    if( "Astc8x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x5UnormBlock ;
      return;
    }
    if( "eAstc8x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x5UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x5_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc8x5UnormBlock ;
      return;
    }
    if( "Astc8x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x5SrgbBlock ;
      return;
    }
    if( "eAstc8x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x5SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x5_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc8x5SrgbBlock ;
      return;
    }
    if( "Astc8x6UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x6UnormBlock ;
      return;
    }
    if( "eAstc8x6UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x6UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x6_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc8x6UnormBlock ;
      return;
    }
    if( "Astc8x6SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x6SrgbBlock ;
      return;
    }
    if( "eAstc8x6SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x6SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x6_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc8x6SrgbBlock ;
      return;
    }
    if( "Astc8x8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x8UnormBlock ;
      return;
    }
    if( "eAstc8x8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x8UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x8_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc8x8UnormBlock ;
      return;
    }
    if( "Astc8x8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x8SrgbBlock ;
      return;
    }
    if( "eAstc8x8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc8x8SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x8_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc8x8SrgbBlock ;
      return;
    }
    if( "Astc10x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x5UnormBlock ;
      return;
    }
    if( "eAstc10x5UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x5UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x5_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x5UnormBlock ;
      return;
    }
    if( "Astc10x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x5SrgbBlock ;
      return;
    }
    if( "eAstc10x5SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x5SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x5_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x5SrgbBlock ;
      return;
    }
    if( "Astc10x6UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x6UnormBlock ;
      return;
    }
    if( "eAstc10x6UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x6UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x6_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x6UnormBlock ;
      return;
    }
    if( "Astc10x6SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x6SrgbBlock ;
      return;
    }
    if( "eAstc10x6SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x6SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x6_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x6SrgbBlock ;
      return;
    }
    if( "Astc10x8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x8UnormBlock ;
      return;
    }
    if( "eAstc10x8UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x8UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x8_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x8UnormBlock ;
      return;
    }
    if( "Astc10x8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x8SrgbBlock ;
      return;
    }
    if( "eAstc10x8SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x8SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x8_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x8SrgbBlock ;
      return;
    }
    if( "Astc10x10UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x10UnormBlock ;
      return;
    }
    if( "eAstc10x10UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x10UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x10_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x10UnormBlock ;
      return;
    }
    if( "Astc10x10SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x10SrgbBlock ;
      return;
    }
    if( "eAstc10x10SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc10x10SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x10_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc10x10SrgbBlock ;
      return;
    }
    if( "Astc12x10UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x10UnormBlock ;
      return;
    }
    if( "eAstc12x10UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x10UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_12x10_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc12x10UnormBlock ;
      return;
    }
    if( "Astc12x10SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x10SrgbBlock ;
      return;
    }
    if( "eAstc12x10SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x10SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_12x10_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc12x10SrgbBlock ;
      return;
    }
    if( "Astc12x12UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x12UnormBlock ;
      return;
    }
    if( "eAstc12x12UnormBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x12UnormBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_12x12_UNORM_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc12x12UnormBlock ;
      return;
    }
    if( "Astc12x12SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x12SrgbBlock ;
      return;
    }
    if( "eAstc12x12SrgbBlock" == j.get< std::string >() ) {
      p = Format :: eAstc12x12SrgbBlock ;
      return;
    }
    if( "VK_FORMAT_ASTC_12x12_SRGB_BLOCK" == j.get< std::string >() ) {
      p = Format :: eAstc12x12SrgbBlock ;
      return;
    }
    if( "G8B8G8R8422Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8G8R8422Unorm ;
      return;
    }
    if( "eG8B8G8R8422Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8G8R8422Unorm ;
      return;
    }
    if( "VK_FORMAT_G8B8G8R8_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eG8B8G8R8422Unorm ;
      return;
    }
    if( "B8G8R8G8422Unorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8G8422Unorm ;
      return;
    }
    if( "eB8G8R8G8422Unorm" == j.get< std::string >() ) {
      p = Format :: eB8G8R8G8422Unorm ;
      return;
    }
    if( "VK_FORMAT_B8G8R8G8_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eB8G8R8G8422Unorm ;
      return;
    }
    if( "G8B8R83Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane420Unorm ;
      return;
    }
    if( "eG8B8R83Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane420Unorm ;
      return;
    }
    if( "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane420Unorm ;
      return;
    }
    if( "G8B8R82Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane420Unorm ;
      return;
    }
    if( "eG8B8R82Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane420Unorm ;
      return;
    }
    if( "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane420Unorm ;
      return;
    }
    if( "G8B8R83Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane422Unorm ;
      return;
    }
    if( "eG8B8R83Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane422Unorm ;
      return;
    }
    if( "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane422Unorm ;
      return;
    }
    if( "G8B8R82Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane422Unorm ;
      return;
    }
    if( "eG8B8R82Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane422Unorm ;
      return;
    }
    if( "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane422Unorm ;
      return;
    }
    if( "G8B8R83Plane444Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane444Unorm ;
      return;
    }
    if( "eG8B8R83Plane444Unorm" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane444Unorm ;
      return;
    }
    if( "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane444Unorm ;
      return;
    }
    if( "R10X6UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR10X6UnormPack16 ;
      return;
    }
    if( "eR10X6UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR10X6UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_R10X6_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eR10X6UnormPack16 ;
      return;
    }
    if( "R10X6G10X6Unorm2Pack16" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6Unorm2Pack16 ;
      return;
    }
    if( "eR10X6G10X6Unorm2Pack16" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6Unorm2Pack16 ;
      return;
    }
    if( "VK_FORMAT_R10X6G10X6_UNORM_2PACK16" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6Unorm2Pack16 ;
      return;
    }
    if( "R10X6G10X6B10X6A10X6Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16 ;
      return;
    }
    if( "eR10X6G10X6B10X6A10X6Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16 ;
      return;
    }
    if( "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16 ;
      return;
    }
    if( "G10X6B10X6G10X6R10X6422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16 ;
      return;
    }
    if( "eG10X6B10X6G10X6R10X6422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16 ;
      return;
    }
    if( "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16 ;
      return;
    }
    if( "B10X6G10X6R10X6G10X6422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16 ;
      return;
    }
    if( "eB10X6G10X6R10X6G10X6422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16 ;
      return;
    }
    if( "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16" == j.get< std::string >() ) {
      p = Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16 ;
      return;
    }
    if( "G10X6B10X6R10X63Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16 ;
      return;
    }
    if( "eG10X6B10X6R10X63Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16 ;
      return;
    }
    if( "G10X6B10X6R10X62Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16 ;
      return;
    }
    if( "eG10X6B10X6R10X62Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16 ;
      return;
    }
    if( "G10X6B10X6R10X63Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16 ;
      return;
    }
    if( "eG10X6B10X6R10X63Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16 ;
      return;
    }
    if( "G10X6B10X6R10X62Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16 ;
      return;
    }
    if( "eG10X6B10X6R10X62Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16 ;
      return;
    }
    if( "G10X6B10X6R10X63Plane444Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16 ;
      return;
    }
    if( "eG10X6B10X6R10X63Plane444Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16 ;
      return;
    }
    if( "R12X4UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR12X4UnormPack16 ;
      return;
    }
    if( "eR12X4UnormPack16" == j.get< std::string >() ) {
      p = Format :: eR12X4UnormPack16 ;
      return;
    }
    if( "VK_FORMAT_R12X4_UNORM_PACK16" == j.get< std::string >() ) {
      p = Format :: eR12X4UnormPack16 ;
      return;
    }
    if( "R12X4G12X4Unorm2Pack16" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4Unorm2Pack16 ;
      return;
    }
    if( "eR12X4G12X4Unorm2Pack16" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4Unorm2Pack16 ;
      return;
    }
    if( "VK_FORMAT_R12X4G12X4_UNORM_2PACK16" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4Unorm2Pack16 ;
      return;
    }
    if( "R12X4G12X4B12X4A12X4Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16 ;
      return;
    }
    if( "eR12X4G12X4B12X4A12X4Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16 ;
      return;
    }
    if( "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16 ;
      return;
    }
    if( "G12X4B12X4G12X4R12X4422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16 ;
      return;
    }
    if( "eG12X4B12X4G12X4R12X4422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16 ;
      return;
    }
    if( "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16 ;
      return;
    }
    if( "B12X4G12X4R12X4G12X4422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16 ;
      return;
    }
    if( "eB12X4G12X4R12X4G12X4422Unorm4Pack16" == j.get< std::string >() ) {
      p = Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16 ;
      return;
    }
    if( "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16" == j.get< std::string >() ) {
      p = Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16 ;
      return;
    }
    if( "G12X4B12X4R12X43Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16 ;
      return;
    }
    if( "eG12X4B12X4R12X43Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16 ;
      return;
    }
    if( "G12X4B12X4R12X42Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16 ;
      return;
    }
    if( "eG12X4B12X4R12X42Plane420Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16 ;
      return;
    }
    if( "G12X4B12X4R12X43Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16 ;
      return;
    }
    if( "eG12X4B12X4R12X43Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16 ;
      return;
    }
    if( "G12X4B12X4R12X42Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16 ;
      return;
    }
    if( "eG12X4B12X4R12X42Plane422Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16 ;
      return;
    }
    if( "G12X4B12X4R12X43Plane444Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16 ;
      return;
    }
    if( "eG12X4B12X4R12X43Plane444Unorm3Pack16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16 ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16 ;
      return;
    }
    if( "G16B16G16R16422Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16G16R16422Unorm ;
      return;
    }
    if( "eG16B16G16R16422Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16G16R16422Unorm ;
      return;
    }
    if( "VK_FORMAT_G16B16G16R16_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eG16B16G16R16422Unorm ;
      return;
    }
    if( "B16G16R16G16422Unorm" == j.get< std::string >() ) {
      p = Format :: eB16G16R16G16422Unorm ;
      return;
    }
    if( "eB16G16R16G16422Unorm" == j.get< std::string >() ) {
      p = Format :: eB16G16R16G16422Unorm ;
      return;
    }
    if( "VK_FORMAT_B16G16R16G16_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eB16G16R16G16422Unorm ;
      return;
    }
    if( "G16B16R163Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane420Unorm ;
      return;
    }
    if( "eG16B16R163Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane420Unorm ;
      return;
    }
    if( "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane420Unorm ;
      return;
    }
    if( "G16B16R162Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane420Unorm ;
      return;
    }
    if( "eG16B16R162Plane420Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane420Unorm ;
      return;
    }
    if( "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane420Unorm ;
      return;
    }
    if( "G16B16R163Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane422Unorm ;
      return;
    }
    if( "eG16B16R163Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane422Unorm ;
      return;
    }
    if( "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane422Unorm ;
      return;
    }
    if( "G16B16R162Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane422Unorm ;
      return;
    }
    if( "eG16B16R162Plane422Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane422Unorm ;
      return;
    }
    if( "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane422Unorm ;
      return;
    }
    if( "G16B16R163Plane444Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane444Unorm ;
      return;
    }
    if( "eG16B16R163Plane444Unorm" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane444Unorm ;
      return;
    }
    if( "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane444Unorm ;
      return;
    }
    if( "Pvrtc12BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc12BppUnormBlockIMG ;
      return;
    }
    if( "ePvrtc12BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc12BppUnormBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc12BppUnormBlockIMG ;
      return;
    }
    if( "Pvrtc14BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc14BppUnormBlockIMG ;
      return;
    }
    if( "ePvrtc14BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc14BppUnormBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc14BppUnormBlockIMG ;
      return;
    }
    if( "Pvrtc22BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc22BppUnormBlockIMG ;
      return;
    }
    if( "ePvrtc22BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc22BppUnormBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc22BppUnormBlockIMG ;
      return;
    }
    if( "Pvrtc24BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc24BppUnormBlockIMG ;
      return;
    }
    if( "ePvrtc24BppUnormBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc24BppUnormBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc24BppUnormBlockIMG ;
      return;
    }
    if( "Pvrtc12BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc12BppSrgbBlockIMG ;
      return;
    }
    if( "ePvrtc12BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc12BppSrgbBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc12BppSrgbBlockIMG ;
      return;
    }
    if( "Pvrtc14BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc14BppSrgbBlockIMG ;
      return;
    }
    if( "ePvrtc14BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc14BppSrgbBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc14BppSrgbBlockIMG ;
      return;
    }
    if( "Pvrtc22BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc22BppSrgbBlockIMG ;
      return;
    }
    if( "ePvrtc22BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc22BppSrgbBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc22BppSrgbBlockIMG ;
      return;
    }
    if( "Pvrtc24BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc24BppSrgbBlockIMG ;
      return;
    }
    if( "ePvrtc24BppSrgbBlockIMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc24BppSrgbBlockIMG ;
      return;
    }
    if( "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG" == j.get< std::string >() ) {
      p = Format :: ePvrtc24BppSrgbBlockIMG ;
      return;
    }
    if( "Astc4x4SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc4x4SfloatBlockEXT ;
      return;
    }
    if( "eAstc4x4SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc4x4SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc4x4SfloatBlockEXT ;
      return;
    }
    if( "Astc5x4SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc5x4SfloatBlockEXT ;
      return;
    }
    if( "eAstc5x4SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc5x4SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc5x4SfloatBlockEXT ;
      return;
    }
    if( "Astc5x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc5x5SfloatBlockEXT ;
      return;
    }
    if( "eAstc5x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc5x5SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc5x5SfloatBlockEXT ;
      return;
    }
    if( "Astc6x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc6x5SfloatBlockEXT ;
      return;
    }
    if( "eAstc6x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc6x5SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc6x5SfloatBlockEXT ;
      return;
    }
    if( "Astc6x6SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc6x6SfloatBlockEXT ;
      return;
    }
    if( "eAstc6x6SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc6x6SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc6x6SfloatBlockEXT ;
      return;
    }
    if( "Astc8x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x5SfloatBlockEXT ;
      return;
    }
    if( "eAstc8x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x5SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x5SfloatBlockEXT ;
      return;
    }
    if( "Astc8x6SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x6SfloatBlockEXT ;
      return;
    }
    if( "eAstc8x6SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x6SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x6SfloatBlockEXT ;
      return;
    }
    if( "Astc8x8SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x8SfloatBlockEXT ;
      return;
    }
    if( "eAstc8x8SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x8SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc8x8SfloatBlockEXT ;
      return;
    }
    if( "Astc10x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x5SfloatBlockEXT ;
      return;
    }
    if( "eAstc10x5SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x5SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x5SfloatBlockEXT ;
      return;
    }
    if( "Astc10x6SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x6SfloatBlockEXT ;
      return;
    }
    if( "eAstc10x6SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x6SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x6SfloatBlockEXT ;
      return;
    }
    if( "Astc10x8SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x8SfloatBlockEXT ;
      return;
    }
    if( "eAstc10x8SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x8SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x8SfloatBlockEXT ;
      return;
    }
    if( "Astc10x10SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x10SfloatBlockEXT ;
      return;
    }
    if( "eAstc10x10SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x10SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc10x10SfloatBlockEXT ;
      return;
    }
    if( "Astc12x10SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc12x10SfloatBlockEXT ;
      return;
    }
    if( "eAstc12x10SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc12x10SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc12x10SfloatBlockEXT ;
      return;
    }
    if( "Astc12x12SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc12x12SfloatBlockEXT ;
      return;
    }
    if( "eAstc12x12SfloatBlockEXT" == j.get< std::string >() ) {
      p = Format :: eAstc12x12SfloatBlockEXT ;
      return;
    }
    if( "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT" == j.get< std::string >() ) {
      p = Format :: eAstc12x12SfloatBlockEXT ;
      return;
    }
    if( "G8B8R82Plane444UnormEXT" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane444UnormEXT ;
      return;
    }
    if( "eG8B8R82Plane444UnormEXT" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane444UnormEXT ;
      return;
    }
    if( "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane444UnormEXT ;
      return;
    }
    if( "G10X6B10X6R10X62Plane444Unorm3Pack16EXT" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane444Unorm3Pack16EXT ;
      return;
    }
    if( "eG10X6B10X6R10X62Plane444Unorm3Pack16EXT" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane444Unorm3Pack16EXT ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane444Unorm3Pack16EXT ;
      return;
    }
    if( "G12X4B12X4R12X42Plane444Unorm3Pack16EXT" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane444Unorm3Pack16EXT ;
      return;
    }
    if( "eG12X4B12X4R12X42Plane444Unorm3Pack16EXT" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane444Unorm3Pack16EXT ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane444Unorm3Pack16EXT ;
      return;
    }
    if( "G16B16R162Plane444UnormEXT" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane444UnormEXT ;
      return;
    }
    if( "eG16B16R162Plane444UnormEXT" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane444UnormEXT ;
      return;
    }
    if( "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane444UnormEXT ;
      return;
    }
    if( "A4R4G4B4UnormPack16EXT" == j.get< std::string >() ) {
      p = Format :: eA4R4G4B4UnormPack16EXT ;
      return;
    }
    if( "eA4R4G4B4UnormPack16EXT" == j.get< std::string >() ) {
      p = Format :: eA4R4G4B4UnormPack16EXT ;
      return;
    }
    if( "VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT" == j.get< std::string >() ) {
      p = Format :: eA4R4G4B4UnormPack16EXT ;
      return;
    }
    if( "A4B4G4R4UnormPack16EXT" == j.get< std::string >() ) {
      p = Format :: eA4B4G4R4UnormPack16EXT ;
      return;
    }
    if( "eA4B4G4R4UnormPack16EXT" == j.get< std::string >() ) {
      p = Format :: eA4B4G4R4UnormPack16EXT ;
      return;
    }
    if( "VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT" == j.get< std::string >() ) {
      p = Format :: eA4B4G4R4UnormPack16EXT ;
      return;
    }
    if( "B10X6G10X6R10X6G10X6422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16KHR ;
      return;
    }
    if( "eB10X6G10X6R10X6G10X6422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eB10X6G10X6R10X6G10X6422Unorm4Pack16KHR ;
      return;
    }
    if( "B12X4G12X4R12X4G12X4422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16KHR ;
      return;
    }
    if( "eB12X4G12X4R12X4G12X4422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eB12X4G12X4R12X4G12X4422Unorm4Pack16KHR ;
      return;
    }
    if( "B16G16R16G16422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eB16G16R16G16422UnormKHR ;
      return;
    }
    if( "eB16G16R16G16422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eB16G16R16G16422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_B16G16R16G16_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eB16G16R16G16422UnormKHR ;
      return;
    }
    if( "B8G8R8G8422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eB8G8R8G8422UnormKHR ;
      return;
    }
    if( "eB8G8R8G8422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eB8G8R8G8422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_B8G8R8G8_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eB8G8R8G8422UnormKHR ;
      return;
    }
    if( "G10X6B10X6G10X6R10X6422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16KHR ;
      return;
    }
    if( "eG10X6B10X6G10X6R10X6422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6G10X6R10X6422Unorm4Pack16KHR ;
      return;
    }
    if( "G10X6B10X6R10X62Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "eG10X6B10X6R10X62Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "G10X6B10X6R10X62Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "eG10X6B10X6R10X62Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X62Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "G10X6B10X6R10X63Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "eG10X6B10X6R10X63Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "G10X6B10X6R10X63Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "eG10X6B10X6R10X63Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "G10X6B10X6R10X63Plane444Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16KHR ;
      return;
    }
    if( "eG10X6B10X6R10X63Plane444Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG10X6B10X6R10X63Plane444Unorm3Pack16KHR ;
      return;
    }
    if( "G12X4B12X4G12X4R12X4422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16KHR ;
      return;
    }
    if( "eG12X4B12X4G12X4R12X4422Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4G12X4R12X4422Unorm4Pack16KHR ;
      return;
    }
    if( "G12X4B12X4R12X42Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "eG12X4B12X4R12X42Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "G12X4B12X4R12X42Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "eG12X4B12X4R12X42Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X42Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "G12X4B12X4R12X43Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "eG12X4B12X4R12X43Plane420Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane420Unorm3Pack16KHR ;
      return;
    }
    if( "G12X4B12X4R12X43Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "eG12X4B12X4R12X43Plane422Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane422Unorm3Pack16KHR ;
      return;
    }
    if( "G12X4B12X4R12X43Plane444Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16KHR ;
      return;
    }
    if( "eG12X4B12X4R12X43Plane444Unorm3Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eG12X4B12X4R12X43Plane444Unorm3Pack16KHR ;
      return;
    }
    if( "G16B16G16R16422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16G16R16422UnormKHR ;
      return;
    }
    if( "eG16B16G16R16422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16G16R16422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G16B16G16R16_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG16B16G16R16422UnormKHR ;
      return;
    }
    if( "G16B16R162Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane420UnormKHR ;
      return;
    }
    if( "eG16B16R162Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane420UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane420UnormKHR ;
      return;
    }
    if( "G16B16R162Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane422UnormKHR ;
      return;
    }
    if( "eG16B16R162Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R162Plane422UnormKHR ;
      return;
    }
    if( "G16B16R163Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane420UnormKHR ;
      return;
    }
    if( "eG16B16R163Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane420UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane420UnormKHR ;
      return;
    }
    if( "G16B16R163Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane422UnormKHR ;
      return;
    }
    if( "eG16B16R163Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane422UnormKHR ;
      return;
    }
    if( "G16B16R163Plane444UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane444UnormKHR ;
      return;
    }
    if( "eG16B16R163Plane444UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane444UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG16B16R163Plane444UnormKHR ;
      return;
    }
    if( "G8B8G8R8422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8G8R8422UnormKHR ;
      return;
    }
    if( "eG8B8G8R8422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8G8R8422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G8B8G8R8_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG8B8G8R8422UnormKHR ;
      return;
    }
    if( "G8B8R82Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane420UnormKHR ;
      return;
    }
    if( "eG8B8R82Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane420UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane420UnormKHR ;
      return;
    }
    if( "G8B8R82Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane422UnormKHR ;
      return;
    }
    if( "eG8B8R82Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R82Plane422UnormKHR ;
      return;
    }
    if( "G8B8R83Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane420UnormKHR ;
      return;
    }
    if( "eG8B8R83Plane420UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane420UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane420UnormKHR ;
      return;
    }
    if( "G8B8R83Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane422UnormKHR ;
      return;
    }
    if( "eG8B8R83Plane422UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane422UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane422UnormKHR ;
      return;
    }
    if( "G8B8R83Plane444UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane444UnormKHR ;
      return;
    }
    if( "eG8B8R83Plane444UnormKHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane444UnormKHR ;
      return;
    }
    if( "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR" == j.get< std::string >() ) {
      p = Format :: eG8B8R83Plane444UnormKHR ;
      return;
    }
    if( "R10X6G10X6B10X6A10X6Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16KHR ;
      return;
    }
    if( "eR10X6G10X6B10X6A10X6Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6B10X6A10X6Unorm4Pack16KHR ;
      return;
    }
    if( "R10X6G10X6Unorm2Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6Unorm2Pack16KHR ;
      return;
    }
    if( "eR10X6G10X6Unorm2Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6Unorm2Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6G10X6Unorm2Pack16KHR ;
      return;
    }
    if( "R10X6UnormPack16KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6UnormPack16KHR ;
      return;
    }
    if( "eR10X6UnormPack16KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6UnormPack16KHR ;
      return;
    }
    if( "VK_FORMAT_R10X6_UNORM_PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eR10X6UnormPack16KHR ;
      return;
    }
    if( "R12X4G12X4B12X4A12X4Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16KHR ;
      return;
    }
    if( "eR12X4G12X4B12X4A12X4Unorm4Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4B12X4A12X4Unorm4Pack16KHR ;
      return;
    }
    if( "R12X4G12X4Unorm2Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4Unorm2Pack16KHR ;
      return;
    }
    if( "eR12X4G12X4Unorm2Pack16KHR" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4Unorm2Pack16KHR ;
      return;
    }
    if( "VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR" == j.get< std::string >() ) {
      p = Format :: eR12X4G12X4Unorm2Pack16KHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for Format" );
  }
  if( j.is_number() ) {
    p = Format ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for Format" );
}
inline void from_json( const nlohmann::json &j, VkFormat &p ) {
  Format temp;
  from_json( j, temp );
  p = VkFormat ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const ImageTiling &p ) {
  if( ImageTiling :: eOptimal == p ) {
    j = "Optimal";
    return;
  }
  if( ImageTiling :: eLinear == p ) {
    j = "Linear";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkImageTiling &p ) {
  to_json( j, ImageTiling ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageTiling &p ) {
  if( j.is_string() ) {
    if( "Optimal" == j.get< std::string >() ) {
      p = ImageTiling :: eOptimal ;
      return;
    }
    if( "eOptimal" == j.get< std::string >() ) {
      p = ImageTiling :: eOptimal ;
      return;
    }
    if( "VK_IMAGE_TILING_OPTIMAL" == j.get< std::string >() ) {
      p = ImageTiling :: eOptimal ;
      return;
    }
    if( "Linear" == j.get< std::string >() ) {
      p = ImageTiling :: eLinear ;
      return;
    }
    if( "eLinear" == j.get< std::string >() ) {
      p = ImageTiling :: eLinear ;
      return;
    }
    if( "VK_IMAGE_TILING_LINEAR" == j.get< std::string >() ) {
      p = ImageTiling :: eLinear ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImageTiling" );
  }
  if( j.is_number() ) {
    p = ImageTiling ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImageTiling" );
}
inline void from_json( const nlohmann::json &j, VkImageTiling &p ) {
  ImageTiling temp;
  from_json( j, temp );
  p = VkImageTiling ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const ImageType &p ) {
  if( ImageType :: e1D == p ) {
    j = "1D";
    return;
  }
  if( ImageType :: e2D == p ) {
    j = "2D";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkImageType &p ) {
  to_json( j, ImageType ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageType &p ) {
  if( j.is_string() ) {
    if( "1D" == j.get< std::string >() ) {
      p = ImageType :: e1D ;
      return;
    }
    if( "e1D" == j.get< std::string >() ) {
      p = ImageType :: e1D ;
      return;
    }
    if( "VK_IMAGE_TYPE_1D" == j.get< std::string >() ) {
      p = ImageType :: e1D ;
      return;
    }
    if( "2D" == j.get< std::string >() ) {
      p = ImageType :: e2D ;
      return;
    }
    if( "e2D" == j.get< std::string >() ) {
      p = ImageType :: e2D ;
      return;
    }
    if( "VK_IMAGE_TYPE_2D" == j.get< std::string >() ) {
      p = ImageType :: e2D ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImageType" );
  }
  if( j.is_number() ) {
    p = ImageType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImageType" );
}
inline void from_json( const nlohmann::json &j, VkImageType &p ) {
  ImageType temp;
  from_json( j, temp );
  p = VkImageType ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const InternalAllocationType &p ) {
}
inline void to_json( nlohmann::json &j, const VkInternalAllocationType &p ) {
  to_json( j, InternalAllocationType ( p ) );
}
inline void from_json( const nlohmann::json &j, InternalAllocationType &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for InternalAllocationType" );
  }
  if( j.is_number() ) {
    p = InternalAllocationType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for InternalAllocationType" );
}
inline void from_json( const nlohmann::json &j, VkInternalAllocationType &p ) {
  InternalAllocationType temp;
  from_json( j, temp );
  p = VkInternalAllocationType ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PhysicalDeviceType &p ) {
  if( PhysicalDeviceType :: eOther == p ) {
    j = "Other";
    return;
  }
  if( PhysicalDeviceType :: eIntegratedGpu == p ) {
    j = "IntegratedGpu";
    return;
  }
  if( PhysicalDeviceType :: eDiscreteGpu == p ) {
    j = "DiscreteGpu";
    return;
  }
  if( PhysicalDeviceType :: eVirtualGpu == p ) {
    j = "VirtualGpu";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceType &p ) {
  to_json( j, PhysicalDeviceType ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceType &p ) {
  if( j.is_string() ) {
    if( "Other" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eOther ;
      return;
    }
    if( "eOther" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eOther ;
      return;
    }
    if( "VK_PHYSICAL_DEVICE_TYPE_OTHER" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eOther ;
      return;
    }
    if( "IntegratedGpu" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eIntegratedGpu ;
      return;
    }
    if( "eIntegratedGpu" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eIntegratedGpu ;
      return;
    }
    if( "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eIntegratedGpu ;
      return;
    }
    if( "DiscreteGpu" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eDiscreteGpu ;
      return;
    }
    if( "eDiscreteGpu" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eDiscreteGpu ;
      return;
    }
    if( "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eDiscreteGpu ;
      return;
    }
    if( "VirtualGpu" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eVirtualGpu ;
      return;
    }
    if( "eVirtualGpu" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eVirtualGpu ;
      return;
    }
    if( "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU" == j.get< std::string >() ) {
      p = PhysicalDeviceType :: eVirtualGpu ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PhysicalDeviceType" );
  }
  if( j.is_number() ) {
    p = PhysicalDeviceType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PhysicalDeviceType" );
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceType &p ) {
  PhysicalDeviceType temp;
  from_json( j, temp );
  p = VkPhysicalDeviceType ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const SystemAllocationScope &p ) {
  if( SystemAllocationScope :: eCommand == p ) {
    j = "Command";
    return;
  }
  if( SystemAllocationScope :: eObject == p ) {
    j = "Object";
    return;
  }
  if( SystemAllocationScope :: eCache == p ) {
    j = "Cache";
    return;
  }
  if( SystemAllocationScope :: eDevice == p ) {
    j = "Device";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkSystemAllocationScope &p ) {
  to_json( j, SystemAllocationScope ( p ) );
}
inline void from_json( const nlohmann::json &j, SystemAllocationScope &p ) {
  if( j.is_string() ) {
    if( "Command" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eCommand ;
      return;
    }
    if( "eCommand" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eCommand ;
      return;
    }
    if( "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eCommand ;
      return;
    }
    if( "Object" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eObject ;
      return;
    }
    if( "eObject" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eObject ;
      return;
    }
    if( "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eObject ;
      return;
    }
    if( "Cache" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eCache ;
      return;
    }
    if( "eCache" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eCache ;
      return;
    }
    if( "VK_SYSTEM_ALLOCATION_SCOPE_CACHE" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eCache ;
      return;
    }
    if( "Device" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eDevice ;
      return;
    }
    if( "eDevice" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eDevice ;
      return;
    }
    if( "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE" == j.get< std::string >() ) {
      p = SystemAllocationScope :: eDevice ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SystemAllocationScope" );
  }
  if( j.is_number() ) {
    p = SystemAllocationScope ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SystemAllocationScope" );
}
inline void from_json( const nlohmann::json &j, VkSystemAllocationScope &p ) {
  SystemAllocationScope temp;
  from_json( j, temp );
  p = VkSystemAllocationScope ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const QueryType &p ) {
  if( QueryType :: eOcclusion == p ) {
    j = "Occlusion";
    return;
  }
  if( QueryType :: ePipelineStatistics == p ) {
    j = "PipelineStatistics";
    return;
  }
  if( QueryType :: eTimestamp == p ) {
    j = "Timestamp";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( QueryType :: eResultStatusOnlyKHR == p ) {
    j = "ResultStatusOnlyKHR";
    return;
  }
#endif
  if( QueryType :: eTransformFeedbackStreamEXT == p ) {
    j = "TransformFeedbackStreamEXT";
    return;
  }
  if( QueryType :: ePerformanceQueryKHR == p ) {
    j = "PerformanceQueryKHR";
    return;
  }
  if( QueryType :: eAccelerationStructureCompactedSizeKHR == p ) {
    j = "AccelerationStructureCompactedSizeKHR";
    return;
  }
  if( QueryType :: eAccelerationStructureSerializationSizeKHR == p ) {
    j = "AccelerationStructureSerializationSizeKHR";
    return;
  }
  if( QueryType :: eAccelerationStructureCompactedSizeNV == p ) {
    j = "AccelerationStructureCompactedSizeNV";
    return;
  }
  if( QueryType :: ePerformanceQueryINTEL == p ) {
    j = "PerformanceQueryINTEL";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkQueryType &p ) {
  to_json( j, QueryType ( p ) );
}
inline void from_json( const nlohmann::json &j, QueryType &p ) {
  if( j.is_string() ) {
    if( "Occlusion" == j.get< std::string >() ) {
      p = QueryType :: eOcclusion ;
      return;
    }
    if( "eOcclusion" == j.get< std::string >() ) {
      p = QueryType :: eOcclusion ;
      return;
    }
    if( "VK_QUERY_TYPE_OCCLUSION" == j.get< std::string >() ) {
      p = QueryType :: eOcclusion ;
      return;
    }
    if( "PipelineStatistics" == j.get< std::string >() ) {
      p = QueryType :: ePipelineStatistics ;
      return;
    }
    if( "ePipelineStatistics" == j.get< std::string >() ) {
      p = QueryType :: ePipelineStatistics ;
      return;
    }
    if( "VK_QUERY_TYPE_PIPELINE_STATISTICS" == j.get< std::string >() ) {
      p = QueryType :: ePipelineStatistics ;
      return;
    }
    if( "Timestamp" == j.get< std::string >() ) {
      p = QueryType :: eTimestamp ;
      return;
    }
    if( "eTimestamp" == j.get< std::string >() ) {
      p = QueryType :: eTimestamp ;
      return;
    }
    if( "VK_QUERY_TYPE_TIMESTAMP" == j.get< std::string >() ) {
      p = QueryType :: eTimestamp ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "ResultStatusOnlyKHR" == j.get< std::string >() ) {
      p = QueryType :: eResultStatusOnlyKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eResultStatusOnlyKHR" == j.get< std::string >() ) {
      p = QueryType :: eResultStatusOnlyKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR" == j.get< std::string >() ) {
      p = QueryType :: eResultStatusOnlyKHR ;
      return;
    }
#endif
    if( "TransformFeedbackStreamEXT" == j.get< std::string >() ) {
      p = QueryType :: eTransformFeedbackStreamEXT ;
      return;
    }
    if( "eTransformFeedbackStreamEXT" == j.get< std::string >() ) {
      p = QueryType :: eTransformFeedbackStreamEXT ;
      return;
    }
    if( "VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT" == j.get< std::string >() ) {
      p = QueryType :: eTransformFeedbackStreamEXT ;
      return;
    }
    if( "PerformanceQueryKHR" == j.get< std::string >() ) {
      p = QueryType :: ePerformanceQueryKHR ;
      return;
    }
    if( "ePerformanceQueryKHR" == j.get< std::string >() ) {
      p = QueryType :: ePerformanceQueryKHR ;
      return;
    }
    if( "VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR" == j.get< std::string >() ) {
      p = QueryType :: ePerformanceQueryKHR ;
      return;
    }
    if( "AccelerationStructureCompactedSizeKHR" == j.get< std::string >() ) {
      p = QueryType :: eAccelerationStructureCompactedSizeKHR ;
      return;
    }
    if( "eAccelerationStructureCompactedSizeKHR" == j.get< std::string >() ) {
      p = QueryType :: eAccelerationStructureCompactedSizeKHR ;
      return;
    }
    if( "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR" == j.get< std::string >() ) {
      p = QueryType :: eAccelerationStructureCompactedSizeKHR ;
      return;
    }
    if( "AccelerationStructureSerializationSizeKHR" == j.get< std::string >() ) {
      p = QueryType :: eAccelerationStructureSerializationSizeKHR ;
      return;
    }
    if( "eAccelerationStructureSerializationSizeKHR" == j.get< std::string >() ) {
      p = QueryType :: eAccelerationStructureSerializationSizeKHR ;
      return;
    }
    if( "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR" == j.get< std::string >() ) {
      p = QueryType :: eAccelerationStructureSerializationSizeKHR ;
      return;
    }
    if( "AccelerationStructureCompactedSizeNV" == j.get< std::string >() ) {
      p = QueryType :: eAccelerationStructureCompactedSizeNV ;
      return;
    }
    if( "eAccelerationStructureCompactedSizeNV" == j.get< std::string >() ) {
      p = QueryType :: eAccelerationStructureCompactedSizeNV ;
      return;
    }
    if( "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV" == j.get< std::string >() ) {
      p = QueryType :: eAccelerationStructureCompactedSizeNV ;
      return;
    }
    if( "PerformanceQueryINTEL" == j.get< std::string >() ) {
      p = QueryType :: ePerformanceQueryINTEL ;
      return;
    }
    if( "ePerformanceQueryINTEL" == j.get< std::string >() ) {
      p = QueryType :: ePerformanceQueryINTEL ;
      return;
    }
    if( "VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL" == j.get< std::string >() ) {
      p = QueryType :: ePerformanceQueryINTEL ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueryType" );
  }
  if( j.is_number() ) {
    p = QueryType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueryType" );
}
inline void from_json( const nlohmann::json &j, VkQueryType &p ) {
  QueryType temp;
  from_json( j, temp );
  p = VkQueryType ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const SharingMode &p ) {
  if( SharingMode :: eExclusive == p ) {
    j = "Exclusive";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkSharingMode &p ) {
  to_json( j, SharingMode ( p ) );
}
inline void from_json( const nlohmann::json &j, SharingMode &p ) {
  if( j.is_string() ) {
    if( "Exclusive" == j.get< std::string >() ) {
      p = SharingMode :: eExclusive ;
      return;
    }
    if( "eExclusive" == j.get< std::string >() ) {
      p = SharingMode :: eExclusive ;
      return;
    }
    if( "VK_SHARING_MODE_EXCLUSIVE" == j.get< std::string >() ) {
      p = SharingMode :: eExclusive ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SharingMode" );
  }
  if( j.is_number() ) {
    p = SharingMode ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SharingMode" );
}
inline void from_json( const nlohmann::json &j, VkSharingMode &p ) {
  SharingMode temp;
  from_json( j, temp );
  p = VkSharingMode ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const ImageLayout &p ) {
  if( ImageLayout :: eUndefined == p ) {
    j = "Undefined";
    return;
  }
  if( ImageLayout :: eGeneral == p ) {
    j = "General";
    return;
  }
  if( ImageLayout :: eColorAttachmentOptimal == p ) {
    j = "ColorAttachmentOptimal";
    return;
  }
  if( ImageLayout :: eDepthStencilAttachmentOptimal == p ) {
    j = "DepthStencilAttachmentOptimal";
    return;
  }
  if( ImageLayout :: eDepthStencilReadOnlyOptimal == p ) {
    j = "DepthStencilReadOnlyOptimal";
    return;
  }
  if( ImageLayout :: eShaderReadOnlyOptimal == p ) {
    j = "ShaderReadOnlyOptimal";
    return;
  }
  if( ImageLayout :: eTransferSrcOptimal == p ) {
    j = "TransferSrcOptimal";
    return;
  }
  if( ImageLayout :: eTransferDstOptimal == p ) {
    j = "TransferDstOptimal";
    return;
  }
  if( ImageLayout :: ePreinitialized == p ) {
    j = "Preinitialized";
    return;
  }
  if( ImageLayout :: eDepthReadOnlyStencilAttachmentOptimal == p ) {
    j = "DepthReadOnlyStencilAttachmentOptimal";
    return;
  }
  if( ImageLayout :: eDepthAttachmentStencilReadOnlyOptimal == p ) {
    j = "DepthAttachmentStencilReadOnlyOptimal";
    return;
  }
  if( ImageLayout :: eDepthAttachmentOptimal == p ) {
    j = "DepthAttachmentOptimal";
    return;
  }
  if( ImageLayout :: eDepthReadOnlyOptimal == p ) {
    j = "DepthReadOnlyOptimal";
    return;
  }
  if( ImageLayout :: eStencilAttachmentOptimal == p ) {
    j = "StencilAttachmentOptimal";
    return;
  }
  if( ImageLayout :: eStencilReadOnlyOptimal == p ) {
    j = "StencilReadOnlyOptimal";
    return;
  }
  if( ImageLayout :: ePresentSrcKHR == p ) {
    j = "PresentSrcKHR";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( ImageLayout :: eVideoDecodeDstKHR == p ) {
    j = "VideoDecodeDstKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( ImageLayout :: eVideoDecodeSrcKHR == p ) {
    j = "VideoDecodeSrcKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( ImageLayout :: eVideoDecodeDpbKHR == p ) {
    j = "VideoDecodeDpbKHR";
    return;
  }
#endif
  if( ImageLayout :: eSharedPresentKHR == p ) {
    j = "SharedPresentKHR";
    return;
  }
  if( ImageLayout :: eFragmentDensityMapOptimalEXT == p ) {
    j = "FragmentDensityMapOptimalEXT";
    return;
  }
  if( ImageLayout :: eFragmentShadingRateAttachmentOptimalKHR == p ) {
    j = "FragmentShadingRateAttachmentOptimalKHR";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( ImageLayout :: eVideoEncodeDstKHR == p ) {
    j = "VideoEncodeDstKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( ImageLayout :: eVideoEncodeSrcKHR == p ) {
    j = "VideoEncodeSrcKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( ImageLayout :: eVideoEncodeDpbKHR == p ) {
    j = "VideoEncodeDpbKHR";
    return;
  }
#endif
  if( ImageLayout :: eReadOnlyOptimalKHR == p ) {
    j = "ReadOnlyOptimalKHR";
    return;
  }
  if( ImageLayout :: eAttachmentOptimalKHR == p ) {
    j = "AttachmentOptimalKHR";
    return;
  }
  if( ImageLayout :: eDepthAttachmentOptimalKHR == p ) {
    j = "DepthAttachmentOptimalKHR";
    return;
  }
  if( ImageLayout :: eDepthAttachmentStencilReadOnlyOptimalKHR == p ) {
    j = "DepthAttachmentStencilReadOnlyOptimalKHR";
    return;
  }
  if( ImageLayout :: eDepthReadOnlyOptimalKHR == p ) {
    j = "DepthReadOnlyOptimalKHR";
    return;
  }
  if( ImageLayout :: eDepthReadOnlyStencilAttachmentOptimalKHR == p ) {
    j = "DepthReadOnlyStencilAttachmentOptimalKHR";
    return;
  }
  if( ImageLayout :: eShadingRateOptimalNV == p ) {
    j = "ShadingRateOptimalNV";
    return;
  }
  if( ImageLayout :: eStencilAttachmentOptimalKHR == p ) {
    j = "StencilAttachmentOptimalKHR";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkImageLayout &p ) {
  to_json( j, ImageLayout ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageLayout &p ) {
  if( j.is_string() ) {
    if( "Undefined" == j.get< std::string >() ) {
      p = ImageLayout :: eUndefined ;
      return;
    }
    if( "eUndefined" == j.get< std::string >() ) {
      p = ImageLayout :: eUndefined ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_UNDEFINED" == j.get< std::string >() ) {
      p = ImageLayout :: eUndefined ;
      return;
    }
    if( "General" == j.get< std::string >() ) {
      p = ImageLayout :: eGeneral ;
      return;
    }
    if( "eGeneral" == j.get< std::string >() ) {
      p = ImageLayout :: eGeneral ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_GENERAL" == j.get< std::string >() ) {
      p = ImageLayout :: eGeneral ;
      return;
    }
    if( "ColorAttachmentOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eColorAttachmentOptimal ;
      return;
    }
    if( "eColorAttachmentOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eColorAttachmentOptimal ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL" == j.get< std::string >() ) {
      p = ImageLayout :: eColorAttachmentOptimal ;
      return;
    }
    if( "DepthStencilAttachmentOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthStencilAttachmentOptimal ;
      return;
    }
    if( "eDepthStencilAttachmentOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthStencilAttachmentOptimal ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthStencilAttachmentOptimal ;
      return;
    }
    if( "DepthStencilReadOnlyOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthStencilReadOnlyOptimal ;
      return;
    }
    if( "eDepthStencilReadOnlyOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthStencilReadOnlyOptimal ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthStencilReadOnlyOptimal ;
      return;
    }
    if( "ShaderReadOnlyOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eShaderReadOnlyOptimal ;
      return;
    }
    if( "eShaderReadOnlyOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eShaderReadOnlyOptimal ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL" == j.get< std::string >() ) {
      p = ImageLayout :: eShaderReadOnlyOptimal ;
      return;
    }
    if( "TransferSrcOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eTransferSrcOptimal ;
      return;
    }
    if( "eTransferSrcOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eTransferSrcOptimal ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL" == j.get< std::string >() ) {
      p = ImageLayout :: eTransferSrcOptimal ;
      return;
    }
    if( "TransferDstOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eTransferDstOptimal ;
      return;
    }
    if( "eTransferDstOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eTransferDstOptimal ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL" == j.get< std::string >() ) {
      p = ImageLayout :: eTransferDstOptimal ;
      return;
    }
    if( "Preinitialized" == j.get< std::string >() ) {
      p = ImageLayout :: ePreinitialized ;
      return;
    }
    if( "ePreinitialized" == j.get< std::string >() ) {
      p = ImageLayout :: ePreinitialized ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_PREINITIALIZED" == j.get< std::string >() ) {
      p = ImageLayout :: ePreinitialized ;
      return;
    }
    if( "DepthReadOnlyStencilAttachmentOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthReadOnlyStencilAttachmentOptimal ;
      return;
    }
    if( "eDepthReadOnlyStencilAttachmentOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthReadOnlyStencilAttachmentOptimal ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthReadOnlyStencilAttachmentOptimal ;
      return;
    }
    if( "DepthAttachmentStencilReadOnlyOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthAttachmentStencilReadOnlyOptimal ;
      return;
    }
    if( "eDepthAttachmentStencilReadOnlyOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthAttachmentStencilReadOnlyOptimal ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthAttachmentStencilReadOnlyOptimal ;
      return;
    }
    if( "DepthAttachmentOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthAttachmentOptimal ;
      return;
    }
    if( "eDepthAttachmentOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthAttachmentOptimal ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthAttachmentOptimal ;
      return;
    }
    if( "DepthReadOnlyOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthReadOnlyOptimal ;
      return;
    }
    if( "eDepthReadOnlyOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthReadOnlyOptimal ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthReadOnlyOptimal ;
      return;
    }
    if( "StencilAttachmentOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eStencilAttachmentOptimal ;
      return;
    }
    if( "eStencilAttachmentOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eStencilAttachmentOptimal ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL" == j.get< std::string >() ) {
      p = ImageLayout :: eStencilAttachmentOptimal ;
      return;
    }
    if( "StencilReadOnlyOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eStencilReadOnlyOptimal ;
      return;
    }
    if( "eStencilReadOnlyOptimal" == j.get< std::string >() ) {
      p = ImageLayout :: eStencilReadOnlyOptimal ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL" == j.get< std::string >() ) {
      p = ImageLayout :: eStencilReadOnlyOptimal ;
      return;
    }
    if( "PresentSrcKHR" == j.get< std::string >() ) {
      p = ImageLayout :: ePresentSrcKHR ;
      return;
    }
    if( "ePresentSrcKHR" == j.get< std::string >() ) {
      p = ImageLayout :: ePresentSrcKHR ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: ePresentSrcKHR ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeDstKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoDecodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeDstKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoDecodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoDecodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeSrcKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoDecodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeSrcKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoDecodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoDecodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeDpbKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoDecodeDpbKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeDpbKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoDecodeDpbKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoDecodeDpbKHR ;
      return;
    }
#endif
    if( "SharedPresentKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eSharedPresentKHR ;
      return;
    }
    if( "eSharedPresentKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eSharedPresentKHR ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eSharedPresentKHR ;
      return;
    }
    if( "FragmentDensityMapOptimalEXT" == j.get< std::string >() ) {
      p = ImageLayout :: eFragmentDensityMapOptimalEXT ;
      return;
    }
    if( "eFragmentDensityMapOptimalEXT" == j.get< std::string >() ) {
      p = ImageLayout :: eFragmentDensityMapOptimalEXT ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT" == j.get< std::string >() ) {
      p = ImageLayout :: eFragmentDensityMapOptimalEXT ;
      return;
    }
    if( "FragmentShadingRateAttachmentOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eFragmentShadingRateAttachmentOptimalKHR ;
      return;
    }
    if( "eFragmentShadingRateAttachmentOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eFragmentShadingRateAttachmentOptimalKHR ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eFragmentShadingRateAttachmentOptimalKHR ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeDstKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoEncodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeDstKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoEncodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoEncodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeSrcKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoEncodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeSrcKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoEncodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoEncodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeDpbKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoEncodeDpbKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeDpbKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoEncodeDpbKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eVideoEncodeDpbKHR ;
      return;
    }
#endif
    if( "ReadOnlyOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eReadOnlyOptimalKHR ;
      return;
    }
    if( "eReadOnlyOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eReadOnlyOptimalKHR ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eReadOnlyOptimalKHR ;
      return;
    }
    if( "AttachmentOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eAttachmentOptimalKHR ;
      return;
    }
    if( "eAttachmentOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eAttachmentOptimalKHR ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eAttachmentOptimalKHR ;
      return;
    }
    if( "DepthAttachmentOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthAttachmentOptimalKHR ;
      return;
    }
    if( "eDepthAttachmentOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthAttachmentOptimalKHR ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthAttachmentOptimalKHR ;
      return;
    }
    if( "DepthAttachmentStencilReadOnlyOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthAttachmentStencilReadOnlyOptimalKHR ;
      return;
    }
    if( "eDepthAttachmentStencilReadOnlyOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthAttachmentStencilReadOnlyOptimalKHR ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthAttachmentStencilReadOnlyOptimalKHR ;
      return;
    }
    if( "DepthReadOnlyOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthReadOnlyOptimalKHR ;
      return;
    }
    if( "eDepthReadOnlyOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthReadOnlyOptimalKHR ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthReadOnlyOptimalKHR ;
      return;
    }
    if( "DepthReadOnlyStencilAttachmentOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthReadOnlyStencilAttachmentOptimalKHR ;
      return;
    }
    if( "eDepthReadOnlyStencilAttachmentOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthReadOnlyStencilAttachmentOptimalKHR ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eDepthReadOnlyStencilAttachmentOptimalKHR ;
      return;
    }
    if( "ShadingRateOptimalNV" == j.get< std::string >() ) {
      p = ImageLayout :: eShadingRateOptimalNV ;
      return;
    }
    if( "eShadingRateOptimalNV" == j.get< std::string >() ) {
      p = ImageLayout :: eShadingRateOptimalNV ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV" == j.get< std::string >() ) {
      p = ImageLayout :: eShadingRateOptimalNV ;
      return;
    }
    if( "StencilAttachmentOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eStencilAttachmentOptimalKHR ;
      return;
    }
    if( "eStencilAttachmentOptimalKHR" == j.get< std::string >() ) {
      p = ImageLayout :: eStencilAttachmentOptimalKHR ;
      return;
    }
    if( "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR" == j.get< std::string >() ) {
      p = ImageLayout :: eStencilAttachmentOptimalKHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImageLayout" );
  }
  if( j.is_number() ) {
    p = ImageLayout ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImageLayout" );
}
inline void from_json( const nlohmann::json &j, VkImageLayout &p ) {
  ImageLayout temp;
  from_json( j, temp );
  p = VkImageLayout ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const ComponentSwizzle &p ) {
  if( ComponentSwizzle :: eIdentity == p ) {
    j = "Identity";
    return;
  }
  if( ComponentSwizzle :: eZero == p ) {
    j = "Zero";
    return;
  }
  if( ComponentSwizzle :: eOne == p ) {
    j = "One";
    return;
  }
  if( ComponentSwizzle :: eR == p ) {
    j = "R";
    return;
  }
  if( ComponentSwizzle :: eG == p ) {
    j = "G";
    return;
  }
  if( ComponentSwizzle :: eB == p ) {
    j = "B";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkComponentSwizzle &p ) {
  to_json( j, ComponentSwizzle ( p ) );
}
inline void from_json( const nlohmann::json &j, ComponentSwizzle &p ) {
  if( j.is_string() ) {
    if( "Identity" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eIdentity ;
      return;
    }
    if( "eIdentity" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eIdentity ;
      return;
    }
    if( "VK_COMPONENT_SWIZZLE_IDENTITY" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eIdentity ;
      return;
    }
    if( "Zero" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eZero ;
      return;
    }
    if( "eZero" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eZero ;
      return;
    }
    if( "VK_COMPONENT_SWIZZLE_ZERO" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eZero ;
      return;
    }
    if( "One" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eOne ;
      return;
    }
    if( "eOne" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eOne ;
      return;
    }
    if( "VK_COMPONENT_SWIZZLE_ONE" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eOne ;
      return;
    }
    if( "R" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eR ;
      return;
    }
    if( "eR" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eR ;
      return;
    }
    if( "VK_COMPONENT_SWIZZLE_R" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eR ;
      return;
    }
    if( "G" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eG ;
      return;
    }
    if( "eG" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eG ;
      return;
    }
    if( "VK_COMPONENT_SWIZZLE_G" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eG ;
      return;
    }
    if( "B" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eB ;
      return;
    }
    if( "eB" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eB ;
      return;
    }
    if( "VK_COMPONENT_SWIZZLE_B" == j.get< std::string >() ) {
      p = ComponentSwizzle :: eB ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ComponentSwizzle" );
  }
  if( j.is_number() ) {
    p = ComponentSwizzle ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ComponentSwizzle" );
}
inline void from_json( const nlohmann::json &j, VkComponentSwizzle &p ) {
  ComponentSwizzle temp;
  from_json( j, temp );
  p = VkComponentSwizzle ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const ImageViewType &p ) {
  if( ImageViewType :: e1D == p ) {
    j = "1D";
    return;
  }
  if( ImageViewType :: e2D == p ) {
    j = "2D";
    return;
  }
  if( ImageViewType :: e3D == p ) {
    j = "3D";
    return;
  }
  if( ImageViewType :: eCube == p ) {
    j = "Cube";
    return;
  }
  if( ImageViewType :: e1DArray == p ) {
    j = "1DArray";
    return;
  }
  if( ImageViewType :: e2DArray == p ) {
    j = "2DArray";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkImageViewType &p ) {
  to_json( j, ImageViewType ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageViewType &p ) {
  if( j.is_string() ) {
    if( "1D" == j.get< std::string >() ) {
      p = ImageViewType :: e1D ;
      return;
    }
    if( "e1D" == j.get< std::string >() ) {
      p = ImageViewType :: e1D ;
      return;
    }
    if( "VK_IMAGE_VIEW_TYPE_1D" == j.get< std::string >() ) {
      p = ImageViewType :: e1D ;
      return;
    }
    if( "2D" == j.get< std::string >() ) {
      p = ImageViewType :: e2D ;
      return;
    }
    if( "e2D" == j.get< std::string >() ) {
      p = ImageViewType :: e2D ;
      return;
    }
    if( "VK_IMAGE_VIEW_TYPE_2D" == j.get< std::string >() ) {
      p = ImageViewType :: e2D ;
      return;
    }
    if( "3D" == j.get< std::string >() ) {
      p = ImageViewType :: e3D ;
      return;
    }
    if( "e3D" == j.get< std::string >() ) {
      p = ImageViewType :: e3D ;
      return;
    }
    if( "VK_IMAGE_VIEW_TYPE_3D" == j.get< std::string >() ) {
      p = ImageViewType :: e3D ;
      return;
    }
    if( "Cube" == j.get< std::string >() ) {
      p = ImageViewType :: eCube ;
      return;
    }
    if( "eCube" == j.get< std::string >() ) {
      p = ImageViewType :: eCube ;
      return;
    }
    if( "VK_IMAGE_VIEW_TYPE_CUBE" == j.get< std::string >() ) {
      p = ImageViewType :: eCube ;
      return;
    }
    if( "1DArray" == j.get< std::string >() ) {
      p = ImageViewType :: e1DArray ;
      return;
    }
    if( "e1DArray" == j.get< std::string >() ) {
      p = ImageViewType :: e1DArray ;
      return;
    }
    if( "VK_IMAGE_VIEW_TYPE_1D_ARRAY" == j.get< std::string >() ) {
      p = ImageViewType :: e1DArray ;
      return;
    }
    if( "2DArray" == j.get< std::string >() ) {
      p = ImageViewType :: e2DArray ;
      return;
    }
    if( "e2DArray" == j.get< std::string >() ) {
      p = ImageViewType :: e2DArray ;
      return;
    }
    if( "VK_IMAGE_VIEW_TYPE_2D_ARRAY" == j.get< std::string >() ) {
      p = ImageViewType :: e2DArray ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImageViewType" );
  }
  if( j.is_number() ) {
    p = ImageViewType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImageViewType" );
}
inline void from_json( const nlohmann::json &j, VkImageViewType &p ) {
  ImageViewType temp;
  from_json( j, temp );
  p = VkImageViewType ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const BlendFactor &p ) {
  if( BlendFactor :: eZero == p ) {
    j = "Zero";
    return;
  }
  if( BlendFactor :: eOne == p ) {
    j = "One";
    return;
  }
  if( BlendFactor :: eSrcColor == p ) {
    j = "SrcColor";
    return;
  }
  if( BlendFactor :: eOneMinusSrcColor == p ) {
    j = "OneMinusSrcColor";
    return;
  }
  if( BlendFactor :: eDstColor == p ) {
    j = "DstColor";
    return;
  }
  if( BlendFactor :: eOneMinusDstColor == p ) {
    j = "OneMinusDstColor";
    return;
  }
  if( BlendFactor :: eSrcAlpha == p ) {
    j = "SrcAlpha";
    return;
  }
  if( BlendFactor :: eOneMinusSrcAlpha == p ) {
    j = "OneMinusSrcAlpha";
    return;
  }
  if( BlendFactor :: eDstAlpha == p ) {
    j = "DstAlpha";
    return;
  }
  if( BlendFactor :: eOneMinusDstAlpha == p ) {
    j = "OneMinusDstAlpha";
    return;
  }
  if( BlendFactor :: eConstantColor == p ) {
    j = "ConstantColor";
    return;
  }
  if( BlendFactor :: eOneMinusConstantColor == p ) {
    j = "OneMinusConstantColor";
    return;
  }
  if( BlendFactor :: eConstantAlpha == p ) {
    j = "ConstantAlpha";
    return;
  }
  if( BlendFactor :: eOneMinusConstantAlpha == p ) {
    j = "OneMinusConstantAlpha";
    return;
  }
  if( BlendFactor :: eSrcAlphaSaturate == p ) {
    j = "SrcAlphaSaturate";
    return;
  }
  if( BlendFactor :: eSrc1Color == p ) {
    j = "Src1Color";
    return;
  }
  if( BlendFactor :: eOneMinusSrc1Color == p ) {
    j = "OneMinusSrc1Color";
    return;
  }
  if( BlendFactor :: eSrc1Alpha == p ) {
    j = "Src1Alpha";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkBlendFactor &p ) {
  to_json( j, BlendFactor ( p ) );
}
inline void from_json( const nlohmann::json &j, BlendFactor &p ) {
  if( j.is_string() ) {
    if( "Zero" == j.get< std::string >() ) {
      p = BlendFactor :: eZero ;
      return;
    }
    if( "eZero" == j.get< std::string >() ) {
      p = BlendFactor :: eZero ;
      return;
    }
    if( "VK_BLEND_FACTOR_ZERO" == j.get< std::string >() ) {
      p = BlendFactor :: eZero ;
      return;
    }
    if( "One" == j.get< std::string >() ) {
      p = BlendFactor :: eOne ;
      return;
    }
    if( "eOne" == j.get< std::string >() ) {
      p = BlendFactor :: eOne ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE" == j.get< std::string >() ) {
      p = BlendFactor :: eOne ;
      return;
    }
    if( "SrcColor" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcColor ;
      return;
    }
    if( "eSrcColor" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcColor ;
      return;
    }
    if( "VK_BLEND_FACTOR_SRC_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcColor ;
      return;
    }
    if( "OneMinusSrcColor" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrcColor ;
      return;
    }
    if( "eOneMinusSrcColor" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrcColor ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrcColor ;
      return;
    }
    if( "DstColor" == j.get< std::string >() ) {
      p = BlendFactor :: eDstColor ;
      return;
    }
    if( "eDstColor" == j.get< std::string >() ) {
      p = BlendFactor :: eDstColor ;
      return;
    }
    if( "VK_BLEND_FACTOR_DST_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eDstColor ;
      return;
    }
    if( "OneMinusDstColor" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusDstColor ;
      return;
    }
    if( "eOneMinusDstColor" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusDstColor ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusDstColor ;
      return;
    }
    if( "SrcAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcAlpha ;
      return;
    }
    if( "eSrcAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcAlpha ;
      return;
    }
    if( "VK_BLEND_FACTOR_SRC_ALPHA" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcAlpha ;
      return;
    }
    if( "OneMinusSrcAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrcAlpha ;
      return;
    }
    if( "eOneMinusSrcAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrcAlpha ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrcAlpha ;
      return;
    }
    if( "DstAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eDstAlpha ;
      return;
    }
    if( "eDstAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eDstAlpha ;
      return;
    }
    if( "VK_BLEND_FACTOR_DST_ALPHA" == j.get< std::string >() ) {
      p = BlendFactor :: eDstAlpha ;
      return;
    }
    if( "OneMinusDstAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusDstAlpha ;
      return;
    }
    if( "eOneMinusDstAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusDstAlpha ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusDstAlpha ;
      return;
    }
    if( "ConstantColor" == j.get< std::string >() ) {
      p = BlendFactor :: eConstantColor ;
      return;
    }
    if( "eConstantColor" == j.get< std::string >() ) {
      p = BlendFactor :: eConstantColor ;
      return;
    }
    if( "VK_BLEND_FACTOR_CONSTANT_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eConstantColor ;
      return;
    }
    if( "OneMinusConstantColor" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusConstantColor ;
      return;
    }
    if( "eOneMinusConstantColor" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusConstantColor ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusConstantColor ;
      return;
    }
    if( "ConstantAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eConstantAlpha ;
      return;
    }
    if( "eConstantAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eConstantAlpha ;
      return;
    }
    if( "VK_BLEND_FACTOR_CONSTANT_ALPHA" == j.get< std::string >() ) {
      p = BlendFactor :: eConstantAlpha ;
      return;
    }
    if( "OneMinusConstantAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusConstantAlpha ;
      return;
    }
    if( "eOneMinusConstantAlpha" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusConstantAlpha ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusConstantAlpha ;
      return;
    }
    if( "SrcAlphaSaturate" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcAlphaSaturate ;
      return;
    }
    if( "eSrcAlphaSaturate" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcAlphaSaturate ;
      return;
    }
    if( "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE" == j.get< std::string >() ) {
      p = BlendFactor :: eSrcAlphaSaturate ;
      return;
    }
    if( "Src1Color" == j.get< std::string >() ) {
      p = BlendFactor :: eSrc1Color ;
      return;
    }
    if( "eSrc1Color" == j.get< std::string >() ) {
      p = BlendFactor :: eSrc1Color ;
      return;
    }
    if( "VK_BLEND_FACTOR_SRC1_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eSrc1Color ;
      return;
    }
    if( "OneMinusSrc1Color" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrc1Color ;
      return;
    }
    if( "eOneMinusSrc1Color" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrc1Color ;
      return;
    }
    if( "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR" == j.get< std::string >() ) {
      p = BlendFactor :: eOneMinusSrc1Color ;
      return;
    }
    if( "Src1Alpha" == j.get< std::string >() ) {
      p = BlendFactor :: eSrc1Alpha ;
      return;
    }
    if( "eSrc1Alpha" == j.get< std::string >() ) {
      p = BlendFactor :: eSrc1Alpha ;
      return;
    }
    if( "VK_BLEND_FACTOR_SRC1_ALPHA" == j.get< std::string >() ) {
      p = BlendFactor :: eSrc1Alpha ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BlendFactor" );
  }
  if( j.is_number() ) {
    p = BlendFactor ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BlendFactor" );
}
inline void from_json( const nlohmann::json &j, VkBlendFactor &p ) {
  BlendFactor temp;
  from_json( j, temp );
  p = VkBlendFactor ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const BlendOp &p ) {
  if( BlendOp :: eAdd == p ) {
    j = "Add";
    return;
  }
  if( BlendOp :: eSubtract == p ) {
    j = "Subtract";
    return;
  }
  if( BlendOp :: eReverseSubtract == p ) {
    j = "ReverseSubtract";
    return;
  }
  if( BlendOp :: eMin == p ) {
    j = "Min";
    return;
  }
  if( BlendOp :: eMax == p ) {
    j = "Max";
    return;
  }
  if( BlendOp :: eZeroEXT == p ) {
    j = "ZeroEXT";
    return;
  }
  if( BlendOp :: eSrcEXT == p ) {
    j = "SrcEXT";
    return;
  }
  if( BlendOp :: eDstEXT == p ) {
    j = "DstEXT";
    return;
  }
  if( BlendOp :: eSrcOverEXT == p ) {
    j = "SrcOverEXT";
    return;
  }
  if( BlendOp :: eDstOverEXT == p ) {
    j = "DstOverEXT";
    return;
  }
  if( BlendOp :: eSrcInEXT == p ) {
    j = "SrcInEXT";
    return;
  }
  if( BlendOp :: eDstInEXT == p ) {
    j = "DstInEXT";
    return;
  }
  if( BlendOp :: eSrcOutEXT == p ) {
    j = "SrcOutEXT";
    return;
  }
  if( BlendOp :: eDstOutEXT == p ) {
    j = "DstOutEXT";
    return;
  }
  if( BlendOp :: eSrcAtopEXT == p ) {
    j = "SrcAtopEXT";
    return;
  }
  if( BlendOp :: eDstAtopEXT == p ) {
    j = "DstAtopEXT";
    return;
  }
  if( BlendOp :: eXorEXT == p ) {
    j = "XorEXT";
    return;
  }
  if( BlendOp :: eMultiplyEXT == p ) {
    j = "MultiplyEXT";
    return;
  }
  if( BlendOp :: eScreenEXT == p ) {
    j = "ScreenEXT";
    return;
  }
  if( BlendOp :: eOverlayEXT == p ) {
    j = "OverlayEXT";
    return;
  }
  if( BlendOp :: eDarkenEXT == p ) {
    j = "DarkenEXT";
    return;
  }
  if( BlendOp :: eLightenEXT == p ) {
    j = "LightenEXT";
    return;
  }
  if( BlendOp :: eColordodgeEXT == p ) {
    j = "ColordodgeEXT";
    return;
  }
  if( BlendOp :: eColorburnEXT == p ) {
    j = "ColorburnEXT";
    return;
  }
  if( BlendOp :: eHardlightEXT == p ) {
    j = "HardlightEXT";
    return;
  }
  if( BlendOp :: eSoftlightEXT == p ) {
    j = "SoftlightEXT";
    return;
  }
  if( BlendOp :: eDifferenceEXT == p ) {
    j = "DifferenceEXT";
    return;
  }
  if( BlendOp :: eExclusionEXT == p ) {
    j = "ExclusionEXT";
    return;
  }
  if( BlendOp :: eInvertEXT == p ) {
    j = "InvertEXT";
    return;
  }
  if( BlendOp :: eInvertRgbEXT == p ) {
    j = "InvertRgbEXT";
    return;
  }
  if( BlendOp :: eLineardodgeEXT == p ) {
    j = "LineardodgeEXT";
    return;
  }
  if( BlendOp :: eLinearburnEXT == p ) {
    j = "LinearburnEXT";
    return;
  }
  if( BlendOp :: eVividlightEXT == p ) {
    j = "VividlightEXT";
    return;
  }
  if( BlendOp :: eLinearlightEXT == p ) {
    j = "LinearlightEXT";
    return;
  }
  if( BlendOp :: ePinlightEXT == p ) {
    j = "PinlightEXT";
    return;
  }
  if( BlendOp :: eHardmixEXT == p ) {
    j = "HardmixEXT";
    return;
  }
  if( BlendOp :: eHslHueEXT == p ) {
    j = "HslHueEXT";
    return;
  }
  if( BlendOp :: eHslSaturationEXT == p ) {
    j = "HslSaturationEXT";
    return;
  }
  if( BlendOp :: eHslColorEXT == p ) {
    j = "HslColorEXT";
    return;
  }
  if( BlendOp :: eHslLuminosityEXT == p ) {
    j = "HslLuminosityEXT";
    return;
  }
  if( BlendOp :: ePlusEXT == p ) {
    j = "PlusEXT";
    return;
  }
  if( BlendOp :: ePlusClampedEXT == p ) {
    j = "PlusClampedEXT";
    return;
  }
  if( BlendOp :: ePlusClampedAlphaEXT == p ) {
    j = "PlusClampedAlphaEXT";
    return;
  }
  if( BlendOp :: ePlusDarkerEXT == p ) {
    j = "PlusDarkerEXT";
    return;
  }
  if( BlendOp :: eMinusEXT == p ) {
    j = "MinusEXT";
    return;
  }
  if( BlendOp :: eMinusClampedEXT == p ) {
    j = "MinusClampedEXT";
    return;
  }
  if( BlendOp :: eContrastEXT == p ) {
    j = "ContrastEXT";
    return;
  }
  if( BlendOp :: eInvertOvgEXT == p ) {
    j = "InvertOvgEXT";
    return;
  }
  if( BlendOp :: eRedEXT == p ) {
    j = "RedEXT";
    return;
  }
  if( BlendOp :: eGreenEXT == p ) {
    j = "GreenEXT";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkBlendOp &p ) {
  to_json( j, BlendOp ( p ) );
}
inline void from_json( const nlohmann::json &j, BlendOp &p ) {
  if( j.is_string() ) {
    if( "Add" == j.get< std::string >() ) {
      p = BlendOp :: eAdd ;
      return;
    }
    if( "eAdd" == j.get< std::string >() ) {
      p = BlendOp :: eAdd ;
      return;
    }
    if( "VK_BLEND_OP_ADD" == j.get< std::string >() ) {
      p = BlendOp :: eAdd ;
      return;
    }
    if( "Subtract" == j.get< std::string >() ) {
      p = BlendOp :: eSubtract ;
      return;
    }
    if( "eSubtract" == j.get< std::string >() ) {
      p = BlendOp :: eSubtract ;
      return;
    }
    if( "VK_BLEND_OP_SUBTRACT" == j.get< std::string >() ) {
      p = BlendOp :: eSubtract ;
      return;
    }
    if( "ReverseSubtract" == j.get< std::string >() ) {
      p = BlendOp :: eReverseSubtract ;
      return;
    }
    if( "eReverseSubtract" == j.get< std::string >() ) {
      p = BlendOp :: eReverseSubtract ;
      return;
    }
    if( "VK_BLEND_OP_REVERSE_SUBTRACT" == j.get< std::string >() ) {
      p = BlendOp :: eReverseSubtract ;
      return;
    }
    if( "Min" == j.get< std::string >() ) {
      p = BlendOp :: eMin ;
      return;
    }
    if( "eMin" == j.get< std::string >() ) {
      p = BlendOp :: eMin ;
      return;
    }
    if( "VK_BLEND_OP_MIN" == j.get< std::string >() ) {
      p = BlendOp :: eMin ;
      return;
    }
    if( "Max" == j.get< std::string >() ) {
      p = BlendOp :: eMax ;
      return;
    }
    if( "eMax" == j.get< std::string >() ) {
      p = BlendOp :: eMax ;
      return;
    }
    if( "VK_BLEND_OP_MAX" == j.get< std::string >() ) {
      p = BlendOp :: eMax ;
      return;
    }
    if( "ZeroEXT" == j.get< std::string >() ) {
      p = BlendOp :: eZeroEXT ;
      return;
    }
    if( "eZeroEXT" == j.get< std::string >() ) {
      p = BlendOp :: eZeroEXT ;
      return;
    }
    if( "VK_BLEND_OP_ZERO_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eZeroEXT ;
      return;
    }
    if( "SrcEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcEXT ;
      return;
    }
    if( "eSrcEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcEXT ;
      return;
    }
    if( "VK_BLEND_OP_SRC_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcEXT ;
      return;
    }
    if( "DstEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstEXT ;
      return;
    }
    if( "eDstEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstEXT ;
      return;
    }
    if( "VK_BLEND_OP_DST_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstEXT ;
      return;
    }
    if( "SrcOverEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcOverEXT ;
      return;
    }
    if( "eSrcOverEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcOverEXT ;
      return;
    }
    if( "VK_BLEND_OP_SRC_OVER_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcOverEXT ;
      return;
    }
    if( "DstOverEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstOverEXT ;
      return;
    }
    if( "eDstOverEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstOverEXT ;
      return;
    }
    if( "VK_BLEND_OP_DST_OVER_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstOverEXT ;
      return;
    }
    if( "SrcInEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcInEXT ;
      return;
    }
    if( "eSrcInEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcInEXT ;
      return;
    }
    if( "VK_BLEND_OP_SRC_IN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcInEXT ;
      return;
    }
    if( "DstInEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstInEXT ;
      return;
    }
    if( "eDstInEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstInEXT ;
      return;
    }
    if( "VK_BLEND_OP_DST_IN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstInEXT ;
      return;
    }
    if( "SrcOutEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcOutEXT ;
      return;
    }
    if( "eSrcOutEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcOutEXT ;
      return;
    }
    if( "VK_BLEND_OP_SRC_OUT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcOutEXT ;
      return;
    }
    if( "DstOutEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstOutEXT ;
      return;
    }
    if( "eDstOutEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstOutEXT ;
      return;
    }
    if( "VK_BLEND_OP_DST_OUT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstOutEXT ;
      return;
    }
    if( "SrcAtopEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcAtopEXT ;
      return;
    }
    if( "eSrcAtopEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcAtopEXT ;
      return;
    }
    if( "VK_BLEND_OP_SRC_ATOP_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eSrcAtopEXT ;
      return;
    }
    if( "DstAtopEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstAtopEXT ;
      return;
    }
    if( "eDstAtopEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstAtopEXT ;
      return;
    }
    if( "VK_BLEND_OP_DST_ATOP_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eDstAtopEXT ;
      return;
    }
    if( "XorEXT" == j.get< std::string >() ) {
      p = BlendOp :: eXorEXT ;
      return;
    }
    if( "eXorEXT" == j.get< std::string >() ) {
      p = BlendOp :: eXorEXT ;
      return;
    }
    if( "VK_BLEND_OP_XOR_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eXorEXT ;
      return;
    }
    if( "MultiplyEXT" == j.get< std::string >() ) {
      p = BlendOp :: eMultiplyEXT ;
      return;
    }
    if( "eMultiplyEXT" == j.get< std::string >() ) {
      p = BlendOp :: eMultiplyEXT ;
      return;
    }
    if( "VK_BLEND_OP_MULTIPLY_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eMultiplyEXT ;
      return;
    }
    if( "ScreenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eScreenEXT ;
      return;
    }
    if( "eScreenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eScreenEXT ;
      return;
    }
    if( "VK_BLEND_OP_SCREEN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eScreenEXT ;
      return;
    }
    if( "OverlayEXT" == j.get< std::string >() ) {
      p = BlendOp :: eOverlayEXT ;
      return;
    }
    if( "eOverlayEXT" == j.get< std::string >() ) {
      p = BlendOp :: eOverlayEXT ;
      return;
    }
    if( "VK_BLEND_OP_OVERLAY_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eOverlayEXT ;
      return;
    }
    if( "DarkenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDarkenEXT ;
      return;
    }
    if( "eDarkenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDarkenEXT ;
      return;
    }
    if( "VK_BLEND_OP_DARKEN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eDarkenEXT ;
      return;
    }
    if( "LightenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLightenEXT ;
      return;
    }
    if( "eLightenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLightenEXT ;
      return;
    }
    if( "VK_BLEND_OP_LIGHTEN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eLightenEXT ;
      return;
    }
    if( "ColordodgeEXT" == j.get< std::string >() ) {
      p = BlendOp :: eColordodgeEXT ;
      return;
    }
    if( "eColordodgeEXT" == j.get< std::string >() ) {
      p = BlendOp :: eColordodgeEXT ;
      return;
    }
    if( "VK_BLEND_OP_COLORDODGE_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eColordodgeEXT ;
      return;
    }
    if( "ColorburnEXT" == j.get< std::string >() ) {
      p = BlendOp :: eColorburnEXT ;
      return;
    }
    if( "eColorburnEXT" == j.get< std::string >() ) {
      p = BlendOp :: eColorburnEXT ;
      return;
    }
    if( "VK_BLEND_OP_COLORBURN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eColorburnEXT ;
      return;
    }
    if( "HardlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHardlightEXT ;
      return;
    }
    if( "eHardlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHardlightEXT ;
      return;
    }
    if( "VK_BLEND_OP_HARDLIGHT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eHardlightEXT ;
      return;
    }
    if( "SoftlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSoftlightEXT ;
      return;
    }
    if( "eSoftlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eSoftlightEXT ;
      return;
    }
    if( "VK_BLEND_OP_SOFTLIGHT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eSoftlightEXT ;
      return;
    }
    if( "DifferenceEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDifferenceEXT ;
      return;
    }
    if( "eDifferenceEXT" == j.get< std::string >() ) {
      p = BlendOp :: eDifferenceEXT ;
      return;
    }
    if( "VK_BLEND_OP_DIFFERENCE_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eDifferenceEXT ;
      return;
    }
    if( "ExclusionEXT" == j.get< std::string >() ) {
      p = BlendOp :: eExclusionEXT ;
      return;
    }
    if( "eExclusionEXT" == j.get< std::string >() ) {
      p = BlendOp :: eExclusionEXT ;
      return;
    }
    if( "VK_BLEND_OP_EXCLUSION_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eExclusionEXT ;
      return;
    }
    if( "InvertEXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertEXT ;
      return;
    }
    if( "eInvertEXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertEXT ;
      return;
    }
    if( "VK_BLEND_OP_INVERT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertEXT ;
      return;
    }
    if( "InvertRgbEXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertRgbEXT ;
      return;
    }
    if( "eInvertRgbEXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertRgbEXT ;
      return;
    }
    if( "VK_BLEND_OP_INVERT_RGB_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertRgbEXT ;
      return;
    }
    if( "LineardodgeEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLineardodgeEXT ;
      return;
    }
    if( "eLineardodgeEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLineardodgeEXT ;
      return;
    }
    if( "VK_BLEND_OP_LINEARDODGE_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eLineardodgeEXT ;
      return;
    }
    if( "LinearburnEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLinearburnEXT ;
      return;
    }
    if( "eLinearburnEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLinearburnEXT ;
      return;
    }
    if( "VK_BLEND_OP_LINEARBURN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eLinearburnEXT ;
      return;
    }
    if( "VividlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eVividlightEXT ;
      return;
    }
    if( "eVividlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eVividlightEXT ;
      return;
    }
    if( "VK_BLEND_OP_VIVIDLIGHT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eVividlightEXT ;
      return;
    }
    if( "LinearlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLinearlightEXT ;
      return;
    }
    if( "eLinearlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: eLinearlightEXT ;
      return;
    }
    if( "VK_BLEND_OP_LINEARLIGHT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eLinearlightEXT ;
      return;
    }
    if( "PinlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePinlightEXT ;
      return;
    }
    if( "ePinlightEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePinlightEXT ;
      return;
    }
    if( "VK_BLEND_OP_PINLIGHT_EXT" == j.get< std::string >() ) {
      p = BlendOp :: ePinlightEXT ;
      return;
    }
    if( "HardmixEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHardmixEXT ;
      return;
    }
    if( "eHardmixEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHardmixEXT ;
      return;
    }
    if( "VK_BLEND_OP_HARDMIX_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eHardmixEXT ;
      return;
    }
    if( "HslHueEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslHueEXT ;
      return;
    }
    if( "eHslHueEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslHueEXT ;
      return;
    }
    if( "VK_BLEND_OP_HSL_HUE_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslHueEXT ;
      return;
    }
    if( "HslSaturationEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslSaturationEXT ;
      return;
    }
    if( "eHslSaturationEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslSaturationEXT ;
      return;
    }
    if( "VK_BLEND_OP_HSL_SATURATION_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslSaturationEXT ;
      return;
    }
    if( "HslColorEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslColorEXT ;
      return;
    }
    if( "eHslColorEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslColorEXT ;
      return;
    }
    if( "VK_BLEND_OP_HSL_COLOR_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslColorEXT ;
      return;
    }
    if( "HslLuminosityEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslLuminosityEXT ;
      return;
    }
    if( "eHslLuminosityEXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslLuminosityEXT ;
      return;
    }
    if( "VK_BLEND_OP_HSL_LUMINOSITY_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eHslLuminosityEXT ;
      return;
    }
    if( "PlusEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusEXT ;
      return;
    }
    if( "ePlusEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusEXT ;
      return;
    }
    if( "VK_BLEND_OP_PLUS_EXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusEXT ;
      return;
    }
    if( "PlusClampedEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusClampedEXT ;
      return;
    }
    if( "ePlusClampedEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusClampedEXT ;
      return;
    }
    if( "VK_BLEND_OP_PLUS_CLAMPED_EXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusClampedEXT ;
      return;
    }
    if( "PlusClampedAlphaEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusClampedAlphaEXT ;
      return;
    }
    if( "ePlusClampedAlphaEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusClampedAlphaEXT ;
      return;
    }
    if( "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusClampedAlphaEXT ;
      return;
    }
    if( "PlusDarkerEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusDarkerEXT ;
      return;
    }
    if( "ePlusDarkerEXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusDarkerEXT ;
      return;
    }
    if( "VK_BLEND_OP_PLUS_DARKER_EXT" == j.get< std::string >() ) {
      p = BlendOp :: ePlusDarkerEXT ;
      return;
    }
    if( "MinusEXT" == j.get< std::string >() ) {
      p = BlendOp :: eMinusEXT ;
      return;
    }
    if( "eMinusEXT" == j.get< std::string >() ) {
      p = BlendOp :: eMinusEXT ;
      return;
    }
    if( "VK_BLEND_OP_MINUS_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eMinusEXT ;
      return;
    }
    if( "MinusClampedEXT" == j.get< std::string >() ) {
      p = BlendOp :: eMinusClampedEXT ;
      return;
    }
    if( "eMinusClampedEXT" == j.get< std::string >() ) {
      p = BlendOp :: eMinusClampedEXT ;
      return;
    }
    if( "VK_BLEND_OP_MINUS_CLAMPED_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eMinusClampedEXT ;
      return;
    }
    if( "ContrastEXT" == j.get< std::string >() ) {
      p = BlendOp :: eContrastEXT ;
      return;
    }
    if( "eContrastEXT" == j.get< std::string >() ) {
      p = BlendOp :: eContrastEXT ;
      return;
    }
    if( "VK_BLEND_OP_CONTRAST_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eContrastEXT ;
      return;
    }
    if( "InvertOvgEXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertOvgEXT ;
      return;
    }
    if( "eInvertOvgEXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertOvgEXT ;
      return;
    }
    if( "VK_BLEND_OP_INVERT_OVG_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eInvertOvgEXT ;
      return;
    }
    if( "RedEXT" == j.get< std::string >() ) {
      p = BlendOp :: eRedEXT ;
      return;
    }
    if( "eRedEXT" == j.get< std::string >() ) {
      p = BlendOp :: eRedEXT ;
      return;
    }
    if( "VK_BLEND_OP_RED_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eRedEXT ;
      return;
    }
    if( "GreenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eGreenEXT ;
      return;
    }
    if( "eGreenEXT" == j.get< std::string >() ) {
      p = BlendOp :: eGreenEXT ;
      return;
    }
    if( "VK_BLEND_OP_GREEN_EXT" == j.get< std::string >() ) {
      p = BlendOp :: eGreenEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BlendOp" );
  }
  if( j.is_number() ) {
    p = BlendOp ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BlendOp" );
}
inline void from_json( const nlohmann::json &j, VkBlendOp &p ) {
  BlendOp temp;
  from_json( j, temp );
  p = VkBlendOp ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const CompareOp &p ) {
  if( CompareOp :: eNever == p ) {
    j = "Never";
    return;
  }
  if( CompareOp :: eLess == p ) {
    j = "Less";
    return;
  }
  if( CompareOp :: eEqual == p ) {
    j = "Equal";
    return;
  }
  if( CompareOp :: eLessOrEqual == p ) {
    j = "LessOrEqual";
    return;
  }
  if( CompareOp :: eGreater == p ) {
    j = "Greater";
    return;
  }
  if( CompareOp :: eNotEqual == p ) {
    j = "NotEqual";
    return;
  }
  if( CompareOp :: eGreaterOrEqual == p ) {
    j = "GreaterOrEqual";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkCompareOp &p ) {
  to_json( j, CompareOp ( p ) );
}
inline void from_json( const nlohmann::json &j, CompareOp &p ) {
  if( j.is_string() ) {
    if( "Never" == j.get< std::string >() ) {
      p = CompareOp :: eNever ;
      return;
    }
    if( "eNever" == j.get< std::string >() ) {
      p = CompareOp :: eNever ;
      return;
    }
    if( "VK_COMPARE_OP_NEVER" == j.get< std::string >() ) {
      p = CompareOp :: eNever ;
      return;
    }
    if( "Less" == j.get< std::string >() ) {
      p = CompareOp :: eLess ;
      return;
    }
    if( "eLess" == j.get< std::string >() ) {
      p = CompareOp :: eLess ;
      return;
    }
    if( "VK_COMPARE_OP_LESS" == j.get< std::string >() ) {
      p = CompareOp :: eLess ;
      return;
    }
    if( "Equal" == j.get< std::string >() ) {
      p = CompareOp :: eEqual ;
      return;
    }
    if( "eEqual" == j.get< std::string >() ) {
      p = CompareOp :: eEqual ;
      return;
    }
    if( "VK_COMPARE_OP_EQUAL" == j.get< std::string >() ) {
      p = CompareOp :: eEqual ;
      return;
    }
    if( "LessOrEqual" == j.get< std::string >() ) {
      p = CompareOp :: eLessOrEqual ;
      return;
    }
    if( "eLessOrEqual" == j.get< std::string >() ) {
      p = CompareOp :: eLessOrEqual ;
      return;
    }
    if( "VK_COMPARE_OP_LESS_OR_EQUAL" == j.get< std::string >() ) {
      p = CompareOp :: eLessOrEqual ;
      return;
    }
    if( "Greater" == j.get< std::string >() ) {
      p = CompareOp :: eGreater ;
      return;
    }
    if( "eGreater" == j.get< std::string >() ) {
      p = CompareOp :: eGreater ;
      return;
    }
    if( "VK_COMPARE_OP_GREATER" == j.get< std::string >() ) {
      p = CompareOp :: eGreater ;
      return;
    }
    if( "NotEqual" == j.get< std::string >() ) {
      p = CompareOp :: eNotEqual ;
      return;
    }
    if( "eNotEqual" == j.get< std::string >() ) {
      p = CompareOp :: eNotEqual ;
      return;
    }
    if( "VK_COMPARE_OP_NOT_EQUAL" == j.get< std::string >() ) {
      p = CompareOp :: eNotEqual ;
      return;
    }
    if( "GreaterOrEqual" == j.get< std::string >() ) {
      p = CompareOp :: eGreaterOrEqual ;
      return;
    }
    if( "eGreaterOrEqual" == j.get< std::string >() ) {
      p = CompareOp :: eGreaterOrEqual ;
      return;
    }
    if( "VK_COMPARE_OP_GREATER_OR_EQUAL" == j.get< std::string >() ) {
      p = CompareOp :: eGreaterOrEqual ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CompareOp" );
  }
  if( j.is_number() ) {
    p = CompareOp ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CompareOp" );
}
inline void from_json( const nlohmann::json &j, VkCompareOp &p ) {
  CompareOp temp;
  from_json( j, temp );
  p = VkCompareOp ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const DynamicState &p ) {
  if( DynamicState :: eViewport == p ) {
    j = "Viewport";
    return;
  }
  if( DynamicState :: eScissor == p ) {
    j = "Scissor";
    return;
  }
  if( DynamicState :: eLineWidth == p ) {
    j = "LineWidth";
    return;
  }
  if( DynamicState :: eDepthBias == p ) {
    j = "DepthBias";
    return;
  }
  if( DynamicState :: eBlendConstants == p ) {
    j = "BlendConstants";
    return;
  }
  if( DynamicState :: eDepthBounds == p ) {
    j = "DepthBounds";
    return;
  }
  if( DynamicState :: eStencilCompareMask == p ) {
    j = "StencilCompareMask";
    return;
  }
  if( DynamicState :: eStencilWriteMask == p ) {
    j = "StencilWriteMask";
    return;
  }
  if( DynamicState :: eStencilReference == p ) {
    j = "StencilReference";
    return;
  }
  if( DynamicState :: eViewportWScalingNV == p ) {
    j = "ViewportWScalingNV";
    return;
  }
  if( DynamicState :: eDiscardRectangleEXT == p ) {
    j = "DiscardRectangleEXT";
    return;
  }
  if( DynamicState :: eSampleLocationsEXT == p ) {
    j = "SampleLocationsEXT";
    return;
  }
  if( DynamicState :: eRayTracingPipelineStackSizeKHR == p ) {
    j = "RayTracingPipelineStackSizeKHR";
    return;
  }
  if( DynamicState :: eViewportShadingRatePaletteNV == p ) {
    j = "ViewportShadingRatePaletteNV";
    return;
  }
  if( DynamicState :: eViewportCoarseSampleOrderNV == p ) {
    j = "ViewportCoarseSampleOrderNV";
    return;
  }
  if( DynamicState :: eExclusiveScissorNV == p ) {
    j = "ExclusiveScissorNV";
    return;
  }
  if( DynamicState :: eFragmentShadingRateKHR == p ) {
    j = "FragmentShadingRateKHR";
    return;
  }
  if( DynamicState :: eLineStippleEXT == p ) {
    j = "LineStippleEXT";
    return;
  }
  if( DynamicState :: eCullModeEXT == p ) {
    j = "CullModeEXT";
    return;
  }
  if( DynamicState :: eFrontFaceEXT == p ) {
    j = "FrontFaceEXT";
    return;
  }
  if( DynamicState :: ePrimitiveTopologyEXT == p ) {
    j = "PrimitiveTopologyEXT";
    return;
  }
  if( DynamicState :: eViewportWithCountEXT == p ) {
    j = "ViewportWithCountEXT";
    return;
  }
  if( DynamicState :: eScissorWithCountEXT == p ) {
    j = "ScissorWithCountEXT";
    return;
  }
  if( DynamicState :: eVertexInputBindingStrideEXT == p ) {
    j = "VertexInputBindingStrideEXT";
    return;
  }
  if( DynamicState :: eDepthTestEnableEXT == p ) {
    j = "DepthTestEnableEXT";
    return;
  }
  if( DynamicState :: eDepthWriteEnableEXT == p ) {
    j = "DepthWriteEnableEXT";
    return;
  }
  if( DynamicState :: eDepthCompareOpEXT == p ) {
    j = "DepthCompareOpEXT";
    return;
  }
  if( DynamicState :: eDepthBoundsTestEnableEXT == p ) {
    j = "DepthBoundsTestEnableEXT";
    return;
  }
  if( DynamicState :: eStencilTestEnableEXT == p ) {
    j = "StencilTestEnableEXT";
    return;
  }
  if( DynamicState :: eStencilOpEXT == p ) {
    j = "StencilOpEXT";
    return;
  }
  if( DynamicState :: eVertexInputEXT == p ) {
    j = "VertexInputEXT";
    return;
  }
  if( DynamicState :: ePatchControlPointsEXT == p ) {
    j = "PatchControlPointsEXT";
    return;
  }
  if( DynamicState :: eRasterizerDiscardEnableEXT == p ) {
    j = "RasterizerDiscardEnableEXT";
    return;
  }
  if( DynamicState :: eDepthBiasEnableEXT == p ) {
    j = "DepthBiasEnableEXT";
    return;
  }
  if( DynamicState :: eLogicOpEXT == p ) {
    j = "LogicOpEXT";
    return;
  }
  if( DynamicState :: ePrimitiveRestartEnableEXT == p ) {
    j = "PrimitiveRestartEnableEXT";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkDynamicState &p ) {
  to_json( j, DynamicState ( p ) );
}
inline void from_json( const nlohmann::json &j, DynamicState &p ) {
  if( j.is_string() ) {
    if( "Viewport" == j.get< std::string >() ) {
      p = DynamicState :: eViewport ;
      return;
    }
    if( "eViewport" == j.get< std::string >() ) {
      p = DynamicState :: eViewport ;
      return;
    }
    if( "VK_DYNAMIC_STATE_VIEWPORT" == j.get< std::string >() ) {
      p = DynamicState :: eViewport ;
      return;
    }
    if( "Scissor" == j.get< std::string >() ) {
      p = DynamicState :: eScissor ;
      return;
    }
    if( "eScissor" == j.get< std::string >() ) {
      p = DynamicState :: eScissor ;
      return;
    }
    if( "VK_DYNAMIC_STATE_SCISSOR" == j.get< std::string >() ) {
      p = DynamicState :: eScissor ;
      return;
    }
    if( "LineWidth" == j.get< std::string >() ) {
      p = DynamicState :: eLineWidth ;
      return;
    }
    if( "eLineWidth" == j.get< std::string >() ) {
      p = DynamicState :: eLineWidth ;
      return;
    }
    if( "VK_DYNAMIC_STATE_LINE_WIDTH" == j.get< std::string >() ) {
      p = DynamicState :: eLineWidth ;
      return;
    }
    if( "DepthBias" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBias ;
      return;
    }
    if( "eDepthBias" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBias ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DEPTH_BIAS" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBias ;
      return;
    }
    if( "BlendConstants" == j.get< std::string >() ) {
      p = DynamicState :: eBlendConstants ;
      return;
    }
    if( "eBlendConstants" == j.get< std::string >() ) {
      p = DynamicState :: eBlendConstants ;
      return;
    }
    if( "VK_DYNAMIC_STATE_BLEND_CONSTANTS" == j.get< std::string >() ) {
      p = DynamicState :: eBlendConstants ;
      return;
    }
    if( "DepthBounds" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBounds ;
      return;
    }
    if( "eDepthBounds" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBounds ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DEPTH_BOUNDS" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBounds ;
      return;
    }
    if( "StencilCompareMask" == j.get< std::string >() ) {
      p = DynamicState :: eStencilCompareMask ;
      return;
    }
    if( "eStencilCompareMask" == j.get< std::string >() ) {
      p = DynamicState :: eStencilCompareMask ;
      return;
    }
    if( "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK" == j.get< std::string >() ) {
      p = DynamicState :: eStencilCompareMask ;
      return;
    }
    if( "StencilWriteMask" == j.get< std::string >() ) {
      p = DynamicState :: eStencilWriteMask ;
      return;
    }
    if( "eStencilWriteMask" == j.get< std::string >() ) {
      p = DynamicState :: eStencilWriteMask ;
      return;
    }
    if( "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK" == j.get< std::string >() ) {
      p = DynamicState :: eStencilWriteMask ;
      return;
    }
    if( "StencilReference" == j.get< std::string >() ) {
      p = DynamicState :: eStencilReference ;
      return;
    }
    if( "eStencilReference" == j.get< std::string >() ) {
      p = DynamicState :: eStencilReference ;
      return;
    }
    if( "VK_DYNAMIC_STATE_STENCIL_REFERENCE" == j.get< std::string >() ) {
      p = DynamicState :: eStencilReference ;
      return;
    }
    if( "ViewportWScalingNV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportWScalingNV ;
      return;
    }
    if( "eViewportWScalingNV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportWScalingNV ;
      return;
    }
    if( "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportWScalingNV ;
      return;
    }
    if( "DiscardRectangleEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDiscardRectangleEXT ;
      return;
    }
    if( "eDiscardRectangleEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDiscardRectangleEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eDiscardRectangleEXT ;
      return;
    }
    if( "SampleLocationsEXT" == j.get< std::string >() ) {
      p = DynamicState :: eSampleLocationsEXT ;
      return;
    }
    if( "eSampleLocationsEXT" == j.get< std::string >() ) {
      p = DynamicState :: eSampleLocationsEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eSampleLocationsEXT ;
      return;
    }
    if( "RayTracingPipelineStackSizeKHR" == j.get< std::string >() ) {
      p = DynamicState :: eRayTracingPipelineStackSizeKHR ;
      return;
    }
    if( "eRayTracingPipelineStackSizeKHR" == j.get< std::string >() ) {
      p = DynamicState :: eRayTracingPipelineStackSizeKHR ;
      return;
    }
    if( "VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR" == j.get< std::string >() ) {
      p = DynamicState :: eRayTracingPipelineStackSizeKHR ;
      return;
    }
    if( "ViewportShadingRatePaletteNV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportShadingRatePaletteNV ;
      return;
    }
    if( "eViewportShadingRatePaletteNV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportShadingRatePaletteNV ;
      return;
    }
    if( "VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportShadingRatePaletteNV ;
      return;
    }
    if( "ViewportCoarseSampleOrderNV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportCoarseSampleOrderNV ;
      return;
    }
    if( "eViewportCoarseSampleOrderNV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportCoarseSampleOrderNV ;
      return;
    }
    if( "VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV" == j.get< std::string >() ) {
      p = DynamicState :: eViewportCoarseSampleOrderNV ;
      return;
    }
    if( "ExclusiveScissorNV" == j.get< std::string >() ) {
      p = DynamicState :: eExclusiveScissorNV ;
      return;
    }
    if( "eExclusiveScissorNV" == j.get< std::string >() ) {
      p = DynamicState :: eExclusiveScissorNV ;
      return;
    }
    if( "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV" == j.get< std::string >() ) {
      p = DynamicState :: eExclusiveScissorNV ;
      return;
    }
    if( "FragmentShadingRateKHR" == j.get< std::string >() ) {
      p = DynamicState :: eFragmentShadingRateKHR ;
      return;
    }
    if( "eFragmentShadingRateKHR" == j.get< std::string >() ) {
      p = DynamicState :: eFragmentShadingRateKHR ;
      return;
    }
    if( "VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR" == j.get< std::string >() ) {
      p = DynamicState :: eFragmentShadingRateKHR ;
      return;
    }
    if( "LineStippleEXT" == j.get< std::string >() ) {
      p = DynamicState :: eLineStippleEXT ;
      return;
    }
    if( "eLineStippleEXT" == j.get< std::string >() ) {
      p = DynamicState :: eLineStippleEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_LINE_STIPPLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eLineStippleEXT ;
      return;
    }
    if( "CullModeEXT" == j.get< std::string >() ) {
      p = DynamicState :: eCullModeEXT ;
      return;
    }
    if( "eCullModeEXT" == j.get< std::string >() ) {
      p = DynamicState :: eCullModeEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_CULL_MODE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eCullModeEXT ;
      return;
    }
    if( "FrontFaceEXT" == j.get< std::string >() ) {
      p = DynamicState :: eFrontFaceEXT ;
      return;
    }
    if( "eFrontFaceEXT" == j.get< std::string >() ) {
      p = DynamicState :: eFrontFaceEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_FRONT_FACE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eFrontFaceEXT ;
      return;
    }
    if( "PrimitiveTopologyEXT" == j.get< std::string >() ) {
      p = DynamicState :: ePrimitiveTopologyEXT ;
      return;
    }
    if( "ePrimitiveTopologyEXT" == j.get< std::string >() ) {
      p = DynamicState :: ePrimitiveTopologyEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT" == j.get< std::string >() ) {
      p = DynamicState :: ePrimitiveTopologyEXT ;
      return;
    }
    if( "ViewportWithCountEXT" == j.get< std::string >() ) {
      p = DynamicState :: eViewportWithCountEXT ;
      return;
    }
    if( "eViewportWithCountEXT" == j.get< std::string >() ) {
      p = DynamicState :: eViewportWithCountEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eViewportWithCountEXT ;
      return;
    }
    if( "ScissorWithCountEXT" == j.get< std::string >() ) {
      p = DynamicState :: eScissorWithCountEXT ;
      return;
    }
    if( "eScissorWithCountEXT" == j.get< std::string >() ) {
      p = DynamicState :: eScissorWithCountEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eScissorWithCountEXT ;
      return;
    }
    if( "VertexInputBindingStrideEXT" == j.get< std::string >() ) {
      p = DynamicState :: eVertexInputBindingStrideEXT ;
      return;
    }
    if( "eVertexInputBindingStrideEXT" == j.get< std::string >() ) {
      p = DynamicState :: eVertexInputBindingStrideEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eVertexInputBindingStrideEXT ;
      return;
    }
    if( "DepthTestEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthTestEnableEXT ;
      return;
    }
    if( "eDepthTestEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthTestEnableEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthTestEnableEXT ;
      return;
    }
    if( "DepthWriteEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthWriteEnableEXT ;
      return;
    }
    if( "eDepthWriteEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthWriteEnableEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthWriteEnableEXT ;
      return;
    }
    if( "DepthCompareOpEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthCompareOpEXT ;
      return;
    }
    if( "eDepthCompareOpEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthCompareOpEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthCompareOpEXT ;
      return;
    }
    if( "DepthBoundsTestEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBoundsTestEnableEXT ;
      return;
    }
    if( "eDepthBoundsTestEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBoundsTestEnableEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBoundsTestEnableEXT ;
      return;
    }
    if( "StencilTestEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eStencilTestEnableEXT ;
      return;
    }
    if( "eStencilTestEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eStencilTestEnableEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eStencilTestEnableEXT ;
      return;
    }
    if( "StencilOpEXT" == j.get< std::string >() ) {
      p = DynamicState :: eStencilOpEXT ;
      return;
    }
    if( "eStencilOpEXT" == j.get< std::string >() ) {
      p = DynamicState :: eStencilOpEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_STENCIL_OP_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eStencilOpEXT ;
      return;
    }
    if( "VertexInputEXT" == j.get< std::string >() ) {
      p = DynamicState :: eVertexInputEXT ;
      return;
    }
    if( "eVertexInputEXT" == j.get< std::string >() ) {
      p = DynamicState :: eVertexInputEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_VERTEX_INPUT_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eVertexInputEXT ;
      return;
    }
    if( "PatchControlPointsEXT" == j.get< std::string >() ) {
      p = DynamicState :: ePatchControlPointsEXT ;
      return;
    }
    if( "ePatchControlPointsEXT" == j.get< std::string >() ) {
      p = DynamicState :: ePatchControlPointsEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT" == j.get< std::string >() ) {
      p = DynamicState :: ePatchControlPointsEXT ;
      return;
    }
    if( "RasterizerDiscardEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eRasterizerDiscardEnableEXT ;
      return;
    }
    if( "eRasterizerDiscardEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eRasterizerDiscardEnableEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eRasterizerDiscardEnableEXT ;
      return;
    }
    if( "DepthBiasEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBiasEnableEXT ;
      return;
    }
    if( "eDepthBiasEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBiasEnableEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eDepthBiasEnableEXT ;
      return;
    }
    if( "LogicOpEXT" == j.get< std::string >() ) {
      p = DynamicState :: eLogicOpEXT ;
      return;
    }
    if( "eLogicOpEXT" == j.get< std::string >() ) {
      p = DynamicState :: eLogicOpEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_LOGIC_OP_EXT" == j.get< std::string >() ) {
      p = DynamicState :: eLogicOpEXT ;
      return;
    }
    if( "PrimitiveRestartEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: ePrimitiveRestartEnableEXT ;
      return;
    }
    if( "ePrimitiveRestartEnableEXT" == j.get< std::string >() ) {
      p = DynamicState :: ePrimitiveRestartEnableEXT ;
      return;
    }
    if( "VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT" == j.get< std::string >() ) {
      p = DynamicState :: ePrimitiveRestartEnableEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DynamicState" );
  }
  if( j.is_number() ) {
    p = DynamicState ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DynamicState" );
}
inline void from_json( const nlohmann::json &j, VkDynamicState &p ) {
  DynamicState temp;
  from_json( j, temp );
  p = VkDynamicState ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const FrontFace &p ) {
  if( FrontFace :: eCounterClockwise == p ) {
    j = "CounterClockwise";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkFrontFace &p ) {
  to_json( j, FrontFace ( p ) );
}
inline void from_json( const nlohmann::json &j, FrontFace &p ) {
  if( j.is_string() ) {
    if( "CounterClockwise" == j.get< std::string >() ) {
      p = FrontFace :: eCounterClockwise ;
      return;
    }
    if( "eCounterClockwise" == j.get< std::string >() ) {
      p = FrontFace :: eCounterClockwise ;
      return;
    }
    if( "VK_FRONT_FACE_COUNTER_CLOCKWISE" == j.get< std::string >() ) {
      p = FrontFace :: eCounterClockwise ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for FrontFace" );
  }
  if( j.is_number() ) {
    p = FrontFace ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FrontFace" );
}
inline void from_json( const nlohmann::json &j, VkFrontFace &p ) {
  FrontFace temp;
  from_json( j, temp );
  p = VkFrontFace ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const LogicOp &p ) {
  if( LogicOp :: eClear == p ) {
    j = "Clear";
    return;
  }
  if( LogicOp :: eAnd == p ) {
    j = "And";
    return;
  }
  if( LogicOp :: eAndReverse == p ) {
    j = "AndReverse";
    return;
  }
  if( LogicOp :: eCopy == p ) {
    j = "Copy";
    return;
  }
  if( LogicOp :: eAndInverted == p ) {
    j = "AndInverted";
    return;
  }
  if( LogicOp :: eNoOp == p ) {
    j = "NoOp";
    return;
  }
  if( LogicOp :: eXor == p ) {
    j = "Xor";
    return;
  }
  if( LogicOp :: eOr == p ) {
    j = "Or";
    return;
  }
  if( LogicOp :: eNor == p ) {
    j = "Nor";
    return;
  }
  if( LogicOp :: eEquivalent == p ) {
    j = "Equivalent";
    return;
  }
  if( LogicOp :: eInvert == p ) {
    j = "Invert";
    return;
  }
  if( LogicOp :: eOrReverse == p ) {
    j = "OrReverse";
    return;
  }
  if( LogicOp :: eCopyInverted == p ) {
    j = "CopyInverted";
    return;
  }
  if( LogicOp :: eOrInverted == p ) {
    j = "OrInverted";
    return;
  }
  if( LogicOp :: eNand == p ) {
    j = "Nand";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkLogicOp &p ) {
  to_json( j, LogicOp ( p ) );
}
inline void from_json( const nlohmann::json &j, LogicOp &p ) {
  if( j.is_string() ) {
    if( "Clear" == j.get< std::string >() ) {
      p = LogicOp :: eClear ;
      return;
    }
    if( "eClear" == j.get< std::string >() ) {
      p = LogicOp :: eClear ;
      return;
    }
    if( "VK_LOGIC_OP_CLEAR" == j.get< std::string >() ) {
      p = LogicOp :: eClear ;
      return;
    }
    if( "And" == j.get< std::string >() ) {
      p = LogicOp :: eAnd ;
      return;
    }
    if( "eAnd" == j.get< std::string >() ) {
      p = LogicOp :: eAnd ;
      return;
    }
    if( "VK_LOGIC_OP_AND" == j.get< std::string >() ) {
      p = LogicOp :: eAnd ;
      return;
    }
    if( "AndReverse" == j.get< std::string >() ) {
      p = LogicOp :: eAndReverse ;
      return;
    }
    if( "eAndReverse" == j.get< std::string >() ) {
      p = LogicOp :: eAndReverse ;
      return;
    }
    if( "VK_LOGIC_OP_AND_REVERSE" == j.get< std::string >() ) {
      p = LogicOp :: eAndReverse ;
      return;
    }
    if( "Copy" == j.get< std::string >() ) {
      p = LogicOp :: eCopy ;
      return;
    }
    if( "eCopy" == j.get< std::string >() ) {
      p = LogicOp :: eCopy ;
      return;
    }
    if( "VK_LOGIC_OP_COPY" == j.get< std::string >() ) {
      p = LogicOp :: eCopy ;
      return;
    }
    if( "AndInverted" == j.get< std::string >() ) {
      p = LogicOp :: eAndInverted ;
      return;
    }
    if( "eAndInverted" == j.get< std::string >() ) {
      p = LogicOp :: eAndInverted ;
      return;
    }
    if( "VK_LOGIC_OP_AND_INVERTED" == j.get< std::string >() ) {
      p = LogicOp :: eAndInverted ;
      return;
    }
    if( "NoOp" == j.get< std::string >() ) {
      p = LogicOp :: eNoOp ;
      return;
    }
    if( "eNoOp" == j.get< std::string >() ) {
      p = LogicOp :: eNoOp ;
      return;
    }
    if( "VK_LOGIC_OP_NO_OP" == j.get< std::string >() ) {
      p = LogicOp :: eNoOp ;
      return;
    }
    if( "Xor" == j.get< std::string >() ) {
      p = LogicOp :: eXor ;
      return;
    }
    if( "eXor" == j.get< std::string >() ) {
      p = LogicOp :: eXor ;
      return;
    }
    if( "VK_LOGIC_OP_XOR" == j.get< std::string >() ) {
      p = LogicOp :: eXor ;
      return;
    }
    if( "Or" == j.get< std::string >() ) {
      p = LogicOp :: eOr ;
      return;
    }
    if( "eOr" == j.get< std::string >() ) {
      p = LogicOp :: eOr ;
      return;
    }
    if( "VK_LOGIC_OP_OR" == j.get< std::string >() ) {
      p = LogicOp :: eOr ;
      return;
    }
    if( "Nor" == j.get< std::string >() ) {
      p = LogicOp :: eNor ;
      return;
    }
    if( "eNor" == j.get< std::string >() ) {
      p = LogicOp :: eNor ;
      return;
    }
    if( "VK_LOGIC_OP_NOR" == j.get< std::string >() ) {
      p = LogicOp :: eNor ;
      return;
    }
    if( "Equivalent" == j.get< std::string >() ) {
      p = LogicOp :: eEquivalent ;
      return;
    }
    if( "eEquivalent" == j.get< std::string >() ) {
      p = LogicOp :: eEquivalent ;
      return;
    }
    if( "VK_LOGIC_OP_EQUIVALENT" == j.get< std::string >() ) {
      p = LogicOp :: eEquivalent ;
      return;
    }
    if( "Invert" == j.get< std::string >() ) {
      p = LogicOp :: eInvert ;
      return;
    }
    if( "eInvert" == j.get< std::string >() ) {
      p = LogicOp :: eInvert ;
      return;
    }
    if( "VK_LOGIC_OP_INVERT" == j.get< std::string >() ) {
      p = LogicOp :: eInvert ;
      return;
    }
    if( "OrReverse" == j.get< std::string >() ) {
      p = LogicOp :: eOrReverse ;
      return;
    }
    if( "eOrReverse" == j.get< std::string >() ) {
      p = LogicOp :: eOrReverse ;
      return;
    }
    if( "VK_LOGIC_OP_OR_REVERSE" == j.get< std::string >() ) {
      p = LogicOp :: eOrReverse ;
      return;
    }
    if( "CopyInverted" == j.get< std::string >() ) {
      p = LogicOp :: eCopyInverted ;
      return;
    }
    if( "eCopyInverted" == j.get< std::string >() ) {
      p = LogicOp :: eCopyInverted ;
      return;
    }
    if( "VK_LOGIC_OP_COPY_INVERTED" == j.get< std::string >() ) {
      p = LogicOp :: eCopyInverted ;
      return;
    }
    if( "OrInverted" == j.get< std::string >() ) {
      p = LogicOp :: eOrInverted ;
      return;
    }
    if( "eOrInverted" == j.get< std::string >() ) {
      p = LogicOp :: eOrInverted ;
      return;
    }
    if( "VK_LOGIC_OP_OR_INVERTED" == j.get< std::string >() ) {
      p = LogicOp :: eOrInverted ;
      return;
    }
    if( "Nand" == j.get< std::string >() ) {
      p = LogicOp :: eNand ;
      return;
    }
    if( "eNand" == j.get< std::string >() ) {
      p = LogicOp :: eNand ;
      return;
    }
    if( "VK_LOGIC_OP_NAND" == j.get< std::string >() ) {
      p = LogicOp :: eNand ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for LogicOp" );
  }
  if( j.is_number() ) {
    p = LogicOp ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for LogicOp" );
}
inline void from_json( const nlohmann::json &j, VkLogicOp &p ) {
  LogicOp temp;
  from_json( j, temp );
  p = VkLogicOp ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PolygonMode &p ) {
  if( PolygonMode :: eFill == p ) {
    j = "Fill";
    return;
  }
  if( PolygonMode :: eLine == p ) {
    j = "Line";
    return;
  }
  if( PolygonMode :: ePoint == p ) {
    j = "Point";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkPolygonMode &p ) {
  to_json( j, PolygonMode ( p ) );
}
inline void from_json( const nlohmann::json &j, PolygonMode &p ) {
  if( j.is_string() ) {
    if( "Fill" == j.get< std::string >() ) {
      p = PolygonMode :: eFill ;
      return;
    }
    if( "eFill" == j.get< std::string >() ) {
      p = PolygonMode :: eFill ;
      return;
    }
    if( "VK_POLYGON_MODE_FILL" == j.get< std::string >() ) {
      p = PolygonMode :: eFill ;
      return;
    }
    if( "Line" == j.get< std::string >() ) {
      p = PolygonMode :: eLine ;
      return;
    }
    if( "eLine" == j.get< std::string >() ) {
      p = PolygonMode :: eLine ;
      return;
    }
    if( "VK_POLYGON_MODE_LINE" == j.get< std::string >() ) {
      p = PolygonMode :: eLine ;
      return;
    }
    if( "Point" == j.get< std::string >() ) {
      p = PolygonMode :: ePoint ;
      return;
    }
    if( "ePoint" == j.get< std::string >() ) {
      p = PolygonMode :: ePoint ;
      return;
    }
    if( "VK_POLYGON_MODE_POINT" == j.get< std::string >() ) {
      p = PolygonMode :: ePoint ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PolygonMode" );
  }
  if( j.is_number() ) {
    p = PolygonMode ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PolygonMode" );
}
inline void from_json( const nlohmann::json &j, VkPolygonMode &p ) {
  PolygonMode temp;
  from_json( j, temp );
  p = VkPolygonMode ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PrimitiveTopology &p ) {
  if( PrimitiveTopology :: ePointList == p ) {
    j = "PointList";
    return;
  }
  if( PrimitiveTopology :: eLineList == p ) {
    j = "LineList";
    return;
  }
  if( PrimitiveTopology :: eLineStrip == p ) {
    j = "LineStrip";
    return;
  }
  if( PrimitiveTopology :: eTriangleList == p ) {
    j = "TriangleList";
    return;
  }
  if( PrimitiveTopology :: eTriangleStrip == p ) {
    j = "TriangleStrip";
    return;
  }
  if( PrimitiveTopology :: eTriangleFan == p ) {
    j = "TriangleFan";
    return;
  }
  if( PrimitiveTopology :: eLineListWithAdjacency == p ) {
    j = "LineListWithAdjacency";
    return;
  }
  if( PrimitiveTopology :: eLineStripWithAdjacency == p ) {
    j = "LineStripWithAdjacency";
    return;
  }
  if( PrimitiveTopology :: eTriangleListWithAdjacency == p ) {
    j = "TriangleListWithAdjacency";
    return;
  }
  if( PrimitiveTopology :: eTriangleStripWithAdjacency == p ) {
    j = "TriangleStripWithAdjacency";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkPrimitiveTopology &p ) {
  to_json( j, PrimitiveTopology ( p ) );
}
inline void from_json( const nlohmann::json &j, PrimitiveTopology &p ) {
  if( j.is_string() ) {
    if( "PointList" == j.get< std::string >() ) {
      p = PrimitiveTopology :: ePointList ;
      return;
    }
    if( "ePointList" == j.get< std::string >() ) {
      p = PrimitiveTopology :: ePointList ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_POINT_LIST" == j.get< std::string >() ) {
      p = PrimitiveTopology :: ePointList ;
      return;
    }
    if( "LineList" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineList ;
      return;
    }
    if( "eLineList" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineList ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_LINE_LIST" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineList ;
      return;
    }
    if( "LineStrip" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineStrip ;
      return;
    }
    if( "eLineStrip" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineStrip ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineStrip ;
      return;
    }
    if( "TriangleList" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleList ;
      return;
    }
    if( "eTriangleList" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleList ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleList ;
      return;
    }
    if( "TriangleStrip" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleStrip ;
      return;
    }
    if( "eTriangleStrip" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleStrip ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleStrip ;
      return;
    }
    if( "TriangleFan" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleFan ;
      return;
    }
    if( "eTriangleFan" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleFan ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleFan ;
      return;
    }
    if( "LineListWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineListWithAdjacency ;
      return;
    }
    if( "eLineListWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineListWithAdjacency ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineListWithAdjacency ;
      return;
    }
    if( "LineStripWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineStripWithAdjacency ;
      return;
    }
    if( "eLineStripWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineStripWithAdjacency ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eLineStripWithAdjacency ;
      return;
    }
    if( "TriangleListWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleListWithAdjacency ;
      return;
    }
    if( "eTriangleListWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleListWithAdjacency ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleListWithAdjacency ;
      return;
    }
    if( "TriangleStripWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleStripWithAdjacency ;
      return;
    }
    if( "eTriangleStripWithAdjacency" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleStripWithAdjacency ;
      return;
    }
    if( "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY" == j.get< std::string >() ) {
      p = PrimitiveTopology :: eTriangleStripWithAdjacency ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PrimitiveTopology" );
  }
  if( j.is_number() ) {
    p = PrimitiveTopology ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PrimitiveTopology" );
}
inline void from_json( const nlohmann::json &j, VkPrimitiveTopology &p ) {
  PrimitiveTopology temp;
  from_json( j, temp );
  p = VkPrimitiveTopology ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const StencilOp &p ) {
  if( StencilOp :: eKeep == p ) {
    j = "Keep";
    return;
  }
  if( StencilOp :: eZero == p ) {
    j = "Zero";
    return;
  }
  if( StencilOp :: eReplace == p ) {
    j = "Replace";
    return;
  }
  if( StencilOp :: eIncrementAndClamp == p ) {
    j = "IncrementAndClamp";
    return;
  }
  if( StencilOp :: eDecrementAndClamp == p ) {
    j = "DecrementAndClamp";
    return;
  }
  if( StencilOp :: eInvert == p ) {
    j = "Invert";
    return;
  }
  if( StencilOp :: eIncrementAndWrap == p ) {
    j = "IncrementAndWrap";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkStencilOp &p ) {
  to_json( j, StencilOp ( p ) );
}
inline void from_json( const nlohmann::json &j, StencilOp &p ) {
  if( j.is_string() ) {
    if( "Keep" == j.get< std::string >() ) {
      p = StencilOp :: eKeep ;
      return;
    }
    if( "eKeep" == j.get< std::string >() ) {
      p = StencilOp :: eKeep ;
      return;
    }
    if( "VK_STENCIL_OP_KEEP" == j.get< std::string >() ) {
      p = StencilOp :: eKeep ;
      return;
    }
    if( "Zero" == j.get< std::string >() ) {
      p = StencilOp :: eZero ;
      return;
    }
    if( "eZero" == j.get< std::string >() ) {
      p = StencilOp :: eZero ;
      return;
    }
    if( "VK_STENCIL_OP_ZERO" == j.get< std::string >() ) {
      p = StencilOp :: eZero ;
      return;
    }
    if( "Replace" == j.get< std::string >() ) {
      p = StencilOp :: eReplace ;
      return;
    }
    if( "eReplace" == j.get< std::string >() ) {
      p = StencilOp :: eReplace ;
      return;
    }
    if( "VK_STENCIL_OP_REPLACE" == j.get< std::string >() ) {
      p = StencilOp :: eReplace ;
      return;
    }
    if( "IncrementAndClamp" == j.get< std::string >() ) {
      p = StencilOp :: eIncrementAndClamp ;
      return;
    }
    if( "eIncrementAndClamp" == j.get< std::string >() ) {
      p = StencilOp :: eIncrementAndClamp ;
      return;
    }
    if( "VK_STENCIL_OP_INCREMENT_AND_CLAMP" == j.get< std::string >() ) {
      p = StencilOp :: eIncrementAndClamp ;
      return;
    }
    if( "DecrementAndClamp" == j.get< std::string >() ) {
      p = StencilOp :: eDecrementAndClamp ;
      return;
    }
    if( "eDecrementAndClamp" == j.get< std::string >() ) {
      p = StencilOp :: eDecrementAndClamp ;
      return;
    }
    if( "VK_STENCIL_OP_DECREMENT_AND_CLAMP" == j.get< std::string >() ) {
      p = StencilOp :: eDecrementAndClamp ;
      return;
    }
    if( "Invert" == j.get< std::string >() ) {
      p = StencilOp :: eInvert ;
      return;
    }
    if( "eInvert" == j.get< std::string >() ) {
      p = StencilOp :: eInvert ;
      return;
    }
    if( "VK_STENCIL_OP_INVERT" == j.get< std::string >() ) {
      p = StencilOp :: eInvert ;
      return;
    }
    if( "IncrementAndWrap" == j.get< std::string >() ) {
      p = StencilOp :: eIncrementAndWrap ;
      return;
    }
    if( "eIncrementAndWrap" == j.get< std::string >() ) {
      p = StencilOp :: eIncrementAndWrap ;
      return;
    }
    if( "VK_STENCIL_OP_INCREMENT_AND_WRAP" == j.get< std::string >() ) {
      p = StencilOp :: eIncrementAndWrap ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for StencilOp" );
  }
  if( j.is_number() ) {
    p = StencilOp ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for StencilOp" );
}
inline void from_json( const nlohmann::json &j, VkStencilOp &p ) {
  StencilOp temp;
  from_json( j, temp );
  p = VkStencilOp ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const VertexInputRate &p ) {
  if( VertexInputRate :: eVertex == p ) {
    j = "Vertex";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkVertexInputRate &p ) {
  to_json( j, VertexInputRate ( p ) );
}
inline void from_json( const nlohmann::json &j, VertexInputRate &p ) {
  if( j.is_string() ) {
    if( "Vertex" == j.get< std::string >() ) {
      p = VertexInputRate :: eVertex ;
      return;
    }
    if( "eVertex" == j.get< std::string >() ) {
      p = VertexInputRate :: eVertex ;
      return;
    }
    if( "VK_VERTEX_INPUT_RATE_VERTEX" == j.get< std::string >() ) {
      p = VertexInputRate :: eVertex ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for VertexInputRate" );
  }
  if( j.is_number() ) {
    p = VertexInputRate ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VertexInputRate" );
}
inline void from_json( const nlohmann::json &j, VkVertexInputRate &p ) {
  VertexInputRate temp;
  from_json( j, temp );
  p = VkVertexInputRate ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const BorderColor &p ) {
  if( BorderColor :: eFloatTransparentBlack == p ) {
    j = "FloatTransparentBlack";
    return;
  }
  if( BorderColor :: eIntTransparentBlack == p ) {
    j = "IntTransparentBlack";
    return;
  }
  if( BorderColor :: eFloatOpaqueBlack == p ) {
    j = "FloatOpaqueBlack";
    return;
  }
  if( BorderColor :: eIntOpaqueBlack == p ) {
    j = "IntOpaqueBlack";
    return;
  }
  if( BorderColor :: eFloatOpaqueWhite == p ) {
    j = "FloatOpaqueWhite";
    return;
  }
  if( BorderColor :: eIntOpaqueWhite == p ) {
    j = "IntOpaqueWhite";
    return;
  }
  if( BorderColor :: eFloatCustomEXT == p ) {
    j = "FloatCustomEXT";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkBorderColor &p ) {
  to_json( j, BorderColor ( p ) );
}
inline void from_json( const nlohmann::json &j, BorderColor &p ) {
  if( j.is_string() ) {
    if( "FloatTransparentBlack" == j.get< std::string >() ) {
      p = BorderColor :: eFloatTransparentBlack ;
      return;
    }
    if( "eFloatTransparentBlack" == j.get< std::string >() ) {
      p = BorderColor :: eFloatTransparentBlack ;
      return;
    }
    if( "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK" == j.get< std::string >() ) {
      p = BorderColor :: eFloatTransparentBlack ;
      return;
    }
    if( "IntTransparentBlack" == j.get< std::string >() ) {
      p = BorderColor :: eIntTransparentBlack ;
      return;
    }
    if( "eIntTransparentBlack" == j.get< std::string >() ) {
      p = BorderColor :: eIntTransparentBlack ;
      return;
    }
    if( "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK" == j.get< std::string >() ) {
      p = BorderColor :: eIntTransparentBlack ;
      return;
    }
    if( "FloatOpaqueBlack" == j.get< std::string >() ) {
      p = BorderColor :: eFloatOpaqueBlack ;
      return;
    }
    if( "eFloatOpaqueBlack" == j.get< std::string >() ) {
      p = BorderColor :: eFloatOpaqueBlack ;
      return;
    }
    if( "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK" == j.get< std::string >() ) {
      p = BorderColor :: eFloatOpaqueBlack ;
      return;
    }
    if( "IntOpaqueBlack" == j.get< std::string >() ) {
      p = BorderColor :: eIntOpaqueBlack ;
      return;
    }
    if( "eIntOpaqueBlack" == j.get< std::string >() ) {
      p = BorderColor :: eIntOpaqueBlack ;
      return;
    }
    if( "VK_BORDER_COLOR_INT_OPAQUE_BLACK" == j.get< std::string >() ) {
      p = BorderColor :: eIntOpaqueBlack ;
      return;
    }
    if( "FloatOpaqueWhite" == j.get< std::string >() ) {
      p = BorderColor :: eFloatOpaqueWhite ;
      return;
    }
    if( "eFloatOpaqueWhite" == j.get< std::string >() ) {
      p = BorderColor :: eFloatOpaqueWhite ;
      return;
    }
    if( "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE" == j.get< std::string >() ) {
      p = BorderColor :: eFloatOpaqueWhite ;
      return;
    }
    if( "IntOpaqueWhite" == j.get< std::string >() ) {
      p = BorderColor :: eIntOpaqueWhite ;
      return;
    }
    if( "eIntOpaqueWhite" == j.get< std::string >() ) {
      p = BorderColor :: eIntOpaqueWhite ;
      return;
    }
    if( "VK_BORDER_COLOR_INT_OPAQUE_WHITE" == j.get< std::string >() ) {
      p = BorderColor :: eIntOpaqueWhite ;
      return;
    }
    if( "FloatCustomEXT" == j.get< std::string >() ) {
      p = BorderColor :: eFloatCustomEXT ;
      return;
    }
    if( "eFloatCustomEXT" == j.get< std::string >() ) {
      p = BorderColor :: eFloatCustomEXT ;
      return;
    }
    if( "VK_BORDER_COLOR_FLOAT_CUSTOM_EXT" == j.get< std::string >() ) {
      p = BorderColor :: eFloatCustomEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BorderColor" );
  }
  if( j.is_number() ) {
    p = BorderColor ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BorderColor" );
}
inline void from_json( const nlohmann::json &j, VkBorderColor &p ) {
  BorderColor temp;
  from_json( j, temp );
  p = VkBorderColor ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const Filter &p ) {
  if( Filter :: eNearest == p ) {
    j = "Nearest";
    return;
  }
  if( Filter :: eLinear == p ) {
    j = "Linear";
    return;
  }
  if( Filter :: eCubicIMG == p ) {
    j = "CubicIMG";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkFilter &p ) {
  to_json( j, Filter ( p ) );
}
inline void from_json( const nlohmann::json &j, Filter &p ) {
  if( j.is_string() ) {
    if( "Nearest" == j.get< std::string >() ) {
      p = Filter :: eNearest ;
      return;
    }
    if( "eNearest" == j.get< std::string >() ) {
      p = Filter :: eNearest ;
      return;
    }
    if( "VK_FILTER_NEAREST" == j.get< std::string >() ) {
      p = Filter :: eNearest ;
      return;
    }
    if( "Linear" == j.get< std::string >() ) {
      p = Filter :: eLinear ;
      return;
    }
    if( "eLinear" == j.get< std::string >() ) {
      p = Filter :: eLinear ;
      return;
    }
    if( "VK_FILTER_LINEAR" == j.get< std::string >() ) {
      p = Filter :: eLinear ;
      return;
    }
    if( "CubicIMG" == j.get< std::string >() ) {
      p = Filter :: eCubicIMG ;
      return;
    }
    if( "eCubicIMG" == j.get< std::string >() ) {
      p = Filter :: eCubicIMG ;
      return;
    }
    if( "VK_FILTER_CUBIC_IMG" == j.get< std::string >() ) {
      p = Filter :: eCubicIMG ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for Filter" );
  }
  if( j.is_number() ) {
    p = Filter ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for Filter" );
}
inline void from_json( const nlohmann::json &j, VkFilter &p ) {
  Filter temp;
  from_json( j, temp );
  p = VkFilter ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const SamplerAddressMode &p ) {
  if( SamplerAddressMode :: eRepeat == p ) {
    j = "Repeat";
    return;
  }
  if( SamplerAddressMode :: eMirroredRepeat == p ) {
    j = "MirroredRepeat";
    return;
  }
  if( SamplerAddressMode :: eClampToEdge == p ) {
    j = "ClampToEdge";
    return;
  }
  if( SamplerAddressMode :: eClampToBorder == p ) {
    j = "ClampToBorder";
    return;
  }
  if( SamplerAddressMode :: eMirrorClampToEdge == p ) {
    j = "MirrorClampToEdge";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkSamplerAddressMode &p ) {
  to_json( j, SamplerAddressMode ( p ) );
}
inline void from_json( const nlohmann::json &j, SamplerAddressMode &p ) {
  if( j.is_string() ) {
    if( "Repeat" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eRepeat ;
      return;
    }
    if( "eRepeat" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eRepeat ;
      return;
    }
    if( "VK_SAMPLER_ADDRESS_MODE_REPEAT" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eRepeat ;
      return;
    }
    if( "MirroredRepeat" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eMirroredRepeat ;
      return;
    }
    if( "eMirroredRepeat" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eMirroredRepeat ;
      return;
    }
    if( "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eMirroredRepeat ;
      return;
    }
    if( "ClampToEdge" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eClampToEdge ;
      return;
    }
    if( "eClampToEdge" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eClampToEdge ;
      return;
    }
    if( "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eClampToEdge ;
      return;
    }
    if( "ClampToBorder" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eClampToBorder ;
      return;
    }
    if( "eClampToBorder" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eClampToBorder ;
      return;
    }
    if( "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eClampToBorder ;
      return;
    }
    if( "MirrorClampToEdge" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eMirrorClampToEdge ;
      return;
    }
    if( "eMirrorClampToEdge" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eMirrorClampToEdge ;
      return;
    }
    if( "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" == j.get< std::string >() ) {
      p = SamplerAddressMode :: eMirrorClampToEdge ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SamplerAddressMode" );
  }
  if( j.is_number() ) {
    p = SamplerAddressMode ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SamplerAddressMode" );
}
inline void from_json( const nlohmann::json &j, VkSamplerAddressMode &p ) {
  SamplerAddressMode temp;
  from_json( j, temp );
  p = VkSamplerAddressMode ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const SamplerMipmapMode &p ) {
  if( SamplerMipmapMode :: eNearest == p ) {
    j = "Nearest";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkSamplerMipmapMode &p ) {
  to_json( j, SamplerMipmapMode ( p ) );
}
inline void from_json( const nlohmann::json &j, SamplerMipmapMode &p ) {
  if( j.is_string() ) {
    if( "Nearest" == j.get< std::string >() ) {
      p = SamplerMipmapMode :: eNearest ;
      return;
    }
    if( "eNearest" == j.get< std::string >() ) {
      p = SamplerMipmapMode :: eNearest ;
      return;
    }
    if( "VK_SAMPLER_MIPMAP_MODE_NEAREST" == j.get< std::string >() ) {
      p = SamplerMipmapMode :: eNearest ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SamplerMipmapMode" );
  }
  if( j.is_number() ) {
    p = SamplerMipmapMode ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SamplerMipmapMode" );
}
inline void from_json( const nlohmann::json &j, VkSamplerMipmapMode &p ) {
  SamplerMipmapMode temp;
  from_json( j, temp );
  p = VkSamplerMipmapMode ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const DescriptorType &p ) {
  if( DescriptorType :: eSampler == p ) {
    j = "Sampler";
    return;
  }
  if( DescriptorType :: eCombinedImageSampler == p ) {
    j = "CombinedImageSampler";
    return;
  }
  if( DescriptorType :: eSampledImage == p ) {
    j = "SampledImage";
    return;
  }
  if( DescriptorType :: eStorageImage == p ) {
    j = "StorageImage";
    return;
  }
  if( DescriptorType :: eUniformTexelBuffer == p ) {
    j = "UniformTexelBuffer";
    return;
  }
  if( DescriptorType :: eStorageTexelBuffer == p ) {
    j = "StorageTexelBuffer";
    return;
  }
  if( DescriptorType :: eUniformBuffer == p ) {
    j = "UniformBuffer";
    return;
  }
  if( DescriptorType :: eStorageBuffer == p ) {
    j = "StorageBuffer";
    return;
  }
  if( DescriptorType :: eUniformBufferDynamic == p ) {
    j = "UniformBufferDynamic";
    return;
  }
  if( DescriptorType :: eStorageBufferDynamic == p ) {
    j = "StorageBufferDynamic";
    return;
  }
  if( DescriptorType :: eInputAttachment == p ) {
    j = "InputAttachment";
    return;
  }
  if( DescriptorType :: eInlineUniformBlockEXT == p ) {
    j = "InlineUniformBlockEXT";
    return;
  }
  if( DescriptorType :: eAccelerationStructureKHR == p ) {
    j = "AccelerationStructureKHR";
    return;
  }
  if( DescriptorType :: eAccelerationStructureNV == p ) {
    j = "AccelerationStructureNV";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkDescriptorType &p ) {
  to_json( j, DescriptorType ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorType &p ) {
  if( j.is_string() ) {
    if( "Sampler" == j.get< std::string >() ) {
      p = DescriptorType :: eSampler ;
      return;
    }
    if( "eSampler" == j.get< std::string >() ) {
      p = DescriptorType :: eSampler ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_SAMPLER" == j.get< std::string >() ) {
      p = DescriptorType :: eSampler ;
      return;
    }
    if( "CombinedImageSampler" == j.get< std::string >() ) {
      p = DescriptorType :: eCombinedImageSampler ;
      return;
    }
    if( "eCombinedImageSampler" == j.get< std::string >() ) {
      p = DescriptorType :: eCombinedImageSampler ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER" == j.get< std::string >() ) {
      p = DescriptorType :: eCombinedImageSampler ;
      return;
    }
    if( "SampledImage" == j.get< std::string >() ) {
      p = DescriptorType :: eSampledImage ;
      return;
    }
    if( "eSampledImage" == j.get< std::string >() ) {
      p = DescriptorType :: eSampledImage ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE" == j.get< std::string >() ) {
      p = DescriptorType :: eSampledImage ;
      return;
    }
    if( "StorageImage" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageImage ;
      return;
    }
    if( "eStorageImage" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageImage ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageImage ;
      return;
    }
    if( "UniformTexelBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformTexelBuffer ;
      return;
    }
    if( "eUniformTexelBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformTexelBuffer ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformTexelBuffer ;
      return;
    }
    if( "StorageTexelBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageTexelBuffer ;
      return;
    }
    if( "eStorageTexelBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageTexelBuffer ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageTexelBuffer ;
      return;
    }
    if( "UniformBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformBuffer ;
      return;
    }
    if( "eUniformBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformBuffer ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformBuffer ;
      return;
    }
    if( "StorageBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageBuffer ;
      return;
    }
    if( "eStorageBuffer" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageBuffer ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageBuffer ;
      return;
    }
    if( "UniformBufferDynamic" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformBufferDynamic ;
      return;
    }
    if( "eUniformBufferDynamic" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformBufferDynamic ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC" == j.get< std::string >() ) {
      p = DescriptorType :: eUniformBufferDynamic ;
      return;
    }
    if( "StorageBufferDynamic" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageBufferDynamic ;
      return;
    }
    if( "eStorageBufferDynamic" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageBufferDynamic ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC" == j.get< std::string >() ) {
      p = DescriptorType :: eStorageBufferDynamic ;
      return;
    }
    if( "InputAttachment" == j.get< std::string >() ) {
      p = DescriptorType :: eInputAttachment ;
      return;
    }
    if( "eInputAttachment" == j.get< std::string >() ) {
      p = DescriptorType :: eInputAttachment ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT" == j.get< std::string >() ) {
      p = DescriptorType :: eInputAttachment ;
      return;
    }
    if( "InlineUniformBlockEXT" == j.get< std::string >() ) {
      p = DescriptorType :: eInlineUniformBlockEXT ;
      return;
    }
    if( "eInlineUniformBlockEXT" == j.get< std::string >() ) {
      p = DescriptorType :: eInlineUniformBlockEXT ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT" == j.get< std::string >() ) {
      p = DescriptorType :: eInlineUniformBlockEXT ;
      return;
    }
    if( "AccelerationStructureKHR" == j.get< std::string >() ) {
      p = DescriptorType :: eAccelerationStructureKHR ;
      return;
    }
    if( "eAccelerationStructureKHR" == j.get< std::string >() ) {
      p = DescriptorType :: eAccelerationStructureKHR ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR" == j.get< std::string >() ) {
      p = DescriptorType :: eAccelerationStructureKHR ;
      return;
    }
    if( "AccelerationStructureNV" == j.get< std::string >() ) {
      p = DescriptorType :: eAccelerationStructureNV ;
      return;
    }
    if( "eAccelerationStructureNV" == j.get< std::string >() ) {
      p = DescriptorType :: eAccelerationStructureNV ;
      return;
    }
    if( "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV" == j.get< std::string >() ) {
      p = DescriptorType :: eAccelerationStructureNV ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DescriptorType" );
  }
  if( j.is_number() ) {
    p = DescriptorType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DescriptorType" );
}
inline void from_json( const nlohmann::json &j, VkDescriptorType &p ) {
  DescriptorType temp;
  from_json( j, temp );
  p = VkDescriptorType ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const AttachmentLoadOp &p ) {
  if( AttachmentLoadOp :: eLoad == p ) {
    j = "Load";
    return;
  }
  if( AttachmentLoadOp :: eClear == p ) {
    j = "Clear";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkAttachmentLoadOp &p ) {
  to_json( j, AttachmentLoadOp ( p ) );
}
inline void from_json( const nlohmann::json &j, AttachmentLoadOp &p ) {
  if( j.is_string() ) {
    if( "Load" == j.get< std::string >() ) {
      p = AttachmentLoadOp :: eLoad ;
      return;
    }
    if( "eLoad" == j.get< std::string >() ) {
      p = AttachmentLoadOp :: eLoad ;
      return;
    }
    if( "VK_ATTACHMENT_LOAD_OP_LOAD" == j.get< std::string >() ) {
      p = AttachmentLoadOp :: eLoad ;
      return;
    }
    if( "Clear" == j.get< std::string >() ) {
      p = AttachmentLoadOp :: eClear ;
      return;
    }
    if( "eClear" == j.get< std::string >() ) {
      p = AttachmentLoadOp :: eClear ;
      return;
    }
    if( "VK_ATTACHMENT_LOAD_OP_CLEAR" == j.get< std::string >() ) {
      p = AttachmentLoadOp :: eClear ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AttachmentLoadOp" );
  }
  if( j.is_number() ) {
    p = AttachmentLoadOp ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AttachmentLoadOp" );
}
inline void from_json( const nlohmann::json &j, VkAttachmentLoadOp &p ) {
  AttachmentLoadOp temp;
  from_json( j, temp );
  p = VkAttachmentLoadOp ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const AttachmentStoreOp &p ) {
  if( AttachmentStoreOp :: eStore == p ) {
    j = "Store";
    return;
  }
  if( AttachmentStoreOp :: eDontCare == p ) {
    j = "DontCare";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkAttachmentStoreOp &p ) {
  to_json( j, AttachmentStoreOp ( p ) );
}
inline void from_json( const nlohmann::json &j, AttachmentStoreOp &p ) {
  if( j.is_string() ) {
    if( "Store" == j.get< std::string >() ) {
      p = AttachmentStoreOp :: eStore ;
      return;
    }
    if( "eStore" == j.get< std::string >() ) {
      p = AttachmentStoreOp :: eStore ;
      return;
    }
    if( "VK_ATTACHMENT_STORE_OP_STORE" == j.get< std::string >() ) {
      p = AttachmentStoreOp :: eStore ;
      return;
    }
    if( "DontCare" == j.get< std::string >() ) {
      p = AttachmentStoreOp :: eDontCare ;
      return;
    }
    if( "eDontCare" == j.get< std::string >() ) {
      p = AttachmentStoreOp :: eDontCare ;
      return;
    }
    if( "VK_ATTACHMENT_STORE_OP_DONT_CARE" == j.get< std::string >() ) {
      p = AttachmentStoreOp :: eDontCare ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AttachmentStoreOp" );
  }
  if( j.is_number() ) {
    p = AttachmentStoreOp ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AttachmentStoreOp" );
}
inline void from_json( const nlohmann::json &j, VkAttachmentStoreOp &p ) {
  AttachmentStoreOp temp;
  from_json( j, temp );
  p = VkAttachmentStoreOp ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineBindPoint &p ) {
  if( PipelineBindPoint :: eGraphics == p ) {
    j = "Graphics";
    return;
  }
  if( PipelineBindPoint :: eCompute == p ) {
    j = "Compute";
    return;
  }
  if( PipelineBindPoint :: eRayTracingKHR == p ) {
    j = "RayTracingKHR";
    return;
  }
  if( PipelineBindPoint :: eSubpassShadingHUAWEI == p ) {
    j = "SubpassShadingHUAWEI";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkPipelineBindPoint &p ) {
  to_json( j, PipelineBindPoint ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineBindPoint &p ) {
  if( j.is_string() ) {
    if( "Graphics" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eGraphics ;
      return;
    }
    if( "eGraphics" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eGraphics ;
      return;
    }
    if( "VK_PIPELINE_BIND_POINT_GRAPHICS" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eGraphics ;
      return;
    }
    if( "Compute" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eCompute ;
      return;
    }
    if( "eCompute" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eCompute ;
      return;
    }
    if( "VK_PIPELINE_BIND_POINT_COMPUTE" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eCompute ;
      return;
    }
    if( "RayTracingKHR" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eRayTracingKHR ;
      return;
    }
    if( "eRayTracingKHR" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eRayTracingKHR ;
      return;
    }
    if( "VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eRayTracingKHR ;
      return;
    }
    if( "SubpassShadingHUAWEI" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eSubpassShadingHUAWEI ;
      return;
    }
    if( "eSubpassShadingHUAWEI" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eSubpassShadingHUAWEI ;
      return;
    }
    if( "VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI" == j.get< std::string >() ) {
      p = PipelineBindPoint :: eSubpassShadingHUAWEI ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineBindPoint" );
  }
  if( j.is_number() ) {
    p = PipelineBindPoint ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineBindPoint" );
}
inline void from_json( const nlohmann::json &j, VkPipelineBindPoint &p ) {
  PipelineBindPoint temp;
  from_json( j, temp );
  p = VkPipelineBindPoint ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const CommandBufferLevel &p ) {
  if( CommandBufferLevel :: ePrimary == p ) {
    j = "Primary";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkCommandBufferLevel &p ) {
  to_json( j, CommandBufferLevel ( p ) );
}
inline void from_json( const nlohmann::json &j, CommandBufferLevel &p ) {
  if( j.is_string() ) {
    if( "Primary" == j.get< std::string >() ) {
      p = CommandBufferLevel :: ePrimary ;
      return;
    }
    if( "ePrimary" == j.get< std::string >() ) {
      p = CommandBufferLevel :: ePrimary ;
      return;
    }
    if( "VK_COMMAND_BUFFER_LEVEL_PRIMARY" == j.get< std::string >() ) {
      p = CommandBufferLevel :: ePrimary ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CommandBufferLevel" );
  }
  if( j.is_number() ) {
    p = CommandBufferLevel ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CommandBufferLevel" );
}
inline void from_json( const nlohmann::json &j, VkCommandBufferLevel &p ) {
  CommandBufferLevel temp;
  from_json( j, temp );
  p = VkCommandBufferLevel ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const IndexType &p ) {
  if( IndexType :: eUint16 == p ) {
    j = "Uint16";
    return;
  }
  if( IndexType :: eUint32 == p ) {
    j = "Uint32";
    return;
  }
  if( IndexType :: eNoneKHR == p ) {
    j = "NoneKHR";
    return;
  }
  if( IndexType :: eUint8EXT == p ) {
    j = "Uint8EXT";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkIndexType &p ) {
  to_json( j, IndexType ( p ) );
}
inline void from_json( const nlohmann::json &j, IndexType &p ) {
  if( j.is_string() ) {
    if( "Uint16" == j.get< std::string >() ) {
      p = IndexType :: eUint16 ;
      return;
    }
    if( "eUint16" == j.get< std::string >() ) {
      p = IndexType :: eUint16 ;
      return;
    }
    if( "VK_INDEX_TYPE_UINT16" == j.get< std::string >() ) {
      p = IndexType :: eUint16 ;
      return;
    }
    if( "Uint32" == j.get< std::string >() ) {
      p = IndexType :: eUint32 ;
      return;
    }
    if( "eUint32" == j.get< std::string >() ) {
      p = IndexType :: eUint32 ;
      return;
    }
    if( "VK_INDEX_TYPE_UINT32" == j.get< std::string >() ) {
      p = IndexType :: eUint32 ;
      return;
    }
    if( "NoneKHR" == j.get< std::string >() ) {
      p = IndexType :: eNoneKHR ;
      return;
    }
    if( "eNoneKHR" == j.get< std::string >() ) {
      p = IndexType :: eNoneKHR ;
      return;
    }
    if( "VK_INDEX_TYPE_NONE_KHR" == j.get< std::string >() ) {
      p = IndexType :: eNoneKHR ;
      return;
    }
    if( "Uint8EXT" == j.get< std::string >() ) {
      p = IndexType :: eUint8EXT ;
      return;
    }
    if( "eUint8EXT" == j.get< std::string >() ) {
      p = IndexType :: eUint8EXT ;
      return;
    }
    if( "VK_INDEX_TYPE_UINT8_EXT" == j.get< std::string >() ) {
      p = IndexType :: eUint8EXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for IndexType" );
  }
  if( j.is_number() ) {
    p = IndexType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for IndexType" );
}
inline void from_json( const nlohmann::json &j, VkIndexType &p ) {
  IndexType temp;
  from_json( j, temp );
  p = VkIndexType ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const SubpassContents &p ) {
  if( SubpassContents :: eInline == p ) {
    j = "Inline";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkSubpassContents &p ) {
  to_json( j, SubpassContents ( p ) );
}
inline void from_json( const nlohmann::json &j, SubpassContents &p ) {
  if( j.is_string() ) {
    if( "Inline" == j.get< std::string >() ) {
      p = SubpassContents :: eInline ;
      return;
    }
    if( "eInline" == j.get< std::string >() ) {
      p = SubpassContents :: eInline ;
      return;
    }
    if( "VK_SUBPASS_CONTENTS_INLINE" == j.get< std::string >() ) {
      p = SubpassContents :: eInline ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SubpassContents" );
  }
  if( j.is_number() ) {
    p = SubpassContents ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SubpassContents" );
}
inline void from_json( const nlohmann::json &j, VkSubpassContents &p ) {
  SubpassContents temp;
  from_json( j, temp );
  p = VkSubpassContents ( temp );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const PointClippingBehavior &p ) {
  if( PointClippingBehavior :: eAllClipPlanes == p ) {
    j = "AllClipPlanes";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkPointClippingBehavior &p ) {
  to_json( j, PointClippingBehavior ( p ) );
}
inline void from_json( const nlohmann::json &j, PointClippingBehavior &p ) {
  if( j.is_string() ) {
    if( "AllClipPlanes" == j.get< std::string >() ) {
      p = PointClippingBehavior :: eAllClipPlanes ;
      return;
    }
    if( "eAllClipPlanes" == j.get< std::string >() ) {
      p = PointClippingBehavior :: eAllClipPlanes ;
      return;
    }
    if( "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES" == j.get< std::string >() ) {
      p = PointClippingBehavior :: eAllClipPlanes ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PointClippingBehavior" );
  }
  if( j.is_number() ) {
    p = PointClippingBehavior ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PointClippingBehavior" );
}
inline void from_json( const nlohmann::json &j, VkPointClippingBehavior &p ) {
  PointClippingBehavior temp;
  from_json( j, temp );
  p = VkPointClippingBehavior ( temp );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const TessellationDomainOrigin &p ) {
  if( TessellationDomainOrigin :: eUpperLeft == p ) {
    j = "UpperLeft";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkTessellationDomainOrigin &p ) {
  to_json( j, TessellationDomainOrigin ( p ) );
}
inline void from_json( const nlohmann::json &j, TessellationDomainOrigin &p ) {
  if( j.is_string() ) {
    if( "UpperLeft" == j.get< std::string >() ) {
      p = TessellationDomainOrigin :: eUpperLeft ;
      return;
    }
    if( "eUpperLeft" == j.get< std::string >() ) {
      p = TessellationDomainOrigin :: eUpperLeft ;
      return;
    }
    if( "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT" == j.get< std::string >() ) {
      p = TessellationDomainOrigin :: eUpperLeft ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for TessellationDomainOrigin" );
  }
  if( j.is_number() ) {
    p = TessellationDomainOrigin ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for TessellationDomainOrigin" );
}
inline void from_json( const nlohmann::json &j, VkTessellationDomainOrigin &p ) {
  TessellationDomainOrigin temp;
  from_json( j, temp );
  p = VkTessellationDomainOrigin ( temp );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const SamplerYcbcrModelConversion &p ) {
  if( SamplerYcbcrModelConversion :: eRgbIdentity == p ) {
    j = "RgbIdentity";
    return;
  }
  if( SamplerYcbcrModelConversion :: eYcbcrIdentity == p ) {
    j = "YcbcrIdentity";
    return;
  }
  if( SamplerYcbcrModelConversion :: eYcbcr709 == p ) {
    j = "Ycbcr709";
    return;
  }
  if( SamplerYcbcrModelConversion :: eYcbcr601 == p ) {
    j = "Ycbcr601";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkSamplerYcbcrModelConversion &p ) {
  to_json( j, SamplerYcbcrModelConversion ( p ) );
}
inline void from_json( const nlohmann::json &j, SamplerYcbcrModelConversion &p ) {
  if( j.is_string() ) {
    if( "RgbIdentity" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eRgbIdentity ;
      return;
    }
    if( "eRgbIdentity" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eRgbIdentity ;
      return;
    }
    if( "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eRgbIdentity ;
      return;
    }
    if( "YcbcrIdentity" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcrIdentity ;
      return;
    }
    if( "eYcbcrIdentity" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcrIdentity ;
      return;
    }
    if( "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcrIdentity ;
      return;
    }
    if( "Ycbcr709" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcr709 ;
      return;
    }
    if( "eYcbcr709" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcr709 ;
      return;
    }
    if( "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcr709 ;
      return;
    }
    if( "Ycbcr601" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcr601 ;
      return;
    }
    if( "eYcbcr601" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcr601 ;
      return;
    }
    if( "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601" == j.get< std::string >() ) {
      p = SamplerYcbcrModelConversion :: eYcbcr601 ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SamplerYcbcrModelConversion" );
  }
  if( j.is_number() ) {
    p = SamplerYcbcrModelConversion ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SamplerYcbcrModelConversion" );
}
inline void from_json( const nlohmann::json &j, VkSamplerYcbcrModelConversion &p ) {
  SamplerYcbcrModelConversion temp;
  from_json( j, temp );
  p = VkSamplerYcbcrModelConversion ( temp );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const SamplerYcbcrRange &p ) {
  if( SamplerYcbcrRange :: eItuFull == p ) {
    j = "ItuFull";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkSamplerYcbcrRange &p ) {
  to_json( j, SamplerYcbcrRange ( p ) );
}
inline void from_json( const nlohmann::json &j, SamplerYcbcrRange &p ) {
  if( j.is_string() ) {
    if( "ItuFull" == j.get< std::string >() ) {
      p = SamplerYcbcrRange :: eItuFull ;
      return;
    }
    if( "eItuFull" == j.get< std::string >() ) {
      p = SamplerYcbcrRange :: eItuFull ;
      return;
    }
    if( "VK_SAMPLER_YCBCR_RANGE_ITU_FULL" == j.get< std::string >() ) {
      p = SamplerYcbcrRange :: eItuFull ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SamplerYcbcrRange" );
  }
  if( j.is_number() ) {
    p = SamplerYcbcrRange ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SamplerYcbcrRange" );
}
inline void from_json( const nlohmann::json &j, VkSamplerYcbcrRange &p ) {
  SamplerYcbcrRange temp;
  from_json( j, temp );
  p = VkSamplerYcbcrRange ( temp );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const ChromaLocation &p ) {
  if( ChromaLocation :: eCositedEven == p ) {
    j = "CositedEven";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkChromaLocation &p ) {
  to_json( j, ChromaLocation ( p ) );
}
inline void from_json( const nlohmann::json &j, ChromaLocation &p ) {
  if( j.is_string() ) {
    if( "CositedEven" == j.get< std::string >() ) {
      p = ChromaLocation :: eCositedEven ;
      return;
    }
    if( "eCositedEven" == j.get< std::string >() ) {
      p = ChromaLocation :: eCositedEven ;
      return;
    }
    if( "VK_CHROMA_LOCATION_COSITED_EVEN" == j.get< std::string >() ) {
      p = ChromaLocation :: eCositedEven ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ChromaLocation" );
  }
  if( j.is_number() ) {
    p = ChromaLocation ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ChromaLocation" );
}
inline void from_json( const nlohmann::json &j, VkChromaLocation &p ) {
  ChromaLocation temp;
  from_json( j, temp );
  p = VkChromaLocation ( temp );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const DescriptorUpdateTemplateType &p ) {
  if( DescriptorUpdateTemplateType :: eDescriptorSet == p ) {
    j = "DescriptorSet";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkDescriptorUpdateTemplateType &p ) {
  to_json( j, DescriptorUpdateTemplateType ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorUpdateTemplateType &p ) {
  if( j.is_string() ) {
    if( "DescriptorSet" == j.get< std::string >() ) {
      p = DescriptorUpdateTemplateType :: eDescriptorSet ;
      return;
    }
    if( "eDescriptorSet" == j.get< std::string >() ) {
      p = DescriptorUpdateTemplateType :: eDescriptorSet ;
      return;
    }
    if( "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET" == j.get< std::string >() ) {
      p = DescriptorUpdateTemplateType :: eDescriptorSet ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DescriptorUpdateTemplateType" );
  }
  if( j.is_number() ) {
    p = DescriptorUpdateTemplateType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DescriptorUpdateTemplateType" );
}
inline void from_json( const nlohmann::json &j, VkDescriptorUpdateTemplateType &p ) {
  DescriptorUpdateTemplateType temp;
  from_json( j, temp );
  p = VkDescriptorUpdateTemplateType ( temp );
}
#endif

#ifdef VK_VERSION_1_2
inline void to_json( nlohmann::json &j, const DriverId &p ) {
  if( DriverId :: eAmdProprietary == p ) {
    j = "AmdProprietary";
    return;
  }
  if( DriverId :: eAmdOpenSource == p ) {
    j = "AmdOpenSource";
    return;
  }
  if( DriverId :: eMesaRadv == p ) {
    j = "MesaRadv";
    return;
  }
  if( DriverId :: eNvidiaProprietary == p ) {
    j = "NvidiaProprietary";
    return;
  }
  if( DriverId :: eIntelProprietaryWindows == p ) {
    j = "IntelProprietaryWindows";
    return;
  }
  if( DriverId :: eIntelOpenSourceMESA == p ) {
    j = "IntelOpenSourceMESA";
    return;
  }
  if( DriverId :: eImaginationProprietary == p ) {
    j = "ImaginationProprietary";
    return;
  }
  if( DriverId :: eQualcommProprietary == p ) {
    j = "QualcommProprietary";
    return;
  }
  if( DriverId :: eArmProprietary == p ) {
    j = "ArmProprietary";
    return;
  }
  if( DriverId :: eGoogleSwiftshader == p ) {
    j = "GoogleSwiftshader";
    return;
  }
  if( DriverId :: eGgpProprietary == p ) {
    j = "GgpProprietary";
    return;
  }
  if( DriverId :: eBroadcomProprietary == p ) {
    j = "BroadcomProprietary";
    return;
  }
  if( DriverId :: eMesaLlvmpipe == p ) {
    j = "MesaLlvmpipe";
    return;
  }
  if( DriverId :: eMoltenvk == p ) {
    j = "Moltenvk";
    return;
  }
  if( DriverId :: eCoreaviProprietary == p ) {
    j = "CoreaviProprietary";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkDriverId &p ) {
  to_json( j, DriverId ( p ) );
}
inline void from_json( const nlohmann::json &j, DriverId &p ) {
  if( j.is_string() ) {
    if( "AmdProprietary" == j.get< std::string >() ) {
      p = DriverId :: eAmdProprietary ;
      return;
    }
    if( "eAmdProprietary" == j.get< std::string >() ) {
      p = DriverId :: eAmdProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_AMD_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eAmdProprietary ;
      return;
    }
    if( "AmdOpenSource" == j.get< std::string >() ) {
      p = DriverId :: eAmdOpenSource ;
      return;
    }
    if( "eAmdOpenSource" == j.get< std::string >() ) {
      p = DriverId :: eAmdOpenSource ;
      return;
    }
    if( "VK_DRIVER_ID_AMD_OPEN_SOURCE" == j.get< std::string >() ) {
      p = DriverId :: eAmdOpenSource ;
      return;
    }
    if( "MesaRadv" == j.get< std::string >() ) {
      p = DriverId :: eMesaRadv ;
      return;
    }
    if( "eMesaRadv" == j.get< std::string >() ) {
      p = DriverId :: eMesaRadv ;
      return;
    }
    if( "VK_DRIVER_ID_MESA_RADV" == j.get< std::string >() ) {
      p = DriverId :: eMesaRadv ;
      return;
    }
    if( "NvidiaProprietary" == j.get< std::string >() ) {
      p = DriverId :: eNvidiaProprietary ;
      return;
    }
    if( "eNvidiaProprietary" == j.get< std::string >() ) {
      p = DriverId :: eNvidiaProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_NVIDIA_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eNvidiaProprietary ;
      return;
    }
    if( "IntelProprietaryWindows" == j.get< std::string >() ) {
      p = DriverId :: eIntelProprietaryWindows ;
      return;
    }
    if( "eIntelProprietaryWindows" == j.get< std::string >() ) {
      p = DriverId :: eIntelProprietaryWindows ;
      return;
    }
    if( "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS" == j.get< std::string >() ) {
      p = DriverId :: eIntelProprietaryWindows ;
      return;
    }
    if( "IntelOpenSourceMESA" == j.get< std::string >() ) {
      p = DriverId :: eIntelOpenSourceMESA ;
      return;
    }
    if( "eIntelOpenSourceMESA" == j.get< std::string >() ) {
      p = DriverId :: eIntelOpenSourceMESA ;
      return;
    }
    if( "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA" == j.get< std::string >() ) {
      p = DriverId :: eIntelOpenSourceMESA ;
      return;
    }
    if( "ImaginationProprietary" == j.get< std::string >() ) {
      p = DriverId :: eImaginationProprietary ;
      return;
    }
    if( "eImaginationProprietary" == j.get< std::string >() ) {
      p = DriverId :: eImaginationProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_IMAGINATION_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eImaginationProprietary ;
      return;
    }
    if( "QualcommProprietary" == j.get< std::string >() ) {
      p = DriverId :: eQualcommProprietary ;
      return;
    }
    if( "eQualcommProprietary" == j.get< std::string >() ) {
      p = DriverId :: eQualcommProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_QUALCOMM_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eQualcommProprietary ;
      return;
    }
    if( "ArmProprietary" == j.get< std::string >() ) {
      p = DriverId :: eArmProprietary ;
      return;
    }
    if( "eArmProprietary" == j.get< std::string >() ) {
      p = DriverId :: eArmProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_ARM_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eArmProprietary ;
      return;
    }
    if( "GoogleSwiftshader" == j.get< std::string >() ) {
      p = DriverId :: eGoogleSwiftshader ;
      return;
    }
    if( "eGoogleSwiftshader" == j.get< std::string >() ) {
      p = DriverId :: eGoogleSwiftshader ;
      return;
    }
    if( "VK_DRIVER_ID_GOOGLE_SWIFTSHADER" == j.get< std::string >() ) {
      p = DriverId :: eGoogleSwiftshader ;
      return;
    }
    if( "GgpProprietary" == j.get< std::string >() ) {
      p = DriverId :: eGgpProprietary ;
      return;
    }
    if( "eGgpProprietary" == j.get< std::string >() ) {
      p = DriverId :: eGgpProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_GGP_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eGgpProprietary ;
      return;
    }
    if( "BroadcomProprietary" == j.get< std::string >() ) {
      p = DriverId :: eBroadcomProprietary ;
      return;
    }
    if( "eBroadcomProprietary" == j.get< std::string >() ) {
      p = DriverId :: eBroadcomProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_BROADCOM_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eBroadcomProprietary ;
      return;
    }
    if( "MesaLlvmpipe" == j.get< std::string >() ) {
      p = DriverId :: eMesaLlvmpipe ;
      return;
    }
    if( "eMesaLlvmpipe" == j.get< std::string >() ) {
      p = DriverId :: eMesaLlvmpipe ;
      return;
    }
    if( "VK_DRIVER_ID_MESA_LLVMPIPE" == j.get< std::string >() ) {
      p = DriverId :: eMesaLlvmpipe ;
      return;
    }
    if( "Moltenvk" == j.get< std::string >() ) {
      p = DriverId :: eMoltenvk ;
      return;
    }
    if( "eMoltenvk" == j.get< std::string >() ) {
      p = DriverId :: eMoltenvk ;
      return;
    }
    if( "VK_DRIVER_ID_MOLTENVK" == j.get< std::string >() ) {
      p = DriverId :: eMoltenvk ;
      return;
    }
    if( "CoreaviProprietary" == j.get< std::string >() ) {
      p = DriverId :: eCoreaviProprietary ;
      return;
    }
    if( "eCoreaviProprietary" == j.get< std::string >() ) {
      p = DriverId :: eCoreaviProprietary ;
      return;
    }
    if( "VK_DRIVER_ID_COREAVI_PROPRIETARY" == j.get< std::string >() ) {
      p = DriverId :: eCoreaviProprietary ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DriverId" );
  }
  if( j.is_number() ) {
    p = DriverId ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DriverId" );
}
inline void from_json( const nlohmann::json &j, VkDriverId &p ) {
  DriverId temp;
  from_json( j, temp );
  p = VkDriverId ( temp );
}
#endif

#ifdef VK_VERSION_1_2
inline void to_json( nlohmann::json &j, const ShaderFloatControlsIndependence &p ) {
  if( ShaderFloatControlsIndependence :: e32BitOnly == p ) {
    j = "32BitOnly";
    return;
  }
  if( ShaderFloatControlsIndependence :: eAll == p ) {
    j = "All";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkShaderFloatControlsIndependence &p ) {
  to_json( j, ShaderFloatControlsIndependence ( p ) );
}
inline void from_json( const nlohmann::json &j, ShaderFloatControlsIndependence &p ) {
  if( j.is_string() ) {
    if( "32BitOnly" == j.get< std::string >() ) {
      p = ShaderFloatControlsIndependence :: e32BitOnly ;
      return;
    }
    if( "e32BitOnly" == j.get< std::string >() ) {
      p = ShaderFloatControlsIndependence :: e32BitOnly ;
      return;
    }
    if( "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY" == j.get< std::string >() ) {
      p = ShaderFloatControlsIndependence :: e32BitOnly ;
      return;
    }
    if( "All" == j.get< std::string >() ) {
      p = ShaderFloatControlsIndependence :: eAll ;
      return;
    }
    if( "eAll" == j.get< std::string >() ) {
      p = ShaderFloatControlsIndependence :: eAll ;
      return;
    }
    if( "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL" == j.get< std::string >() ) {
      p = ShaderFloatControlsIndependence :: eAll ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ShaderFloatControlsIndependence" );
  }
  if( j.is_number() ) {
    p = ShaderFloatControlsIndependence ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ShaderFloatControlsIndependence" );
}
inline void from_json( const nlohmann::json &j, VkShaderFloatControlsIndependence &p ) {
  ShaderFloatControlsIndependence temp;
  from_json( j, temp );
  p = VkShaderFloatControlsIndependence ( temp );
}
#endif

#ifdef VK_VERSION_1_2
inline void to_json( nlohmann::json &j, const SamplerReductionMode &p ) {
  if( SamplerReductionMode :: eWeightedAverage == p ) {
    j = "WeightedAverage";
    return;
  }
  if( SamplerReductionMode :: eMin == p ) {
    j = "Min";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkSamplerReductionMode &p ) {
  to_json( j, SamplerReductionMode ( p ) );
}
inline void from_json( const nlohmann::json &j, SamplerReductionMode &p ) {
  if( j.is_string() ) {
    if( "WeightedAverage" == j.get< std::string >() ) {
      p = SamplerReductionMode :: eWeightedAverage ;
      return;
    }
    if( "eWeightedAverage" == j.get< std::string >() ) {
      p = SamplerReductionMode :: eWeightedAverage ;
      return;
    }
    if( "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE" == j.get< std::string >() ) {
      p = SamplerReductionMode :: eWeightedAverage ;
      return;
    }
    if( "Min" == j.get< std::string >() ) {
      p = SamplerReductionMode :: eMin ;
      return;
    }
    if( "eMin" == j.get< std::string >() ) {
      p = SamplerReductionMode :: eMin ;
      return;
    }
    if( "VK_SAMPLER_REDUCTION_MODE_MIN" == j.get< std::string >() ) {
      p = SamplerReductionMode :: eMin ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SamplerReductionMode" );
  }
  if( j.is_number() ) {
    p = SamplerReductionMode ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SamplerReductionMode" );
}
inline void from_json( const nlohmann::json &j, VkSamplerReductionMode &p ) {
  SamplerReductionMode temp;
  from_json( j, temp );
  p = VkSamplerReductionMode ( temp );
}
#endif

#ifdef VK_VERSION_1_2
inline void to_json( nlohmann::json &j, const SemaphoreType &p ) {
  if( SemaphoreType :: eBinary == p ) {
    j = "Binary";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkSemaphoreType &p ) {
  to_json( j, SemaphoreType ( p ) );
}
inline void from_json( const nlohmann::json &j, SemaphoreType &p ) {
  if( j.is_string() ) {
    if( "Binary" == j.get< std::string >() ) {
      p = SemaphoreType :: eBinary ;
      return;
    }
    if( "eBinary" == j.get< std::string >() ) {
      p = SemaphoreType :: eBinary ;
      return;
    }
    if( "VK_SEMAPHORE_TYPE_BINARY" == j.get< std::string >() ) {
      p = SemaphoreType :: eBinary ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SemaphoreType" );
  }
  if( j.is_number() ) {
    p = SemaphoreType ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SemaphoreType" );
}
inline void from_json( const nlohmann::json &j, VkSemaphoreType &p ) {
  SemaphoreType temp;
  from_json( j, temp );
  p = VkSemaphoreType ( temp );
}
#endif

#ifdef VK_KHR_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PresentModeKHR &p ) {
  if( PresentModeKHR :: eImmediate == p ) {
    j = "Immediate";
    return;
  }
  if( PresentModeKHR :: eMailbox == p ) {
    j = "Mailbox";
    return;
  }
  if( PresentModeKHR :: eFifo == p ) {
    j = "Fifo";
    return;
  }
  if( PresentModeKHR :: eFifoRelaxed == p ) {
    j = "FifoRelaxed";
    return;
  }
  if( PresentModeKHR :: eSharedDemandRefresh == p ) {
    j = "SharedDemandRefresh";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkPresentModeKHR &p ) {
  to_json( j, PresentModeKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PresentModeKHR &p ) {
  if( j.is_string() ) {
    if( "Immediate" == j.get< std::string >() ) {
      p = PresentModeKHR :: eImmediate ;
      return;
    }
    if( "eImmediate" == j.get< std::string >() ) {
      p = PresentModeKHR :: eImmediate ;
      return;
    }
    if( "VK_PRESENT_MODE_IMMEDIATE_KHR" == j.get< std::string >() ) {
      p = PresentModeKHR :: eImmediate ;
      return;
    }
    if( "Mailbox" == j.get< std::string >() ) {
      p = PresentModeKHR :: eMailbox ;
      return;
    }
    if( "eMailbox" == j.get< std::string >() ) {
      p = PresentModeKHR :: eMailbox ;
      return;
    }
    if( "VK_PRESENT_MODE_MAILBOX_KHR" == j.get< std::string >() ) {
      p = PresentModeKHR :: eMailbox ;
      return;
    }
    if( "Fifo" == j.get< std::string >() ) {
      p = PresentModeKHR :: eFifo ;
      return;
    }
    if( "eFifo" == j.get< std::string >() ) {
      p = PresentModeKHR :: eFifo ;
      return;
    }
    if( "VK_PRESENT_MODE_FIFO_KHR" == j.get< std::string >() ) {
      p = PresentModeKHR :: eFifo ;
      return;
    }
    if( "FifoRelaxed" == j.get< std::string >() ) {
      p = PresentModeKHR :: eFifoRelaxed ;
      return;
    }
    if( "eFifoRelaxed" == j.get< std::string >() ) {
      p = PresentModeKHR :: eFifoRelaxed ;
      return;
    }
    if( "VK_PRESENT_MODE_FIFO_RELAXED_KHR" == j.get< std::string >() ) {
      p = PresentModeKHR :: eFifoRelaxed ;
      return;
    }
    if( "SharedDemandRefresh" == j.get< std::string >() ) {
      p = PresentModeKHR :: eSharedDemandRefresh ;
      return;
    }
    if( "eSharedDemandRefresh" == j.get< std::string >() ) {
      p = PresentModeKHR :: eSharedDemandRefresh ;
      return;
    }
    if( "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR" == j.get< std::string >() ) {
      p = PresentModeKHR :: eSharedDemandRefresh ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PresentModeKHR" );
  }
  if( j.is_number() ) {
    p = PresentModeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PresentModeKHR" );
}
inline void from_json( const nlohmann::json &j, VkPresentModeKHR &p ) {
  PresentModeKHR temp;
  from_json( j, temp );
  p = VkPresentModeKHR ( temp );
}
#endif

#ifdef VK_KHR_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ColorSpaceKHR &p ) {
  if( ColorSpaceKHR :: eSrgbNonlinear == p ) {
    j = "SrgbNonlinear";
    return;
  }
  if( ColorSpaceKHR :: eDisplayP3NonlinearEXT == p ) {
    j = "DisplayP3NonlinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eExtendedSrgbLinearEXT == p ) {
    j = "ExtendedSrgbLinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eDisplayP3LinearEXT == p ) {
    j = "DisplayP3LinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eDciP3NonlinearEXT == p ) {
    j = "DciP3NonlinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eBt709LinearEXT == p ) {
    j = "Bt709LinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eBt709NonlinearEXT == p ) {
    j = "Bt709NonlinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eBt2020LinearEXT == p ) {
    j = "Bt2020LinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eHdr10St2084EXT == p ) {
    j = "Hdr10St2084EXT";
    return;
  }
  if( ColorSpaceKHR :: eDolbyvisionEXT == p ) {
    j = "DolbyvisionEXT";
    return;
  }
  if( ColorSpaceKHR :: eHdr10HlgEXT == p ) {
    j = "Hdr10HlgEXT";
    return;
  }
  if( ColorSpaceKHR :: eAdobergbLinearEXT == p ) {
    j = "AdobergbLinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eAdobergbNonlinearEXT == p ) {
    j = "AdobergbNonlinearEXT";
    return;
  }
  if( ColorSpaceKHR :: ePassThroughEXT == p ) {
    j = "PassThroughEXT";
    return;
  }
  if( ColorSpaceKHR :: eExtendedSrgbNonlinearEXT == p ) {
    j = "ExtendedSrgbNonlinearEXT";
    return;
  }
  if( ColorSpaceKHR :: eDisplayNativeAMD == p ) {
    j = "DisplayNativeAMD";
    return;
  }
  if( ColorSpaceKHR :: eVkColorspaceSrgbNonlinear == p ) {
    j = "VkColorspaceSrgbNonlinear";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkColorSpaceKHR &p ) {
  to_json( j, ColorSpaceKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ColorSpaceKHR &p ) {
  if( j.is_string() ) {
    if( "SrgbNonlinear" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eSrgbNonlinear ;
      return;
    }
    if( "eSrgbNonlinear" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eSrgbNonlinear ;
      return;
    }
    if( "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eSrgbNonlinear ;
      return;
    }
    if( "DisplayP3NonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayP3NonlinearEXT ;
      return;
    }
    if( "eDisplayP3NonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayP3NonlinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayP3NonlinearEXT ;
      return;
    }
    if( "ExtendedSrgbLinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eExtendedSrgbLinearEXT ;
      return;
    }
    if( "eExtendedSrgbLinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eExtendedSrgbLinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eExtendedSrgbLinearEXT ;
      return;
    }
    if( "DisplayP3LinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayP3LinearEXT ;
      return;
    }
    if( "eDisplayP3LinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayP3LinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayP3LinearEXT ;
      return;
    }
    if( "DciP3NonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDciP3NonlinearEXT ;
      return;
    }
    if( "eDciP3NonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDciP3NonlinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDciP3NonlinearEXT ;
      return;
    }
    if( "Bt709LinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt709LinearEXT ;
      return;
    }
    if( "eBt709LinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt709LinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_BT709_LINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt709LinearEXT ;
      return;
    }
    if( "Bt709NonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt709NonlinearEXT ;
      return;
    }
    if( "eBt709NonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt709NonlinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_BT709_NONLINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt709NonlinearEXT ;
      return;
    }
    if( "Bt2020LinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt2020LinearEXT ;
      return;
    }
    if( "eBt2020LinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt2020LinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_BT2020_LINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eBt2020LinearEXT ;
      return;
    }
    if( "Hdr10St2084EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eHdr10St2084EXT ;
      return;
    }
    if( "eHdr10St2084EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eHdr10St2084EXT ;
      return;
    }
    if( "VK_COLOR_SPACE_HDR10_ST2084_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eHdr10St2084EXT ;
      return;
    }
    if( "DolbyvisionEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDolbyvisionEXT ;
      return;
    }
    if( "eDolbyvisionEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDolbyvisionEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_DOLBYVISION_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDolbyvisionEXT ;
      return;
    }
    if( "Hdr10HlgEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eHdr10HlgEXT ;
      return;
    }
    if( "eHdr10HlgEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eHdr10HlgEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_HDR10_HLG_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eHdr10HlgEXT ;
      return;
    }
    if( "AdobergbLinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eAdobergbLinearEXT ;
      return;
    }
    if( "eAdobergbLinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eAdobergbLinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eAdobergbLinearEXT ;
      return;
    }
    if( "AdobergbNonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eAdobergbNonlinearEXT ;
      return;
    }
    if( "eAdobergbNonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eAdobergbNonlinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eAdobergbNonlinearEXT ;
      return;
    }
    if( "PassThroughEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: ePassThroughEXT ;
      return;
    }
    if( "ePassThroughEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: ePassThroughEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_PASS_THROUGH_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: ePassThroughEXT ;
      return;
    }
    if( "ExtendedSrgbNonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eExtendedSrgbNonlinearEXT ;
      return;
    }
    if( "eExtendedSrgbNonlinearEXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eExtendedSrgbNonlinearEXT ;
      return;
    }
    if( "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eExtendedSrgbNonlinearEXT ;
      return;
    }
    if( "DisplayNativeAMD" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayNativeAMD ;
      return;
    }
    if( "eDisplayNativeAMD" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayNativeAMD ;
      return;
    }
    if( "VK_COLOR_SPACE_DISPLAY_NATIVE_AMD" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eDisplayNativeAMD ;
      return;
    }
    if( "VkColorspaceSrgbNonlinear" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eVkColorspaceSrgbNonlinear ;
      return;
    }
    if( "eVkColorspaceSrgbNonlinear" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eVkColorspaceSrgbNonlinear ;
      return;
    }
    if( "VK_COLORSPACE_SRGB_NONLINEAR_KHR" == j.get< std::string >() ) {
      p = ColorSpaceKHR :: eVkColorspaceSrgbNonlinear ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ColorSpaceKHR" );
  }
  if( j.is_number() ) {
    p = ColorSpaceKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ColorSpaceKHR" );
}
inline void from_json( const nlohmann::json &j, VkColorSpaceKHR &p ) {
  ColorSpaceKHR temp;
  from_json( j, temp );
  p = VkColorSpaceKHR ( temp );
}
#endif

#ifdef VK_EXT_DEBUG_REPORT_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DebugReportObjectTypeEXT &p ) {
  if( DebugReportObjectTypeEXT :: eUnknown == p ) {
    j = "Unknown";
    return;
  }
  if( DebugReportObjectTypeEXT :: eInstance == p ) {
    j = "Instance";
    return;
  }
  if( DebugReportObjectTypeEXT :: ePhysicalDevice == p ) {
    j = "PhysicalDevice";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDevice == p ) {
    j = "Device";
    return;
  }
  if( DebugReportObjectTypeEXT :: eQueue == p ) {
    j = "Queue";
    return;
  }
  if( DebugReportObjectTypeEXT :: eSemaphore == p ) {
    j = "Semaphore";
    return;
  }
  if( DebugReportObjectTypeEXT :: eCommandBuffer == p ) {
    j = "CommandBuffer";
    return;
  }
  if( DebugReportObjectTypeEXT :: eFence == p ) {
    j = "Fence";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDeviceMemory == p ) {
    j = "DeviceMemory";
    return;
  }
  if( DebugReportObjectTypeEXT :: eBuffer == p ) {
    j = "Buffer";
    return;
  }
  if( DebugReportObjectTypeEXT :: eImage == p ) {
    j = "Image";
    return;
  }
  if( DebugReportObjectTypeEXT :: eEvent == p ) {
    j = "Event";
    return;
  }
  if( DebugReportObjectTypeEXT :: eQueryPool == p ) {
    j = "QueryPool";
    return;
  }
  if( DebugReportObjectTypeEXT :: eBufferView == p ) {
    j = "BufferView";
    return;
  }
  if( DebugReportObjectTypeEXT :: eImageView == p ) {
    j = "ImageView";
    return;
  }
  if( DebugReportObjectTypeEXT :: eShaderModule == p ) {
    j = "ShaderModule";
    return;
  }
  if( DebugReportObjectTypeEXT :: ePipelineCache == p ) {
    j = "PipelineCache";
    return;
  }
  if( DebugReportObjectTypeEXT :: ePipelineLayout == p ) {
    j = "PipelineLayout";
    return;
  }
  if( DebugReportObjectTypeEXT :: eRenderPass == p ) {
    j = "RenderPass";
    return;
  }
  if( DebugReportObjectTypeEXT :: ePipeline == p ) {
    j = "Pipeline";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDescriptorSetLayout == p ) {
    j = "DescriptorSetLayout";
    return;
  }
  if( DebugReportObjectTypeEXT :: eSampler == p ) {
    j = "Sampler";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDescriptorPool == p ) {
    j = "DescriptorPool";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDescriptorSet == p ) {
    j = "DescriptorSet";
    return;
  }
  if( DebugReportObjectTypeEXT :: eFramebuffer == p ) {
    j = "Framebuffer";
    return;
  }
  if( DebugReportObjectTypeEXT :: eCommandPool == p ) {
    j = "CommandPool";
    return;
  }
  if( DebugReportObjectTypeEXT :: eSurfaceKHR == p ) {
    j = "SurfaceKHR";
    return;
  }
  if( DebugReportObjectTypeEXT :: eSwapchainKHR == p ) {
    j = "SwapchainKHR";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDebugReportCallbackEXT == p ) {
    j = "DebugReportCallbackEXT";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDisplayKHR == p ) {
    j = "DisplayKHR";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDisplayModeKHR == p ) {
    j = "DisplayModeKHR";
    return;
  }
  if( DebugReportObjectTypeEXT :: eValidationCacheEXT == p ) {
    j = "ValidationCacheEXT";
    return;
  }
  if( DebugReportObjectTypeEXT :: eSamplerYcbcrConversion == p ) {
    j = "SamplerYcbcrConversion";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDescriptorUpdateTemplate == p ) {
    j = "DescriptorUpdateTemplate";
    return;
  }
  if( DebugReportObjectTypeEXT :: eCuModuleNVX == p ) {
    j = "CuModuleNVX";
    return;
  }
  if( DebugReportObjectTypeEXT :: eCuFunctionNVX == p ) {
    j = "CuFunctionNVX";
    return;
  }
  if( DebugReportObjectTypeEXT :: eAccelerationStructureKHR == p ) {
    j = "AccelerationStructureKHR";
    return;
  }
  if( DebugReportObjectTypeEXT :: eAccelerationStructureNV == p ) {
    j = "AccelerationStructureNV";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDebugReport == p ) {
    j = "DebugReport";
    return;
  }
  if( DebugReportObjectTypeEXT :: eDescriptorUpdateTemplateKHR == p ) {
    j = "DescriptorUpdateTemplateKHR";
    return;
  }
  if( DebugReportObjectTypeEXT :: eSamplerYcbcrConversionKHR == p ) {
    j = "SamplerYcbcrConversionKHR";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkDebugReportObjectTypeEXT &p ) {
  to_json( j, DebugReportObjectTypeEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DebugReportObjectTypeEXT &p ) {
  if( j.is_string() ) {
    if( "Unknown" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eUnknown ;
      return;
    }
    if( "eUnknown" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eUnknown ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eUnknown ;
      return;
    }
    if( "Instance" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eInstance ;
      return;
    }
    if( "eInstance" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eInstance ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eInstance ;
      return;
    }
    if( "PhysicalDevice" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePhysicalDevice ;
      return;
    }
    if( "ePhysicalDevice" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePhysicalDevice ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePhysicalDevice ;
      return;
    }
    if( "Device" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDevice ;
      return;
    }
    if( "eDevice" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDevice ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDevice ;
      return;
    }
    if( "Queue" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eQueue ;
      return;
    }
    if( "eQueue" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eQueue ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eQueue ;
      return;
    }
    if( "Semaphore" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSemaphore ;
      return;
    }
    if( "eSemaphore" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSemaphore ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSemaphore ;
      return;
    }
    if( "CommandBuffer" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCommandBuffer ;
      return;
    }
    if( "eCommandBuffer" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCommandBuffer ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCommandBuffer ;
      return;
    }
    if( "Fence" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eFence ;
      return;
    }
    if( "eFence" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eFence ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eFence ;
      return;
    }
    if( "DeviceMemory" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDeviceMemory ;
      return;
    }
    if( "eDeviceMemory" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDeviceMemory ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDeviceMemory ;
      return;
    }
    if( "Buffer" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eBuffer ;
      return;
    }
    if( "eBuffer" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eBuffer ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eBuffer ;
      return;
    }
    if( "Image" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eImage ;
      return;
    }
    if( "eImage" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eImage ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eImage ;
      return;
    }
    if( "Event" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eEvent ;
      return;
    }
    if( "eEvent" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eEvent ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eEvent ;
      return;
    }
    if( "QueryPool" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eQueryPool ;
      return;
    }
    if( "eQueryPool" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eQueryPool ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eQueryPool ;
      return;
    }
    if( "BufferView" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eBufferView ;
      return;
    }
    if( "eBufferView" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eBufferView ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eBufferView ;
      return;
    }
    if( "ImageView" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eImageView ;
      return;
    }
    if( "eImageView" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eImageView ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eImageView ;
      return;
    }
    if( "ShaderModule" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eShaderModule ;
      return;
    }
    if( "eShaderModule" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eShaderModule ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eShaderModule ;
      return;
    }
    if( "PipelineCache" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipelineCache ;
      return;
    }
    if( "ePipelineCache" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipelineCache ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipelineCache ;
      return;
    }
    if( "PipelineLayout" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipelineLayout ;
      return;
    }
    if( "ePipelineLayout" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipelineLayout ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipelineLayout ;
      return;
    }
    if( "RenderPass" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eRenderPass ;
      return;
    }
    if( "eRenderPass" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eRenderPass ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eRenderPass ;
      return;
    }
    if( "Pipeline" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipeline ;
      return;
    }
    if( "ePipeline" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipeline ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: ePipeline ;
      return;
    }
    if( "DescriptorSetLayout" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorSetLayout ;
      return;
    }
    if( "eDescriptorSetLayout" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorSetLayout ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorSetLayout ;
      return;
    }
    if( "Sampler" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSampler ;
      return;
    }
    if( "eSampler" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSampler ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSampler ;
      return;
    }
    if( "DescriptorPool" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorPool ;
      return;
    }
    if( "eDescriptorPool" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorPool ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorPool ;
      return;
    }
    if( "DescriptorSet" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorSet ;
      return;
    }
    if( "eDescriptorSet" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorSet ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorSet ;
      return;
    }
    if( "Framebuffer" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eFramebuffer ;
      return;
    }
    if( "eFramebuffer" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eFramebuffer ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eFramebuffer ;
      return;
    }
    if( "CommandPool" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCommandPool ;
      return;
    }
    if( "eCommandPool" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCommandPool ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCommandPool ;
      return;
    }
    if( "SurfaceKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSurfaceKHR ;
      return;
    }
    if( "eSurfaceKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSurfaceKHR ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSurfaceKHR ;
      return;
    }
    if( "SwapchainKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSwapchainKHR ;
      return;
    }
    if( "eSwapchainKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSwapchainKHR ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSwapchainKHR ;
      return;
    }
    if( "DebugReportCallbackEXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDebugReportCallbackEXT ;
      return;
    }
    if( "eDebugReportCallbackEXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDebugReportCallbackEXT ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDebugReportCallbackEXT ;
      return;
    }
    if( "DisplayKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDisplayKHR ;
      return;
    }
    if( "eDisplayKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDisplayKHR ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDisplayKHR ;
      return;
    }
    if( "DisplayModeKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDisplayModeKHR ;
      return;
    }
    if( "eDisplayModeKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDisplayModeKHR ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDisplayModeKHR ;
      return;
    }
    if( "ValidationCacheEXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eValidationCacheEXT ;
      return;
    }
    if( "eValidationCacheEXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eValidationCacheEXT ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eValidationCacheEXT ;
      return;
    }
    if( "SamplerYcbcrConversion" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSamplerYcbcrConversion ;
      return;
    }
    if( "eSamplerYcbcrConversion" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSamplerYcbcrConversion ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSamplerYcbcrConversion ;
      return;
    }
    if( "DescriptorUpdateTemplate" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorUpdateTemplate ;
      return;
    }
    if( "eDescriptorUpdateTemplate" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorUpdateTemplate ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorUpdateTemplate ;
      return;
    }
    if( "CuModuleNVX" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCuModuleNVX ;
      return;
    }
    if( "eCuModuleNVX" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCuModuleNVX ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCuModuleNVX ;
      return;
    }
    if( "CuFunctionNVX" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCuFunctionNVX ;
      return;
    }
    if( "eCuFunctionNVX" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCuFunctionNVX ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eCuFunctionNVX ;
      return;
    }
    if( "AccelerationStructureKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eAccelerationStructureKHR ;
      return;
    }
    if( "eAccelerationStructureKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eAccelerationStructureKHR ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eAccelerationStructureKHR ;
      return;
    }
    if( "AccelerationStructureNV" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eAccelerationStructureNV ;
      return;
    }
    if( "eAccelerationStructureNV" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eAccelerationStructureNV ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eAccelerationStructureNV ;
      return;
    }
    if( "DebugReport" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDebugReport ;
      return;
    }
    if( "eDebugReport" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDebugReport ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDebugReport ;
      return;
    }
    if( "DescriptorUpdateTemplateKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorUpdateTemplateKHR ;
      return;
    }
    if( "eDescriptorUpdateTemplateKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorUpdateTemplateKHR ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eDescriptorUpdateTemplateKHR ;
      return;
    }
    if( "SamplerYcbcrConversionKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSamplerYcbcrConversionKHR ;
      return;
    }
    if( "eSamplerYcbcrConversionKHR" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSamplerYcbcrConversionKHR ;
      return;
    }
    if( "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT" == j.get< std::string >() ) {
      p = DebugReportObjectTypeEXT :: eSamplerYcbcrConversionKHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DebugReportObjectTypeEXT" );
  }
  if( j.is_number() ) {
    p = DebugReportObjectTypeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DebugReportObjectTypeEXT" );
}
inline void from_json( const nlohmann::json &j, VkDebugReportObjectTypeEXT &p ) {
  DebugReportObjectTypeEXT temp;
  from_json( j, temp );
  p = VkDebugReportObjectTypeEXT ( temp );
}
#endif

#ifdef VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const RasterizationOrderAMD &p ) {
  if( RasterizationOrderAMD :: eStrict == p ) {
    j = "Strict";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkRasterizationOrderAMD &p ) {
  to_json( j, RasterizationOrderAMD ( p ) );
}
inline void from_json( const nlohmann::json &j, RasterizationOrderAMD &p ) {
  if( j.is_string() ) {
    if( "Strict" == j.get< std::string >() ) {
      p = RasterizationOrderAMD :: eStrict ;
      return;
    }
    if( "eStrict" == j.get< std::string >() ) {
      p = RasterizationOrderAMD :: eStrict ;
      return;
    }
    if( "VK_RASTERIZATION_ORDER_STRICT_AMD" == j.get< std::string >() ) {
      p = RasterizationOrderAMD :: eStrict ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for RasterizationOrderAMD" );
  }
  if( j.is_number() ) {
    p = RasterizationOrderAMD ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for RasterizationOrderAMD" );
}
inline void from_json( const nlohmann::json &j, VkRasterizationOrderAMD &p ) {
  RasterizationOrderAMD temp;
  from_json( j, temp );
  p = VkRasterizationOrderAMD ( temp );
}
#endif

#ifdef VK_KHR_VIDEO_QUEUE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const QueryResultStatusKHR &p ) {
  if( QueryResultStatusKHR :: eError == p ) {
    j = "Error";
    return;
  }
  if( QueryResultStatusKHR :: eNotReady == p ) {
    j = "NotReady";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkQueryResultStatusKHR &p ) {
  to_json( j, QueryResultStatusKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, QueryResultStatusKHR &p ) {
  if( j.is_string() ) {
    if( "Error" == j.get< std::string >() ) {
      p = QueryResultStatusKHR :: eError ;
      return;
    }
    if( "eError" == j.get< std::string >() ) {
      p = QueryResultStatusKHR :: eError ;
      return;
    }
    if( "VK_QUERY_RESULT_STATUS_ERROR_KHR" == j.get< std::string >() ) {
      p = QueryResultStatusKHR :: eError ;
      return;
    }
    if( "NotReady" == j.get< std::string >() ) {
      p = QueryResultStatusKHR :: eNotReady ;
      return;
    }
    if( "eNotReady" == j.get< std::string >() ) {
      p = QueryResultStatusKHR :: eNotReady ;
      return;
    }
    if( "VK_QUERY_RESULT_STATUS_NOT_READY_KHR" == j.get< std::string >() ) {
      p = QueryResultStatusKHR :: eNotReady ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueryResultStatusKHR" );
  }
  if( j.is_number() ) {
    p = QueryResultStatusKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueryResultStatusKHR" );
}
inline void from_json( const nlohmann::json &j, VkQueryResultStatusKHR &p ) {
  QueryResultStatusKHR temp;
  from_json( j, temp );
  p = VkQueryResultStatusKHR ( temp );
}
#endif

#ifdef VK_AMD_SHADER_INFO_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ShaderInfoTypeAMD &p ) {
  if( ShaderInfoTypeAMD :: eStatistics == p ) {
    j = "Statistics";
    return;
  }
  if( ShaderInfoTypeAMD :: eBinary == p ) {
    j = "Binary";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkShaderInfoTypeAMD &p ) {
  to_json( j, ShaderInfoTypeAMD ( p ) );
}
inline void from_json( const nlohmann::json &j, ShaderInfoTypeAMD &p ) {
  if( j.is_string() ) {
    if( "Statistics" == j.get< std::string >() ) {
      p = ShaderInfoTypeAMD :: eStatistics ;
      return;
    }
    if( "eStatistics" == j.get< std::string >() ) {
      p = ShaderInfoTypeAMD :: eStatistics ;
      return;
    }
    if( "VK_SHADER_INFO_TYPE_STATISTICS_AMD" == j.get< std::string >() ) {
      p = ShaderInfoTypeAMD :: eStatistics ;
      return;
    }
    if( "Binary" == j.get< std::string >() ) {
      p = ShaderInfoTypeAMD :: eBinary ;
      return;
    }
    if( "eBinary" == j.get< std::string >() ) {
      p = ShaderInfoTypeAMD :: eBinary ;
      return;
    }
    if( "VK_SHADER_INFO_TYPE_BINARY_AMD" == j.get< std::string >() ) {
      p = ShaderInfoTypeAMD :: eBinary ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ShaderInfoTypeAMD" );
  }
  if( j.is_number() ) {
    p = ShaderInfoTypeAMD ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ShaderInfoTypeAMD" );
}
inline void from_json( const nlohmann::json &j, VkShaderInfoTypeAMD &p ) {
  ShaderInfoTypeAMD temp;
  from_json( j, temp );
  p = VkShaderInfoTypeAMD ( temp );
}
#endif

#ifdef VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ValidationCheckEXT &p ) {
  if( ValidationCheckEXT :: eAll == p ) {
    j = "All";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkValidationCheckEXT &p ) {
  to_json( j, ValidationCheckEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ValidationCheckEXT &p ) {
  if( j.is_string() ) {
    if( "All" == j.get< std::string >() ) {
      p = ValidationCheckEXT :: eAll ;
      return;
    }
    if( "eAll" == j.get< std::string >() ) {
      p = ValidationCheckEXT :: eAll ;
      return;
    }
    if( "VK_VALIDATION_CHECK_ALL_EXT" == j.get< std::string >() ) {
      p = ValidationCheckEXT :: eAll ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ValidationCheckEXT" );
  }
  if( j.is_number() ) {
    p = ValidationCheckEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ValidationCheckEXT" );
}
inline void from_json( const nlohmann::json &j, VkValidationCheckEXT &p ) {
  ValidationCheckEXT temp;
  from_json( j, temp );
  p = VkValidationCheckEXT ( temp );
}
#endif

#ifdef VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DisplayPowerStateEXT &p ) {
  if( DisplayPowerStateEXT :: eOff == p ) {
    j = "Off";
    return;
  }
  if( DisplayPowerStateEXT :: eSuspend == p ) {
    j = "Suspend";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkDisplayPowerStateEXT &p ) {
  to_json( j, DisplayPowerStateEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayPowerStateEXT &p ) {
  if( j.is_string() ) {
    if( "Off" == j.get< std::string >() ) {
      p = DisplayPowerStateEXT :: eOff ;
      return;
    }
    if( "eOff" == j.get< std::string >() ) {
      p = DisplayPowerStateEXT :: eOff ;
      return;
    }
    if( "VK_DISPLAY_POWER_STATE_OFF_EXT" == j.get< std::string >() ) {
      p = DisplayPowerStateEXT :: eOff ;
      return;
    }
    if( "Suspend" == j.get< std::string >() ) {
      p = DisplayPowerStateEXT :: eSuspend ;
      return;
    }
    if( "eSuspend" == j.get< std::string >() ) {
      p = DisplayPowerStateEXT :: eSuspend ;
      return;
    }
    if( "VK_DISPLAY_POWER_STATE_SUSPEND_EXT" == j.get< std::string >() ) {
      p = DisplayPowerStateEXT :: eSuspend ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DisplayPowerStateEXT" );
  }
  if( j.is_number() ) {
    p = DisplayPowerStateEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DisplayPowerStateEXT" );
}
inline void from_json( const nlohmann::json &j, VkDisplayPowerStateEXT &p ) {
  DisplayPowerStateEXT temp;
  from_json( j, temp );
  p = VkDisplayPowerStateEXT ( temp );
}
#endif

#ifdef VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DeviceEventTypeEXT &p ) {
}
inline void to_json( nlohmann::json &j, const VkDeviceEventTypeEXT &p ) {
  to_json( j, DeviceEventTypeEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceEventTypeEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DeviceEventTypeEXT" );
  }
  if( j.is_number() ) {
    p = DeviceEventTypeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DeviceEventTypeEXT" );
}
inline void from_json( const nlohmann::json &j, VkDeviceEventTypeEXT &p ) {
  DeviceEventTypeEXT temp;
  from_json( j, temp );
  p = VkDeviceEventTypeEXT ( temp );
}
#endif

#ifdef VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DisplayEventTypeEXT &p ) {
}
inline void to_json( nlohmann::json &j, const VkDisplayEventTypeEXT &p ) {
  to_json( j, DisplayEventTypeEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayEventTypeEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DisplayEventTypeEXT" );
  }
  if( j.is_number() ) {
    p = DisplayEventTypeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DisplayEventTypeEXT" );
}
inline void from_json( const nlohmann::json &j, VkDisplayEventTypeEXT &p ) {
  DisplayEventTypeEXT temp;
  from_json( j, temp );
  p = VkDisplayEventTypeEXT ( temp );
}
#endif

#ifdef VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ViewportCoordinateSwizzleNV &p ) {
  if( ViewportCoordinateSwizzleNV :: ePositiveX == p ) {
    j = "PositiveX";
    return;
  }
  if( ViewportCoordinateSwizzleNV :: eNegativeX == p ) {
    j = "NegativeX";
    return;
  }
  if( ViewportCoordinateSwizzleNV :: ePositiveY == p ) {
    j = "PositiveY";
    return;
  }
  if( ViewportCoordinateSwizzleNV :: eNegativeY == p ) {
    j = "NegativeY";
    return;
  }
  if( ViewportCoordinateSwizzleNV :: ePositiveZ == p ) {
    j = "PositiveZ";
    return;
  }
  if( ViewportCoordinateSwizzleNV :: eNegativeZ == p ) {
    j = "NegativeZ";
    return;
  }
  if( ViewportCoordinateSwizzleNV :: ePositiveW == p ) {
    j = "PositiveW";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkViewportCoordinateSwizzleNV &p ) {
  to_json( j, ViewportCoordinateSwizzleNV ( p ) );
}
inline void from_json( const nlohmann::json &j, ViewportCoordinateSwizzleNV &p ) {
  if( j.is_string() ) {
    if( "PositiveX" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveX ;
      return;
    }
    if( "ePositiveX" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveX ;
      return;
    }
    if( "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveX ;
      return;
    }
    if( "NegativeX" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeX ;
      return;
    }
    if( "eNegativeX" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeX ;
      return;
    }
    if( "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeX ;
      return;
    }
    if( "PositiveY" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveY ;
      return;
    }
    if( "ePositiveY" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveY ;
      return;
    }
    if( "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveY ;
      return;
    }
    if( "NegativeY" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeY ;
      return;
    }
    if( "eNegativeY" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeY ;
      return;
    }
    if( "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeY ;
      return;
    }
    if( "PositiveZ" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveZ ;
      return;
    }
    if( "ePositiveZ" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveZ ;
      return;
    }
    if( "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveZ ;
      return;
    }
    if( "NegativeZ" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeZ ;
      return;
    }
    if( "eNegativeZ" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeZ ;
      return;
    }
    if( "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: eNegativeZ ;
      return;
    }
    if( "PositiveW" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveW ;
      return;
    }
    if( "ePositiveW" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveW ;
      return;
    }
    if( "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV" == j.get< std::string >() ) {
      p = ViewportCoordinateSwizzleNV :: ePositiveW ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ViewportCoordinateSwizzleNV" );
  }
  if( j.is_number() ) {
    p = ViewportCoordinateSwizzleNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ViewportCoordinateSwizzleNV" );
}
inline void from_json( const nlohmann::json &j, VkViewportCoordinateSwizzleNV &p ) {
  ViewportCoordinateSwizzleNV temp;
  from_json( j, temp );
  p = VkViewportCoordinateSwizzleNV ( temp );
}
#endif

#ifdef VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DiscardRectangleModeEXT &p ) {
  if( DiscardRectangleModeEXT :: eInclusive == p ) {
    j = "Inclusive";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkDiscardRectangleModeEXT &p ) {
  to_json( j, DiscardRectangleModeEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DiscardRectangleModeEXT &p ) {
  if( j.is_string() ) {
    if( "Inclusive" == j.get< std::string >() ) {
      p = DiscardRectangleModeEXT :: eInclusive ;
      return;
    }
    if( "eInclusive" == j.get< std::string >() ) {
      p = DiscardRectangleModeEXT :: eInclusive ;
      return;
    }
    if( "VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT" == j.get< std::string >() ) {
      p = DiscardRectangleModeEXT :: eInclusive ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DiscardRectangleModeEXT" );
  }
  if( j.is_number() ) {
    p = DiscardRectangleModeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DiscardRectangleModeEXT" );
}
inline void from_json( const nlohmann::json &j, VkDiscardRectangleModeEXT &p ) {
  DiscardRectangleModeEXT temp;
  from_json( j, temp );
  p = VkDiscardRectangleModeEXT ( temp );
}
#endif

#ifdef VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ConservativeRasterizationModeEXT &p ) {
  if( ConservativeRasterizationModeEXT :: eDisabled == p ) {
    j = "Disabled";
    return;
  }
  if( ConservativeRasterizationModeEXT :: eOverestimate == p ) {
    j = "Overestimate";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkConservativeRasterizationModeEXT &p ) {
  to_json( j, ConservativeRasterizationModeEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ConservativeRasterizationModeEXT &p ) {
  if( j.is_string() ) {
    if( "Disabled" == j.get< std::string >() ) {
      p = ConservativeRasterizationModeEXT :: eDisabled ;
      return;
    }
    if( "eDisabled" == j.get< std::string >() ) {
      p = ConservativeRasterizationModeEXT :: eDisabled ;
      return;
    }
    if( "VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT" == j.get< std::string >() ) {
      p = ConservativeRasterizationModeEXT :: eDisabled ;
      return;
    }
    if( "Overestimate" == j.get< std::string >() ) {
      p = ConservativeRasterizationModeEXT :: eOverestimate ;
      return;
    }
    if( "eOverestimate" == j.get< std::string >() ) {
      p = ConservativeRasterizationModeEXT :: eOverestimate ;
      return;
    }
    if( "VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT" == j.get< std::string >() ) {
      p = ConservativeRasterizationModeEXT :: eOverestimate ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ConservativeRasterizationModeEXT" );
  }
  if( j.is_number() ) {
    p = ConservativeRasterizationModeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ConservativeRasterizationModeEXT" );
}
inline void from_json( const nlohmann::json &j, VkConservativeRasterizationModeEXT &p ) {
  ConservativeRasterizationModeEXT temp;
  from_json( j, temp );
  p = VkConservativeRasterizationModeEXT ( temp );
}
#endif

#ifdef VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PerformanceCounterScopeKHR &p ) {
  if( PerformanceCounterScopeKHR :: eCommandBuffer == p ) {
    j = "CommandBuffer";
    return;
  }
  if( PerformanceCounterScopeKHR :: eRenderPass == p ) {
    j = "RenderPass";
    return;
  }
  if( PerformanceCounterScopeKHR :: eCommand == p ) {
    j = "Command";
    return;
  }
  if( PerformanceCounterScopeKHR :: eVkQueryScopeCommandBuffer == p ) {
    j = "VkQueryScopeCommandBuffer";
    return;
  }
  if( PerformanceCounterScopeKHR :: eVkQueryScopeCommand == p ) {
    j = "VkQueryScopeCommand";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkPerformanceCounterScopeKHR &p ) {
  to_json( j, PerformanceCounterScopeKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceCounterScopeKHR &p ) {
  if( j.is_string() ) {
    if( "CommandBuffer" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eCommandBuffer ;
      return;
    }
    if( "eCommandBuffer" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eCommandBuffer ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eCommandBuffer ;
      return;
    }
    if( "RenderPass" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eRenderPass ;
      return;
    }
    if( "eRenderPass" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eRenderPass ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eRenderPass ;
      return;
    }
    if( "Command" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eCommand ;
      return;
    }
    if( "eCommand" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eCommand ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eCommand ;
      return;
    }
    if( "VkQueryScopeCommandBuffer" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eVkQueryScopeCommandBuffer ;
      return;
    }
    if( "eVkQueryScopeCommandBuffer" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eVkQueryScopeCommandBuffer ;
      return;
    }
    if( "VK_QUERY_SCOPE_COMMAND_BUFFER_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eVkQueryScopeCommandBuffer ;
      return;
    }
    if( "VkQueryScopeCommand" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eVkQueryScopeCommand ;
      return;
    }
    if( "eVkQueryScopeCommand" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eVkQueryScopeCommand ;
      return;
    }
    if( "VK_QUERY_SCOPE_COMMAND_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterScopeKHR :: eVkQueryScopeCommand ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceCounterScopeKHR" );
  }
  if( j.is_number() ) {
    p = PerformanceCounterScopeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceCounterScopeKHR" );
}
inline void from_json( const nlohmann::json &j, VkPerformanceCounterScopeKHR &p ) {
  PerformanceCounterScopeKHR temp;
  from_json( j, temp );
  p = VkPerformanceCounterScopeKHR ( temp );
}
#endif

#ifdef VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PerformanceCounterStorageKHR &p ) {
  if( PerformanceCounterStorageKHR :: eInt32 == p ) {
    j = "Int32";
    return;
  }
  if( PerformanceCounterStorageKHR :: eInt64 == p ) {
    j = "Int64";
    return;
  }
  if( PerformanceCounterStorageKHR :: eUint32 == p ) {
    j = "Uint32";
    return;
  }
  if( PerformanceCounterStorageKHR :: eUint64 == p ) {
    j = "Uint64";
    return;
  }
  if( PerformanceCounterStorageKHR :: eFloat32 == p ) {
    j = "Float32";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkPerformanceCounterStorageKHR &p ) {
  to_json( j, PerformanceCounterStorageKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceCounterStorageKHR &p ) {
  if( j.is_string() ) {
    if( "Int32" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eInt32 ;
      return;
    }
    if( "eInt32" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eInt32 ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eInt32 ;
      return;
    }
    if( "Int64" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eInt64 ;
      return;
    }
    if( "eInt64" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eInt64 ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eInt64 ;
      return;
    }
    if( "Uint32" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eUint32 ;
      return;
    }
    if( "eUint32" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eUint32 ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eUint32 ;
      return;
    }
    if( "Uint64" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eUint64 ;
      return;
    }
    if( "eUint64" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eUint64 ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eUint64 ;
      return;
    }
    if( "Float32" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eFloat32 ;
      return;
    }
    if( "eFloat32" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eFloat32 ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterStorageKHR :: eFloat32 ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceCounterStorageKHR" );
  }
  if( j.is_number() ) {
    p = PerformanceCounterStorageKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceCounterStorageKHR" );
}
inline void from_json( const nlohmann::json &j, VkPerformanceCounterStorageKHR &p ) {
  PerformanceCounterStorageKHR temp;
  from_json( j, temp );
  p = VkPerformanceCounterStorageKHR ( temp );
}
#endif

#ifdef VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PerformanceCounterUnitKHR &p ) {
  if( PerformanceCounterUnitKHR :: eGeneric == p ) {
    j = "Generic";
    return;
  }
  if( PerformanceCounterUnitKHR :: ePercentage == p ) {
    j = "Percentage";
    return;
  }
  if( PerformanceCounterUnitKHR :: eNanoseconds == p ) {
    j = "Nanoseconds";
    return;
  }
  if( PerformanceCounterUnitKHR :: eBytes == p ) {
    j = "Bytes";
    return;
  }
  if( PerformanceCounterUnitKHR :: eBytesPerSecond == p ) {
    j = "BytesPerSecond";
    return;
  }
  if( PerformanceCounterUnitKHR :: eKelvin == p ) {
    j = "Kelvin";
    return;
  }
  if( PerformanceCounterUnitKHR :: eWatts == p ) {
    j = "Watts";
    return;
  }
  if( PerformanceCounterUnitKHR :: eVolts == p ) {
    j = "Volts";
    return;
  }
  if( PerformanceCounterUnitKHR :: eAmps == p ) {
    j = "Amps";
    return;
  }
  if( PerformanceCounterUnitKHR :: eHertz == p ) {
    j = "Hertz";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkPerformanceCounterUnitKHR &p ) {
  to_json( j, PerformanceCounterUnitKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceCounterUnitKHR &p ) {
  if( j.is_string() ) {
    if( "Generic" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eGeneric ;
      return;
    }
    if( "eGeneric" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eGeneric ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eGeneric ;
      return;
    }
    if( "Percentage" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: ePercentage ;
      return;
    }
    if( "ePercentage" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: ePercentage ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: ePercentage ;
      return;
    }
    if( "Nanoseconds" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eNanoseconds ;
      return;
    }
    if( "eNanoseconds" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eNanoseconds ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eNanoseconds ;
      return;
    }
    if( "Bytes" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eBytes ;
      return;
    }
    if( "eBytes" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eBytes ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eBytes ;
      return;
    }
    if( "BytesPerSecond" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eBytesPerSecond ;
      return;
    }
    if( "eBytesPerSecond" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eBytesPerSecond ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eBytesPerSecond ;
      return;
    }
    if( "Kelvin" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eKelvin ;
      return;
    }
    if( "eKelvin" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eKelvin ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eKelvin ;
      return;
    }
    if( "Watts" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eWatts ;
      return;
    }
    if( "eWatts" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eWatts ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eWatts ;
      return;
    }
    if( "Volts" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eVolts ;
      return;
    }
    if( "eVolts" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eVolts ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eVolts ;
      return;
    }
    if( "Amps" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eAmps ;
      return;
    }
    if( "eAmps" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eAmps ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eAmps ;
      return;
    }
    if( "Hertz" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eHertz ;
      return;
    }
    if( "eHertz" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eHertz ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterUnitKHR :: eHertz ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceCounterUnitKHR" );
  }
  if( j.is_number() ) {
    p = PerformanceCounterUnitKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceCounterUnitKHR" );
}
inline void from_json( const nlohmann::json &j, VkPerformanceCounterUnitKHR &p ) {
  PerformanceCounterUnitKHR temp;
  from_json( j, temp );
  p = VkPerformanceCounterUnitKHR ( temp );
}
#endif

#ifdef VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const BlendOverlapEXT &p ) {
  if( BlendOverlapEXT :: eUncorrelated == p ) {
    j = "Uncorrelated";
    return;
  }
  if( BlendOverlapEXT :: eDisjoint == p ) {
    j = "Disjoint";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkBlendOverlapEXT &p ) {
  to_json( j, BlendOverlapEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, BlendOverlapEXT &p ) {
  if( j.is_string() ) {
    if( "Uncorrelated" == j.get< std::string >() ) {
      p = BlendOverlapEXT :: eUncorrelated ;
      return;
    }
    if( "eUncorrelated" == j.get< std::string >() ) {
      p = BlendOverlapEXT :: eUncorrelated ;
      return;
    }
    if( "VK_BLEND_OVERLAP_UNCORRELATED_EXT" == j.get< std::string >() ) {
      p = BlendOverlapEXT :: eUncorrelated ;
      return;
    }
    if( "Disjoint" == j.get< std::string >() ) {
      p = BlendOverlapEXT :: eDisjoint ;
      return;
    }
    if( "eDisjoint" == j.get< std::string >() ) {
      p = BlendOverlapEXT :: eDisjoint ;
      return;
    }
    if( "VK_BLEND_OVERLAP_DISJOINT_EXT" == j.get< std::string >() ) {
      p = BlendOverlapEXT :: eDisjoint ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BlendOverlapEXT" );
  }
  if( j.is_number() ) {
    p = BlendOverlapEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BlendOverlapEXT" );
}
inline void from_json( const nlohmann::json &j, VkBlendOverlapEXT &p ) {
  BlendOverlapEXT temp;
  from_json( j, temp );
  p = VkBlendOverlapEXT ( temp );
}
#endif

#ifdef VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const AccelerationStructureTypeKHR &p ) {
  if( AccelerationStructureTypeKHR :: eTopLevel == p ) {
    j = "TopLevel";
    return;
  }
  if( AccelerationStructureTypeKHR :: eBottomLevel == p ) {
    j = "BottomLevel";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureTypeKHR &p ) {
  to_json( j, AccelerationStructureTypeKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureTypeKHR &p ) {
  if( j.is_string() ) {
    if( "TopLevel" == j.get< std::string >() ) {
      p = AccelerationStructureTypeKHR :: eTopLevel ;
      return;
    }
    if( "eTopLevel" == j.get< std::string >() ) {
      p = AccelerationStructureTypeKHR :: eTopLevel ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR" == j.get< std::string >() ) {
      p = AccelerationStructureTypeKHR :: eTopLevel ;
      return;
    }
    if( "BottomLevel" == j.get< std::string >() ) {
      p = AccelerationStructureTypeKHR :: eBottomLevel ;
      return;
    }
    if( "eBottomLevel" == j.get< std::string >() ) {
      p = AccelerationStructureTypeKHR :: eBottomLevel ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR" == j.get< std::string >() ) {
      p = AccelerationStructureTypeKHR :: eBottomLevel ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureTypeKHR" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureTypeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureTypeKHR" );
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureTypeKHR &p ) {
  AccelerationStructureTypeKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureTypeKHR ( temp );
}
#endif

#ifdef VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const AccelerationStructureBuildTypeKHR &p ) {
  if( AccelerationStructureBuildTypeKHR :: eHost == p ) {
    j = "Host";
    return;
  }
  if( AccelerationStructureBuildTypeKHR :: eDevice == p ) {
    j = "Device";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureBuildTypeKHR &p ) {
  to_json( j, AccelerationStructureBuildTypeKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureBuildTypeKHR &p ) {
  if( j.is_string() ) {
    if( "Host" == j.get< std::string >() ) {
      p = AccelerationStructureBuildTypeKHR :: eHost ;
      return;
    }
    if( "eHost" == j.get< std::string >() ) {
      p = AccelerationStructureBuildTypeKHR :: eHost ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR" == j.get< std::string >() ) {
      p = AccelerationStructureBuildTypeKHR :: eHost ;
      return;
    }
    if( "Device" == j.get< std::string >() ) {
      p = AccelerationStructureBuildTypeKHR :: eDevice ;
      return;
    }
    if( "eDevice" == j.get< std::string >() ) {
      p = AccelerationStructureBuildTypeKHR :: eDevice ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR" == j.get< std::string >() ) {
      p = AccelerationStructureBuildTypeKHR :: eDevice ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureBuildTypeKHR" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureBuildTypeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureBuildTypeKHR" );
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureBuildTypeKHR &p ) {
  AccelerationStructureBuildTypeKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureBuildTypeKHR ( temp );
}
#endif

#ifdef VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const CopyAccelerationStructureModeKHR &p ) {
  if( CopyAccelerationStructureModeKHR :: eClone == p ) {
    j = "Clone";
    return;
  }
  if( CopyAccelerationStructureModeKHR :: eCompact == p ) {
    j = "Compact";
    return;
  }
  if( CopyAccelerationStructureModeKHR :: eSerialize == p ) {
    j = "Serialize";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkCopyAccelerationStructureModeKHR &p ) {
  to_json( j, CopyAccelerationStructureModeKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, CopyAccelerationStructureModeKHR &p ) {
  if( j.is_string() ) {
    if( "Clone" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eClone ;
      return;
    }
    if( "eClone" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eClone ;
      return;
    }
    if( "VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eClone ;
      return;
    }
    if( "Compact" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eCompact ;
      return;
    }
    if( "eCompact" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eCompact ;
      return;
    }
    if( "VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eCompact ;
      return;
    }
    if( "Serialize" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eSerialize ;
      return;
    }
    if( "eSerialize" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eSerialize ;
      return;
    }
    if( "VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR" == j.get< std::string >() ) {
      p = CopyAccelerationStructureModeKHR :: eSerialize ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CopyAccelerationStructureModeKHR" );
  }
  if( j.is_number() ) {
    p = CopyAccelerationStructureModeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CopyAccelerationStructureModeKHR" );
}
inline void from_json( const nlohmann::json &j, VkCopyAccelerationStructureModeKHR &p ) {
  CopyAccelerationStructureModeKHR temp;
  from_json( j, temp );
  p = VkCopyAccelerationStructureModeKHR ( temp );
}
#endif

#ifdef VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const GeometryTypeKHR &p ) {
  if( GeometryTypeKHR :: eTriangles == p ) {
    j = "Triangles";
    return;
  }
  if( GeometryTypeKHR :: eAabbs == p ) {
    j = "Aabbs";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkGeometryTypeKHR &p ) {
  to_json( j, GeometryTypeKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, GeometryTypeKHR &p ) {
  if( j.is_string() ) {
    if( "Triangles" == j.get< std::string >() ) {
      p = GeometryTypeKHR :: eTriangles ;
      return;
    }
    if( "eTriangles" == j.get< std::string >() ) {
      p = GeometryTypeKHR :: eTriangles ;
      return;
    }
    if( "VK_GEOMETRY_TYPE_TRIANGLES_KHR" == j.get< std::string >() ) {
      p = GeometryTypeKHR :: eTriangles ;
      return;
    }
    if( "Aabbs" == j.get< std::string >() ) {
      p = GeometryTypeKHR :: eAabbs ;
      return;
    }
    if( "eAabbs" == j.get< std::string >() ) {
      p = GeometryTypeKHR :: eAabbs ;
      return;
    }
    if( "VK_GEOMETRY_TYPE_AABBS_KHR" == j.get< std::string >() ) {
      p = GeometryTypeKHR :: eAabbs ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for GeometryTypeKHR" );
  }
  if( j.is_number() ) {
    p = GeometryTypeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for GeometryTypeKHR" );
}
inline void from_json( const nlohmann::json &j, VkGeometryTypeKHR &p ) {
  GeometryTypeKHR temp;
  from_json( j, temp );
  p = VkGeometryTypeKHR ( temp );
}
#endif

#ifdef VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const AccelerationStructureCompatibilityKHR &p ) {
  if( AccelerationStructureCompatibilityKHR :: eCompatible == p ) {
    j = "Compatible";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureCompatibilityKHR &p ) {
  to_json( j, AccelerationStructureCompatibilityKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureCompatibilityKHR &p ) {
  if( j.is_string() ) {
    if( "Compatible" == j.get< std::string >() ) {
      p = AccelerationStructureCompatibilityKHR :: eCompatible ;
      return;
    }
    if( "eCompatible" == j.get< std::string >() ) {
      p = AccelerationStructureCompatibilityKHR :: eCompatible ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR" == j.get< std::string >() ) {
      p = AccelerationStructureCompatibilityKHR :: eCompatible ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureCompatibilityKHR" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureCompatibilityKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureCompatibilityKHR" );
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureCompatibilityKHR &p ) {
  AccelerationStructureCompatibilityKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureCompatibilityKHR ( temp );
}
#endif

#ifdef VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const BuildAccelerationStructureModeKHR &p ) {
  if( BuildAccelerationStructureModeKHR :: eBuild == p ) {
    j = "Build";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkBuildAccelerationStructureModeKHR &p ) {
  to_json( j, BuildAccelerationStructureModeKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, BuildAccelerationStructureModeKHR &p ) {
  if( j.is_string() ) {
    if( "Build" == j.get< std::string >() ) {
      p = BuildAccelerationStructureModeKHR :: eBuild ;
      return;
    }
    if( "eBuild" == j.get< std::string >() ) {
      p = BuildAccelerationStructureModeKHR :: eBuild ;
      return;
    }
    if( "VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR" == j.get< std::string >() ) {
      p = BuildAccelerationStructureModeKHR :: eBuild ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BuildAccelerationStructureModeKHR" );
  }
  if( j.is_number() ) {
    p = BuildAccelerationStructureModeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BuildAccelerationStructureModeKHR" );
}
inline void from_json( const nlohmann::json &j, VkBuildAccelerationStructureModeKHR &p ) {
  BuildAccelerationStructureModeKHR temp;
  from_json( j, temp );
  p = VkBuildAccelerationStructureModeKHR ( temp );
}
#endif

#ifdef VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const CoverageModulationModeNV &p ) {
  if( CoverageModulationModeNV :: eNone == p ) {
    j = "None";
    return;
  }
  if( CoverageModulationModeNV :: eRgb == p ) {
    j = "Rgb";
    return;
  }
  if( CoverageModulationModeNV :: eAlpha == p ) {
    j = "Alpha";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkCoverageModulationModeNV &p ) {
  to_json( j, CoverageModulationModeNV ( p ) );
}
inline void from_json( const nlohmann::json &j, CoverageModulationModeNV &p ) {
  if( j.is_string() ) {
    if( "None" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eNone ;
      return;
    }
    if( "eNone" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eNone ;
      return;
    }
    if( "VK_COVERAGE_MODULATION_MODE_NONE_NV" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eNone ;
      return;
    }
    if( "Rgb" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eRgb ;
      return;
    }
    if( "eRgb" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eRgb ;
      return;
    }
    if( "VK_COVERAGE_MODULATION_MODE_RGB_NV" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eRgb ;
      return;
    }
    if( "Alpha" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eAlpha ;
      return;
    }
    if( "eAlpha" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eAlpha ;
      return;
    }
    if( "VK_COVERAGE_MODULATION_MODE_ALPHA_NV" == j.get< std::string >() ) {
      p = CoverageModulationModeNV :: eAlpha ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CoverageModulationModeNV" );
  }
  if( j.is_number() ) {
    p = CoverageModulationModeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CoverageModulationModeNV" );
}
inline void from_json( const nlohmann::json &j, VkCoverageModulationModeNV &p ) {
  CoverageModulationModeNV temp;
  from_json( j, temp );
  p = VkCoverageModulationModeNV ( temp );
}
#endif

#ifdef VK_EXT_VALIDATION_CACHE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ValidationCacheHeaderVersionEXT &p ) {
}
inline void to_json( nlohmann::json &j, const VkValidationCacheHeaderVersionEXT &p ) {
  to_json( j, ValidationCacheHeaderVersionEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ValidationCacheHeaderVersionEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for ValidationCacheHeaderVersionEXT" );
  }
  if( j.is_number() ) {
    p = ValidationCacheHeaderVersionEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ValidationCacheHeaderVersionEXT" );
}
inline void from_json( const nlohmann::json &j, VkValidationCacheHeaderVersionEXT &p ) {
  ValidationCacheHeaderVersionEXT temp;
  from_json( j, temp );
  p = VkValidationCacheHeaderVersionEXT ( temp );
}
#endif

#ifdef VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ShadingRatePaletteEntryNV &p ) {
  if( ShadingRatePaletteEntryNV :: eNoInvocations == p ) {
    j = "NoInvocations";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e16InvocationsPerPixel == p ) {
    j = "16InvocationsPerPixel";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e8InvocationsPerPixel == p ) {
    j = "8InvocationsPerPixel";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e4InvocationsPerPixel == p ) {
    j = "4InvocationsPerPixel";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e2InvocationsPerPixel == p ) {
    j = "2InvocationsPerPixel";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e1InvocationPerPixel == p ) {
    j = "1InvocationPerPixel";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e1InvocationPer2X1Pixels == p ) {
    j = "1InvocationPer2X1Pixels";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e1InvocationPer1X2Pixels == p ) {
    j = "1InvocationPer1X2Pixels";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e1InvocationPer2X2Pixels == p ) {
    j = "1InvocationPer2X2Pixels";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e1InvocationPer4X2Pixels == p ) {
    j = "1InvocationPer4X2Pixels";
    return;
  }
  if( ShadingRatePaletteEntryNV :: e1InvocationPer2X4Pixels == p ) {
    j = "1InvocationPer2X4Pixels";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkShadingRatePaletteEntryNV &p ) {
  to_json( j, ShadingRatePaletteEntryNV ( p ) );
}
inline void from_json( const nlohmann::json &j, ShadingRatePaletteEntryNV &p ) {
  if( j.is_string() ) {
    if( "NoInvocations" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: eNoInvocations ;
      return;
    }
    if( "eNoInvocations" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: eNoInvocations ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: eNoInvocations ;
      return;
    }
    if( "16InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e16InvocationsPerPixel ;
      return;
    }
    if( "e16InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e16InvocationsPerPixel ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e16InvocationsPerPixel ;
      return;
    }
    if( "8InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e8InvocationsPerPixel ;
      return;
    }
    if( "e8InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e8InvocationsPerPixel ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e8InvocationsPerPixel ;
      return;
    }
    if( "4InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e4InvocationsPerPixel ;
      return;
    }
    if( "e4InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e4InvocationsPerPixel ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e4InvocationsPerPixel ;
      return;
    }
    if( "2InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e2InvocationsPerPixel ;
      return;
    }
    if( "e2InvocationsPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e2InvocationsPerPixel ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e2InvocationsPerPixel ;
      return;
    }
    if( "1InvocationPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPerPixel ;
      return;
    }
    if( "e1InvocationPerPixel" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPerPixel ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPerPixel ;
      return;
    }
    if( "1InvocationPer2X1Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X1Pixels ;
      return;
    }
    if( "e1InvocationPer2X1Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X1Pixels ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X1Pixels ;
      return;
    }
    if( "1InvocationPer1X2Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer1X2Pixels ;
      return;
    }
    if( "e1InvocationPer1X2Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer1X2Pixels ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer1X2Pixels ;
      return;
    }
    if( "1InvocationPer2X2Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X2Pixels ;
      return;
    }
    if( "e1InvocationPer2X2Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X2Pixels ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X2Pixels ;
      return;
    }
    if( "1InvocationPer4X2Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer4X2Pixels ;
      return;
    }
    if( "e1InvocationPer4X2Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer4X2Pixels ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer4X2Pixels ;
      return;
    }
    if( "1InvocationPer2X4Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X4Pixels ;
      return;
    }
    if( "e1InvocationPer2X4Pixels" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X4Pixels ;
      return;
    }
    if( "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV" == j.get< std::string >() ) {
      p = ShadingRatePaletteEntryNV :: e1InvocationPer2X4Pixels ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ShadingRatePaletteEntryNV" );
  }
  if( j.is_number() ) {
    p = ShadingRatePaletteEntryNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ShadingRatePaletteEntryNV" );
}
inline void from_json( const nlohmann::json &j, VkShadingRatePaletteEntryNV &p ) {
  ShadingRatePaletteEntryNV temp;
  from_json( j, temp );
  p = VkShadingRatePaletteEntryNV ( temp );
}
#endif

#ifdef VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const CoarseSampleOrderTypeNV &p ) {
  if( CoarseSampleOrderTypeNV :: eDefault == p ) {
    j = "Default";
    return;
  }
  if( CoarseSampleOrderTypeNV :: eCustom == p ) {
    j = "Custom";
    return;
  }
  if( CoarseSampleOrderTypeNV :: ePixelMajor == p ) {
    j = "PixelMajor";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkCoarseSampleOrderTypeNV &p ) {
  to_json( j, CoarseSampleOrderTypeNV ( p ) );
}
inline void from_json( const nlohmann::json &j, CoarseSampleOrderTypeNV &p ) {
  if( j.is_string() ) {
    if( "Default" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: eDefault ;
      return;
    }
    if( "eDefault" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: eDefault ;
      return;
    }
    if( "VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: eDefault ;
      return;
    }
    if( "Custom" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: eCustom ;
      return;
    }
    if( "eCustom" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: eCustom ;
      return;
    }
    if( "VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: eCustom ;
      return;
    }
    if( "PixelMajor" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: ePixelMajor ;
      return;
    }
    if( "ePixelMajor" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: ePixelMajor ;
      return;
    }
    if( "VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV" == j.get< std::string >() ) {
      p = CoarseSampleOrderTypeNV :: ePixelMajor ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CoarseSampleOrderTypeNV" );
  }
  if( j.is_number() ) {
    p = CoarseSampleOrderTypeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CoarseSampleOrderTypeNV" );
}
inline void from_json( const nlohmann::json &j, VkCoarseSampleOrderTypeNV &p ) {
  CoarseSampleOrderTypeNV temp;
  from_json( j, temp );
  p = VkCoarseSampleOrderTypeNV ( temp );
}
#endif

#ifdef VK_NV_RAY_TRACING_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const AccelerationStructureMemoryRequirementsTypeNV &p ) {
  if( AccelerationStructureMemoryRequirementsTypeNV :: eObject == p ) {
    j = "Object";
    return;
  }
  if( AccelerationStructureMemoryRequirementsTypeNV :: eBuildScratch == p ) {
    j = "BuildScratch";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureMemoryRequirementsTypeNV &p ) {
  to_json( j, AccelerationStructureMemoryRequirementsTypeNV ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureMemoryRequirementsTypeNV &p ) {
  if( j.is_string() ) {
    if( "Object" == j.get< std::string >() ) {
      p = AccelerationStructureMemoryRequirementsTypeNV :: eObject ;
      return;
    }
    if( "eObject" == j.get< std::string >() ) {
      p = AccelerationStructureMemoryRequirementsTypeNV :: eObject ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV" == j.get< std::string >() ) {
      p = AccelerationStructureMemoryRequirementsTypeNV :: eObject ;
      return;
    }
    if( "BuildScratch" == j.get< std::string >() ) {
      p = AccelerationStructureMemoryRequirementsTypeNV :: eBuildScratch ;
      return;
    }
    if( "eBuildScratch" == j.get< std::string >() ) {
      p = AccelerationStructureMemoryRequirementsTypeNV :: eBuildScratch ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV" == j.get< std::string >() ) {
      p = AccelerationStructureMemoryRequirementsTypeNV :: eBuildScratch ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureMemoryRequirementsTypeNV" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureMemoryRequirementsTypeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureMemoryRequirementsTypeNV" );
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureMemoryRequirementsTypeNV &p ) {
  AccelerationStructureMemoryRequirementsTypeNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureMemoryRequirementsTypeNV ( temp );
}
#endif

#ifdef VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const QueueGlobalPriorityEXT &p ) {
  if( QueueGlobalPriorityEXT :: eLow == p ) {
    j = "Low";
    return;
  }
  if( QueueGlobalPriorityEXT :: eMedium == p ) {
    j = "Medium";
    return;
  }
  if( QueueGlobalPriorityEXT :: eHigh == p ) {
    j = "High";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkQueueGlobalPriorityEXT &p ) {
  to_json( j, QueueGlobalPriorityEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, QueueGlobalPriorityEXT &p ) {
  if( j.is_string() ) {
    if( "Low" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eLow ;
      return;
    }
    if( "eLow" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eLow ;
      return;
    }
    if( "VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eLow ;
      return;
    }
    if( "Medium" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eMedium ;
      return;
    }
    if( "eMedium" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eMedium ;
      return;
    }
    if( "VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eMedium ;
      return;
    }
    if( "High" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eHigh ;
      return;
    }
    if( "eHigh" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eHigh ;
      return;
    }
    if( "VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT" == j.get< std::string >() ) {
      p = QueueGlobalPriorityEXT :: eHigh ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueueGlobalPriorityEXT" );
  }
  if( j.is_number() ) {
    p = QueueGlobalPriorityEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueueGlobalPriorityEXT" );
}
inline void from_json( const nlohmann::json &j, VkQueueGlobalPriorityEXT &p ) {
  QueueGlobalPriorityEXT temp;
  from_json( j, temp );
  p = VkQueueGlobalPriorityEXT ( temp );
}
#endif

#ifdef VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const TimeDomainEXT &p ) {
  if( TimeDomainEXT :: eDevice == p ) {
    j = "Device";
    return;
  }
  if( TimeDomainEXT :: eClockMonotonic == p ) {
    j = "ClockMonotonic";
    return;
  }
  if( TimeDomainEXT :: eClockMonotonicRaw == p ) {
    j = "ClockMonotonicRaw";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkTimeDomainEXT &p ) {
  to_json( j, TimeDomainEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, TimeDomainEXT &p ) {
  if( j.is_string() ) {
    if( "Device" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eDevice ;
      return;
    }
    if( "eDevice" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eDevice ;
      return;
    }
    if( "VK_TIME_DOMAIN_DEVICE_EXT" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eDevice ;
      return;
    }
    if( "ClockMonotonic" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eClockMonotonic ;
      return;
    }
    if( "eClockMonotonic" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eClockMonotonic ;
      return;
    }
    if( "VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eClockMonotonic ;
      return;
    }
    if( "ClockMonotonicRaw" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eClockMonotonicRaw ;
      return;
    }
    if( "eClockMonotonicRaw" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eClockMonotonicRaw ;
      return;
    }
    if( "VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT" == j.get< std::string >() ) {
      p = TimeDomainEXT :: eClockMonotonicRaw ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for TimeDomainEXT" );
  }
  if( j.is_number() ) {
    p = TimeDomainEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for TimeDomainEXT" );
}
inline void from_json( const nlohmann::json &j, VkTimeDomainEXT &p ) {
  TimeDomainEXT temp;
  from_json( j, temp );
  p = VkTimeDomainEXT ( temp );
}
#endif

#ifdef VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const MemoryOverallocationBehaviorAMD &p ) {
  if( MemoryOverallocationBehaviorAMD :: eDefault == p ) {
    j = "Default";
    return;
  }
  if( MemoryOverallocationBehaviorAMD :: eAllowed == p ) {
    j = "Allowed";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkMemoryOverallocationBehaviorAMD &p ) {
  to_json( j, MemoryOverallocationBehaviorAMD ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryOverallocationBehaviorAMD &p ) {
  if( j.is_string() ) {
    if( "Default" == j.get< std::string >() ) {
      p = MemoryOverallocationBehaviorAMD :: eDefault ;
      return;
    }
    if( "eDefault" == j.get< std::string >() ) {
      p = MemoryOverallocationBehaviorAMD :: eDefault ;
      return;
    }
    if( "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD" == j.get< std::string >() ) {
      p = MemoryOverallocationBehaviorAMD :: eDefault ;
      return;
    }
    if( "Allowed" == j.get< std::string >() ) {
      p = MemoryOverallocationBehaviorAMD :: eAllowed ;
      return;
    }
    if( "eAllowed" == j.get< std::string >() ) {
      p = MemoryOverallocationBehaviorAMD :: eAllowed ;
      return;
    }
    if( "VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD" == j.get< std::string >() ) {
      p = MemoryOverallocationBehaviorAMD :: eAllowed ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for MemoryOverallocationBehaviorAMD" );
  }
  if( j.is_number() ) {
    p = MemoryOverallocationBehaviorAMD ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for MemoryOverallocationBehaviorAMD" );
}
inline void from_json( const nlohmann::json &j, VkMemoryOverallocationBehaviorAMD &p ) {
  MemoryOverallocationBehaviorAMD temp;
  from_json( j, temp );
  p = VkMemoryOverallocationBehaviorAMD ( temp );
}
#endif

#ifdef VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PerformanceConfigurationTypeINTEL &p ) {
}
inline void to_json( nlohmann::json &j, const VkPerformanceConfigurationTypeINTEL &p ) {
  to_json( j, PerformanceConfigurationTypeINTEL ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceConfigurationTypeINTEL &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceConfigurationTypeINTEL" );
  }
  if( j.is_number() ) {
    p = PerformanceConfigurationTypeINTEL ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceConfigurationTypeINTEL" );
}
inline void from_json( const nlohmann::json &j, VkPerformanceConfigurationTypeINTEL &p ) {
  PerformanceConfigurationTypeINTEL temp;
  from_json( j, temp );
  p = VkPerformanceConfigurationTypeINTEL ( temp );
}
#endif

#ifdef VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const QueryPoolSamplingModeINTEL &p ) {
}
inline void to_json( nlohmann::json &j, const VkQueryPoolSamplingModeINTEL &p ) {
  to_json( j, QueryPoolSamplingModeINTEL ( p ) );
}
inline void from_json( const nlohmann::json &j, QueryPoolSamplingModeINTEL &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueryPoolSamplingModeINTEL" );
  }
  if( j.is_number() ) {
    p = QueryPoolSamplingModeINTEL ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueryPoolSamplingModeINTEL" );
}
inline void from_json( const nlohmann::json &j, VkQueryPoolSamplingModeINTEL &p ) {
  QueryPoolSamplingModeINTEL temp;
  from_json( j, temp );
  p = VkQueryPoolSamplingModeINTEL ( temp );
}
#endif

#ifdef VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PerformanceOverrideTypeINTEL &p ) {
  if( PerformanceOverrideTypeINTEL :: eNullHardware == p ) {
    j = "NullHardware";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkPerformanceOverrideTypeINTEL &p ) {
  to_json( j, PerformanceOverrideTypeINTEL ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceOverrideTypeINTEL &p ) {
  if( j.is_string() ) {
    if( "NullHardware" == j.get< std::string >() ) {
      p = PerformanceOverrideTypeINTEL :: eNullHardware ;
      return;
    }
    if( "eNullHardware" == j.get< std::string >() ) {
      p = PerformanceOverrideTypeINTEL :: eNullHardware ;
      return;
    }
    if( "VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL" == j.get< std::string >() ) {
      p = PerformanceOverrideTypeINTEL :: eNullHardware ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceOverrideTypeINTEL" );
  }
  if( j.is_number() ) {
    p = PerformanceOverrideTypeINTEL ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceOverrideTypeINTEL" );
}
inline void from_json( const nlohmann::json &j, VkPerformanceOverrideTypeINTEL &p ) {
  PerformanceOverrideTypeINTEL temp;
  from_json( j, temp );
  p = VkPerformanceOverrideTypeINTEL ( temp );
}
#endif

#ifdef VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PerformanceParameterTypeINTEL &p ) {
  if( PerformanceParameterTypeINTEL :: eHwCountersSupported == p ) {
    j = "HwCountersSupported";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkPerformanceParameterTypeINTEL &p ) {
  to_json( j, PerformanceParameterTypeINTEL ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceParameterTypeINTEL &p ) {
  if( j.is_string() ) {
    if( "HwCountersSupported" == j.get< std::string >() ) {
      p = PerformanceParameterTypeINTEL :: eHwCountersSupported ;
      return;
    }
    if( "eHwCountersSupported" == j.get< std::string >() ) {
      p = PerformanceParameterTypeINTEL :: eHwCountersSupported ;
      return;
    }
    if( "VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL" == j.get< std::string >() ) {
      p = PerformanceParameterTypeINTEL :: eHwCountersSupported ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceParameterTypeINTEL" );
  }
  if( j.is_number() ) {
    p = PerformanceParameterTypeINTEL ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceParameterTypeINTEL" );
}
inline void from_json( const nlohmann::json &j, VkPerformanceParameterTypeINTEL &p ) {
  PerformanceParameterTypeINTEL temp;
  from_json( j, temp );
  p = VkPerformanceParameterTypeINTEL ( temp );
}
#endif

#ifdef VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PerformanceValueTypeINTEL &p ) {
  if( PerformanceValueTypeINTEL :: eUint32 == p ) {
    j = "Uint32";
    return;
  }
  if( PerformanceValueTypeINTEL :: eUint64 == p ) {
    j = "Uint64";
    return;
  }
  if( PerformanceValueTypeINTEL :: eFloat == p ) {
    j = "Float";
    return;
  }
  if( PerformanceValueTypeINTEL :: eBool == p ) {
    j = "Bool";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkPerformanceValueTypeINTEL &p ) {
  to_json( j, PerformanceValueTypeINTEL ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceValueTypeINTEL &p ) {
  if( j.is_string() ) {
    if( "Uint32" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eUint32 ;
      return;
    }
    if( "eUint32" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eUint32 ;
      return;
    }
    if( "VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eUint32 ;
      return;
    }
    if( "Uint64" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eUint64 ;
      return;
    }
    if( "eUint64" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eUint64 ;
      return;
    }
    if( "VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eUint64 ;
      return;
    }
    if( "Float" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eFloat ;
      return;
    }
    if( "eFloat" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eFloat ;
      return;
    }
    if( "VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eFloat ;
      return;
    }
    if( "Bool" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eBool ;
      return;
    }
    if( "eBool" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eBool ;
      return;
    }
    if( "VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL" == j.get< std::string >() ) {
      p = PerformanceValueTypeINTEL :: eBool ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceValueTypeINTEL" );
  }
  if( j.is_number() ) {
    p = PerformanceValueTypeINTEL ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceValueTypeINTEL" );
}
inline void from_json( const nlohmann::json &j, VkPerformanceValueTypeINTEL &p ) {
  PerformanceValueTypeINTEL temp;
  from_json( j, temp );
  p = VkPerformanceValueTypeINTEL ( temp );
}
#endif

#ifdef VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const FragmentShadingRateCombinerOpKHR &p ) {
  if( FragmentShadingRateCombinerOpKHR :: eKeep == p ) {
    j = "Keep";
    return;
  }
  if( FragmentShadingRateCombinerOpKHR :: eReplace == p ) {
    j = "Replace";
    return;
  }
  if( FragmentShadingRateCombinerOpKHR :: eMin == p ) {
    j = "Min";
    return;
  }
  if( FragmentShadingRateCombinerOpKHR :: eMax == p ) {
    j = "Max";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkFragmentShadingRateCombinerOpKHR &p ) {
  to_json( j, FragmentShadingRateCombinerOpKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, FragmentShadingRateCombinerOpKHR &p ) {
  if( j.is_string() ) {
    if( "Keep" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eKeep ;
      return;
    }
    if( "eKeep" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eKeep ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eKeep ;
      return;
    }
    if( "Replace" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eReplace ;
      return;
    }
    if( "eReplace" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eReplace ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eReplace ;
      return;
    }
    if( "Min" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eMin ;
      return;
    }
    if( "eMin" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eMin ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eMin ;
      return;
    }
    if( "Max" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eMax ;
      return;
    }
    if( "eMax" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eMax ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR" == j.get< std::string >() ) {
      p = FragmentShadingRateCombinerOpKHR :: eMax ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for FragmentShadingRateCombinerOpKHR" );
  }
  if( j.is_number() ) {
    p = FragmentShadingRateCombinerOpKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FragmentShadingRateCombinerOpKHR" );
}
inline void from_json( const nlohmann::json &j, VkFragmentShadingRateCombinerOpKHR &p ) {
  FragmentShadingRateCombinerOpKHR temp;
  from_json( j, temp );
  p = VkFragmentShadingRateCombinerOpKHR ( temp );
}
#endif

#ifdef VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ValidationFeatureEnableEXT &p ) {
  if( ValidationFeatureEnableEXT :: eGpuAssisted == p ) {
    j = "GpuAssisted";
    return;
  }
  if( ValidationFeatureEnableEXT :: eGpuAssistedReserveBindingSlot == p ) {
    j = "GpuAssistedReserveBindingSlot";
    return;
  }
  if( ValidationFeatureEnableEXT :: eBestPractices == p ) {
    j = "BestPractices";
    return;
  }
  if( ValidationFeatureEnableEXT :: eDebugPrintf == p ) {
    j = "DebugPrintf";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkValidationFeatureEnableEXT &p ) {
  to_json( j, ValidationFeatureEnableEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ValidationFeatureEnableEXT &p ) {
  if( j.is_string() ) {
    if( "GpuAssisted" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eGpuAssisted ;
      return;
    }
    if( "eGpuAssisted" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eGpuAssisted ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eGpuAssisted ;
      return;
    }
    if( "GpuAssistedReserveBindingSlot" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eGpuAssistedReserveBindingSlot ;
      return;
    }
    if( "eGpuAssistedReserveBindingSlot" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eGpuAssistedReserveBindingSlot ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eGpuAssistedReserveBindingSlot ;
      return;
    }
    if( "BestPractices" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eBestPractices ;
      return;
    }
    if( "eBestPractices" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eBestPractices ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eBestPractices ;
      return;
    }
    if( "DebugPrintf" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eDebugPrintf ;
      return;
    }
    if( "eDebugPrintf" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eDebugPrintf ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureEnableEXT :: eDebugPrintf ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ValidationFeatureEnableEXT" );
  }
  if( j.is_number() ) {
    p = ValidationFeatureEnableEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ValidationFeatureEnableEXT" );
}
inline void from_json( const nlohmann::json &j, VkValidationFeatureEnableEXT &p ) {
  ValidationFeatureEnableEXT temp;
  from_json( j, temp );
  p = VkValidationFeatureEnableEXT ( temp );
}
#endif

#ifdef VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ValidationFeatureDisableEXT &p ) {
  if( ValidationFeatureDisableEXT :: eAll == p ) {
    j = "All";
    return;
  }
  if( ValidationFeatureDisableEXT :: eShaders == p ) {
    j = "Shaders";
    return;
  }
  if( ValidationFeatureDisableEXT :: eThreadSafety == p ) {
    j = "ThreadSafety";
    return;
  }
  if( ValidationFeatureDisableEXT :: eApiParameters == p ) {
    j = "ApiParameters";
    return;
  }
  if( ValidationFeatureDisableEXT :: eObjectLifetimes == p ) {
    j = "ObjectLifetimes";
    return;
  }
  if( ValidationFeatureDisableEXT :: eCoreChecks == p ) {
    j = "CoreChecks";
    return;
  }
  if( ValidationFeatureDisableEXT :: eUniqueHandles == p ) {
    j = "UniqueHandles";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkValidationFeatureDisableEXT &p ) {
  to_json( j, ValidationFeatureDisableEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ValidationFeatureDisableEXT &p ) {
  if( j.is_string() ) {
    if( "All" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eAll ;
      return;
    }
    if( "eAll" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eAll ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_DISABLE_ALL_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eAll ;
      return;
    }
    if( "Shaders" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eShaders ;
      return;
    }
    if( "eShaders" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eShaders ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eShaders ;
      return;
    }
    if( "ThreadSafety" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eThreadSafety ;
      return;
    }
    if( "eThreadSafety" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eThreadSafety ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eThreadSafety ;
      return;
    }
    if( "ApiParameters" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eApiParameters ;
      return;
    }
    if( "eApiParameters" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eApiParameters ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eApiParameters ;
      return;
    }
    if( "ObjectLifetimes" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eObjectLifetimes ;
      return;
    }
    if( "eObjectLifetimes" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eObjectLifetimes ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eObjectLifetimes ;
      return;
    }
    if( "CoreChecks" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eCoreChecks ;
      return;
    }
    if( "eCoreChecks" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eCoreChecks ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eCoreChecks ;
      return;
    }
    if( "UniqueHandles" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eUniqueHandles ;
      return;
    }
    if( "eUniqueHandles" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eUniqueHandles ;
      return;
    }
    if( "VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT" == j.get< std::string >() ) {
      p = ValidationFeatureDisableEXT :: eUniqueHandles ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ValidationFeatureDisableEXT" );
  }
  if( j.is_number() ) {
    p = ValidationFeatureDisableEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ValidationFeatureDisableEXT" );
}
inline void from_json( const nlohmann::json &j, VkValidationFeatureDisableEXT &p ) {
  ValidationFeatureDisableEXT temp;
  from_json( j, temp );
  p = VkValidationFeatureDisableEXT ( temp );
}
#endif

#ifdef VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ScopeNV &p ) {
  if( ScopeNV :: eDevice == p ) {
    j = "Device";
    return;
  }
  if( ScopeNV :: eWorkgroup == p ) {
    j = "Workgroup";
    return;
  }
  if( ScopeNV :: eSubgroup == p ) {
    j = "Subgroup";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkScopeNV &p ) {
  to_json( j, ScopeNV ( p ) );
}
inline void from_json( const nlohmann::json &j, ScopeNV &p ) {
  if( j.is_string() ) {
    if( "Device" == j.get< std::string >() ) {
      p = ScopeNV :: eDevice ;
      return;
    }
    if( "eDevice" == j.get< std::string >() ) {
      p = ScopeNV :: eDevice ;
      return;
    }
    if( "VK_SCOPE_DEVICE_NV" == j.get< std::string >() ) {
      p = ScopeNV :: eDevice ;
      return;
    }
    if( "Workgroup" == j.get< std::string >() ) {
      p = ScopeNV :: eWorkgroup ;
      return;
    }
    if( "eWorkgroup" == j.get< std::string >() ) {
      p = ScopeNV :: eWorkgroup ;
      return;
    }
    if( "VK_SCOPE_WORKGROUP_NV" == j.get< std::string >() ) {
      p = ScopeNV :: eWorkgroup ;
      return;
    }
    if( "Subgroup" == j.get< std::string >() ) {
      p = ScopeNV :: eSubgroup ;
      return;
    }
    if( "eSubgroup" == j.get< std::string >() ) {
      p = ScopeNV :: eSubgroup ;
      return;
    }
    if( "VK_SCOPE_SUBGROUP_NV" == j.get< std::string >() ) {
      p = ScopeNV :: eSubgroup ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ScopeNV" );
  }
  if( j.is_number() ) {
    p = ScopeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ScopeNV" );
}
inline void from_json( const nlohmann::json &j, VkScopeNV &p ) {
  ScopeNV temp;
  from_json( j, temp );
  p = VkScopeNV ( temp );
}
#endif

#ifdef VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ComponentTypeNV &p ) {
  if( ComponentTypeNV :: eFloat16 == p ) {
    j = "Float16";
    return;
  }
  if( ComponentTypeNV :: eFloat32 == p ) {
    j = "Float32";
    return;
  }
  if( ComponentTypeNV :: eFloat64 == p ) {
    j = "Float64";
    return;
  }
  if( ComponentTypeNV :: eSint8 == p ) {
    j = "Sint8";
    return;
  }
  if( ComponentTypeNV :: eSint16 == p ) {
    j = "Sint16";
    return;
  }
  if( ComponentTypeNV :: eSint32 == p ) {
    j = "Sint32";
    return;
  }
  if( ComponentTypeNV :: eSint64 == p ) {
    j = "Sint64";
    return;
  }
  if( ComponentTypeNV :: eUint8 == p ) {
    j = "Uint8";
    return;
  }
  if( ComponentTypeNV :: eUint16 == p ) {
    j = "Uint16";
    return;
  }
  if( ComponentTypeNV :: eUint32 == p ) {
    j = "Uint32";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkComponentTypeNV &p ) {
  to_json( j, ComponentTypeNV ( p ) );
}
inline void from_json( const nlohmann::json &j, ComponentTypeNV &p ) {
  if( j.is_string() ) {
    if( "Float16" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat16 ;
      return;
    }
    if( "eFloat16" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat16 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_FLOAT16_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat16 ;
      return;
    }
    if( "Float32" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat32 ;
      return;
    }
    if( "eFloat32" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat32 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_FLOAT32_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat32 ;
      return;
    }
    if( "Float64" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat64 ;
      return;
    }
    if( "eFloat64" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat64 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_FLOAT64_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eFloat64 ;
      return;
    }
    if( "Sint8" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint8 ;
      return;
    }
    if( "eSint8" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint8 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_SINT8_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint8 ;
      return;
    }
    if( "Sint16" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint16 ;
      return;
    }
    if( "eSint16" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint16 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_SINT16_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint16 ;
      return;
    }
    if( "Sint32" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint32 ;
      return;
    }
    if( "eSint32" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint32 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_SINT32_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint32 ;
      return;
    }
    if( "Sint64" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint64 ;
      return;
    }
    if( "eSint64" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint64 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_SINT64_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eSint64 ;
      return;
    }
    if( "Uint8" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint8 ;
      return;
    }
    if( "eUint8" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint8 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_UINT8_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint8 ;
      return;
    }
    if( "Uint16" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint16 ;
      return;
    }
    if( "eUint16" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint16 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_UINT16_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint16 ;
      return;
    }
    if( "Uint32" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint32 ;
      return;
    }
    if( "eUint32" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint32 ;
      return;
    }
    if( "VK_COMPONENT_TYPE_UINT32_NV" == j.get< std::string >() ) {
      p = ComponentTypeNV :: eUint32 ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ComponentTypeNV" );
  }
  if( j.is_number() ) {
    p = ComponentTypeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ComponentTypeNV" );
}
inline void from_json( const nlohmann::json &j, VkComponentTypeNV &p ) {
  ComponentTypeNV temp;
  from_json( j, temp );
  p = VkComponentTypeNV ( temp );
}
#endif

#ifdef VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const CoverageReductionModeNV &p ) {
  if( CoverageReductionModeNV :: eMerge == p ) {
    j = "Merge";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkCoverageReductionModeNV &p ) {
  to_json( j, CoverageReductionModeNV ( p ) );
}
inline void from_json( const nlohmann::json &j, CoverageReductionModeNV &p ) {
  if( j.is_string() ) {
    if( "Merge" == j.get< std::string >() ) {
      p = CoverageReductionModeNV :: eMerge ;
      return;
    }
    if( "eMerge" == j.get< std::string >() ) {
      p = CoverageReductionModeNV :: eMerge ;
      return;
    }
    if( "VK_COVERAGE_REDUCTION_MODE_MERGE_NV" == j.get< std::string >() ) {
      p = CoverageReductionModeNV :: eMerge ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CoverageReductionModeNV" );
  }
  if( j.is_number() ) {
    p = CoverageReductionModeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CoverageReductionModeNV" );
}
inline void from_json( const nlohmann::json &j, VkCoverageReductionModeNV &p ) {
  CoverageReductionModeNV temp;
  from_json( j, temp );
  p = VkCoverageReductionModeNV ( temp );
}
#endif

#ifdef VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ProvokingVertexModeEXT &p ) {
  if( ProvokingVertexModeEXT :: eFirstVertex == p ) {
    j = "FirstVertex";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkProvokingVertexModeEXT &p ) {
  to_json( j, ProvokingVertexModeEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ProvokingVertexModeEXT &p ) {
  if( j.is_string() ) {
    if( "FirstVertex" == j.get< std::string >() ) {
      p = ProvokingVertexModeEXT :: eFirstVertex ;
      return;
    }
    if( "eFirstVertex" == j.get< std::string >() ) {
      p = ProvokingVertexModeEXT :: eFirstVertex ;
      return;
    }
    if( "VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT" == j.get< std::string >() ) {
      p = ProvokingVertexModeEXT :: eFirstVertex ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ProvokingVertexModeEXT" );
  }
  if( j.is_number() ) {
    p = ProvokingVertexModeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ProvokingVertexModeEXT" );
}
inline void from_json( const nlohmann::json &j, VkProvokingVertexModeEXT &p ) {
  ProvokingVertexModeEXT temp;
  from_json( j, temp );
  p = VkProvokingVertexModeEXT ( temp );
}
#endif

#ifdef VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const FullScreenExclusiveEXT &p ) {
  if( FullScreenExclusiveEXT :: eDefault == p ) {
    j = "Default";
    return;
  }
  if( FullScreenExclusiveEXT :: eAllowed == p ) {
    j = "Allowed";
    return;
  }
  if( FullScreenExclusiveEXT :: eDisallowed == p ) {
    j = "Disallowed";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkFullScreenExclusiveEXT &p ) {
  to_json( j, FullScreenExclusiveEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, FullScreenExclusiveEXT &p ) {
  if( j.is_string() ) {
    if( "Default" == j.get< std::string >() ) {
      p = FullScreenExclusiveEXT :: eDefault ;
      return;
    }
    if( "eDefault" == j.get< std::string >() ) {
      p = FullScreenExclusiveEXT :: eDefault ;
      return;
    }
    if( "VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT" == j.get< std::string >() ) {
      p = FullScreenExclusiveEXT :: eDefault ;
      return;
    }
    if( "Allowed" == j.get< std::string >() ) {
      p = FullScreenExclusiveEXT :: eAllowed ;
      return;
    }
    if( "eAllowed" == j.get< std::string >() ) {
      p = FullScreenExclusiveEXT :: eAllowed ;
      return;
    }
    if( "VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT" == j.get< std::string >() ) {
      p = FullScreenExclusiveEXT :: eAllowed ;
      return;
    }
    if( "Disallowed" == j.get< std::string >() ) {
      p = FullScreenExclusiveEXT :: eDisallowed ;
      return;
    }
    if( "eDisallowed" == j.get< std::string >() ) {
      p = FullScreenExclusiveEXT :: eDisallowed ;
      return;
    }
    if( "VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT" == j.get< std::string >() ) {
      p = FullScreenExclusiveEXT :: eDisallowed ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for FullScreenExclusiveEXT" );
  }
  if( j.is_number() ) {
    p = FullScreenExclusiveEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FullScreenExclusiveEXT" );
}
inline void from_json( const nlohmann::json &j, VkFullScreenExclusiveEXT &p ) {
  FullScreenExclusiveEXT temp;
  from_json( j, temp );
  p = VkFullScreenExclusiveEXT ( temp );
}
#endif

#ifdef VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const LineRasterizationModeEXT &p ) {
  if( LineRasterizationModeEXT :: eDefault == p ) {
    j = "Default";
    return;
  }
  if( LineRasterizationModeEXT :: eRectangular == p ) {
    j = "Rectangular";
    return;
  }
  if( LineRasterizationModeEXT :: eBresenham == p ) {
    j = "Bresenham";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkLineRasterizationModeEXT &p ) {
  to_json( j, LineRasterizationModeEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, LineRasterizationModeEXT &p ) {
  if( j.is_string() ) {
    if( "Default" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eDefault ;
      return;
    }
    if( "eDefault" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eDefault ;
      return;
    }
    if( "VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eDefault ;
      return;
    }
    if( "Rectangular" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eRectangular ;
      return;
    }
    if( "eRectangular" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eRectangular ;
      return;
    }
    if( "VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eRectangular ;
      return;
    }
    if( "Bresenham" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eBresenham ;
      return;
    }
    if( "eBresenham" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eBresenham ;
      return;
    }
    if( "VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT" == j.get< std::string >() ) {
      p = LineRasterizationModeEXT :: eBresenham ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for LineRasterizationModeEXT" );
  }
  if( j.is_number() ) {
    p = LineRasterizationModeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for LineRasterizationModeEXT" );
}
inline void from_json( const nlohmann::json &j, VkLineRasterizationModeEXT &p ) {
  LineRasterizationModeEXT temp;
  from_json( j, temp );
  p = VkLineRasterizationModeEXT ( temp );
}
#endif

#ifdef VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PipelineExecutableStatisticFormatKHR &p ) {
  if( PipelineExecutableStatisticFormatKHR :: eBool32 == p ) {
    j = "Bool32";
    return;
  }
  if( PipelineExecutableStatisticFormatKHR :: eInt64 == p ) {
    j = "Int64";
    return;
  }
  if( PipelineExecutableStatisticFormatKHR :: eUint64 == p ) {
    j = "Uint64";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkPipelineExecutableStatisticFormatKHR &p ) {
  to_json( j, PipelineExecutableStatisticFormatKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineExecutableStatisticFormatKHR &p ) {
  if( j.is_string() ) {
    if( "Bool32" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eBool32 ;
      return;
    }
    if( "eBool32" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eBool32 ;
      return;
    }
    if( "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eBool32 ;
      return;
    }
    if( "Int64" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eInt64 ;
      return;
    }
    if( "eInt64" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eInt64 ;
      return;
    }
    if( "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eInt64 ;
      return;
    }
    if( "Uint64" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eUint64 ;
      return;
    }
    if( "eUint64" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eUint64 ;
      return;
    }
    if( "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR" == j.get< std::string >() ) {
      p = PipelineExecutableStatisticFormatKHR :: eUint64 ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineExecutableStatisticFormatKHR" );
  }
  if( j.is_number() ) {
    p = PipelineExecutableStatisticFormatKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineExecutableStatisticFormatKHR" );
}
inline void from_json( const nlohmann::json &j, VkPipelineExecutableStatisticFormatKHR &p ) {
  PipelineExecutableStatisticFormatKHR temp;
  from_json( j, temp );
  p = VkPipelineExecutableStatisticFormatKHR ( temp );
}
#endif

#ifdef VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const IndirectCommandsTokenTypeNV &p ) {
  if( IndirectCommandsTokenTypeNV :: eShaderGroup == p ) {
    j = "ShaderGroup";
    return;
  }
  if( IndirectCommandsTokenTypeNV :: eStateFlags == p ) {
    j = "StateFlags";
    return;
  }
  if( IndirectCommandsTokenTypeNV :: eIndexBuffer == p ) {
    j = "IndexBuffer";
    return;
  }
  if( IndirectCommandsTokenTypeNV :: eVertexBuffer == p ) {
    j = "VertexBuffer";
    return;
  }
  if( IndirectCommandsTokenTypeNV :: ePushConstant == p ) {
    j = "PushConstant";
    return;
  }
  if( IndirectCommandsTokenTypeNV :: eDrawIndexed == p ) {
    j = "DrawIndexed";
    return;
  }
  if( IndirectCommandsTokenTypeNV :: eDraw == p ) {
    j = "Draw";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkIndirectCommandsTokenTypeNV &p ) {
  to_json( j, IndirectCommandsTokenTypeNV ( p ) );
}
inline void from_json( const nlohmann::json &j, IndirectCommandsTokenTypeNV &p ) {
  if( j.is_string() ) {
    if( "ShaderGroup" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eShaderGroup ;
      return;
    }
    if( "eShaderGroup" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eShaderGroup ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eShaderGroup ;
      return;
    }
    if( "StateFlags" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eStateFlags ;
      return;
    }
    if( "eStateFlags" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eStateFlags ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eStateFlags ;
      return;
    }
    if( "IndexBuffer" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eIndexBuffer ;
      return;
    }
    if( "eIndexBuffer" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eIndexBuffer ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eIndexBuffer ;
      return;
    }
    if( "VertexBuffer" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eVertexBuffer ;
      return;
    }
    if( "eVertexBuffer" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eVertexBuffer ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eVertexBuffer ;
      return;
    }
    if( "PushConstant" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: ePushConstant ;
      return;
    }
    if( "ePushConstant" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: ePushConstant ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: ePushConstant ;
      return;
    }
    if( "DrawIndexed" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eDrawIndexed ;
      return;
    }
    if( "eDrawIndexed" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eDrawIndexed ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eDrawIndexed ;
      return;
    }
    if( "Draw" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eDraw ;
      return;
    }
    if( "eDraw" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eDraw ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV" == j.get< std::string >() ) {
      p = IndirectCommandsTokenTypeNV :: eDraw ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for IndirectCommandsTokenTypeNV" );
  }
  if( j.is_number() ) {
    p = IndirectCommandsTokenTypeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for IndirectCommandsTokenTypeNV" );
}
inline void from_json( const nlohmann::json &j, VkIndirectCommandsTokenTypeNV &p ) {
  IndirectCommandsTokenTypeNV temp;
  from_json( j, temp );
  p = VkIndirectCommandsTokenTypeNV ( temp );
}
#endif

#ifdef VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DeviceMemoryReportEventTypeEXT &p ) {
  if( DeviceMemoryReportEventTypeEXT :: eAllocate == p ) {
    j = "Allocate";
    return;
  }
  if( DeviceMemoryReportEventTypeEXT :: eFree == p ) {
    j = "Free";
    return;
  }
  if( DeviceMemoryReportEventTypeEXT :: eImport == p ) {
    j = "Import";
    return;
  }
  if( DeviceMemoryReportEventTypeEXT :: eUnimport == p ) {
    j = "Unimport";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkDeviceMemoryReportEventTypeEXT &p ) {
  to_json( j, DeviceMemoryReportEventTypeEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceMemoryReportEventTypeEXT &p ) {
  if( j.is_string() ) {
    if( "Allocate" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eAllocate ;
      return;
    }
    if( "eAllocate" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eAllocate ;
      return;
    }
    if( "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eAllocate ;
      return;
    }
    if( "Free" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eFree ;
      return;
    }
    if( "eFree" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eFree ;
      return;
    }
    if( "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eFree ;
      return;
    }
    if( "Import" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eImport ;
      return;
    }
    if( "eImport" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eImport ;
      return;
    }
    if( "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eImport ;
      return;
    }
    if( "Unimport" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eUnimport ;
      return;
    }
    if( "eUnimport" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eUnimport ;
      return;
    }
    if( "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT" == j.get< std::string >() ) {
      p = DeviceMemoryReportEventTypeEXT :: eUnimport ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DeviceMemoryReportEventTypeEXT" );
  }
  if( j.is_number() ) {
    p = DeviceMemoryReportEventTypeEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DeviceMemoryReportEventTypeEXT" );
}
inline void from_json( const nlohmann::json &j, VkDeviceMemoryReportEventTypeEXT &p ) {
  DeviceMemoryReportEventTypeEXT temp;
  from_json( j, temp );
  p = VkDeviceMemoryReportEventTypeEXT ( temp );
}
#endif

#ifdef VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const FragmentShadingRateNV &p ) {
  if( FragmentShadingRateNV :: e1InvocationPerPixel == p ) {
    j = "1InvocationPerPixel";
    return;
  }
  if( FragmentShadingRateNV :: e1InvocationPer1X2Pixels == p ) {
    j = "1InvocationPer1X2Pixels";
    return;
  }
  if( FragmentShadingRateNV :: e1InvocationPer2X1Pixels == p ) {
    j = "1InvocationPer2X1Pixels";
    return;
  }
  if( FragmentShadingRateNV :: e1InvocationPer2X2Pixels == p ) {
    j = "1InvocationPer2X2Pixels";
    return;
  }
  if( FragmentShadingRateNV :: e1InvocationPer2X4Pixels == p ) {
    j = "1InvocationPer2X4Pixels";
    return;
  }
  if( FragmentShadingRateNV :: e1InvocationPer4X2Pixels == p ) {
    j = "1InvocationPer4X2Pixels";
    return;
  }
  if( FragmentShadingRateNV :: e1InvocationPer4X4Pixels == p ) {
    j = "1InvocationPer4X4Pixels";
    return;
  }
  if( FragmentShadingRateNV :: e2InvocationsPerPixel == p ) {
    j = "2InvocationsPerPixel";
    return;
  }
  if( FragmentShadingRateNV :: e4InvocationsPerPixel == p ) {
    j = "4InvocationsPerPixel";
    return;
  }
  if( FragmentShadingRateNV :: e8InvocationsPerPixel == p ) {
    j = "8InvocationsPerPixel";
    return;
  }
  if( FragmentShadingRateNV :: e16InvocationsPerPixel == p ) {
    j = "16InvocationsPerPixel";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkFragmentShadingRateNV &p ) {
  to_json( j, FragmentShadingRateNV ( p ) );
}
inline void from_json( const nlohmann::json &j, FragmentShadingRateNV &p ) {
  if( j.is_string() ) {
    if( "1InvocationPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPerPixel ;
      return;
    }
    if( "e1InvocationPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPerPixel ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPerPixel ;
      return;
    }
    if( "1InvocationPer1X2Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer1X2Pixels ;
      return;
    }
    if( "e1InvocationPer1X2Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer1X2Pixels ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer1X2Pixels ;
      return;
    }
    if( "1InvocationPer2X1Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X1Pixels ;
      return;
    }
    if( "e1InvocationPer2X1Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X1Pixels ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X1Pixels ;
      return;
    }
    if( "1InvocationPer2X2Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X2Pixels ;
      return;
    }
    if( "e1InvocationPer2X2Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X2Pixels ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X2Pixels ;
      return;
    }
    if( "1InvocationPer2X4Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X4Pixels ;
      return;
    }
    if( "e1InvocationPer2X4Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X4Pixels ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer2X4Pixels ;
      return;
    }
    if( "1InvocationPer4X2Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer4X2Pixels ;
      return;
    }
    if( "e1InvocationPer4X2Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer4X2Pixels ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer4X2Pixels ;
      return;
    }
    if( "1InvocationPer4X4Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer4X4Pixels ;
      return;
    }
    if( "e1InvocationPer4X4Pixels" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer4X4Pixels ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e1InvocationPer4X4Pixels ;
      return;
    }
    if( "2InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e2InvocationsPerPixel ;
      return;
    }
    if( "e2InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e2InvocationsPerPixel ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e2InvocationsPerPixel ;
      return;
    }
    if( "4InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e4InvocationsPerPixel ;
      return;
    }
    if( "e4InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e4InvocationsPerPixel ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e4InvocationsPerPixel ;
      return;
    }
    if( "8InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e8InvocationsPerPixel ;
      return;
    }
    if( "e8InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e8InvocationsPerPixel ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e8InvocationsPerPixel ;
      return;
    }
    if( "16InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e16InvocationsPerPixel ;
      return;
    }
    if( "e16InvocationsPerPixel" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e16InvocationsPerPixel ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateNV :: e16InvocationsPerPixel ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for FragmentShadingRateNV" );
  }
  if( j.is_number() ) {
    p = FragmentShadingRateNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FragmentShadingRateNV" );
}
inline void from_json( const nlohmann::json &j, VkFragmentShadingRateNV &p ) {
  FragmentShadingRateNV temp;
  from_json( j, temp );
  p = VkFragmentShadingRateNV ( temp );
}
#endif

#ifdef VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const FragmentShadingRateTypeNV &p ) {
  if( FragmentShadingRateTypeNV :: eFragmentSize == p ) {
    j = "FragmentSize";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkFragmentShadingRateTypeNV &p ) {
  to_json( j, FragmentShadingRateTypeNV ( p ) );
}
inline void from_json( const nlohmann::json &j, FragmentShadingRateTypeNV &p ) {
  if( j.is_string() ) {
    if( "FragmentSize" == j.get< std::string >() ) {
      p = FragmentShadingRateTypeNV :: eFragmentSize ;
      return;
    }
    if( "eFragmentSize" == j.get< std::string >() ) {
      p = FragmentShadingRateTypeNV :: eFragmentSize ;
      return;
    }
    if( "VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV" == j.get< std::string >() ) {
      p = FragmentShadingRateTypeNV :: eFragmentSize ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for FragmentShadingRateTypeNV" );
  }
  if( j.is_number() ) {
    p = FragmentShadingRateTypeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FragmentShadingRateTypeNV" );
}
inline void from_json( const nlohmann::json &j, VkFragmentShadingRateTypeNV &p ) {
  FragmentShadingRateTypeNV temp;
  from_json( j, temp );
  p = VkFragmentShadingRateTypeNV ( temp );
}
#endif

#ifdef VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const AccelerationStructureMotionInstanceTypeNV &p ) {
  if( AccelerationStructureMotionInstanceTypeNV :: eStatic == p ) {
    j = "Static";
    return;
  }
  if( AccelerationStructureMotionInstanceTypeNV :: eMatrixMotion == p ) {
    j = "MatrixMotion";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureMotionInstanceTypeNV &p ) {
  to_json( j, AccelerationStructureMotionInstanceTypeNV ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureMotionInstanceTypeNV &p ) {
  if( j.is_string() ) {
    if( "Static" == j.get< std::string >() ) {
      p = AccelerationStructureMotionInstanceTypeNV :: eStatic ;
      return;
    }
    if( "eStatic" == j.get< std::string >() ) {
      p = AccelerationStructureMotionInstanceTypeNV :: eStatic ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV" == j.get< std::string >() ) {
      p = AccelerationStructureMotionInstanceTypeNV :: eStatic ;
      return;
    }
    if( "MatrixMotion" == j.get< std::string >() ) {
      p = AccelerationStructureMotionInstanceTypeNV :: eMatrixMotion ;
      return;
    }
    if( "eMatrixMotion" == j.get< std::string >() ) {
      p = AccelerationStructureMotionInstanceTypeNV :: eMatrixMotion ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV" == j.get< std::string >() ) {
      p = AccelerationStructureMotionInstanceTypeNV :: eMatrixMotion ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureMotionInstanceTypeNV" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureMotionInstanceTypeNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureMotionInstanceTypeNV" );
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureMotionInstanceTypeNV &p ) {
  AccelerationStructureMotionInstanceTypeNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureMotionInstanceTypeNV ( temp );
}
#endif

#ifdef VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const RayTracingShaderGroupTypeKHR &p ) {
  if( RayTracingShaderGroupTypeKHR :: eGeneral == p ) {
    j = "General";
    return;
  }
  if( RayTracingShaderGroupTypeKHR :: eTrianglesHitGroup == p ) {
    j = "TrianglesHitGroup";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkRayTracingShaderGroupTypeKHR &p ) {
  to_json( j, RayTracingShaderGroupTypeKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, RayTracingShaderGroupTypeKHR &p ) {
  if( j.is_string() ) {
    if( "General" == j.get< std::string >() ) {
      p = RayTracingShaderGroupTypeKHR :: eGeneral ;
      return;
    }
    if( "eGeneral" == j.get< std::string >() ) {
      p = RayTracingShaderGroupTypeKHR :: eGeneral ;
      return;
    }
    if( "VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR" == j.get< std::string >() ) {
      p = RayTracingShaderGroupTypeKHR :: eGeneral ;
      return;
    }
    if( "TrianglesHitGroup" == j.get< std::string >() ) {
      p = RayTracingShaderGroupTypeKHR :: eTrianglesHitGroup ;
      return;
    }
    if( "eTrianglesHitGroup" == j.get< std::string >() ) {
      p = RayTracingShaderGroupTypeKHR :: eTrianglesHitGroup ;
      return;
    }
    if( "VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR" == j.get< std::string >() ) {
      p = RayTracingShaderGroupTypeKHR :: eTrianglesHitGroup ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for RayTracingShaderGroupTypeKHR" );
  }
  if( j.is_number() ) {
    p = RayTracingShaderGroupTypeKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for RayTracingShaderGroupTypeKHR" );
}
inline void from_json( const nlohmann::json &j, VkRayTracingShaderGroupTypeKHR &p ) {
  RayTracingShaderGroupTypeKHR temp;
  from_json( j, temp );
  p = VkRayTracingShaderGroupTypeKHR ( temp );
}
#endif

#ifdef VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ShaderGroupShaderKHR &p ) {
  if( ShaderGroupShaderKHR :: eGeneral == p ) {
    j = "General";
    return;
  }
  if( ShaderGroupShaderKHR :: eClosestHit == p ) {
    j = "ClosestHit";
    return;
  }
  if( ShaderGroupShaderKHR :: eAnyHit == p ) {
    j = "AnyHit";
    return;
  }
}
inline void to_json( nlohmann::json &j, const VkShaderGroupShaderKHR &p ) {
  to_json( j, ShaderGroupShaderKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ShaderGroupShaderKHR &p ) {
  if( j.is_string() ) {
    if( "General" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eGeneral ;
      return;
    }
    if( "eGeneral" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eGeneral ;
      return;
    }
    if( "VK_SHADER_GROUP_SHADER_GENERAL_KHR" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eGeneral ;
      return;
    }
    if( "ClosestHit" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eClosestHit ;
      return;
    }
    if( "eClosestHit" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eClosestHit ;
      return;
    }
    if( "VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eClosestHit ;
      return;
    }
    if( "AnyHit" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eAnyHit ;
      return;
    }
    if( "eAnyHit" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eAnyHit ;
      return;
    }
    if( "VK_SHADER_GROUP_SHADER_ANY_HIT_KHR" == j.get< std::string >() ) {
      p = ShaderGroupShaderKHR :: eAnyHit ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ShaderGroupShaderKHR" );
  }
  if( j.is_number() ) {
    p = ShaderGroupShaderKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ShaderGroupShaderKHR" );
}
inline void from_json( const nlohmann::json &j, VkShaderGroupShaderKHR &p ) {
  ShaderGroupShaderKHR temp;
  from_json( j, temp );
  p = VkShaderGroupShaderKHR ( temp );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const FormatFeatureFlagBits &p ) {
  if( FormatFeatureFlagBits :: eSampledImage == p ) {
    j = "SampledImage";
    return;
  }
  if( FormatFeatureFlagBits :: eStorageImage == p ) {
    j = "StorageImage";
    return;
  }
  if( FormatFeatureFlagBits :: eStorageImageAtomic == p ) {
    j = "StorageImageAtomic";
    return;
  }
  if( FormatFeatureFlagBits :: eUniformTexelBuffer == p ) {
    j = "UniformTexelBuffer";
    return;
  }
  if( FormatFeatureFlagBits :: eStorageTexelBuffer == p ) {
    j = "StorageTexelBuffer";
    return;
  }
  if( FormatFeatureFlagBits :: eStorageTexelBufferAtomic == p ) {
    j = "StorageTexelBufferAtomic";
    return;
  }
  if( FormatFeatureFlagBits :: eVertexBuffer == p ) {
    j = "VertexBuffer";
    return;
  }
  if( FormatFeatureFlagBits :: eColorAttachment == p ) {
    j = "ColorAttachment";
    return;
  }
  if( FormatFeatureFlagBits :: eColorAttachmentBlend == p ) {
    j = "ColorAttachmentBlend";
    return;
  }
  if( FormatFeatureFlagBits :: eDepthStencilAttachment == p ) {
    j = "DepthStencilAttachment";
    return;
  }
  if( FormatFeatureFlagBits :: eBlitSrc == p ) {
    j = "BlitSrc";
    return;
  }
  if( FormatFeatureFlagBits :: eBlitDst == p ) {
    j = "BlitDst";
    return;
  }
  if( FormatFeatureFlagBits :: eSampledImageFilterLinear == p ) {
    j = "SampledImageFilterLinear";
    return;
  }
  if( FormatFeatureFlagBits :: eTransferSrc == p ) {
    j = "TransferSrc";
    return;
  }
  if( FormatFeatureFlagBits :: eTransferDst == p ) {
    j = "TransferDst";
    return;
  }
  if( FormatFeatureFlagBits :: eMidpointChromaSamples == p ) {
    j = "MidpointChromaSamples";
    return;
  }
  if( FormatFeatureFlagBits :: eSampledImageYcbcrConversionLinearFilter == p ) {
    j = "SampledImageYcbcrConversionLinearFilter";
    return;
  }
  if( FormatFeatureFlagBits :: eDisjoint == p ) {
    j = "Disjoint";
    return;
  }
  if( FormatFeatureFlagBits :: eCositedChromaSamples == p ) {
    j = "CositedChromaSamples";
    return;
  }
  if( FormatFeatureFlagBits :: eSampledImageFilterMinmax == p ) {
    j = "SampledImageFilterMinmax";
    return;
  }
  if( FormatFeatureFlagBits :: eSampledImageFilterCubicIMG == p ) {
    j = "SampledImageFilterCubicIMG";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( FormatFeatureFlagBits :: eVideoDecodeOutputKHR == p ) {
    j = "VideoDecodeOutputKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( FormatFeatureFlagBits :: eVideoDecodeDpbKHR == p ) {
    j = "VideoDecodeDpbKHR";
    return;
  }
#endif
  if( FormatFeatureFlagBits :: eAccelerationStructureVertexBufferKHR == p ) {
    j = "AccelerationStructureVertexBufferKHR";
    return;
  }
  if( FormatFeatureFlagBits :: eFragmentDensityMapEXT == p ) {
    j = "FragmentDensityMapEXT";
    return;
  }
  if( FormatFeatureFlagBits :: eFragmentShadingRateAttachmentKHR == p ) {
    j = "FragmentShadingRateAttachmentKHR";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( FormatFeatureFlagBits :: eVideoEncodeInputKHR == p ) {
    j = "VideoEncodeInputKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( FormatFeatureFlagBits :: eVideoEncodeDpbKHR == p ) {
    j = "VideoEncodeDpbKHR";
    return;
  }
#endif
  if( FormatFeatureFlagBits :: eCositedChromaSamplesKHR == p ) {
    j = "CositedChromaSamplesKHR";
    return;
  }
  if( FormatFeatureFlagBits :: eDisjointKHR == p ) {
    j = "DisjointKHR";
    return;
  }
  if( FormatFeatureFlagBits :: eMidpointChromaSamplesKHR == p ) {
    j = "MidpointChromaSamplesKHR";
    return;
  }
  if( FormatFeatureFlagBits :: eSampledImageFilterCubicEXT == p ) {
    j = "SampledImageFilterCubicEXT";
    return;
  }
  if( FormatFeatureFlagBits :: eSampledImageFilterMinmaxEXT == p ) {
    j = "SampledImageFilterMinmaxEXT";
    return;
  }
  if( FormatFeatureFlagBits :: eTransferDstKHR == p ) {
    j = "TransferDstKHR";
    return;
  }
}
inline void from_json( const nlohmann::json &j, FormatFeatureFlagBits &p ) {
  if( j.is_string() ) {
    if( "SampledImage" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImage ;
      return;
    }
    if( "eSampledImage" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImage ;
      return;
    }
    if( "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImage ;
      return;
    }
    if( "StorageImage" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eStorageImage ;
      return;
    }
    if( "eStorageImage" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eStorageImage ;
      return;
    }
    if( "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eStorageImage ;
      return;
    }
    if( "StorageImageAtomic" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eStorageImageAtomic ;
      return;
    }
    if( "eStorageImageAtomic" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eStorageImageAtomic ;
      return;
    }
    if( "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eStorageImageAtomic ;
      return;
    }
    if( "UniformTexelBuffer" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eUniformTexelBuffer ;
      return;
    }
    if( "eUniformTexelBuffer" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eUniformTexelBuffer ;
      return;
    }
    if( "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eUniformTexelBuffer ;
      return;
    }
    if( "StorageTexelBuffer" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eStorageTexelBuffer ;
      return;
    }
    if( "eStorageTexelBuffer" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eStorageTexelBuffer ;
      return;
    }
    if( "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eStorageTexelBuffer ;
      return;
    }
    if( "StorageTexelBufferAtomic" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eStorageTexelBufferAtomic ;
      return;
    }
    if( "eStorageTexelBufferAtomic" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eStorageTexelBufferAtomic ;
      return;
    }
    if( "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eStorageTexelBufferAtomic ;
      return;
    }
    if( "VertexBuffer" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVertexBuffer ;
      return;
    }
    if( "eVertexBuffer" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVertexBuffer ;
      return;
    }
    if( "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVertexBuffer ;
      return;
    }
    if( "ColorAttachment" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eColorAttachment ;
      return;
    }
    if( "eColorAttachment" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eColorAttachment ;
      return;
    }
    if( "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eColorAttachment ;
      return;
    }
    if( "ColorAttachmentBlend" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eColorAttachmentBlend ;
      return;
    }
    if( "eColorAttachmentBlend" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eColorAttachmentBlend ;
      return;
    }
    if( "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eColorAttachmentBlend ;
      return;
    }
    if( "DepthStencilAttachment" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eDepthStencilAttachment ;
      return;
    }
    if( "eDepthStencilAttachment" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eDepthStencilAttachment ;
      return;
    }
    if( "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eDepthStencilAttachment ;
      return;
    }
    if( "BlitSrc" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eBlitSrc ;
      return;
    }
    if( "eBlitSrc" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eBlitSrc ;
      return;
    }
    if( "VK_FORMAT_FEATURE_BLIT_SRC_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eBlitSrc ;
      return;
    }
    if( "BlitDst" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eBlitDst ;
      return;
    }
    if( "eBlitDst" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eBlitDst ;
      return;
    }
    if( "VK_FORMAT_FEATURE_BLIT_DST_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eBlitDst ;
      return;
    }
    if( "SampledImageFilterLinear" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterLinear ;
      return;
    }
    if( "eSampledImageFilterLinear" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterLinear ;
      return;
    }
    if( "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterLinear ;
      return;
    }
    if( "TransferSrc" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eTransferSrc ;
      return;
    }
    if( "eTransferSrc" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eTransferSrc ;
      return;
    }
    if( "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eTransferSrc ;
      return;
    }
    if( "TransferDst" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eTransferDst ;
      return;
    }
    if( "eTransferDst" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eTransferDst ;
      return;
    }
    if( "VK_FORMAT_FEATURE_TRANSFER_DST_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eTransferDst ;
      return;
    }
    if( "MidpointChromaSamples" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eMidpointChromaSamples ;
      return;
    }
    if( "eMidpointChromaSamples" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eMidpointChromaSamples ;
      return;
    }
    if( "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eMidpointChromaSamples ;
      return;
    }
    if( "SampledImageYcbcrConversionLinearFilter" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageYcbcrConversionLinearFilter ;
      return;
    }
    if( "eSampledImageYcbcrConversionLinearFilter" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageYcbcrConversionLinearFilter ;
      return;
    }
    if( "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageYcbcrConversionLinearFilter ;
      return;
    }
    if( "Disjoint" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eDisjoint ;
      return;
    }
    if( "eDisjoint" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eDisjoint ;
      return;
    }
    if( "VK_FORMAT_FEATURE_DISJOINT_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eDisjoint ;
      return;
    }
    if( "CositedChromaSamples" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eCositedChromaSamples ;
      return;
    }
    if( "eCositedChromaSamples" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eCositedChromaSamples ;
      return;
    }
    if( "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eCositedChromaSamples ;
      return;
    }
    if( "SampledImageFilterMinmax" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterMinmax ;
      return;
    }
    if( "eSampledImageFilterMinmax" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterMinmax ;
      return;
    }
    if( "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterMinmax ;
      return;
    }
    if( "SampledImageFilterCubicIMG" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterCubicIMG ;
      return;
    }
    if( "eSampledImageFilterCubicIMG" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterCubicIMG ;
      return;
    }
    if( "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterCubicIMG ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeOutputKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVideoDecodeOutputKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeOutputKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVideoDecodeOutputKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVideoDecodeOutputKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeDpbKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVideoDecodeDpbKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeDpbKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVideoDecodeDpbKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVideoDecodeDpbKHR ;
      return;
    }
#endif
    if( "AccelerationStructureVertexBufferKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eAccelerationStructureVertexBufferKHR ;
      return;
    }
    if( "eAccelerationStructureVertexBufferKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eAccelerationStructureVertexBufferKHR ;
      return;
    }
    if( "VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eAccelerationStructureVertexBufferKHR ;
      return;
    }
    if( "FragmentDensityMapEXT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eFragmentDensityMapEXT ;
      return;
    }
    if( "eFragmentDensityMapEXT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eFragmentDensityMapEXT ;
      return;
    }
    if( "VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eFragmentDensityMapEXT ;
      return;
    }
    if( "FragmentShadingRateAttachmentKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eFragmentShadingRateAttachmentKHR ;
      return;
    }
    if( "eFragmentShadingRateAttachmentKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eFragmentShadingRateAttachmentKHR ;
      return;
    }
    if( "VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eFragmentShadingRateAttachmentKHR ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeInputKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVideoEncodeInputKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeInputKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVideoEncodeInputKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVideoEncodeInputKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeDpbKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVideoEncodeDpbKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeDpbKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVideoEncodeDpbKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eVideoEncodeDpbKHR ;
      return;
    }
#endif
    if( "CositedChromaSamplesKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eCositedChromaSamplesKHR ;
      return;
    }
    if( "eCositedChromaSamplesKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eCositedChromaSamplesKHR ;
      return;
    }
    if( "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eCositedChromaSamplesKHR ;
      return;
    }
    if( "DisjointKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eDisjointKHR ;
      return;
    }
    if( "eDisjointKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eDisjointKHR ;
      return;
    }
    if( "VK_FORMAT_FEATURE_DISJOINT_BIT_KHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eDisjointKHR ;
      return;
    }
    if( "MidpointChromaSamplesKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eMidpointChromaSamplesKHR ;
      return;
    }
    if( "eMidpointChromaSamplesKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eMidpointChromaSamplesKHR ;
      return;
    }
    if( "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eMidpointChromaSamplesKHR ;
      return;
    }
    if( "SampledImageFilterCubicEXT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterCubicEXT ;
      return;
    }
    if( "eSampledImageFilterCubicEXT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterCubicEXT ;
      return;
    }
    if( "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterCubicEXT ;
      return;
    }
    if( "SampledImageFilterMinmaxEXT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterMinmaxEXT ;
      return;
    }
    if( "eSampledImageFilterMinmaxEXT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterMinmaxEXT ;
      return;
    }
    if( "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eSampledImageFilterMinmaxEXT ;
      return;
    }
    if( "TransferDstKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eTransferDstKHR ;
      return;
    }
    if( "eTransferDstKHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eTransferDstKHR ;
      return;
    }
    if( "VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR" == j.get< std::string >() ) {
      p = FormatFeatureFlagBits :: eTransferDstKHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for FormatFeatureFlagBits" );
  }
  if( j.is_number() ) {
    p = FormatFeatureFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FormatFeatureFlagBits" );
}
inline void to_json( nlohmann::json &j, const FormatFeatureFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( FormatFeatureFlagBits ) * 8u; ++n ) {
    if( p & FormatFeatureFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, FormatFeatureFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, FormatFeatureFlags &p ) {
  if( j.is_array() ) {
    p = FormatFeatureFlags ( 0 );
    for( auto &e:  j ) {
      FormatFeatureFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for FormatFeatureFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const ImageCreateFlagBits &p ) {
  if( ImageCreateFlagBits :: eSparseBinding == p ) {
    j = "SparseBinding";
    return;
  }
  if( ImageCreateFlagBits :: eSparseResidency == p ) {
    j = "SparseResidency";
    return;
  }
  if( ImageCreateFlagBits :: eSparseAliased == p ) {
    j = "SparseAliased";
    return;
  }
  if( ImageCreateFlagBits :: eMutableFormat == p ) {
    j = "MutableFormat";
    return;
  }
  if( ImageCreateFlagBits :: eCubeCompatible == p ) {
    j = "CubeCompatible";
    return;
  }
  if( ImageCreateFlagBits :: eAlias == p ) {
    j = "Alias";
    return;
  }
  if( ImageCreateFlagBits :: eSplitInstanceBindRegions == p ) {
    j = "SplitInstanceBindRegions";
    return;
  }
  if( ImageCreateFlagBits :: e2DArrayCompatible == p ) {
    j = "2DArrayCompatible";
    return;
  }
  if( ImageCreateFlagBits :: eBlockTexelViewCompatible == p ) {
    j = "BlockTexelViewCompatible";
    return;
  }
  if( ImageCreateFlagBits :: eExtendedUsage == p ) {
    j = "ExtendedUsage";
    return;
  }
  if( ImageCreateFlagBits :: eProtected == p ) {
    j = "Protected";
    return;
  }
  if( ImageCreateFlagBits :: eDisjoint == p ) {
    j = "Disjoint";
    return;
  }
  if( ImageCreateFlagBits :: eCornerSampledNV == p ) {
    j = "CornerSampledNV";
    return;
  }
  if( ImageCreateFlagBits :: eSampleLocationsCompatibleDepthEXT == p ) {
    j = "SampleLocationsCompatibleDepthEXT";
    return;
  }
  if( ImageCreateFlagBits :: eSubsampledEXT == p ) {
    j = "SubsampledEXT";
    return;
  }
  if( ImageCreateFlagBits :: e2DArrayCompatibleKHR == p ) {
    j = "2DArrayCompatibleKHR";
    return;
  }
  if( ImageCreateFlagBits :: eAliasKHR == p ) {
    j = "AliasKHR";
    return;
  }
  if( ImageCreateFlagBits :: eBlockTexelViewCompatibleKHR == p ) {
    j = "BlockTexelViewCompatibleKHR";
    return;
  }
  if( ImageCreateFlagBits :: eDisjointKHR == p ) {
    j = "DisjointKHR";
    return;
  }
  if( ImageCreateFlagBits :: eExtendedUsageKHR == p ) {
    j = "ExtendedUsageKHR";
    return;
  }
}
inline void from_json( const nlohmann::json &j, ImageCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "SparseBinding" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseBinding ;
      return;
    }
    if( "eSparseBinding" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseBinding ;
      return;
    }
    if( "VK_IMAGE_CREATE_SPARSE_BINDING_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseBinding ;
      return;
    }
    if( "SparseResidency" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseResidency ;
      return;
    }
    if( "eSparseResidency" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseResidency ;
      return;
    }
    if( "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseResidency ;
      return;
    }
    if( "SparseAliased" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseAliased ;
      return;
    }
    if( "eSparseAliased" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseAliased ;
      return;
    }
    if( "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSparseAliased ;
      return;
    }
    if( "MutableFormat" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eMutableFormat ;
      return;
    }
    if( "eMutableFormat" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eMutableFormat ;
      return;
    }
    if( "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eMutableFormat ;
      return;
    }
    if( "CubeCompatible" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eCubeCompatible ;
      return;
    }
    if( "eCubeCompatible" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eCubeCompatible ;
      return;
    }
    if( "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eCubeCompatible ;
      return;
    }
    if( "Alias" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eAlias ;
      return;
    }
    if( "eAlias" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eAlias ;
      return;
    }
    if( "VK_IMAGE_CREATE_ALIAS_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eAlias ;
      return;
    }
    if( "SplitInstanceBindRegions" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSplitInstanceBindRegions ;
      return;
    }
    if( "eSplitInstanceBindRegions" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSplitInstanceBindRegions ;
      return;
    }
    if( "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSplitInstanceBindRegions ;
      return;
    }
    if( "2DArrayCompatible" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: e2DArrayCompatible ;
      return;
    }
    if( "e2DArrayCompatible" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: e2DArrayCompatible ;
      return;
    }
    if( "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: e2DArrayCompatible ;
      return;
    }
    if( "BlockTexelViewCompatible" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eBlockTexelViewCompatible ;
      return;
    }
    if( "eBlockTexelViewCompatible" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eBlockTexelViewCompatible ;
      return;
    }
    if( "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eBlockTexelViewCompatible ;
      return;
    }
    if( "ExtendedUsage" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eExtendedUsage ;
      return;
    }
    if( "eExtendedUsage" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eExtendedUsage ;
      return;
    }
    if( "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eExtendedUsage ;
      return;
    }
    if( "Protected" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eProtected ;
      return;
    }
    if( "eProtected" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eProtected ;
      return;
    }
    if( "VK_IMAGE_CREATE_PROTECTED_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eProtected ;
      return;
    }
    if( "Disjoint" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eDisjoint ;
      return;
    }
    if( "eDisjoint" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eDisjoint ;
      return;
    }
    if( "VK_IMAGE_CREATE_DISJOINT_BIT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eDisjoint ;
      return;
    }
    if( "CornerSampledNV" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eCornerSampledNV ;
      return;
    }
    if( "eCornerSampledNV" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eCornerSampledNV ;
      return;
    }
    if( "VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eCornerSampledNV ;
      return;
    }
    if( "SampleLocationsCompatibleDepthEXT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSampleLocationsCompatibleDepthEXT ;
      return;
    }
    if( "eSampleLocationsCompatibleDepthEXT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSampleLocationsCompatibleDepthEXT ;
      return;
    }
    if( "VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSampleLocationsCompatibleDepthEXT ;
      return;
    }
    if( "SubsampledEXT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSubsampledEXT ;
      return;
    }
    if( "eSubsampledEXT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSubsampledEXT ;
      return;
    }
    if( "VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eSubsampledEXT ;
      return;
    }
    if( "2DArrayCompatibleKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: e2DArrayCompatibleKHR ;
      return;
    }
    if( "e2DArrayCompatibleKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: e2DArrayCompatibleKHR ;
      return;
    }
    if( "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: e2DArrayCompatibleKHR ;
      return;
    }
    if( "AliasKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eAliasKHR ;
      return;
    }
    if( "eAliasKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eAliasKHR ;
      return;
    }
    if( "VK_IMAGE_CREATE_ALIAS_BIT_KHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eAliasKHR ;
      return;
    }
    if( "BlockTexelViewCompatibleKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eBlockTexelViewCompatibleKHR ;
      return;
    }
    if( "eBlockTexelViewCompatibleKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eBlockTexelViewCompatibleKHR ;
      return;
    }
    if( "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eBlockTexelViewCompatibleKHR ;
      return;
    }
    if( "DisjointKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eDisjointKHR ;
      return;
    }
    if( "eDisjointKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eDisjointKHR ;
      return;
    }
    if( "VK_IMAGE_CREATE_DISJOINT_BIT_KHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eDisjointKHR ;
      return;
    }
    if( "ExtendedUsageKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eExtendedUsageKHR ;
      return;
    }
    if( "eExtendedUsageKHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eExtendedUsageKHR ;
      return;
    }
    if( "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR" == j.get< std::string >() ) {
      p = ImageCreateFlagBits :: eExtendedUsageKHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImageCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = ImageCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImageCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const ImageCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ImageCreateFlagBits ) * 8u; ++n ) {
    if( p & ImageCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ImageCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ImageCreateFlags &p ) {
  if( j.is_array() ) {
    p = ImageCreateFlags ( 0 );
    for( auto &e:  j ) {
      ImageCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ImageCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const ImageUsageFlagBits &p ) {
  if( ImageUsageFlagBits :: eTransferSrc == p ) {
    j = "TransferSrc";
    return;
  }
  if( ImageUsageFlagBits :: eTransferDst == p ) {
    j = "TransferDst";
    return;
  }
  if( ImageUsageFlagBits :: eSampled == p ) {
    j = "Sampled";
    return;
  }
  if( ImageUsageFlagBits :: eStorage == p ) {
    j = "Storage";
    return;
  }
  if( ImageUsageFlagBits :: eColorAttachment == p ) {
    j = "ColorAttachment";
    return;
  }
  if( ImageUsageFlagBits :: eDepthStencilAttachment == p ) {
    j = "DepthStencilAttachment";
    return;
  }
  if( ImageUsageFlagBits :: eTransientAttachment == p ) {
    j = "TransientAttachment";
    return;
  }
  if( ImageUsageFlagBits :: eInputAttachment == p ) {
    j = "InputAttachment";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( ImageUsageFlagBits :: eVideoDecodeDstKHR == p ) {
    j = "VideoDecodeDstKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( ImageUsageFlagBits :: eVideoDecodeSrcKHR == p ) {
    j = "VideoDecodeSrcKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( ImageUsageFlagBits :: eVideoDecodeDpbKHR == p ) {
    j = "VideoDecodeDpbKHR";
    return;
  }
#endif
  if( ImageUsageFlagBits :: eFragmentDensityMapEXT == p ) {
    j = "FragmentDensityMapEXT";
    return;
  }
  if( ImageUsageFlagBits :: eFragmentShadingRateAttachmentKHR == p ) {
    j = "FragmentShadingRateAttachmentKHR";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( ImageUsageFlagBits :: eVideoEncodeDstKHR == p ) {
    j = "VideoEncodeDstKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( ImageUsageFlagBits :: eVideoEncodeSrcKHR == p ) {
    j = "VideoEncodeSrcKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( ImageUsageFlagBits :: eVideoEncodeDpbKHR == p ) {
    j = "VideoEncodeDpbKHR";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, ImageUsageFlagBits &p ) {
  if( j.is_string() ) {
    if( "TransferSrc" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eTransferSrc ;
      return;
    }
    if( "eTransferSrc" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eTransferSrc ;
      return;
    }
    if( "VK_IMAGE_USAGE_TRANSFER_SRC_BIT" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eTransferSrc ;
      return;
    }
    if( "TransferDst" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eTransferDst ;
      return;
    }
    if( "eTransferDst" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eTransferDst ;
      return;
    }
    if( "VK_IMAGE_USAGE_TRANSFER_DST_BIT" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eTransferDst ;
      return;
    }
    if( "Sampled" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eSampled ;
      return;
    }
    if( "eSampled" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eSampled ;
      return;
    }
    if( "VK_IMAGE_USAGE_SAMPLED_BIT" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eSampled ;
      return;
    }
    if( "Storage" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eStorage ;
      return;
    }
    if( "eStorage" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eStorage ;
      return;
    }
    if( "VK_IMAGE_USAGE_STORAGE_BIT" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eStorage ;
      return;
    }
    if( "ColorAttachment" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eColorAttachment ;
      return;
    }
    if( "eColorAttachment" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eColorAttachment ;
      return;
    }
    if( "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eColorAttachment ;
      return;
    }
    if( "DepthStencilAttachment" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eDepthStencilAttachment ;
      return;
    }
    if( "eDepthStencilAttachment" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eDepthStencilAttachment ;
      return;
    }
    if( "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eDepthStencilAttachment ;
      return;
    }
    if( "TransientAttachment" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eTransientAttachment ;
      return;
    }
    if( "eTransientAttachment" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eTransientAttachment ;
      return;
    }
    if( "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eTransientAttachment ;
      return;
    }
    if( "InputAttachment" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eInputAttachment ;
      return;
    }
    if( "eInputAttachment" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eInputAttachment ;
      return;
    }
    if( "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eInputAttachment ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeDstKHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoDecodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeDstKHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoDecodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoDecodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeSrcKHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoDecodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeSrcKHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoDecodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoDecodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeDpbKHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoDecodeDpbKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeDpbKHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoDecodeDpbKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoDecodeDpbKHR ;
      return;
    }
#endif
    if( "FragmentDensityMapEXT" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eFragmentDensityMapEXT ;
      return;
    }
    if( "eFragmentDensityMapEXT" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eFragmentDensityMapEXT ;
      return;
    }
    if( "VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eFragmentDensityMapEXT ;
      return;
    }
    if( "FragmentShadingRateAttachmentKHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eFragmentShadingRateAttachmentKHR ;
      return;
    }
    if( "eFragmentShadingRateAttachmentKHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eFragmentShadingRateAttachmentKHR ;
      return;
    }
    if( "VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eFragmentShadingRateAttachmentKHR ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeDstKHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoEncodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeDstKHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoEncodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoEncodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeSrcKHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoEncodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeSrcKHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoEncodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoEncodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeDpbKHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoEncodeDpbKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeDpbKHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoEncodeDpbKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR" == j.get< std::string >() ) {
      p = ImageUsageFlagBits :: eVideoEncodeDpbKHR ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImageUsageFlagBits" );
  }
  if( j.is_number() ) {
    p = ImageUsageFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImageUsageFlagBits" );
}
inline void to_json( nlohmann::json &j, const ImageUsageFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ImageUsageFlagBits ) * 8u; ++n ) {
    if( p & ImageUsageFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ImageUsageFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ImageUsageFlags &p ) {
  if( j.is_array() ) {
    p = ImageUsageFlags ( 0 );
    for( auto &e:  j ) {
      ImageUsageFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ImageUsageFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const MemoryHeapFlagBits &p ) {
  if( MemoryHeapFlagBits :: eDeviceLocal == p ) {
    j = "DeviceLocal";
    return;
  }
  if( MemoryHeapFlagBits :: eMultiInstance == p ) {
    j = "MultiInstance";
    return;
  }
}
inline void from_json( const nlohmann::json &j, MemoryHeapFlagBits &p ) {
  if( j.is_string() ) {
    if( "DeviceLocal" == j.get< std::string >() ) {
      p = MemoryHeapFlagBits :: eDeviceLocal ;
      return;
    }
    if( "eDeviceLocal" == j.get< std::string >() ) {
      p = MemoryHeapFlagBits :: eDeviceLocal ;
      return;
    }
    if( "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT" == j.get< std::string >() ) {
      p = MemoryHeapFlagBits :: eDeviceLocal ;
      return;
    }
    if( "MultiInstance" == j.get< std::string >() ) {
      p = MemoryHeapFlagBits :: eMultiInstance ;
      return;
    }
    if( "eMultiInstance" == j.get< std::string >() ) {
      p = MemoryHeapFlagBits :: eMultiInstance ;
      return;
    }
    if( "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT" == j.get< std::string >() ) {
      p = MemoryHeapFlagBits :: eMultiInstance ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for MemoryHeapFlagBits" );
  }
  if( j.is_number() ) {
    p = MemoryHeapFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for MemoryHeapFlagBits" );
}
inline void to_json( nlohmann::json &j, const MemoryHeapFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( MemoryHeapFlagBits ) * 8u; ++n ) {
    if( p & MemoryHeapFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, MemoryHeapFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, MemoryHeapFlags &p ) {
  if( j.is_array() ) {
    p = MemoryHeapFlags ( 0 );
    for( auto &e:  j ) {
      MemoryHeapFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for MemoryHeapFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const MemoryPropertyFlagBits &p ) {
  if( MemoryPropertyFlagBits :: eDeviceLocal == p ) {
    j = "DeviceLocal";
    return;
  }
  if( MemoryPropertyFlagBits :: eHostVisible == p ) {
    j = "HostVisible";
    return;
  }
  if( MemoryPropertyFlagBits :: eHostCoherent == p ) {
    j = "HostCoherent";
    return;
  }
  if( MemoryPropertyFlagBits :: eHostCached == p ) {
    j = "HostCached";
    return;
  }
  if( MemoryPropertyFlagBits :: eLazilyAllocated == p ) {
    j = "LazilyAllocated";
    return;
  }
  if( MemoryPropertyFlagBits :: eProtected == p ) {
    j = "Protected";
    return;
  }
  if( MemoryPropertyFlagBits :: eDeviceCoherentAMD == p ) {
    j = "DeviceCoherentAMD";
    return;
  }
}
inline void from_json( const nlohmann::json &j, MemoryPropertyFlagBits &p ) {
  if( j.is_string() ) {
    if( "DeviceLocal" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eDeviceLocal ;
      return;
    }
    if( "eDeviceLocal" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eDeviceLocal ;
      return;
    }
    if( "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eDeviceLocal ;
      return;
    }
    if( "HostVisible" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostVisible ;
      return;
    }
    if( "eHostVisible" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostVisible ;
      return;
    }
    if( "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostVisible ;
      return;
    }
    if( "HostCoherent" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostCoherent ;
      return;
    }
    if( "eHostCoherent" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostCoherent ;
      return;
    }
    if( "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostCoherent ;
      return;
    }
    if( "HostCached" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostCached ;
      return;
    }
    if( "eHostCached" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostCached ;
      return;
    }
    if( "VK_MEMORY_PROPERTY_HOST_CACHED_BIT" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eHostCached ;
      return;
    }
    if( "LazilyAllocated" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eLazilyAllocated ;
      return;
    }
    if( "eLazilyAllocated" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eLazilyAllocated ;
      return;
    }
    if( "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eLazilyAllocated ;
      return;
    }
    if( "Protected" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eProtected ;
      return;
    }
    if( "eProtected" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eProtected ;
      return;
    }
    if( "VK_MEMORY_PROPERTY_PROTECTED_BIT" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eProtected ;
      return;
    }
    if( "DeviceCoherentAMD" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eDeviceCoherentAMD ;
      return;
    }
    if( "eDeviceCoherentAMD" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eDeviceCoherentAMD ;
      return;
    }
    if( "VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD" == j.get< std::string >() ) {
      p = MemoryPropertyFlagBits :: eDeviceCoherentAMD ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for MemoryPropertyFlagBits" );
  }
  if( j.is_number() ) {
    p = MemoryPropertyFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for MemoryPropertyFlagBits" );
}
inline void to_json( nlohmann::json &j, const MemoryPropertyFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( MemoryPropertyFlagBits ) * 8u; ++n ) {
    if( p & MemoryPropertyFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, MemoryPropertyFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, MemoryPropertyFlags &p ) {
  if( j.is_array() ) {
    p = MemoryPropertyFlags ( 0 );
    for( auto &e:  j ) {
      MemoryPropertyFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for MemoryPropertyFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const QueueFlagBits &p ) {
  if( QueueFlagBits :: eGraphics == p ) {
    j = "Graphics";
    return;
  }
  if( QueueFlagBits :: eCompute == p ) {
    j = "Compute";
    return;
  }
  if( QueueFlagBits :: eTransfer == p ) {
    j = "Transfer";
    return;
  }
  if( QueueFlagBits :: eSparseBinding == p ) {
    j = "SparseBinding";
    return;
  }
  if( QueueFlagBits :: eProtected == p ) {
    j = "Protected";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( QueueFlagBits :: eVideoDecodeKHR == p ) {
    j = "VideoDecodeKHR";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, QueueFlagBits &p ) {
  if( j.is_string() ) {
    if( "Graphics" == j.get< std::string >() ) {
      p = QueueFlagBits :: eGraphics ;
      return;
    }
    if( "eGraphics" == j.get< std::string >() ) {
      p = QueueFlagBits :: eGraphics ;
      return;
    }
    if( "VK_QUEUE_GRAPHICS_BIT" == j.get< std::string >() ) {
      p = QueueFlagBits :: eGraphics ;
      return;
    }
    if( "Compute" == j.get< std::string >() ) {
      p = QueueFlagBits :: eCompute ;
      return;
    }
    if( "eCompute" == j.get< std::string >() ) {
      p = QueueFlagBits :: eCompute ;
      return;
    }
    if( "VK_QUEUE_COMPUTE_BIT" == j.get< std::string >() ) {
      p = QueueFlagBits :: eCompute ;
      return;
    }
    if( "Transfer" == j.get< std::string >() ) {
      p = QueueFlagBits :: eTransfer ;
      return;
    }
    if( "eTransfer" == j.get< std::string >() ) {
      p = QueueFlagBits :: eTransfer ;
      return;
    }
    if( "VK_QUEUE_TRANSFER_BIT" == j.get< std::string >() ) {
      p = QueueFlagBits :: eTransfer ;
      return;
    }
    if( "SparseBinding" == j.get< std::string >() ) {
      p = QueueFlagBits :: eSparseBinding ;
      return;
    }
    if( "eSparseBinding" == j.get< std::string >() ) {
      p = QueueFlagBits :: eSparseBinding ;
      return;
    }
    if( "VK_QUEUE_SPARSE_BINDING_BIT" == j.get< std::string >() ) {
      p = QueueFlagBits :: eSparseBinding ;
      return;
    }
    if( "Protected" == j.get< std::string >() ) {
      p = QueueFlagBits :: eProtected ;
      return;
    }
    if( "eProtected" == j.get< std::string >() ) {
      p = QueueFlagBits :: eProtected ;
      return;
    }
    if( "VK_QUEUE_PROTECTED_BIT" == j.get< std::string >() ) {
      p = QueueFlagBits :: eProtected ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeKHR" == j.get< std::string >() ) {
      p = QueueFlagBits :: eVideoDecodeKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeKHR" == j.get< std::string >() ) {
      p = QueueFlagBits :: eVideoDecodeKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_QUEUE_VIDEO_DECODE_BIT_KHR" == j.get< std::string >() ) {
      p = QueueFlagBits :: eVideoDecodeKHR ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueueFlagBits" );
  }
  if( j.is_number() ) {
    p = QueueFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueueFlagBits" );
}
inline void to_json( nlohmann::json &j, const QueueFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( QueueFlagBits ) * 8u; ++n ) {
    if( p & QueueFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, QueueFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, QueueFlags &p ) {
  if( j.is_array() ) {
    p = QueueFlags ( 0 );
    for( auto &e:  j ) {
      QueueFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for QueueFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const SampleCountFlagBits &p ) {
  if( SampleCountFlagBits :: e1 == p ) {
    j = "1";
    return;
  }
  if( SampleCountFlagBits :: e2 == p ) {
    j = "2";
    return;
  }
  if( SampleCountFlagBits :: e4 == p ) {
    j = "4";
    return;
  }
  if( SampleCountFlagBits :: e8 == p ) {
    j = "8";
    return;
  }
  if( SampleCountFlagBits :: e16 == p ) {
    j = "16";
    return;
  }
  if( SampleCountFlagBits :: e32 == p ) {
    j = "32";
    return;
  }
}
inline void from_json( const nlohmann::json &j, SampleCountFlagBits &p ) {
  if( j.is_string() ) {
    if( "1" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e1 ;
      return;
    }
    if( "e1" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e1 ;
      return;
    }
    if( "VK_SAMPLE_COUNT_1_BIT" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e1 ;
      return;
    }
    if( "2" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e2 ;
      return;
    }
    if( "e2" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e2 ;
      return;
    }
    if( "VK_SAMPLE_COUNT_2_BIT" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e2 ;
      return;
    }
    if( "4" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e4 ;
      return;
    }
    if( "e4" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e4 ;
      return;
    }
    if( "VK_SAMPLE_COUNT_4_BIT" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e4 ;
      return;
    }
    if( "8" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e8 ;
      return;
    }
    if( "e8" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e8 ;
      return;
    }
    if( "VK_SAMPLE_COUNT_8_BIT" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e8 ;
      return;
    }
    if( "16" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e16 ;
      return;
    }
    if( "e16" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e16 ;
      return;
    }
    if( "VK_SAMPLE_COUNT_16_BIT" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e16 ;
      return;
    }
    if( "32" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e32 ;
      return;
    }
    if( "e32" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e32 ;
      return;
    }
    if( "VK_SAMPLE_COUNT_32_BIT" == j.get< std::string >() ) {
      p = SampleCountFlagBits :: e32 ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SampleCountFlagBits" );
  }
  if( j.is_number() ) {
    p = SampleCountFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SampleCountFlagBits" );
}
inline void to_json( nlohmann::json &j, const SampleCountFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SampleCountFlagBits ) * 8u; ++n ) {
    if( p & SampleCountFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SampleCountFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, SampleCountFlags &p ) {
  if( j.is_array() ) {
    p = SampleCountFlags ( 0 );
    for( auto &e:  j ) {
      SampleCountFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SampleCountFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const DeviceQueueCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, DeviceQueueCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DeviceQueueCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = DeviceQueueCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DeviceQueueCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const DeviceQueueCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DeviceQueueCreateFlagBits ) * 8u; ++n ) {
    if( p & DeviceQueueCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DeviceQueueCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DeviceQueueCreateFlags &p ) {
  if( j.is_array() ) {
    p = DeviceQueueCreateFlags ( 0 );
    for( auto &e:  j ) {
      DeviceQueueCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DeviceQueueCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineStageFlagBits &p ) {
  if( PipelineStageFlagBits :: eTopOfPipe == p ) {
    j = "TopOfPipe";
    return;
  }
  if( PipelineStageFlagBits :: eDrawIndirect == p ) {
    j = "DrawIndirect";
    return;
  }
  if( PipelineStageFlagBits :: eVertexInput == p ) {
    j = "VertexInput";
    return;
  }
  if( PipelineStageFlagBits :: eVertexShader == p ) {
    j = "VertexShader";
    return;
  }
  if( PipelineStageFlagBits :: eTessellationControlShader == p ) {
    j = "TessellationControlShader";
    return;
  }
  if( PipelineStageFlagBits :: eTessellationEvaluationShader == p ) {
    j = "TessellationEvaluationShader";
    return;
  }
  if( PipelineStageFlagBits :: eGeometryShader == p ) {
    j = "GeometryShader";
    return;
  }
  if( PipelineStageFlagBits :: eFragmentShader == p ) {
    j = "FragmentShader";
    return;
  }
  if( PipelineStageFlagBits :: eEarlyFragmentTests == p ) {
    j = "EarlyFragmentTests";
    return;
  }
  if( PipelineStageFlagBits :: eLateFragmentTests == p ) {
    j = "LateFragmentTests";
    return;
  }
  if( PipelineStageFlagBits :: eColorAttachmentOutput == p ) {
    j = "ColorAttachmentOutput";
    return;
  }
  if( PipelineStageFlagBits :: eComputeShader == p ) {
    j = "ComputeShader";
    return;
  }
  if( PipelineStageFlagBits :: eTransfer == p ) {
    j = "Transfer";
    return;
  }
  if( PipelineStageFlagBits :: eBottomOfPipe == p ) {
    j = "BottomOfPipe";
    return;
  }
  if( PipelineStageFlagBits :: eHost == p ) {
    j = "Host";
    return;
  }
  if( PipelineStageFlagBits :: eAllGraphics == p ) {
    j = "AllGraphics";
    return;
  }
  if( PipelineStageFlagBits :: eAllCommands == p ) {
    j = "AllCommands";
    return;
  }
  if( PipelineStageFlagBits :: eTransformFeedbackEXT == p ) {
    j = "TransformFeedbackEXT";
    return;
  }
  if( PipelineStageFlagBits :: eConditionalRenderingEXT == p ) {
    j = "ConditionalRenderingEXT";
    return;
  }
  if( PipelineStageFlagBits :: eAccelerationStructureBuildKHR == p ) {
    j = "AccelerationStructureBuildKHR";
    return;
  }
  if( PipelineStageFlagBits :: eRayTracingShaderKHR == p ) {
    j = "RayTracingShaderKHR";
    return;
  }
  if( PipelineStageFlagBits :: eTaskShaderNV == p ) {
    j = "TaskShaderNV";
    return;
  }
  if( PipelineStageFlagBits :: eMeshShaderNV == p ) {
    j = "MeshShaderNV";
    return;
  }
  if( PipelineStageFlagBits :: eFragmentDensityProcessEXT == p ) {
    j = "FragmentDensityProcessEXT";
    return;
  }
  if( PipelineStageFlagBits :: eFragmentShadingRateAttachmentKHR == p ) {
    j = "FragmentShadingRateAttachmentKHR";
    return;
  }
  if( PipelineStageFlagBits :: eCommandPreprocessNV == p ) {
    j = "CommandPreprocessNV";
    return;
  }
  if( PipelineStageFlagBits :: eNoneKHR == p ) {
    j = "NoneKHR";
    return;
  }
  if( PipelineStageFlagBits :: eAccelerationStructureBuildNV == p ) {
    j = "AccelerationStructureBuildNV";
    return;
  }
  if( PipelineStageFlagBits :: eRayTracingShaderNV == p ) {
    j = "RayTracingShaderNV";
    return;
  }
}
inline void from_json( const nlohmann::json &j, PipelineStageFlagBits &p ) {
  if( j.is_string() ) {
    if( "TopOfPipe" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTopOfPipe ;
      return;
    }
    if( "eTopOfPipe" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTopOfPipe ;
      return;
    }
    if( "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTopOfPipe ;
      return;
    }
    if( "DrawIndirect" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eDrawIndirect ;
      return;
    }
    if( "eDrawIndirect" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eDrawIndirect ;
      return;
    }
    if( "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eDrawIndirect ;
      return;
    }
    if( "VertexInput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eVertexInput ;
      return;
    }
    if( "eVertexInput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eVertexInput ;
      return;
    }
    if( "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eVertexInput ;
      return;
    }
    if( "VertexShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eVertexShader ;
      return;
    }
    if( "eVertexShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eVertexShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eVertexShader ;
      return;
    }
    if( "TessellationControlShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTessellationControlShader ;
      return;
    }
    if( "eTessellationControlShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTessellationControlShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTessellationControlShader ;
      return;
    }
    if( "TessellationEvaluationShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTessellationEvaluationShader ;
      return;
    }
    if( "eTessellationEvaluationShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTessellationEvaluationShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTessellationEvaluationShader ;
      return;
    }
    if( "GeometryShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eGeometryShader ;
      return;
    }
    if( "eGeometryShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eGeometryShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eGeometryShader ;
      return;
    }
    if( "FragmentShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentShader ;
      return;
    }
    if( "eFragmentShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentShader ;
      return;
    }
    if( "EarlyFragmentTests" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eEarlyFragmentTests ;
      return;
    }
    if( "eEarlyFragmentTests" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eEarlyFragmentTests ;
      return;
    }
    if( "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eEarlyFragmentTests ;
      return;
    }
    if( "LateFragmentTests" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eLateFragmentTests ;
      return;
    }
    if( "eLateFragmentTests" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eLateFragmentTests ;
      return;
    }
    if( "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eLateFragmentTests ;
      return;
    }
    if( "ColorAttachmentOutput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eColorAttachmentOutput ;
      return;
    }
    if( "eColorAttachmentOutput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eColorAttachmentOutput ;
      return;
    }
    if( "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eColorAttachmentOutput ;
      return;
    }
    if( "ComputeShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eComputeShader ;
      return;
    }
    if( "eComputeShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eComputeShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eComputeShader ;
      return;
    }
    if( "Transfer" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTransfer ;
      return;
    }
    if( "eTransfer" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTransfer ;
      return;
    }
    if( "VK_PIPELINE_STAGE_TRANSFER_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTransfer ;
      return;
    }
    if( "BottomOfPipe" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eBottomOfPipe ;
      return;
    }
    if( "eBottomOfPipe" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eBottomOfPipe ;
      return;
    }
    if( "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eBottomOfPipe ;
      return;
    }
    if( "Host" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eHost ;
      return;
    }
    if( "eHost" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eHost ;
      return;
    }
    if( "VK_PIPELINE_STAGE_HOST_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eHost ;
      return;
    }
    if( "AllGraphics" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAllGraphics ;
      return;
    }
    if( "eAllGraphics" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAllGraphics ;
      return;
    }
    if( "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAllGraphics ;
      return;
    }
    if( "AllCommands" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAllCommands ;
      return;
    }
    if( "eAllCommands" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAllCommands ;
      return;
    }
    if( "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAllCommands ;
      return;
    }
    if( "TransformFeedbackEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTransformFeedbackEXT ;
      return;
    }
    if( "eTransformFeedbackEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTransformFeedbackEXT ;
      return;
    }
    if( "VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTransformFeedbackEXT ;
      return;
    }
    if( "ConditionalRenderingEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eConditionalRenderingEXT ;
      return;
    }
    if( "eConditionalRenderingEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eConditionalRenderingEXT ;
      return;
    }
    if( "VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eConditionalRenderingEXT ;
      return;
    }
    if( "AccelerationStructureBuildKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAccelerationStructureBuildKHR ;
      return;
    }
    if( "eAccelerationStructureBuildKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAccelerationStructureBuildKHR ;
      return;
    }
    if( "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAccelerationStructureBuildKHR ;
      return;
    }
    if( "RayTracingShaderKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eRayTracingShaderKHR ;
      return;
    }
    if( "eRayTracingShaderKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eRayTracingShaderKHR ;
      return;
    }
    if( "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eRayTracingShaderKHR ;
      return;
    }
    if( "TaskShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTaskShaderNV ;
      return;
    }
    if( "eTaskShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTaskShaderNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eTaskShaderNV ;
      return;
    }
    if( "MeshShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eMeshShaderNV ;
      return;
    }
    if( "eMeshShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eMeshShaderNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eMeshShaderNV ;
      return;
    }
    if( "FragmentDensityProcessEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentDensityProcessEXT ;
      return;
    }
    if( "eFragmentDensityProcessEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentDensityProcessEXT ;
      return;
    }
    if( "VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentDensityProcessEXT ;
      return;
    }
    if( "FragmentShadingRateAttachmentKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentShadingRateAttachmentKHR ;
      return;
    }
    if( "eFragmentShadingRateAttachmentKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentShadingRateAttachmentKHR ;
      return;
    }
    if( "VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eFragmentShadingRateAttachmentKHR ;
      return;
    }
    if( "CommandPreprocessNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eCommandPreprocessNV ;
      return;
    }
    if( "eCommandPreprocessNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eCommandPreprocessNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eCommandPreprocessNV ;
      return;
    }
    if( "NoneKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eNoneKHR ;
      return;
    }
    if( "eNoneKHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eNoneKHR ;
      return;
    }
    if( "VK_PIPELINE_STAGE_NONE_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eNoneKHR ;
      return;
    }
    if( "AccelerationStructureBuildNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAccelerationStructureBuildNV ;
      return;
    }
    if( "eAccelerationStructureBuildNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAccelerationStructureBuildNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eAccelerationStructureBuildNV ;
      return;
    }
    if( "RayTracingShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eRayTracingShaderNV ;
      return;
    }
    if( "eRayTracingShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eRayTracingShaderNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits :: eRayTracingShaderNV ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineStageFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineStageFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineStageFlagBits" );
}
inline void to_json( nlohmann::json &j, const PipelineStageFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineStageFlagBits ) * 8u; ++n ) {
    if( p & PipelineStageFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineStageFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineStageFlags &p ) {
  if( j.is_array() ) {
    p = PipelineStageFlags ( 0 );
    for( auto &e:  j ) {
      PipelineStageFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineStageFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const ImageAspectFlagBits &p ) {
  if( ImageAspectFlagBits :: eColor == p ) {
    j = "Color";
    return;
  }
  if( ImageAspectFlagBits :: eDepth == p ) {
    j = "Depth";
    return;
  }
  if( ImageAspectFlagBits :: eStencil == p ) {
    j = "Stencil";
    return;
  }
  if( ImageAspectFlagBits :: eMetadata == p ) {
    j = "Metadata";
    return;
  }
  if( ImageAspectFlagBits :: ePlane0 == p ) {
    j = "Plane0";
    return;
  }
  if( ImageAspectFlagBits :: ePlane1 == p ) {
    j = "Plane1";
    return;
  }
  if( ImageAspectFlagBits :: ePlane2 == p ) {
    j = "Plane2";
    return;
  }
  if( ImageAspectFlagBits :: eMemoryPlane0EXT == p ) {
    j = "MemoryPlane0EXT";
    return;
  }
  if( ImageAspectFlagBits :: eMemoryPlane1EXT == p ) {
    j = "MemoryPlane1EXT";
    return;
  }
  if( ImageAspectFlagBits :: eMemoryPlane2EXT == p ) {
    j = "MemoryPlane2EXT";
    return;
  }
  if( ImageAspectFlagBits :: eMemoryPlane3EXT == p ) {
    j = "MemoryPlane3EXT";
    return;
  }
  if( ImageAspectFlagBits :: ePlane0KHR == p ) {
    j = "Plane0KHR";
    return;
  }
  if( ImageAspectFlagBits :: ePlane1KHR == p ) {
    j = "Plane1KHR";
    return;
  }
}
inline void from_json( const nlohmann::json &j, ImageAspectFlagBits &p ) {
  if( j.is_string() ) {
    if( "Color" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eColor ;
      return;
    }
    if( "eColor" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eColor ;
      return;
    }
    if( "VK_IMAGE_ASPECT_COLOR_BIT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eColor ;
      return;
    }
    if( "Depth" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eDepth ;
      return;
    }
    if( "eDepth" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eDepth ;
      return;
    }
    if( "VK_IMAGE_ASPECT_DEPTH_BIT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eDepth ;
      return;
    }
    if( "Stencil" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eStencil ;
      return;
    }
    if( "eStencil" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eStencil ;
      return;
    }
    if( "VK_IMAGE_ASPECT_STENCIL_BIT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eStencil ;
      return;
    }
    if( "Metadata" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMetadata ;
      return;
    }
    if( "eMetadata" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMetadata ;
      return;
    }
    if( "VK_IMAGE_ASPECT_METADATA_BIT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMetadata ;
      return;
    }
    if( "Plane0" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane0 ;
      return;
    }
    if( "ePlane0" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane0 ;
      return;
    }
    if( "VK_IMAGE_ASPECT_PLANE_0_BIT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane0 ;
      return;
    }
    if( "Plane1" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane1 ;
      return;
    }
    if( "ePlane1" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane1 ;
      return;
    }
    if( "VK_IMAGE_ASPECT_PLANE_1_BIT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane1 ;
      return;
    }
    if( "Plane2" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane2 ;
      return;
    }
    if( "ePlane2" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane2 ;
      return;
    }
    if( "VK_IMAGE_ASPECT_PLANE_2_BIT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane2 ;
      return;
    }
    if( "MemoryPlane0EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane0EXT ;
      return;
    }
    if( "eMemoryPlane0EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane0EXT ;
      return;
    }
    if( "VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane0EXT ;
      return;
    }
    if( "MemoryPlane1EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane1EXT ;
      return;
    }
    if( "eMemoryPlane1EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane1EXT ;
      return;
    }
    if( "VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane1EXT ;
      return;
    }
    if( "MemoryPlane2EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane2EXT ;
      return;
    }
    if( "eMemoryPlane2EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane2EXT ;
      return;
    }
    if( "VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane2EXT ;
      return;
    }
    if( "MemoryPlane3EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane3EXT ;
      return;
    }
    if( "eMemoryPlane3EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane3EXT ;
      return;
    }
    if( "VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: eMemoryPlane3EXT ;
      return;
    }
    if( "Plane0KHR" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane0KHR ;
      return;
    }
    if( "ePlane0KHR" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane0KHR ;
      return;
    }
    if( "VK_IMAGE_ASPECT_PLANE_0_BIT_KHR" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane0KHR ;
      return;
    }
    if( "Plane1KHR" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane1KHR ;
      return;
    }
    if( "ePlane1KHR" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane1KHR ;
      return;
    }
    if( "VK_IMAGE_ASPECT_PLANE_1_BIT_KHR" == j.get< std::string >() ) {
      p = ImageAspectFlagBits :: ePlane1KHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImageAspectFlagBits" );
  }
  if( j.is_number() ) {
    p = ImageAspectFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImageAspectFlagBits" );
}
inline void to_json( nlohmann::json &j, const ImageAspectFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ImageAspectFlagBits ) * 8u; ++n ) {
    if( p & ImageAspectFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ImageAspectFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ImageAspectFlags &p ) {
  if( j.is_array() ) {
    p = ImageAspectFlags ( 0 );
    for( auto &e:  j ) {
      ImageAspectFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ImageAspectFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const SparseImageFormatFlagBits &p ) {
  if( SparseImageFormatFlagBits :: eSingleMiptail == p ) {
    j = "SingleMiptail";
    return;
  }
  if( SparseImageFormatFlagBits :: eAlignedMipSize == p ) {
    j = "AlignedMipSize";
    return;
  }
}
inline void from_json( const nlohmann::json &j, SparseImageFormatFlagBits &p ) {
  if( j.is_string() ) {
    if( "SingleMiptail" == j.get< std::string >() ) {
      p = SparseImageFormatFlagBits :: eSingleMiptail ;
      return;
    }
    if( "eSingleMiptail" == j.get< std::string >() ) {
      p = SparseImageFormatFlagBits :: eSingleMiptail ;
      return;
    }
    if( "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT" == j.get< std::string >() ) {
      p = SparseImageFormatFlagBits :: eSingleMiptail ;
      return;
    }
    if( "AlignedMipSize" == j.get< std::string >() ) {
      p = SparseImageFormatFlagBits :: eAlignedMipSize ;
      return;
    }
    if( "eAlignedMipSize" == j.get< std::string >() ) {
      p = SparseImageFormatFlagBits :: eAlignedMipSize ;
      return;
    }
    if( "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT" == j.get< std::string >() ) {
      p = SparseImageFormatFlagBits :: eAlignedMipSize ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SparseImageFormatFlagBits" );
  }
  if( j.is_number() ) {
    p = SparseImageFormatFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SparseImageFormatFlagBits" );
}
inline void to_json( nlohmann::json &j, const SparseImageFormatFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SparseImageFormatFlagBits ) * 8u; ++n ) {
    if( p & SparseImageFormatFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SparseImageFormatFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, SparseImageFormatFlags &p ) {
  if( j.is_array() ) {
    p = SparseImageFormatFlags ( 0 );
    for( auto &e:  j ) {
      SparseImageFormatFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SparseImageFormatFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const SparseMemoryBindFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, SparseMemoryBindFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for SparseMemoryBindFlagBits" );
  }
  if( j.is_number() ) {
    p = SparseMemoryBindFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SparseMemoryBindFlagBits" );
}
inline void to_json( nlohmann::json &j, const SparseMemoryBindFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SparseMemoryBindFlagBits ) * 8u; ++n ) {
    if( p & SparseMemoryBindFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SparseMemoryBindFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, SparseMemoryBindFlags &p ) {
  if( j.is_array() ) {
    p = SparseMemoryBindFlags ( 0 );
    for( auto &e:  j ) {
      SparseMemoryBindFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SparseMemoryBindFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const FenceCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, FenceCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for FenceCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = FenceCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FenceCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const FenceCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( FenceCreateFlagBits ) * 8u; ++n ) {
    if( p & FenceCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, FenceCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, FenceCreateFlags &p ) {
  if( j.is_array() ) {
    p = FenceCreateFlags ( 0 );
    for( auto &e:  j ) {
      FenceCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for FenceCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const EventCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, EventCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for EventCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = EventCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for EventCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const EventCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( EventCreateFlagBits ) * 8u; ++n ) {
    if( p & EventCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, EventCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, EventCreateFlags &p ) {
  if( j.is_array() ) {
    p = EventCreateFlags ( 0 );
    for( auto &e:  j ) {
      EventCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for EventCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const QueryPipelineStatisticFlagBits &p ) {
  if( QueryPipelineStatisticFlagBits :: eInputAssemblyVertices == p ) {
    j = "InputAssemblyVertices";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eInputAssemblyPrimitives == p ) {
    j = "InputAssemblyPrimitives";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eVertexShaderInvocations == p ) {
    j = "VertexShaderInvocations";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eGeometryShaderInvocations == p ) {
    j = "GeometryShaderInvocations";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eGeometryShaderPrimitives == p ) {
    j = "GeometryShaderPrimitives";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eClippingInvocations == p ) {
    j = "ClippingInvocations";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eClippingPrimitives == p ) {
    j = "ClippingPrimitives";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eFragmentShaderInvocations == p ) {
    j = "FragmentShaderInvocations";
    return;
  }
  if( QueryPipelineStatisticFlagBits :: eTessellationControlShaderPatches == p ) {
    j = "TessellationControlShaderPatches";
    return;
  }
}
inline void from_json( const nlohmann::json &j, QueryPipelineStatisticFlagBits &p ) {
  if( j.is_string() ) {
    if( "InputAssemblyVertices" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eInputAssemblyVertices ;
      return;
    }
    if( "eInputAssemblyVertices" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eInputAssemblyVertices ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eInputAssemblyVertices ;
      return;
    }
    if( "InputAssemblyPrimitives" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eInputAssemblyPrimitives ;
      return;
    }
    if( "eInputAssemblyPrimitives" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eInputAssemblyPrimitives ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eInputAssemblyPrimitives ;
      return;
    }
    if( "VertexShaderInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eVertexShaderInvocations ;
      return;
    }
    if( "eVertexShaderInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eVertexShaderInvocations ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eVertexShaderInvocations ;
      return;
    }
    if( "GeometryShaderInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eGeometryShaderInvocations ;
      return;
    }
    if( "eGeometryShaderInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eGeometryShaderInvocations ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eGeometryShaderInvocations ;
      return;
    }
    if( "GeometryShaderPrimitives" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eGeometryShaderPrimitives ;
      return;
    }
    if( "eGeometryShaderPrimitives" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eGeometryShaderPrimitives ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eGeometryShaderPrimitives ;
      return;
    }
    if( "ClippingInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eClippingInvocations ;
      return;
    }
    if( "eClippingInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eClippingInvocations ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eClippingInvocations ;
      return;
    }
    if( "ClippingPrimitives" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eClippingPrimitives ;
      return;
    }
    if( "eClippingPrimitives" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eClippingPrimitives ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eClippingPrimitives ;
      return;
    }
    if( "FragmentShaderInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eFragmentShaderInvocations ;
      return;
    }
    if( "eFragmentShaderInvocations" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eFragmentShaderInvocations ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eFragmentShaderInvocations ;
      return;
    }
    if( "TessellationControlShaderPatches" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eTessellationControlShaderPatches ;
      return;
    }
    if( "eTessellationControlShaderPatches" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eTessellationControlShaderPatches ;
      return;
    }
    if( "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT" == j.get< std::string >() ) {
      p = QueryPipelineStatisticFlagBits :: eTessellationControlShaderPatches ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueryPipelineStatisticFlagBits" );
  }
  if( j.is_number() ) {
    p = QueryPipelineStatisticFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueryPipelineStatisticFlagBits" );
}
inline void to_json( nlohmann::json &j, const QueryPipelineStatisticFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( QueryPipelineStatisticFlagBits ) * 8u; ++n ) {
    if( p & QueryPipelineStatisticFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, QueryPipelineStatisticFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, QueryPipelineStatisticFlags &p ) {
  if( j.is_array() ) {
    p = QueryPipelineStatisticFlags ( 0 );
    for( auto &e:  j ) {
      QueryPipelineStatisticFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for QueryPipelineStatisticFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const QueryResultFlagBits &p ) {
  if( QueryResultFlagBits :: e64 == p ) {
    j = "64";
    return;
  }
  if( QueryResultFlagBits :: eWait == p ) {
    j = "Wait";
    return;
  }
  if( QueryResultFlagBits :: eWithAvailability == p ) {
    j = "WithAvailability";
    return;
  }
  if( QueryResultFlagBits :: ePartial == p ) {
    j = "Partial";
    return;
  }
}
inline void from_json( const nlohmann::json &j, QueryResultFlagBits &p ) {
  if( j.is_string() ) {
    if( "64" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: e64 ;
      return;
    }
    if( "e64" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: e64 ;
      return;
    }
    if( "VK_QUERY_RESULT_64_BIT" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: e64 ;
      return;
    }
    if( "Wait" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: eWait ;
      return;
    }
    if( "eWait" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: eWait ;
      return;
    }
    if( "VK_QUERY_RESULT_WAIT_BIT" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: eWait ;
      return;
    }
    if( "WithAvailability" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: eWithAvailability ;
      return;
    }
    if( "eWithAvailability" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: eWithAvailability ;
      return;
    }
    if( "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: eWithAvailability ;
      return;
    }
    if( "Partial" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: ePartial ;
      return;
    }
    if( "ePartial" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: ePartial ;
      return;
    }
    if( "VK_QUERY_RESULT_PARTIAL_BIT" == j.get< std::string >() ) {
      p = QueryResultFlagBits :: ePartial ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueryResultFlagBits" );
  }
  if( j.is_number() ) {
    p = QueryResultFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueryResultFlagBits" );
}
inline void to_json( nlohmann::json &j, const QueryResultFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( QueryResultFlagBits ) * 8u; ++n ) {
    if( p & QueryResultFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, QueryResultFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, QueryResultFlags &p ) {
  if( j.is_array() ) {
    p = QueryResultFlags ( 0 );
    for( auto &e:  j ) {
      QueryResultFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for QueryResultFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const BufferCreateFlagBits &p ) {
  if( BufferCreateFlagBits :: eSparseBinding == p ) {
    j = "SparseBinding";
    return;
  }
  if( BufferCreateFlagBits :: eSparseResidency == p ) {
    j = "SparseResidency";
    return;
  }
  if( BufferCreateFlagBits :: eSparseAliased == p ) {
    j = "SparseAliased";
    return;
  }
  if( BufferCreateFlagBits :: eProtected == p ) {
    j = "Protected";
    return;
  }
  if( BufferCreateFlagBits :: eDeviceAddressCaptureReplay == p ) {
    j = "DeviceAddressCaptureReplay";
    return;
  }
  if( BufferCreateFlagBits :: eDeviceAddressCaptureReplayEXT == p ) {
    j = "DeviceAddressCaptureReplayEXT";
    return;
  }
}
inline void from_json( const nlohmann::json &j, BufferCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "SparseBinding" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseBinding ;
      return;
    }
    if( "eSparseBinding" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseBinding ;
      return;
    }
    if( "VK_BUFFER_CREATE_SPARSE_BINDING_BIT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseBinding ;
      return;
    }
    if( "SparseResidency" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseResidency ;
      return;
    }
    if( "eSparseResidency" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseResidency ;
      return;
    }
    if( "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseResidency ;
      return;
    }
    if( "SparseAliased" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseAliased ;
      return;
    }
    if( "eSparseAliased" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseAliased ;
      return;
    }
    if( "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eSparseAliased ;
      return;
    }
    if( "Protected" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eProtected ;
      return;
    }
    if( "eProtected" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eProtected ;
      return;
    }
    if( "VK_BUFFER_CREATE_PROTECTED_BIT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eProtected ;
      return;
    }
    if( "DeviceAddressCaptureReplay" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eDeviceAddressCaptureReplay ;
      return;
    }
    if( "eDeviceAddressCaptureReplay" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eDeviceAddressCaptureReplay ;
      return;
    }
    if( "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eDeviceAddressCaptureReplay ;
      return;
    }
    if( "DeviceAddressCaptureReplayEXT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eDeviceAddressCaptureReplayEXT ;
      return;
    }
    if( "eDeviceAddressCaptureReplayEXT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eDeviceAddressCaptureReplayEXT ;
      return;
    }
    if( "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT" == j.get< std::string >() ) {
      p = BufferCreateFlagBits :: eDeviceAddressCaptureReplayEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BufferCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = BufferCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BufferCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const BufferCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( BufferCreateFlagBits ) * 8u; ++n ) {
    if( p & BufferCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, BufferCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, BufferCreateFlags &p ) {
  if( j.is_array() ) {
    p = BufferCreateFlags ( 0 );
    for( auto &e:  j ) {
      BufferCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for BufferCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const BufferUsageFlagBits &p ) {
  if( BufferUsageFlagBits :: eTransferSrc == p ) {
    j = "TransferSrc";
    return;
  }
  if( BufferUsageFlagBits :: eTransferDst == p ) {
    j = "TransferDst";
    return;
  }
  if( BufferUsageFlagBits :: eUniformTexelBuffer == p ) {
    j = "UniformTexelBuffer";
    return;
  }
  if( BufferUsageFlagBits :: eStorageTexelBuffer == p ) {
    j = "StorageTexelBuffer";
    return;
  }
  if( BufferUsageFlagBits :: eUniformBuffer == p ) {
    j = "UniformBuffer";
    return;
  }
  if( BufferUsageFlagBits :: eStorageBuffer == p ) {
    j = "StorageBuffer";
    return;
  }
  if( BufferUsageFlagBits :: eIndexBuffer == p ) {
    j = "IndexBuffer";
    return;
  }
  if( BufferUsageFlagBits :: eVertexBuffer == p ) {
    j = "VertexBuffer";
    return;
  }
  if( BufferUsageFlagBits :: eIndirectBuffer == p ) {
    j = "IndirectBuffer";
    return;
  }
  if( BufferUsageFlagBits :: eShaderDeviceAddress == p ) {
    j = "ShaderDeviceAddress";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( BufferUsageFlagBits :: eVideoDecodeSrcKHR == p ) {
    j = "VideoDecodeSrcKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( BufferUsageFlagBits :: eVideoDecodeDstKHR == p ) {
    j = "VideoDecodeDstKHR";
    return;
  }
#endif
  if( BufferUsageFlagBits :: eTransformFeedbackBufferEXT == p ) {
    j = "TransformFeedbackBufferEXT";
    return;
  }
  if( BufferUsageFlagBits :: eTransformFeedbackCounterBufferEXT == p ) {
    j = "TransformFeedbackCounterBufferEXT";
    return;
  }
  if( BufferUsageFlagBits :: eConditionalRenderingEXT == p ) {
    j = "ConditionalRenderingEXT";
    return;
  }
  if( BufferUsageFlagBits :: eAccelerationStructureBuildInputReadOnlyKHR == p ) {
    j = "AccelerationStructureBuildInputReadOnlyKHR";
    return;
  }
  if( BufferUsageFlagBits :: eAccelerationStructureStorageKHR == p ) {
    j = "AccelerationStructureStorageKHR";
    return;
  }
  if( BufferUsageFlagBits :: eShaderBindingTableKHR == p ) {
    j = "ShaderBindingTableKHR";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( BufferUsageFlagBits :: eVideoEncodeDstKHR == p ) {
    j = "VideoEncodeDstKHR";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( BufferUsageFlagBits :: eVideoEncodeSrcKHR == p ) {
    j = "VideoEncodeSrcKHR";
    return;
  }
#endif
  if( BufferUsageFlagBits :: eRayTracingNV == p ) {
    j = "RayTracingNV";
    return;
  }
  if( BufferUsageFlagBits :: eShaderDeviceAddressEXT == p ) {
    j = "ShaderDeviceAddressEXT";
    return;
  }
}
inline void from_json( const nlohmann::json &j, BufferUsageFlagBits &p ) {
  if( j.is_string() ) {
    if( "TransferSrc" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eTransferSrc ;
      return;
    }
    if( "eTransferSrc" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eTransferSrc ;
      return;
    }
    if( "VK_BUFFER_USAGE_TRANSFER_SRC_BIT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eTransferSrc ;
      return;
    }
    if( "TransferDst" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eTransferDst ;
      return;
    }
    if( "eTransferDst" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eTransferDst ;
      return;
    }
    if( "VK_BUFFER_USAGE_TRANSFER_DST_BIT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eTransferDst ;
      return;
    }
    if( "UniformTexelBuffer" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eUniformTexelBuffer ;
      return;
    }
    if( "eUniformTexelBuffer" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eUniformTexelBuffer ;
      return;
    }
    if( "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eUniformTexelBuffer ;
      return;
    }
    if( "StorageTexelBuffer" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eStorageTexelBuffer ;
      return;
    }
    if( "eStorageTexelBuffer" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eStorageTexelBuffer ;
      return;
    }
    if( "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eStorageTexelBuffer ;
      return;
    }
    if( "UniformBuffer" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eUniformBuffer ;
      return;
    }
    if( "eUniformBuffer" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eUniformBuffer ;
      return;
    }
    if( "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eUniformBuffer ;
      return;
    }
    if( "StorageBuffer" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eStorageBuffer ;
      return;
    }
    if( "eStorageBuffer" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eStorageBuffer ;
      return;
    }
    if( "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eStorageBuffer ;
      return;
    }
    if( "IndexBuffer" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eIndexBuffer ;
      return;
    }
    if( "eIndexBuffer" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eIndexBuffer ;
      return;
    }
    if( "VK_BUFFER_USAGE_INDEX_BUFFER_BIT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eIndexBuffer ;
      return;
    }
    if( "VertexBuffer" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVertexBuffer ;
      return;
    }
    if( "eVertexBuffer" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVertexBuffer ;
      return;
    }
    if( "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVertexBuffer ;
      return;
    }
    if( "IndirectBuffer" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eIndirectBuffer ;
      return;
    }
    if( "eIndirectBuffer" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eIndirectBuffer ;
      return;
    }
    if( "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eIndirectBuffer ;
      return;
    }
    if( "ShaderDeviceAddress" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eShaderDeviceAddress ;
      return;
    }
    if( "eShaderDeviceAddress" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eShaderDeviceAddress ;
      return;
    }
    if( "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eShaderDeviceAddress ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeSrcKHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVideoDecodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeSrcKHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVideoDecodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVideoDecodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeDstKHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVideoDecodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeDstKHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVideoDecodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVideoDecodeDstKHR ;
      return;
    }
#endif
    if( "TransformFeedbackBufferEXT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eTransformFeedbackBufferEXT ;
      return;
    }
    if( "eTransformFeedbackBufferEXT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eTransformFeedbackBufferEXT ;
      return;
    }
    if( "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eTransformFeedbackBufferEXT ;
      return;
    }
    if( "TransformFeedbackCounterBufferEXT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eTransformFeedbackCounterBufferEXT ;
      return;
    }
    if( "eTransformFeedbackCounterBufferEXT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eTransformFeedbackCounterBufferEXT ;
      return;
    }
    if( "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eTransformFeedbackCounterBufferEXT ;
      return;
    }
    if( "ConditionalRenderingEXT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eConditionalRenderingEXT ;
      return;
    }
    if( "eConditionalRenderingEXT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eConditionalRenderingEXT ;
      return;
    }
    if( "VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eConditionalRenderingEXT ;
      return;
    }
    if( "AccelerationStructureBuildInputReadOnlyKHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eAccelerationStructureBuildInputReadOnlyKHR ;
      return;
    }
    if( "eAccelerationStructureBuildInputReadOnlyKHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eAccelerationStructureBuildInputReadOnlyKHR ;
      return;
    }
    if( "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eAccelerationStructureBuildInputReadOnlyKHR ;
      return;
    }
    if( "AccelerationStructureStorageKHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eAccelerationStructureStorageKHR ;
      return;
    }
    if( "eAccelerationStructureStorageKHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eAccelerationStructureStorageKHR ;
      return;
    }
    if( "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eAccelerationStructureStorageKHR ;
      return;
    }
    if( "ShaderBindingTableKHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eShaderBindingTableKHR ;
      return;
    }
    if( "eShaderBindingTableKHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eShaderBindingTableKHR ;
      return;
    }
    if( "VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eShaderBindingTableKHR ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeDstKHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVideoEncodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeDstKHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVideoEncodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVideoEncodeDstKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeSrcKHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVideoEncodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeSrcKHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVideoEncodeSrcKHR ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eVideoEncodeSrcKHR ;
      return;
    }
#endif
    if( "RayTracingNV" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eRayTracingNV ;
      return;
    }
    if( "eRayTracingNV" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eRayTracingNV ;
      return;
    }
    if( "VK_BUFFER_USAGE_RAY_TRACING_BIT_NV" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eRayTracingNV ;
      return;
    }
    if( "ShaderDeviceAddressEXT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eShaderDeviceAddressEXT ;
      return;
    }
    if( "eShaderDeviceAddressEXT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eShaderDeviceAddressEXT ;
      return;
    }
    if( "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT" == j.get< std::string >() ) {
      p = BufferUsageFlagBits :: eShaderDeviceAddressEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BufferUsageFlagBits" );
  }
  if( j.is_number() ) {
    p = BufferUsageFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BufferUsageFlagBits" );
}
inline void to_json( nlohmann::json &j, const BufferUsageFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( BufferUsageFlagBits ) * 8u; ++n ) {
    if( p & BufferUsageFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, BufferUsageFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, BufferUsageFlags &p ) {
  if( j.is_array() ) {
    p = BufferUsageFlags ( 0 );
    for( auto &e:  j ) {
      BufferUsageFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for BufferUsageFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const ImageViewCreateFlagBits &p ) {
  if( ImageViewCreateFlagBits :: eFragmentDensityMapDynamicEXT == p ) {
    j = "FragmentDensityMapDynamicEXT";
    return;
  }
}
inline void from_json( const nlohmann::json &j, ImageViewCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "FragmentDensityMapDynamicEXT" == j.get< std::string >() ) {
      p = ImageViewCreateFlagBits :: eFragmentDensityMapDynamicEXT ;
      return;
    }
    if( "eFragmentDensityMapDynamicEXT" == j.get< std::string >() ) {
      p = ImageViewCreateFlagBits :: eFragmentDensityMapDynamicEXT ;
      return;
    }
    if( "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT" == j.get< std::string >() ) {
      p = ImageViewCreateFlagBits :: eFragmentDensityMapDynamicEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImageViewCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = ImageViewCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImageViewCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const ImageViewCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ImageViewCreateFlagBits ) * 8u; ++n ) {
    if( p & ImageViewCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ImageViewCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ImageViewCreateFlags &p ) {
  if( j.is_array() ) {
    p = ImageViewCreateFlags ( 0 );
    for( auto &e:  j ) {
      ImageViewCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ImageViewCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const ShaderModuleCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, ShaderModuleCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for ShaderModuleCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = ShaderModuleCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ShaderModuleCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const ShaderModuleCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ShaderModuleCreateFlagBits ) * 8u; ++n ) {
    if( p & ShaderModuleCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ShaderModuleCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ShaderModuleCreateFlags &p ) {
  if( j.is_array() ) {
    p = ShaderModuleCreateFlags ( 0 );
    for( auto &e:  j ) {
      ShaderModuleCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ShaderModuleCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineCacheCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineCacheCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCacheCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineCacheCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCacheCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const PipelineCacheCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineCacheCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineCacheCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineCacheCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineCacheCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineCacheCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineCacheCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineCacheCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const ColorComponentFlagBits &p ) {
  if( ColorComponentFlagBits :: eR == p ) {
    j = "R";
    return;
  }
  if( ColorComponentFlagBits :: eG == p ) {
    j = "G";
    return;
  }
  if( ColorComponentFlagBits :: eB == p ) {
    j = "B";
    return;
  }
}
inline void from_json( const nlohmann::json &j, ColorComponentFlagBits &p ) {
  if( j.is_string() ) {
    if( "R" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eR ;
      return;
    }
    if( "eR" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eR ;
      return;
    }
    if( "VK_COLOR_COMPONENT_R_BIT" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eR ;
      return;
    }
    if( "G" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eG ;
      return;
    }
    if( "eG" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eG ;
      return;
    }
    if( "VK_COLOR_COMPONENT_G_BIT" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eG ;
      return;
    }
    if( "B" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eB ;
      return;
    }
    if( "eB" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eB ;
      return;
    }
    if( "VK_COLOR_COMPONENT_B_BIT" == j.get< std::string >() ) {
      p = ColorComponentFlagBits :: eB ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ColorComponentFlagBits" );
  }
  if( j.is_number() ) {
    p = ColorComponentFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ColorComponentFlagBits" );
}
inline void to_json( nlohmann::json &j, const ColorComponentFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ColorComponentFlagBits ) * 8u; ++n ) {
    if( p & ColorComponentFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ColorComponentFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ColorComponentFlags &p ) {
  if( j.is_array() ) {
    p = ColorComponentFlags ( 0 );
    for( auto &e:  j ) {
      ColorComponentFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ColorComponentFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const CullModeFlagBits &p ) {
  if( CullModeFlagBits :: eNone == p ) {
    j = "None";
    return;
  }
  if( CullModeFlagBits :: eFront == p ) {
    j = "Front";
    return;
  }
  if( CullModeFlagBits :: eBack == p ) {
    j = "Back";
    return;
  }
}
inline void from_json( const nlohmann::json &j, CullModeFlagBits &p ) {
  if( j.is_string() ) {
    if( "None" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eNone ;
      return;
    }
    if( "eNone" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eNone ;
      return;
    }
    if( "VK_CULL_MODE_NONE" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eNone ;
      return;
    }
    if( "Front" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eFront ;
      return;
    }
    if( "eFront" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eFront ;
      return;
    }
    if( "VK_CULL_MODE_FRONT_BIT" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eFront ;
      return;
    }
    if( "Back" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eBack ;
      return;
    }
    if( "eBack" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eBack ;
      return;
    }
    if( "VK_CULL_MODE_BACK_BIT" == j.get< std::string >() ) {
      p = CullModeFlagBits :: eBack ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CullModeFlagBits" );
  }
  if( j.is_number() ) {
    p = CullModeFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CullModeFlagBits" );
}
inline void to_json( nlohmann::json &j, const CullModeFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( CullModeFlagBits ) * 8u; ++n ) {
    if( p & CullModeFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, CullModeFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, CullModeFlags &p ) {
  if( j.is_array() ) {
    p = CullModeFlags ( 0 );
    for( auto &e:  j ) {
      CullModeFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for CullModeFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineCreateFlagBits &p ) {
  if( PipelineCreateFlagBits :: eDisableOptimization == p ) {
    j = "DisableOptimization";
    return;
  }
  if( PipelineCreateFlagBits :: eAllowDerivatives == p ) {
    j = "AllowDerivatives";
    return;
  }
  if( PipelineCreateFlagBits :: eDerivative == p ) {
    j = "Derivative";
    return;
  }
  if( PipelineCreateFlagBits :: eViewIndexFromDeviceIndex == p ) {
    j = "ViewIndexFromDeviceIndex";
    return;
  }
  if( PipelineCreateFlagBits :: eDispatchBase == p ) {
    j = "DispatchBase";
    return;
  }
  if( PipelineCreateFlagBits :: eRayTracingNoNullAnyHitShadersKHR == p ) {
    j = "RayTracingNoNullAnyHitShadersKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eRayTracingNoNullClosestHitShadersKHR == p ) {
    j = "RayTracingNoNullClosestHitShadersKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eRayTracingNoNullMissShadersKHR == p ) {
    j = "RayTracingNoNullMissShadersKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eRayTracingNoNullIntersectionShadersKHR == p ) {
    j = "RayTracingNoNullIntersectionShadersKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eRayTracingSkipTrianglesKHR == p ) {
    j = "RayTracingSkipTrianglesKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eRayTracingSkipAabbsKHR == p ) {
    j = "RayTracingSkipAabbsKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eDeferCompileNV == p ) {
    j = "DeferCompileNV";
    return;
  }
  if( PipelineCreateFlagBits :: eCaptureStatisticsKHR == p ) {
    j = "CaptureStatisticsKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eCaptureInternalRepresentationsKHR == p ) {
    j = "CaptureInternalRepresentationsKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eIndirectBindableNV == p ) {
    j = "IndirectBindableNV";
    return;
  }
  if( PipelineCreateFlagBits :: eLibraryKHR == p ) {
    j = "LibraryKHR";
    return;
  }
  if( PipelineCreateFlagBits :: eFailOnPipelineCompileRequiredEXT == p ) {
    j = "FailOnPipelineCompileRequiredEXT";
    return;
  }
  if( PipelineCreateFlagBits :: eEarlyReturnOnFailureEXT == p ) {
    j = "EarlyReturnOnFailureEXT";
    return;
  }
  if( PipelineCreateFlagBits :: eRayTracingAllowMotionNV == p ) {
    j = "RayTracingAllowMotionNV";
    return;
  }
  if( PipelineCreateFlagBits :: eDispatchBaseKHR == p ) {
    j = "DispatchBaseKHR";
    return;
  }
}
inline void from_json( const nlohmann::json &j, PipelineCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "DisableOptimization" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDisableOptimization ;
      return;
    }
    if( "eDisableOptimization" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDisableOptimization ;
      return;
    }
    if( "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDisableOptimization ;
      return;
    }
    if( "AllowDerivatives" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eAllowDerivatives ;
      return;
    }
    if( "eAllowDerivatives" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eAllowDerivatives ;
      return;
    }
    if( "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eAllowDerivatives ;
      return;
    }
    if( "Derivative" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDerivative ;
      return;
    }
    if( "eDerivative" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDerivative ;
      return;
    }
    if( "VK_PIPELINE_CREATE_DERIVATIVE_BIT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDerivative ;
      return;
    }
    if( "ViewIndexFromDeviceIndex" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eViewIndexFromDeviceIndex ;
      return;
    }
    if( "eViewIndexFromDeviceIndex" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eViewIndexFromDeviceIndex ;
      return;
    }
    if( "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eViewIndexFromDeviceIndex ;
      return;
    }
    if( "DispatchBase" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDispatchBase ;
      return;
    }
    if( "eDispatchBase" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDispatchBase ;
      return;
    }
    if( "VK_PIPELINE_CREATE_DISPATCH_BASE_BIT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDispatchBase ;
      return;
    }
    if( "RayTracingNoNullAnyHitShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullAnyHitShadersKHR ;
      return;
    }
    if( "eRayTracingNoNullAnyHitShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullAnyHitShadersKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullAnyHitShadersKHR ;
      return;
    }
    if( "RayTracingNoNullClosestHitShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullClosestHitShadersKHR ;
      return;
    }
    if( "eRayTracingNoNullClosestHitShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullClosestHitShadersKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullClosestHitShadersKHR ;
      return;
    }
    if( "RayTracingNoNullMissShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullMissShadersKHR ;
      return;
    }
    if( "eRayTracingNoNullMissShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullMissShadersKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullMissShadersKHR ;
      return;
    }
    if( "RayTracingNoNullIntersectionShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullIntersectionShadersKHR ;
      return;
    }
    if( "eRayTracingNoNullIntersectionShadersKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullIntersectionShadersKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingNoNullIntersectionShadersKHR ;
      return;
    }
    if( "RayTracingSkipTrianglesKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingSkipTrianglesKHR ;
      return;
    }
    if( "eRayTracingSkipTrianglesKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingSkipTrianglesKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingSkipTrianglesKHR ;
      return;
    }
    if( "RayTracingSkipAabbsKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingSkipAabbsKHR ;
      return;
    }
    if( "eRayTracingSkipAabbsKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingSkipAabbsKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingSkipAabbsKHR ;
      return;
    }
    if( "DeferCompileNV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDeferCompileNV ;
      return;
    }
    if( "eDeferCompileNV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDeferCompileNV ;
      return;
    }
    if( "VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDeferCompileNV ;
      return;
    }
    if( "CaptureStatisticsKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eCaptureStatisticsKHR ;
      return;
    }
    if( "eCaptureStatisticsKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eCaptureStatisticsKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eCaptureStatisticsKHR ;
      return;
    }
    if( "CaptureInternalRepresentationsKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eCaptureInternalRepresentationsKHR ;
      return;
    }
    if( "eCaptureInternalRepresentationsKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eCaptureInternalRepresentationsKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eCaptureInternalRepresentationsKHR ;
      return;
    }
    if( "IndirectBindableNV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eIndirectBindableNV ;
      return;
    }
    if( "eIndirectBindableNV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eIndirectBindableNV ;
      return;
    }
    if( "VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eIndirectBindableNV ;
      return;
    }
    if( "LibraryKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eLibraryKHR ;
      return;
    }
    if( "eLibraryKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eLibraryKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_LIBRARY_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eLibraryKHR ;
      return;
    }
    if( "FailOnPipelineCompileRequiredEXT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eFailOnPipelineCompileRequiredEXT ;
      return;
    }
    if( "eFailOnPipelineCompileRequiredEXT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eFailOnPipelineCompileRequiredEXT ;
      return;
    }
    if( "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eFailOnPipelineCompileRequiredEXT ;
      return;
    }
    if( "EarlyReturnOnFailureEXT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eEarlyReturnOnFailureEXT ;
      return;
    }
    if( "eEarlyReturnOnFailureEXT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eEarlyReturnOnFailureEXT ;
      return;
    }
    if( "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eEarlyReturnOnFailureEXT ;
      return;
    }
    if( "RayTracingAllowMotionNV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingAllowMotionNV ;
      return;
    }
    if( "eRayTracingAllowMotionNV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingAllowMotionNV ;
      return;
    }
    if( "VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eRayTracingAllowMotionNV ;
      return;
    }
    if( "DispatchBaseKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDispatchBaseKHR ;
      return;
    }
    if( "eDispatchBaseKHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDispatchBaseKHR ;
      return;
    }
    if( "VK_PIPELINE_CREATE_DISPATCH_BASE_KHR" == j.get< std::string >() ) {
      p = PipelineCreateFlagBits :: eDispatchBaseKHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const PipelineCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineShaderStageCreateFlagBits &p ) {
  if( PipelineShaderStageCreateFlagBits :: eAllowVaryingSubgroupSizeEXT == p ) {
    j = "AllowVaryingSubgroupSizeEXT";
    return;
  }
}
inline void from_json( const nlohmann::json &j, PipelineShaderStageCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "AllowVaryingSubgroupSizeEXT" == j.get< std::string >() ) {
      p = PipelineShaderStageCreateFlagBits :: eAllowVaryingSubgroupSizeEXT ;
      return;
    }
    if( "eAllowVaryingSubgroupSizeEXT" == j.get< std::string >() ) {
      p = PipelineShaderStageCreateFlagBits :: eAllowVaryingSubgroupSizeEXT ;
      return;
    }
    if( "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineShaderStageCreateFlagBits :: eAllowVaryingSubgroupSizeEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineShaderStageCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineShaderStageCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineShaderStageCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const PipelineShaderStageCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineShaderStageCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineShaderStageCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineShaderStageCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineShaderStageCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineShaderStageCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineShaderStageCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineShaderStageCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const ShaderStageFlagBits &p ) {
  if( ShaderStageFlagBits :: eVertex == p ) {
    j = "Vertex";
    return;
  }
  if( ShaderStageFlagBits :: eTessellationControl == p ) {
    j = "TessellationControl";
    return;
  }
  if( ShaderStageFlagBits :: eTessellationEvaluation == p ) {
    j = "TessellationEvaluation";
    return;
  }
  if( ShaderStageFlagBits :: eGeometry == p ) {
    j = "Geometry";
    return;
  }
  if( ShaderStageFlagBits :: eFragment == p ) {
    j = "Fragment";
    return;
  }
  if( ShaderStageFlagBits :: eCompute == p ) {
    j = "Compute";
    return;
  }
  if( ShaderStageFlagBits :: eAllGraphics == p ) {
    j = "AllGraphics";
    return;
  }
  if( ShaderStageFlagBits :: eAll == p ) {
    j = "All";
    return;
  }
  if( ShaderStageFlagBits :: eRaygenKHR == p ) {
    j = "RaygenKHR";
    return;
  }
  if( ShaderStageFlagBits :: eAnyHitKHR == p ) {
    j = "AnyHitKHR";
    return;
  }
  if( ShaderStageFlagBits :: eClosestHitKHR == p ) {
    j = "ClosestHitKHR";
    return;
  }
  if( ShaderStageFlagBits :: eMissKHR == p ) {
    j = "MissKHR";
    return;
  }
  if( ShaderStageFlagBits :: eIntersectionKHR == p ) {
    j = "IntersectionKHR";
    return;
  }
  if( ShaderStageFlagBits :: eCallableKHR == p ) {
    j = "CallableKHR";
    return;
  }
  if( ShaderStageFlagBits :: eTaskNV == p ) {
    j = "TaskNV";
    return;
  }
  if( ShaderStageFlagBits :: eMeshNV == p ) {
    j = "MeshNV";
    return;
  }
  if( ShaderStageFlagBits :: eSubpassShadingHUAWEI == p ) {
    j = "SubpassShadingHUAWEI";
    return;
  }
  if( ShaderStageFlagBits :: eAnyHitNV == p ) {
    j = "AnyHitNV";
    return;
  }
  if( ShaderStageFlagBits :: eCallableNV == p ) {
    j = "CallableNV";
    return;
  }
  if( ShaderStageFlagBits :: eClosestHitNV == p ) {
    j = "ClosestHitNV";
    return;
  }
  if( ShaderStageFlagBits :: eIntersectionNV == p ) {
    j = "IntersectionNV";
    return;
  }
  if( ShaderStageFlagBits :: eMissNV == p ) {
    j = "MissNV";
    return;
  }
}
inline void from_json( const nlohmann::json &j, ShaderStageFlagBits &p ) {
  if( j.is_string() ) {
    if( "Vertex" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eVertex ;
      return;
    }
    if( "eVertex" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eVertex ;
      return;
    }
    if( "VK_SHADER_STAGE_VERTEX_BIT" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eVertex ;
      return;
    }
    if( "TessellationControl" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTessellationControl ;
      return;
    }
    if( "eTessellationControl" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTessellationControl ;
      return;
    }
    if( "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTessellationControl ;
      return;
    }
    if( "TessellationEvaluation" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTessellationEvaluation ;
      return;
    }
    if( "eTessellationEvaluation" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTessellationEvaluation ;
      return;
    }
    if( "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTessellationEvaluation ;
      return;
    }
    if( "Geometry" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eGeometry ;
      return;
    }
    if( "eGeometry" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eGeometry ;
      return;
    }
    if( "VK_SHADER_STAGE_GEOMETRY_BIT" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eGeometry ;
      return;
    }
    if( "Fragment" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eFragment ;
      return;
    }
    if( "eFragment" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eFragment ;
      return;
    }
    if( "VK_SHADER_STAGE_FRAGMENT_BIT" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eFragment ;
      return;
    }
    if( "Compute" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCompute ;
      return;
    }
    if( "eCompute" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCompute ;
      return;
    }
    if( "VK_SHADER_STAGE_COMPUTE_BIT" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCompute ;
      return;
    }
    if( "AllGraphics" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAllGraphics ;
      return;
    }
    if( "eAllGraphics" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAllGraphics ;
      return;
    }
    if( "VK_SHADER_STAGE_ALL_GRAPHICS" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAllGraphics ;
      return;
    }
    if( "All" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAll ;
      return;
    }
    if( "eAll" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAll ;
      return;
    }
    if( "VK_SHADER_STAGE_ALL" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAll ;
      return;
    }
    if( "RaygenKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eRaygenKHR ;
      return;
    }
    if( "eRaygenKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eRaygenKHR ;
      return;
    }
    if( "VK_SHADER_STAGE_RAYGEN_BIT_KHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eRaygenKHR ;
      return;
    }
    if( "AnyHitKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAnyHitKHR ;
      return;
    }
    if( "eAnyHitKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAnyHitKHR ;
      return;
    }
    if( "VK_SHADER_STAGE_ANY_HIT_BIT_KHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAnyHitKHR ;
      return;
    }
    if( "ClosestHitKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eClosestHitKHR ;
      return;
    }
    if( "eClosestHitKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eClosestHitKHR ;
      return;
    }
    if( "VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eClosestHitKHR ;
      return;
    }
    if( "MissKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMissKHR ;
      return;
    }
    if( "eMissKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMissKHR ;
      return;
    }
    if( "VK_SHADER_STAGE_MISS_BIT_KHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMissKHR ;
      return;
    }
    if( "IntersectionKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eIntersectionKHR ;
      return;
    }
    if( "eIntersectionKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eIntersectionKHR ;
      return;
    }
    if( "VK_SHADER_STAGE_INTERSECTION_BIT_KHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eIntersectionKHR ;
      return;
    }
    if( "CallableKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCallableKHR ;
      return;
    }
    if( "eCallableKHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCallableKHR ;
      return;
    }
    if( "VK_SHADER_STAGE_CALLABLE_BIT_KHR" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCallableKHR ;
      return;
    }
    if( "TaskNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTaskNV ;
      return;
    }
    if( "eTaskNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTaskNV ;
      return;
    }
    if( "VK_SHADER_STAGE_TASK_BIT_NV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eTaskNV ;
      return;
    }
    if( "MeshNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMeshNV ;
      return;
    }
    if( "eMeshNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMeshNV ;
      return;
    }
    if( "VK_SHADER_STAGE_MESH_BIT_NV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMeshNV ;
      return;
    }
    if( "SubpassShadingHUAWEI" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eSubpassShadingHUAWEI ;
      return;
    }
    if( "eSubpassShadingHUAWEI" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eSubpassShadingHUAWEI ;
      return;
    }
    if( "VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eSubpassShadingHUAWEI ;
      return;
    }
    if( "AnyHitNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAnyHitNV ;
      return;
    }
    if( "eAnyHitNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAnyHitNV ;
      return;
    }
    if( "VK_SHADER_STAGE_ANY_HIT_BIT_NV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eAnyHitNV ;
      return;
    }
    if( "CallableNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCallableNV ;
      return;
    }
    if( "eCallableNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCallableNV ;
      return;
    }
    if( "VK_SHADER_STAGE_CALLABLE_BIT_NV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eCallableNV ;
      return;
    }
    if( "ClosestHitNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eClosestHitNV ;
      return;
    }
    if( "eClosestHitNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eClosestHitNV ;
      return;
    }
    if( "VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eClosestHitNV ;
      return;
    }
    if( "IntersectionNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eIntersectionNV ;
      return;
    }
    if( "eIntersectionNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eIntersectionNV ;
      return;
    }
    if( "VK_SHADER_STAGE_INTERSECTION_BIT_NV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eIntersectionNV ;
      return;
    }
    if( "MissNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMissNV ;
      return;
    }
    if( "eMissNV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMissNV ;
      return;
    }
    if( "VK_SHADER_STAGE_MISS_BIT_NV" == j.get< std::string >() ) {
      p = ShaderStageFlagBits :: eMissNV ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ShaderStageFlagBits" );
  }
  if( j.is_number() ) {
    p = ShaderStageFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ShaderStageFlagBits" );
}
inline void to_json( nlohmann::json &j, const ShaderStageFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ShaderStageFlagBits ) * 8u; ++n ) {
    if( p & ShaderStageFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ShaderStageFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ShaderStageFlags &p ) {
  if( j.is_array() ) {
    p = ShaderStageFlags ( 0 );
    for( auto &e:  j ) {
      ShaderStageFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ShaderStageFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const SamplerCreateFlagBits &p ) {
  if( SamplerCreateFlagBits :: eSubsampledEXT == p ) {
    j = "SubsampledEXT";
    return;
  }
}
inline void from_json( const nlohmann::json &j, SamplerCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "SubsampledEXT" == j.get< std::string >() ) {
      p = SamplerCreateFlagBits :: eSubsampledEXT ;
      return;
    }
    if( "eSubsampledEXT" == j.get< std::string >() ) {
      p = SamplerCreateFlagBits :: eSubsampledEXT ;
      return;
    }
    if( "VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT" == j.get< std::string >() ) {
      p = SamplerCreateFlagBits :: eSubsampledEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SamplerCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = SamplerCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SamplerCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const SamplerCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SamplerCreateFlagBits ) * 8u; ++n ) {
    if( p & SamplerCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SamplerCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, SamplerCreateFlags &p ) {
  if( j.is_array() ) {
    p = SamplerCreateFlags ( 0 );
    for( auto &e:  j ) {
      SamplerCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SamplerCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const DescriptorPoolCreateFlagBits &p ) {
  if( DescriptorPoolCreateFlagBits :: eFreeDescriptorSet == p ) {
    j = "FreeDescriptorSet";
    return;
  }
  if( DescriptorPoolCreateFlagBits :: eUpdateAfterBind == p ) {
    j = "UpdateAfterBind";
    return;
  }
  if( DescriptorPoolCreateFlagBits :: eHostOnlyVALVE == p ) {
    j = "HostOnlyVALVE";
    return;
  }
}
inline void from_json( const nlohmann::json &j, DescriptorPoolCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "FreeDescriptorSet" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eFreeDescriptorSet ;
      return;
    }
    if( "eFreeDescriptorSet" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eFreeDescriptorSet ;
      return;
    }
    if( "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eFreeDescriptorSet ;
      return;
    }
    if( "UpdateAfterBind" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eUpdateAfterBind ;
      return;
    }
    if( "eUpdateAfterBind" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eUpdateAfterBind ;
      return;
    }
    if( "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eUpdateAfterBind ;
      return;
    }
    if( "HostOnlyVALVE" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eHostOnlyVALVE ;
      return;
    }
    if( "eHostOnlyVALVE" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eHostOnlyVALVE ;
      return;
    }
    if( "VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE" == j.get< std::string >() ) {
      p = DescriptorPoolCreateFlagBits :: eHostOnlyVALVE ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DescriptorPoolCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = DescriptorPoolCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DescriptorPoolCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const DescriptorPoolCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DescriptorPoolCreateFlagBits ) * 8u; ++n ) {
    if( p & DescriptorPoolCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DescriptorPoolCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DescriptorPoolCreateFlags &p ) {
  if( j.is_array() ) {
    p = DescriptorPoolCreateFlags ( 0 );
    for( auto &e:  j ) {
      DescriptorPoolCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DescriptorPoolCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const DescriptorSetLayoutCreateFlagBits &p ) {
  if( DescriptorSetLayoutCreateFlagBits :: eUpdateAfterBindPool == p ) {
    j = "UpdateAfterBindPool";
    return;
  }
  if( DescriptorSetLayoutCreateFlagBits :: ePushDescriptorKHR == p ) {
    j = "PushDescriptorKHR";
    return;
  }
  if( DescriptorSetLayoutCreateFlagBits :: eHostOnlyPoolVALVE == p ) {
    j = "HostOnlyPoolVALVE";
    return;
  }
}
inline void from_json( const nlohmann::json &j, DescriptorSetLayoutCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "UpdateAfterBindPool" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: eUpdateAfterBindPool ;
      return;
    }
    if( "eUpdateAfterBindPool" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: eUpdateAfterBindPool ;
      return;
    }
    if( "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: eUpdateAfterBindPool ;
      return;
    }
    if( "PushDescriptorKHR" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: ePushDescriptorKHR ;
      return;
    }
    if( "ePushDescriptorKHR" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: ePushDescriptorKHR ;
      return;
    }
    if( "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: ePushDescriptorKHR ;
      return;
    }
    if( "HostOnlyPoolVALVE" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: eHostOnlyPoolVALVE ;
      return;
    }
    if( "eHostOnlyPoolVALVE" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: eHostOnlyPoolVALVE ;
      return;
    }
    if( "VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE" == j.get< std::string >() ) {
      p = DescriptorSetLayoutCreateFlagBits :: eHostOnlyPoolVALVE ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DescriptorSetLayoutCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = DescriptorSetLayoutCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DescriptorSetLayoutCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const DescriptorSetLayoutCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DescriptorSetLayoutCreateFlagBits ) * 8u; ++n ) {
    if( p & DescriptorSetLayoutCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DescriptorSetLayoutCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DescriptorSetLayoutCreateFlags &p ) {
  if( j.is_array() ) {
    p = DescriptorSetLayoutCreateFlags ( 0 );
    for( auto &e:  j ) {
      DescriptorSetLayoutCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DescriptorSetLayoutCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const AccessFlagBits &p ) {
  if( AccessFlagBits :: eIndirectCommandRead == p ) {
    j = "IndirectCommandRead";
    return;
  }
  if( AccessFlagBits :: eIndexRead == p ) {
    j = "IndexRead";
    return;
  }
  if( AccessFlagBits :: eVertexAttributeRead == p ) {
    j = "VertexAttributeRead";
    return;
  }
  if( AccessFlagBits :: eUniformRead == p ) {
    j = "UniformRead";
    return;
  }
  if( AccessFlagBits :: eInputAttachmentRead == p ) {
    j = "InputAttachmentRead";
    return;
  }
  if( AccessFlagBits :: eShaderRead == p ) {
    j = "ShaderRead";
    return;
  }
  if( AccessFlagBits :: eShaderWrite == p ) {
    j = "ShaderWrite";
    return;
  }
  if( AccessFlagBits :: eColorAttachmentRead == p ) {
    j = "ColorAttachmentRead";
    return;
  }
  if( AccessFlagBits :: eColorAttachmentWrite == p ) {
    j = "ColorAttachmentWrite";
    return;
  }
  if( AccessFlagBits :: eDepthStencilAttachmentRead == p ) {
    j = "DepthStencilAttachmentRead";
    return;
  }
  if( AccessFlagBits :: eDepthStencilAttachmentWrite == p ) {
    j = "DepthStencilAttachmentWrite";
    return;
  }
  if( AccessFlagBits :: eTransferRead == p ) {
    j = "TransferRead";
    return;
  }
  if( AccessFlagBits :: eTransferWrite == p ) {
    j = "TransferWrite";
    return;
  }
  if( AccessFlagBits :: eHostRead == p ) {
    j = "HostRead";
    return;
  }
  if( AccessFlagBits :: eHostWrite == p ) {
    j = "HostWrite";
    return;
  }
  if( AccessFlagBits :: eMemoryRead == p ) {
    j = "MemoryRead";
    return;
  }
  if( AccessFlagBits :: eMemoryWrite == p ) {
    j = "MemoryWrite";
    return;
  }
  if( AccessFlagBits :: eTransformFeedbackWriteEXT == p ) {
    j = "TransformFeedbackWriteEXT";
    return;
  }
  if( AccessFlagBits :: eTransformFeedbackCounterReadEXT == p ) {
    j = "TransformFeedbackCounterReadEXT";
    return;
  }
  if( AccessFlagBits :: eTransformFeedbackCounterWriteEXT == p ) {
    j = "TransformFeedbackCounterWriteEXT";
    return;
  }
  if( AccessFlagBits :: eConditionalRenderingReadEXT == p ) {
    j = "ConditionalRenderingReadEXT";
    return;
  }
  if( AccessFlagBits :: eColorAttachmentReadNoncoherentEXT == p ) {
    j = "ColorAttachmentReadNoncoherentEXT";
    return;
  }
  if( AccessFlagBits :: eAccelerationStructureReadKHR == p ) {
    j = "AccelerationStructureReadKHR";
    return;
  }
  if( AccessFlagBits :: eAccelerationStructureWriteKHR == p ) {
    j = "AccelerationStructureWriteKHR";
    return;
  }
  if( AccessFlagBits :: eFragmentDensityMapReadEXT == p ) {
    j = "FragmentDensityMapReadEXT";
    return;
  }
  if( AccessFlagBits :: eFragmentShadingRateAttachmentReadKHR == p ) {
    j = "FragmentShadingRateAttachmentReadKHR";
    return;
  }
  if( AccessFlagBits :: eCommandPreprocessReadNV == p ) {
    j = "CommandPreprocessReadNV";
    return;
  }
  if( AccessFlagBits :: eCommandPreprocessWriteNV == p ) {
    j = "CommandPreprocessWriteNV";
    return;
  }
  if( AccessFlagBits :: eNoneKHR == p ) {
    j = "NoneKHR";
    return;
  }
  if( AccessFlagBits :: eAccelerationStructureReadNV == p ) {
    j = "AccelerationStructureReadNV";
    return;
  }
  if( AccessFlagBits :: eAccelerationStructureWriteNV == p ) {
    j = "AccelerationStructureWriteNV";
    return;
  }
}
inline void from_json( const nlohmann::json &j, AccessFlagBits &p ) {
  if( j.is_string() ) {
    if( "IndirectCommandRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eIndirectCommandRead ;
      return;
    }
    if( "eIndirectCommandRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eIndirectCommandRead ;
      return;
    }
    if( "VK_ACCESS_INDIRECT_COMMAND_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eIndirectCommandRead ;
      return;
    }
    if( "IndexRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eIndexRead ;
      return;
    }
    if( "eIndexRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eIndexRead ;
      return;
    }
    if( "VK_ACCESS_INDEX_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eIndexRead ;
      return;
    }
    if( "VertexAttributeRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eVertexAttributeRead ;
      return;
    }
    if( "eVertexAttributeRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eVertexAttributeRead ;
      return;
    }
    if( "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eVertexAttributeRead ;
      return;
    }
    if( "UniformRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eUniformRead ;
      return;
    }
    if( "eUniformRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eUniformRead ;
      return;
    }
    if( "VK_ACCESS_UNIFORM_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eUniformRead ;
      return;
    }
    if( "InputAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eInputAttachmentRead ;
      return;
    }
    if( "eInputAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eInputAttachmentRead ;
      return;
    }
    if( "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eInputAttachmentRead ;
      return;
    }
    if( "ShaderRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eShaderRead ;
      return;
    }
    if( "eShaderRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eShaderRead ;
      return;
    }
    if( "VK_ACCESS_SHADER_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eShaderRead ;
      return;
    }
    if( "ShaderWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eShaderWrite ;
      return;
    }
    if( "eShaderWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eShaderWrite ;
      return;
    }
    if( "VK_ACCESS_SHADER_WRITE_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eShaderWrite ;
      return;
    }
    if( "ColorAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentRead ;
      return;
    }
    if( "eColorAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentRead ;
      return;
    }
    if( "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentRead ;
      return;
    }
    if( "ColorAttachmentWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentWrite ;
      return;
    }
    if( "eColorAttachmentWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentWrite ;
      return;
    }
    if( "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentWrite ;
      return;
    }
    if( "DepthStencilAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eDepthStencilAttachmentRead ;
      return;
    }
    if( "eDepthStencilAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eDepthStencilAttachmentRead ;
      return;
    }
    if( "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eDepthStencilAttachmentRead ;
      return;
    }
    if( "DepthStencilAttachmentWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eDepthStencilAttachmentWrite ;
      return;
    }
    if( "eDepthStencilAttachmentWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eDepthStencilAttachmentWrite ;
      return;
    }
    if( "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eDepthStencilAttachmentWrite ;
      return;
    }
    if( "TransferRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransferRead ;
      return;
    }
    if( "eTransferRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransferRead ;
      return;
    }
    if( "VK_ACCESS_TRANSFER_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransferRead ;
      return;
    }
    if( "TransferWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransferWrite ;
      return;
    }
    if( "eTransferWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransferWrite ;
      return;
    }
    if( "VK_ACCESS_TRANSFER_WRITE_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransferWrite ;
      return;
    }
    if( "HostRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eHostRead ;
      return;
    }
    if( "eHostRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eHostRead ;
      return;
    }
    if( "VK_ACCESS_HOST_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eHostRead ;
      return;
    }
    if( "HostWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eHostWrite ;
      return;
    }
    if( "eHostWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eHostWrite ;
      return;
    }
    if( "VK_ACCESS_HOST_WRITE_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eHostWrite ;
      return;
    }
    if( "MemoryRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eMemoryRead ;
      return;
    }
    if( "eMemoryRead" == j.get< std::string >() ) {
      p = AccessFlagBits :: eMemoryRead ;
      return;
    }
    if( "VK_ACCESS_MEMORY_READ_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eMemoryRead ;
      return;
    }
    if( "MemoryWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eMemoryWrite ;
      return;
    }
    if( "eMemoryWrite" == j.get< std::string >() ) {
      p = AccessFlagBits :: eMemoryWrite ;
      return;
    }
    if( "VK_ACCESS_MEMORY_WRITE_BIT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eMemoryWrite ;
      return;
    }
    if( "TransformFeedbackWriteEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackWriteEXT ;
      return;
    }
    if( "eTransformFeedbackWriteEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackWriteEXT ;
      return;
    }
    if( "VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackWriteEXT ;
      return;
    }
    if( "TransformFeedbackCounterReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackCounterReadEXT ;
      return;
    }
    if( "eTransformFeedbackCounterReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackCounterReadEXT ;
      return;
    }
    if( "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackCounterReadEXT ;
      return;
    }
    if( "TransformFeedbackCounterWriteEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackCounterWriteEXT ;
      return;
    }
    if( "eTransformFeedbackCounterWriteEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackCounterWriteEXT ;
      return;
    }
    if( "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eTransformFeedbackCounterWriteEXT ;
      return;
    }
    if( "ConditionalRenderingReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eConditionalRenderingReadEXT ;
      return;
    }
    if( "eConditionalRenderingReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eConditionalRenderingReadEXT ;
      return;
    }
    if( "VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eConditionalRenderingReadEXT ;
      return;
    }
    if( "ColorAttachmentReadNoncoherentEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentReadNoncoherentEXT ;
      return;
    }
    if( "eColorAttachmentReadNoncoherentEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentReadNoncoherentEXT ;
      return;
    }
    if( "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eColorAttachmentReadNoncoherentEXT ;
      return;
    }
    if( "AccelerationStructureReadKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureReadKHR ;
      return;
    }
    if( "eAccelerationStructureReadKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureReadKHR ;
      return;
    }
    if( "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureReadKHR ;
      return;
    }
    if( "AccelerationStructureWriteKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureWriteKHR ;
      return;
    }
    if( "eAccelerationStructureWriteKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureWriteKHR ;
      return;
    }
    if( "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureWriteKHR ;
      return;
    }
    if( "FragmentDensityMapReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eFragmentDensityMapReadEXT ;
      return;
    }
    if( "eFragmentDensityMapReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eFragmentDensityMapReadEXT ;
      return;
    }
    if( "VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits :: eFragmentDensityMapReadEXT ;
      return;
    }
    if( "FragmentShadingRateAttachmentReadKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eFragmentShadingRateAttachmentReadKHR ;
      return;
    }
    if( "eFragmentShadingRateAttachmentReadKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eFragmentShadingRateAttachmentReadKHR ;
      return;
    }
    if( "VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eFragmentShadingRateAttachmentReadKHR ;
      return;
    }
    if( "CommandPreprocessReadNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eCommandPreprocessReadNV ;
      return;
    }
    if( "eCommandPreprocessReadNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eCommandPreprocessReadNV ;
      return;
    }
    if( "VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eCommandPreprocessReadNV ;
      return;
    }
    if( "CommandPreprocessWriteNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eCommandPreprocessWriteNV ;
      return;
    }
    if( "eCommandPreprocessWriteNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eCommandPreprocessWriteNV ;
      return;
    }
    if( "VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eCommandPreprocessWriteNV ;
      return;
    }
    if( "NoneKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eNoneKHR ;
      return;
    }
    if( "eNoneKHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eNoneKHR ;
      return;
    }
    if( "VK_ACCESS_NONE_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits :: eNoneKHR ;
      return;
    }
    if( "AccelerationStructureReadNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureReadNV ;
      return;
    }
    if( "eAccelerationStructureReadNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureReadNV ;
      return;
    }
    if( "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureReadNV ;
      return;
    }
    if( "AccelerationStructureWriteNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureWriteNV ;
      return;
    }
    if( "eAccelerationStructureWriteNV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureWriteNV ;
      return;
    }
    if( "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV" == j.get< std::string >() ) {
      p = AccessFlagBits :: eAccelerationStructureWriteNV ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccessFlagBits" );
  }
  if( j.is_number() ) {
    p = AccessFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccessFlagBits" );
}
inline void to_json( nlohmann::json &j, const AccessFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( AccessFlagBits ) * 8u; ++n ) {
    if( p & AccessFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, AccessFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, AccessFlags &p ) {
  if( j.is_array() ) {
    p = AccessFlags ( 0 );
    for( auto &e:  j ) {
      AccessFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for AccessFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const AttachmentDescriptionFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, AttachmentDescriptionFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for AttachmentDescriptionFlagBits" );
  }
  if( j.is_number() ) {
    p = AttachmentDescriptionFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AttachmentDescriptionFlagBits" );
}
inline void to_json( nlohmann::json &j, const AttachmentDescriptionFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( AttachmentDescriptionFlagBits ) * 8u; ++n ) {
    if( p & AttachmentDescriptionFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, AttachmentDescriptionFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, AttachmentDescriptionFlags &p ) {
  if( j.is_array() ) {
    p = AttachmentDescriptionFlags ( 0 );
    for( auto &e:  j ) {
      AttachmentDescriptionFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for AttachmentDescriptionFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const DependencyFlagBits &p ) {
  if( DependencyFlagBits :: eByRegion == p ) {
    j = "ByRegion";
    return;
  }
  if( DependencyFlagBits :: eDeviceGroup == p ) {
    j = "DeviceGroup";
    return;
  }
  if( DependencyFlagBits :: eViewLocal == p ) {
    j = "ViewLocal";
    return;
  }
  if( DependencyFlagBits :: eDeviceGroupKHR == p ) {
    j = "DeviceGroupKHR";
    return;
  }
}
inline void from_json( const nlohmann::json &j, DependencyFlagBits &p ) {
  if( j.is_string() ) {
    if( "ByRegion" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eByRegion ;
      return;
    }
    if( "eByRegion" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eByRegion ;
      return;
    }
    if( "VK_DEPENDENCY_BY_REGION_BIT" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eByRegion ;
      return;
    }
    if( "DeviceGroup" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eDeviceGroup ;
      return;
    }
    if( "eDeviceGroup" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eDeviceGroup ;
      return;
    }
    if( "VK_DEPENDENCY_DEVICE_GROUP_BIT" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eDeviceGroup ;
      return;
    }
    if( "ViewLocal" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eViewLocal ;
      return;
    }
    if( "eViewLocal" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eViewLocal ;
      return;
    }
    if( "VK_DEPENDENCY_VIEW_LOCAL_BIT" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eViewLocal ;
      return;
    }
    if( "DeviceGroupKHR" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eDeviceGroupKHR ;
      return;
    }
    if( "eDeviceGroupKHR" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eDeviceGroupKHR ;
      return;
    }
    if( "VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR" == j.get< std::string >() ) {
      p = DependencyFlagBits :: eDeviceGroupKHR ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DependencyFlagBits" );
  }
  if( j.is_number() ) {
    p = DependencyFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DependencyFlagBits" );
}
inline void to_json( nlohmann::json &j, const DependencyFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DependencyFlagBits ) * 8u; ++n ) {
    if( p & DependencyFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DependencyFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DependencyFlags &p ) {
  if( j.is_array() ) {
    p = DependencyFlags ( 0 );
    for( auto &e:  j ) {
      DependencyFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DependencyFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const FramebufferCreateFlagBits &p ) {
  if( FramebufferCreateFlagBits :: eImageless == p ) {
    j = "Imageless";
    return;
  }
}
inline void from_json( const nlohmann::json &j, FramebufferCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "Imageless" == j.get< std::string >() ) {
      p = FramebufferCreateFlagBits :: eImageless ;
      return;
    }
    if( "eImageless" == j.get< std::string >() ) {
      p = FramebufferCreateFlagBits :: eImageless ;
      return;
    }
    if( "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT" == j.get< std::string >() ) {
      p = FramebufferCreateFlagBits :: eImageless ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for FramebufferCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = FramebufferCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FramebufferCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const FramebufferCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( FramebufferCreateFlagBits ) * 8u; ++n ) {
    if( p & FramebufferCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, FramebufferCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, FramebufferCreateFlags &p ) {
  if( j.is_array() ) {
    p = FramebufferCreateFlags ( 0 );
    for( auto &e:  j ) {
      FramebufferCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for FramebufferCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const RenderPassCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, RenderPassCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for RenderPassCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = RenderPassCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for RenderPassCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const RenderPassCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( RenderPassCreateFlagBits ) * 8u; ++n ) {
    if( p & RenderPassCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, RenderPassCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, RenderPassCreateFlags &p ) {
  if( j.is_array() ) {
    p = RenderPassCreateFlags ( 0 );
    for( auto &e:  j ) {
      RenderPassCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for RenderPassCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const SubpassDescriptionFlagBits &p ) {
  if( SubpassDescriptionFlagBits :: ePerViewAttributesNVX == p ) {
    j = "PerViewAttributesNVX";
    return;
  }
  if( SubpassDescriptionFlagBits :: ePerViewPositionXOnlyNVX == p ) {
    j = "PerViewPositionXOnlyNVX";
    return;
  }
  if( SubpassDescriptionFlagBits :: eFragmentRegionQCOM == p ) {
    j = "FragmentRegionQCOM";
    return;
  }
}
inline void from_json( const nlohmann::json &j, SubpassDescriptionFlagBits &p ) {
  if( j.is_string() ) {
    if( "PerViewAttributesNVX" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: ePerViewAttributesNVX ;
      return;
    }
    if( "ePerViewAttributesNVX" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: ePerViewAttributesNVX ;
      return;
    }
    if( "VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: ePerViewAttributesNVX ;
      return;
    }
    if( "PerViewPositionXOnlyNVX" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: ePerViewPositionXOnlyNVX ;
      return;
    }
    if( "ePerViewPositionXOnlyNVX" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: ePerViewPositionXOnlyNVX ;
      return;
    }
    if( "VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: ePerViewPositionXOnlyNVX ;
      return;
    }
    if( "FragmentRegionQCOM" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: eFragmentRegionQCOM ;
      return;
    }
    if( "eFragmentRegionQCOM" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: eFragmentRegionQCOM ;
      return;
    }
    if( "VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM" == j.get< std::string >() ) {
      p = SubpassDescriptionFlagBits :: eFragmentRegionQCOM ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SubpassDescriptionFlagBits" );
  }
  if( j.is_number() ) {
    p = SubpassDescriptionFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SubpassDescriptionFlagBits" );
}
inline void to_json( nlohmann::json &j, const SubpassDescriptionFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SubpassDescriptionFlagBits ) * 8u; ++n ) {
    if( p & SubpassDescriptionFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SubpassDescriptionFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, SubpassDescriptionFlags &p ) {
  if( j.is_array() ) {
    p = SubpassDescriptionFlags ( 0 );
    for( auto &e:  j ) {
      SubpassDescriptionFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SubpassDescriptionFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const CommandPoolCreateFlagBits &p ) {
  if( CommandPoolCreateFlagBits :: eTransient == p ) {
    j = "Transient";
    return;
  }
  if( CommandPoolCreateFlagBits :: eResetCommandBuffer == p ) {
    j = "ResetCommandBuffer";
    return;
  }
}
inline void from_json( const nlohmann::json &j, CommandPoolCreateFlagBits &p ) {
  if( j.is_string() ) {
    if( "Transient" == j.get< std::string >() ) {
      p = CommandPoolCreateFlagBits :: eTransient ;
      return;
    }
    if( "eTransient" == j.get< std::string >() ) {
      p = CommandPoolCreateFlagBits :: eTransient ;
      return;
    }
    if( "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT" == j.get< std::string >() ) {
      p = CommandPoolCreateFlagBits :: eTransient ;
      return;
    }
    if( "ResetCommandBuffer" == j.get< std::string >() ) {
      p = CommandPoolCreateFlagBits :: eResetCommandBuffer ;
      return;
    }
    if( "eResetCommandBuffer" == j.get< std::string >() ) {
      p = CommandPoolCreateFlagBits :: eResetCommandBuffer ;
      return;
    }
    if( "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT" == j.get< std::string >() ) {
      p = CommandPoolCreateFlagBits :: eResetCommandBuffer ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CommandPoolCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = CommandPoolCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CommandPoolCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const CommandPoolCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( CommandPoolCreateFlagBits ) * 8u; ++n ) {
    if( p & CommandPoolCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, CommandPoolCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, CommandPoolCreateFlags &p ) {
  if( j.is_array() ) {
    p = CommandPoolCreateFlags ( 0 );
    for( auto &e:  j ) {
      CommandPoolCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for CommandPoolCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const CommandPoolResetFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, CommandPoolResetFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for CommandPoolResetFlagBits" );
  }
  if( j.is_number() ) {
    p = CommandPoolResetFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CommandPoolResetFlagBits" );
}
inline void to_json( nlohmann::json &j, const CommandPoolResetFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( CommandPoolResetFlagBits ) * 8u; ++n ) {
    if( p & CommandPoolResetFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, CommandPoolResetFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, CommandPoolResetFlags &p ) {
  if( j.is_array() ) {
    p = CommandPoolResetFlags ( 0 );
    for( auto &e:  j ) {
      CommandPoolResetFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for CommandPoolResetFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const CommandBufferResetFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, CommandBufferResetFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for CommandBufferResetFlagBits" );
  }
  if( j.is_number() ) {
    p = CommandBufferResetFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CommandBufferResetFlagBits" );
}
inline void to_json( nlohmann::json &j, const CommandBufferResetFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( CommandBufferResetFlagBits ) * 8u; ++n ) {
    if( p & CommandBufferResetFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, CommandBufferResetFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, CommandBufferResetFlags &p ) {
  if( j.is_array() ) {
    p = CommandBufferResetFlags ( 0 );
    for( auto &e:  j ) {
      CommandBufferResetFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for CommandBufferResetFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const CommandBufferUsageFlagBits &p ) {
  if( CommandBufferUsageFlagBits :: eOneTimeSubmit == p ) {
    j = "OneTimeSubmit";
    return;
  }
  if( CommandBufferUsageFlagBits :: eRenderPassContinue == p ) {
    j = "RenderPassContinue";
    return;
  }
}
inline void from_json( const nlohmann::json &j, CommandBufferUsageFlagBits &p ) {
  if( j.is_string() ) {
    if( "OneTimeSubmit" == j.get< std::string >() ) {
      p = CommandBufferUsageFlagBits :: eOneTimeSubmit ;
      return;
    }
    if( "eOneTimeSubmit" == j.get< std::string >() ) {
      p = CommandBufferUsageFlagBits :: eOneTimeSubmit ;
      return;
    }
    if( "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT" == j.get< std::string >() ) {
      p = CommandBufferUsageFlagBits :: eOneTimeSubmit ;
      return;
    }
    if( "RenderPassContinue" == j.get< std::string >() ) {
      p = CommandBufferUsageFlagBits :: eRenderPassContinue ;
      return;
    }
    if( "eRenderPassContinue" == j.get< std::string >() ) {
      p = CommandBufferUsageFlagBits :: eRenderPassContinue ;
      return;
    }
    if( "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT" == j.get< std::string >() ) {
      p = CommandBufferUsageFlagBits :: eRenderPassContinue ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CommandBufferUsageFlagBits" );
  }
  if( j.is_number() ) {
    p = CommandBufferUsageFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CommandBufferUsageFlagBits" );
}
inline void to_json( nlohmann::json &j, const CommandBufferUsageFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( CommandBufferUsageFlagBits ) * 8u; ++n ) {
    if( p & CommandBufferUsageFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, CommandBufferUsageFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, CommandBufferUsageFlags &p ) {
  if( j.is_array() ) {
    p = CommandBufferUsageFlags ( 0 );
    for( auto &e:  j ) {
      CommandBufferUsageFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for CommandBufferUsageFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const QueryControlFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, QueryControlFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueryControlFlagBits" );
  }
  if( j.is_number() ) {
    p = QueryControlFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueryControlFlagBits" );
}
inline void to_json( nlohmann::json &j, const QueryControlFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( QueryControlFlagBits ) * 8u; ++n ) {
    if( p & QueryControlFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, QueryControlFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, QueryControlFlags &p ) {
  if( j.is_array() ) {
    p = QueryControlFlags ( 0 );
    for( auto &e:  j ) {
      QueryControlFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for QueryControlFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const StencilFaceFlagBits &p ) {
  if( StencilFaceFlagBits :: eFront == p ) {
    j = "Front";
    return;
  }
  if( StencilFaceFlagBits :: eBack == p ) {
    j = "Back";
    return;
  }
  if( StencilFaceFlagBits :: eFrontAndBack == p ) {
    j = "FrontAndBack";
    return;
  }
}
inline void from_json( const nlohmann::json &j, StencilFaceFlagBits &p ) {
  if( j.is_string() ) {
    if( "Front" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eFront ;
      return;
    }
    if( "eFront" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eFront ;
      return;
    }
    if( "VK_STENCIL_FACE_FRONT_BIT" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eFront ;
      return;
    }
    if( "Back" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eBack ;
      return;
    }
    if( "eBack" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eBack ;
      return;
    }
    if( "VK_STENCIL_FACE_BACK_BIT" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eBack ;
      return;
    }
    if( "FrontAndBack" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eFrontAndBack ;
      return;
    }
    if( "eFrontAndBack" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eFrontAndBack ;
      return;
    }
    if( "VK_STENCIL_FACE_FRONT_AND_BACK" == j.get< std::string >() ) {
      p = StencilFaceFlagBits :: eFrontAndBack ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for StencilFaceFlagBits" );
  }
  if( j.is_number() ) {
    p = StencilFaceFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for StencilFaceFlagBits" );
}
inline void to_json( nlohmann::json &j, const StencilFaceFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( StencilFaceFlagBits ) * 8u; ++n ) {
    if( p & StencilFaceFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, StencilFaceFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, StencilFaceFlags &p ) {
  if( j.is_array() ) {
    p = StencilFaceFlags ( 0 );
    for( auto &e:  j ) {
      StencilFaceFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for StencilFaceFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const InstanceCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, InstanceCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for InstanceCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = InstanceCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for InstanceCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const InstanceCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( InstanceCreateFlagBits ) * 8u; ++n ) {
    if( p & InstanceCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, InstanceCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, InstanceCreateFlags &p ) {
  if( j.is_array() ) {
    p = InstanceCreateFlags ( 0 );
    for( auto &e:  j ) {
      InstanceCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for InstanceCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const DeviceCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, DeviceCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DeviceCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = DeviceCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DeviceCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const DeviceCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DeviceCreateFlagBits ) * 8u; ++n ) {
    if( p & DeviceCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DeviceCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DeviceCreateFlags &p ) {
  if( j.is_array() ) {
    p = DeviceCreateFlags ( 0 );
    for( auto &e:  j ) {
      DeviceCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DeviceCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const MemoryMapFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, MemoryMapFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for MemoryMapFlagBits" );
  }
  if( j.is_number() ) {
    p = MemoryMapFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for MemoryMapFlagBits" );
}
inline void to_json( nlohmann::json &j, const MemoryMapFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( MemoryMapFlagBits ) * 8u; ++n ) {
    if( p & MemoryMapFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, MemoryMapFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, MemoryMapFlags &p ) {
  if( j.is_array() ) {
    p = MemoryMapFlags ( 0 );
    for( auto &e:  j ) {
      MemoryMapFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for MemoryMapFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const SemaphoreCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, SemaphoreCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for SemaphoreCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = SemaphoreCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SemaphoreCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const SemaphoreCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SemaphoreCreateFlagBits ) * 8u; ++n ) {
    if( p & SemaphoreCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SemaphoreCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, SemaphoreCreateFlags &p ) {
  if( j.is_array() ) {
    p = SemaphoreCreateFlags ( 0 );
    for( auto &e:  j ) {
      SemaphoreCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SemaphoreCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const QueryPoolCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, QueryPoolCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for QueryPoolCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = QueryPoolCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for QueryPoolCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const QueryPoolCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( QueryPoolCreateFlagBits ) * 8u; ++n ) {
    if( p & QueryPoolCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, QueryPoolCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, QueryPoolCreateFlags &p ) {
  if( j.is_array() ) {
    p = QueryPoolCreateFlags ( 0 );
    for( auto &e:  j ) {
      QueryPoolCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for QueryPoolCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const BufferViewCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, BufferViewCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for BufferViewCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = BufferViewCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BufferViewCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const BufferViewCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( BufferViewCreateFlagBits ) * 8u; ++n ) {
    if( p & BufferViewCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, BufferViewCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, BufferViewCreateFlags &p ) {
  if( j.is_array() ) {
    p = BufferViewCreateFlags ( 0 );
    for( auto &e:  j ) {
      BufferViewCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for BufferViewCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineColorBlendStateCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineColorBlendStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineColorBlendStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineColorBlendStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineColorBlendStateCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const PipelineColorBlendStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineColorBlendStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineColorBlendStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineColorBlendStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineColorBlendStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineColorBlendStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineColorBlendStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineColorBlendStateCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineDepthStencilStateCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineDepthStencilStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineDepthStencilStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineDepthStencilStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineDepthStencilStateCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const PipelineDepthStencilStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineDepthStencilStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineDepthStencilStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineDepthStencilStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineDepthStencilStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineDepthStencilStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineDepthStencilStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineDepthStencilStateCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineDynamicStateCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineDynamicStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineDynamicStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineDynamicStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineDynamicStateCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const PipelineDynamicStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineDynamicStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineDynamicStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineDynamicStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineDynamicStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineDynamicStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineDynamicStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineDynamicStateCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineInputAssemblyStateCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineInputAssemblyStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineInputAssemblyStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineInputAssemblyStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineInputAssemblyStateCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const PipelineInputAssemblyStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineInputAssemblyStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineInputAssemblyStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineInputAssemblyStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineInputAssemblyStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineInputAssemblyStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineInputAssemblyStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineInputAssemblyStateCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineLayoutCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineLayoutCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineLayoutCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineLayoutCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineLayoutCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const PipelineLayoutCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineLayoutCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineLayoutCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineLayoutCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineLayoutCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineLayoutCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineLayoutCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineLayoutCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineMultisampleStateCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineMultisampleStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineMultisampleStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineMultisampleStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineMultisampleStateCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const PipelineMultisampleStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineMultisampleStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineMultisampleStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineMultisampleStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineMultisampleStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineMultisampleStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineMultisampleStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineMultisampleStateCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineRasterizationStateCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineRasterizationStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineRasterizationStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineRasterizationStateCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const PipelineRasterizationStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineRasterizationStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineRasterizationStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineRasterizationStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineRasterizationStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineRasterizationStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineRasterizationStateCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineTessellationStateCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineTessellationStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineTessellationStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineTessellationStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineTessellationStateCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const PipelineTessellationStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineTessellationStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineTessellationStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineTessellationStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineTessellationStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineTessellationStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineTessellationStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineTessellationStateCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineVertexInputStateCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineVertexInputStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineVertexInputStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineVertexInputStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineVertexInputStateCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const PipelineVertexInputStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineVertexInputStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineVertexInputStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineVertexInputStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineVertexInputStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineVertexInputStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineVertexInputStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineVertexInputStateCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const PipelineViewportStateCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineViewportStateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineViewportStateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = PipelineViewportStateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineViewportStateCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const PipelineViewportStateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineViewportStateCreateFlagBits ) * 8u; ++n ) {
    if( p & PipelineViewportStateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineViewportStateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineViewportStateCreateFlags &p ) {
  if( j.is_array() ) {
    p = PipelineViewportStateCreateFlags ( 0 );
    for( auto &e:  j ) {
      PipelineViewportStateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineViewportStateCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_0
inline void to_json( nlohmann::json &j, const DescriptorPoolResetFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, DescriptorPoolResetFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DescriptorPoolResetFlagBits" );
  }
  if( j.is_number() ) {
    p = DescriptorPoolResetFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DescriptorPoolResetFlagBits" );
}
inline void to_json( nlohmann::json &j, const DescriptorPoolResetFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DescriptorPoolResetFlagBits ) * 8u; ++n ) {
    if( p & DescriptorPoolResetFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DescriptorPoolResetFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DescriptorPoolResetFlags &p ) {
  if( j.is_array() ) {
    p = DescriptorPoolResetFlags ( 0 );
    for( auto &e:  j ) {
      DescriptorPoolResetFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DescriptorPoolResetFlags" );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const SubgroupFeatureFlagBits &p ) {
  if( SubgroupFeatureFlagBits :: eBasic == p ) {
    j = "Basic";
    return;
  }
  if( SubgroupFeatureFlagBits :: eVote == p ) {
    j = "Vote";
    return;
  }
  if( SubgroupFeatureFlagBits :: eArithmetic == p ) {
    j = "Arithmetic";
    return;
  }
  if( SubgroupFeatureFlagBits :: eBallot == p ) {
    j = "Ballot";
    return;
  }
  if( SubgroupFeatureFlagBits :: eShuffle == p ) {
    j = "Shuffle";
    return;
  }
  if( SubgroupFeatureFlagBits :: eShuffleRelative == p ) {
    j = "ShuffleRelative";
    return;
  }
  if( SubgroupFeatureFlagBits :: eClustered == p ) {
    j = "Clustered";
    return;
  }
  if( SubgroupFeatureFlagBits :: eQuad == p ) {
    j = "Quad";
    return;
  }
}
inline void from_json( const nlohmann::json &j, SubgroupFeatureFlagBits &p ) {
  if( j.is_string() ) {
    if( "Basic" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eBasic ;
      return;
    }
    if( "eBasic" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eBasic ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_BASIC_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eBasic ;
      return;
    }
    if( "Vote" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eVote ;
      return;
    }
    if( "eVote" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eVote ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_VOTE_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eVote ;
      return;
    }
    if( "Arithmetic" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eArithmetic ;
      return;
    }
    if( "eArithmetic" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eArithmetic ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_ARITHMETIC_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eArithmetic ;
      return;
    }
    if( "Ballot" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eBallot ;
      return;
    }
    if( "eBallot" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eBallot ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_BALLOT_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eBallot ;
      return;
    }
    if( "Shuffle" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eShuffle ;
      return;
    }
    if( "eShuffle" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eShuffle ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_SHUFFLE_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eShuffle ;
      return;
    }
    if( "ShuffleRelative" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eShuffleRelative ;
      return;
    }
    if( "eShuffleRelative" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eShuffleRelative ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eShuffleRelative ;
      return;
    }
    if( "Clustered" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eClustered ;
      return;
    }
    if( "eClustered" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eClustered ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_CLUSTERED_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eClustered ;
      return;
    }
    if( "Quad" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eQuad ;
      return;
    }
    if( "eQuad" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eQuad ;
      return;
    }
    if( "VK_SUBGROUP_FEATURE_QUAD_BIT" == j.get< std::string >() ) {
      p = SubgroupFeatureFlagBits :: eQuad ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SubgroupFeatureFlagBits" );
  }
  if( j.is_number() ) {
    p = SubgroupFeatureFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SubgroupFeatureFlagBits" );
}
inline void to_json( nlohmann::json &j, const SubgroupFeatureFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SubgroupFeatureFlagBits ) * 8u; ++n ) {
    if( p & SubgroupFeatureFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SubgroupFeatureFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, SubgroupFeatureFlags &p ) {
  if( j.is_array() ) {
    p = SubgroupFeatureFlags ( 0 );
    for( auto &e:  j ) {
      SubgroupFeatureFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SubgroupFeatureFlags" );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const PeerMemoryFeatureFlagBits &p ) {
  if( PeerMemoryFeatureFlagBits :: eCopySrc == p ) {
    j = "CopySrc";
    return;
  }
  if( PeerMemoryFeatureFlagBits :: eCopyDst == p ) {
    j = "CopyDst";
    return;
  }
  if( PeerMemoryFeatureFlagBits :: eGenericSrc == p ) {
    j = "GenericSrc";
    return;
  }
}
inline void from_json( const nlohmann::json &j, PeerMemoryFeatureFlagBits &p ) {
  if( j.is_string() ) {
    if( "CopySrc" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eCopySrc ;
      return;
    }
    if( "eCopySrc" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eCopySrc ;
      return;
    }
    if( "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eCopySrc ;
      return;
    }
    if( "CopyDst" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eCopyDst ;
      return;
    }
    if( "eCopyDst" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eCopyDst ;
      return;
    }
    if( "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eCopyDst ;
      return;
    }
    if( "GenericSrc" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eGenericSrc ;
      return;
    }
    if( "eGenericSrc" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eGenericSrc ;
      return;
    }
    if( "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT" == j.get< std::string >() ) {
      p = PeerMemoryFeatureFlagBits :: eGenericSrc ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PeerMemoryFeatureFlagBits" );
  }
  if( j.is_number() ) {
    p = PeerMemoryFeatureFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PeerMemoryFeatureFlagBits" );
}
inline void to_json( nlohmann::json &j, const PeerMemoryFeatureFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PeerMemoryFeatureFlagBits ) * 8u; ++n ) {
    if( p & PeerMemoryFeatureFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PeerMemoryFeatureFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PeerMemoryFeatureFlags &p ) {
  if( j.is_array() ) {
    p = PeerMemoryFeatureFlags ( 0 );
    for( auto &e:  j ) {
      PeerMemoryFeatureFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PeerMemoryFeatureFlags" );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const MemoryAllocateFlagBits &p ) {
  if( MemoryAllocateFlagBits :: eDeviceMask == p ) {
    j = "DeviceMask";
    return;
  }
  if( MemoryAllocateFlagBits :: eDeviceAddress == p ) {
    j = "DeviceAddress";
    return;
  }
}
inline void from_json( const nlohmann::json &j, MemoryAllocateFlagBits &p ) {
  if( j.is_string() ) {
    if( "DeviceMask" == j.get< std::string >() ) {
      p = MemoryAllocateFlagBits :: eDeviceMask ;
      return;
    }
    if( "eDeviceMask" == j.get< std::string >() ) {
      p = MemoryAllocateFlagBits :: eDeviceMask ;
      return;
    }
    if( "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT" == j.get< std::string >() ) {
      p = MemoryAllocateFlagBits :: eDeviceMask ;
      return;
    }
    if( "DeviceAddress" == j.get< std::string >() ) {
      p = MemoryAllocateFlagBits :: eDeviceAddress ;
      return;
    }
    if( "eDeviceAddress" == j.get< std::string >() ) {
      p = MemoryAllocateFlagBits :: eDeviceAddress ;
      return;
    }
    if( "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT" == j.get< std::string >() ) {
      p = MemoryAllocateFlagBits :: eDeviceAddress ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for MemoryAllocateFlagBits" );
  }
  if( j.is_number() ) {
    p = MemoryAllocateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for MemoryAllocateFlagBits" );
}
inline void to_json( nlohmann::json &j, const MemoryAllocateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( MemoryAllocateFlagBits ) * 8u; ++n ) {
    if( p & MemoryAllocateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, MemoryAllocateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, MemoryAllocateFlags &p ) {
  if( j.is_array() ) {
    p = MemoryAllocateFlags ( 0 );
    for( auto &e:  j ) {
      MemoryAllocateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for MemoryAllocateFlags" );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const ExternalMemoryHandleTypeFlagBits &p ) {
  if( ExternalMemoryHandleTypeFlagBits :: eOpaqueFd == p ) {
    j = "OpaqueFd";
    return;
  }
  if( ExternalMemoryHandleTypeFlagBits :: eOpaqueWin32 == p ) {
    j = "OpaqueWin32";
    return;
  }
  if( ExternalMemoryHandleTypeFlagBits :: eOpaqueWin32Kmt == p ) {
    j = "OpaqueWin32Kmt";
    return;
  }
  if( ExternalMemoryHandleTypeFlagBits :: eD3D11Texture == p ) {
    j = "D3D11Texture";
    return;
  }
  if( ExternalMemoryHandleTypeFlagBits :: eD3D11TextureKmt == p ) {
    j = "D3D11TextureKmt";
    return;
  }
  if( ExternalMemoryHandleTypeFlagBits :: eD3D12Heap == p ) {
    j = "D3D12Heap";
    return;
  }
  if( ExternalMemoryHandleTypeFlagBits :: eD3D12Resource == p ) {
    j = "D3D12Resource";
    return;
  }
  if( ExternalMemoryHandleTypeFlagBits :: eDmaBufEXT == p ) {
    j = "DmaBufEXT";
    return;
  }
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
  if( ExternalMemoryHandleTypeFlagBits :: eAndroidHardwareBufferANDROID == p ) {
    j = "AndroidHardwareBufferANDROID";
    return;
  }
#endif
  if( ExternalMemoryHandleTypeFlagBits :: eHostAllocationEXT == p ) {
    j = "HostAllocationEXT";
    return;
  }
  if( ExternalMemoryHandleTypeFlagBits :: eHostMappedForeignMemoryEXT == p ) {
    j = "HostMappedForeignMemoryEXT";
    return;
  }
}
inline void from_json( const nlohmann::json &j, ExternalMemoryHandleTypeFlagBits &p ) {
  if( j.is_string() ) {
    if( "OpaqueFd" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eOpaqueFd ;
      return;
    }
    if( "eOpaqueFd" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eOpaqueFd ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eOpaqueFd ;
      return;
    }
    if( "OpaqueWin32" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eOpaqueWin32 ;
      return;
    }
    if( "eOpaqueWin32" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eOpaqueWin32 ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eOpaqueWin32 ;
      return;
    }
    if( "OpaqueWin32Kmt" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eOpaqueWin32Kmt ;
      return;
    }
    if( "eOpaqueWin32Kmt" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eOpaqueWin32Kmt ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eOpaqueWin32Kmt ;
      return;
    }
    if( "D3D11Texture" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eD3D11Texture ;
      return;
    }
    if( "eD3D11Texture" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eD3D11Texture ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eD3D11Texture ;
      return;
    }
    if( "D3D11TextureKmt" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eD3D11TextureKmt ;
      return;
    }
    if( "eD3D11TextureKmt" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eD3D11TextureKmt ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eD3D11TextureKmt ;
      return;
    }
    if( "D3D12Heap" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eD3D12Heap ;
      return;
    }
    if( "eD3D12Heap" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eD3D12Heap ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eD3D12Heap ;
      return;
    }
    if( "D3D12Resource" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eD3D12Resource ;
      return;
    }
    if( "eD3D12Resource" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eD3D12Resource ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eD3D12Resource ;
      return;
    }
    if( "DmaBufEXT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eDmaBufEXT ;
      return;
    }
    if( "eDmaBufEXT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eDmaBufEXT ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eDmaBufEXT ;
      return;
    }
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "AndroidHardwareBufferANDROID" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eAndroidHardwareBufferANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "eAndroidHardwareBufferANDROID" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eAndroidHardwareBufferANDROID ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eAndroidHardwareBufferANDROID ;
      return;
    }
#endif
    if( "HostAllocationEXT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eHostAllocationEXT ;
      return;
    }
    if( "eHostAllocationEXT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eHostAllocationEXT ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eHostAllocationEXT ;
      return;
    }
    if( "HostMappedForeignMemoryEXT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eHostMappedForeignMemoryEXT ;
      return;
    }
    if( "eHostMappedForeignMemoryEXT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eHostMappedForeignMemoryEXT ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBits :: eHostMappedForeignMemoryEXT ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ExternalMemoryHandleTypeFlagBits" );
  }
  if( j.is_number() ) {
    p = ExternalMemoryHandleTypeFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ExternalMemoryHandleTypeFlagBits" );
}
inline void to_json( nlohmann::json &j, const ExternalMemoryHandleTypeFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ExternalMemoryHandleTypeFlagBits ) * 8u; ++n ) {
    if( p & ExternalMemoryHandleTypeFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ExternalMemoryHandleTypeFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ExternalMemoryHandleTypeFlags &p ) {
  if( j.is_array() ) {
    p = ExternalMemoryHandleTypeFlags ( 0 );
    for( auto &e:  j ) {
      ExternalMemoryHandleTypeFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ExternalMemoryHandleTypeFlags" );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const ExternalMemoryFeatureFlagBits &p ) {
  if( ExternalMemoryFeatureFlagBits :: eDedicatedOnly == p ) {
    j = "DedicatedOnly";
    return;
  }
  if( ExternalMemoryFeatureFlagBits :: eExportable == p ) {
    j = "Exportable";
    return;
  }
}
inline void from_json( const nlohmann::json &j, ExternalMemoryFeatureFlagBits &p ) {
  if( j.is_string() ) {
    if( "DedicatedOnly" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBits :: eDedicatedOnly ;
      return;
    }
    if( "eDedicatedOnly" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBits :: eDedicatedOnly ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBits :: eDedicatedOnly ;
      return;
    }
    if( "Exportable" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBits :: eExportable ;
      return;
    }
    if( "eExportable" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBits :: eExportable ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBits :: eExportable ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ExternalMemoryFeatureFlagBits" );
  }
  if( j.is_number() ) {
    p = ExternalMemoryFeatureFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ExternalMemoryFeatureFlagBits" );
}
inline void to_json( nlohmann::json &j, const ExternalMemoryFeatureFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ExternalMemoryFeatureFlagBits ) * 8u; ++n ) {
    if( p & ExternalMemoryFeatureFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ExternalMemoryFeatureFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ExternalMemoryFeatureFlags &p ) {
  if( j.is_array() ) {
    p = ExternalMemoryFeatureFlags ( 0 );
    for( auto &e:  j ) {
      ExternalMemoryFeatureFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ExternalMemoryFeatureFlags" );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const ExternalFenceHandleTypeFlagBits &p ) {
  if( ExternalFenceHandleTypeFlagBits :: eOpaqueFd == p ) {
    j = "OpaqueFd";
    return;
  }
  if( ExternalFenceHandleTypeFlagBits :: eOpaqueWin32 == p ) {
    j = "OpaqueWin32";
    return;
  }
  if( ExternalFenceHandleTypeFlagBits :: eOpaqueWin32Kmt == p ) {
    j = "OpaqueWin32Kmt";
    return;
  }
}
inline void from_json( const nlohmann::json &j, ExternalFenceHandleTypeFlagBits &p ) {
  if( j.is_string() ) {
    if( "OpaqueFd" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueFd ;
      return;
    }
    if( "eOpaqueFd" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueFd ;
      return;
    }
    if( "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueFd ;
      return;
    }
    if( "OpaqueWin32" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueWin32 ;
      return;
    }
    if( "eOpaqueWin32" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueWin32 ;
      return;
    }
    if( "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueWin32 ;
      return;
    }
    if( "OpaqueWin32Kmt" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueWin32Kmt ;
      return;
    }
    if( "eOpaqueWin32Kmt" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueWin32Kmt ;
      return;
    }
    if( "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT" == j.get< std::string >() ) {
      p = ExternalFenceHandleTypeFlagBits :: eOpaqueWin32Kmt ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ExternalFenceHandleTypeFlagBits" );
  }
  if( j.is_number() ) {
    p = ExternalFenceHandleTypeFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ExternalFenceHandleTypeFlagBits" );
}
inline void to_json( nlohmann::json &j, const ExternalFenceHandleTypeFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ExternalFenceHandleTypeFlagBits ) * 8u; ++n ) {
    if( p & ExternalFenceHandleTypeFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ExternalFenceHandleTypeFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ExternalFenceHandleTypeFlags &p ) {
  if( j.is_array() ) {
    p = ExternalFenceHandleTypeFlags ( 0 );
    for( auto &e:  j ) {
      ExternalFenceHandleTypeFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ExternalFenceHandleTypeFlags" );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const ExternalFenceFeatureFlagBits &p ) {
  if( ExternalFenceFeatureFlagBits :: eExportable == p ) {
    j = "Exportable";
    return;
  }
}
inline void from_json( const nlohmann::json &j, ExternalFenceFeatureFlagBits &p ) {
  if( j.is_string() ) {
    if( "Exportable" == j.get< std::string >() ) {
      p = ExternalFenceFeatureFlagBits :: eExportable ;
      return;
    }
    if( "eExportable" == j.get< std::string >() ) {
      p = ExternalFenceFeatureFlagBits :: eExportable ;
      return;
    }
    if( "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT" == j.get< std::string >() ) {
      p = ExternalFenceFeatureFlagBits :: eExportable ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ExternalFenceFeatureFlagBits" );
  }
  if( j.is_number() ) {
    p = ExternalFenceFeatureFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ExternalFenceFeatureFlagBits" );
}
inline void to_json( nlohmann::json &j, const ExternalFenceFeatureFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ExternalFenceFeatureFlagBits ) * 8u; ++n ) {
    if( p & ExternalFenceFeatureFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ExternalFenceFeatureFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ExternalFenceFeatureFlags &p ) {
  if( j.is_array() ) {
    p = ExternalFenceFeatureFlags ( 0 );
    for( auto &e:  j ) {
      ExternalFenceFeatureFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ExternalFenceFeatureFlags" );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const FenceImportFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, FenceImportFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for FenceImportFlagBits" );
  }
  if( j.is_number() ) {
    p = FenceImportFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for FenceImportFlagBits" );
}
inline void to_json( nlohmann::json &j, const FenceImportFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( FenceImportFlagBits ) * 8u; ++n ) {
    if( p & FenceImportFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, FenceImportFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, FenceImportFlags &p ) {
  if( j.is_array() ) {
    p = FenceImportFlags ( 0 );
    for( auto &e:  j ) {
      FenceImportFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for FenceImportFlags" );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const SemaphoreImportFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, SemaphoreImportFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for SemaphoreImportFlagBits" );
  }
  if( j.is_number() ) {
    p = SemaphoreImportFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SemaphoreImportFlagBits" );
}
inline void to_json( nlohmann::json &j, const SemaphoreImportFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SemaphoreImportFlagBits ) * 8u; ++n ) {
    if( p & SemaphoreImportFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SemaphoreImportFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, SemaphoreImportFlags &p ) {
  if( j.is_array() ) {
    p = SemaphoreImportFlags ( 0 );
    for( auto &e:  j ) {
      SemaphoreImportFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SemaphoreImportFlags" );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const ExternalSemaphoreHandleTypeFlagBits &p ) {
  if( ExternalSemaphoreHandleTypeFlagBits :: eOpaqueFd == p ) {
    j = "OpaqueFd";
    return;
  }
  if( ExternalSemaphoreHandleTypeFlagBits :: eOpaqueWin32 == p ) {
    j = "OpaqueWin32";
    return;
  }
  if( ExternalSemaphoreHandleTypeFlagBits :: eOpaqueWin32Kmt == p ) {
    j = "OpaqueWin32Kmt";
    return;
  }
  if( ExternalSemaphoreHandleTypeFlagBits :: eD3D12Fence == p ) {
    j = "D3D12Fence";
    return;
  }
  if( ExternalSemaphoreHandleTypeFlagBits :: eSyncFd == p ) {
    j = "SyncFd";
    return;
  }
#if defined(VK_USE_PLATFORM_FUCHSIA)
  if( ExternalSemaphoreHandleTypeFlagBits :: eZirconEventFUCHSIA == p ) {
    j = "ZirconEventFUCHSIA";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, ExternalSemaphoreHandleTypeFlagBits &p ) {
  if( j.is_string() ) {
    if( "OpaqueFd" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eOpaqueFd ;
      return;
    }
    if( "eOpaqueFd" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eOpaqueFd ;
      return;
    }
    if( "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eOpaqueFd ;
      return;
    }
    if( "OpaqueWin32" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eOpaqueWin32 ;
      return;
    }
    if( "eOpaqueWin32" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eOpaqueWin32 ;
      return;
    }
    if( "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eOpaqueWin32 ;
      return;
    }
    if( "OpaqueWin32Kmt" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eOpaqueWin32Kmt ;
      return;
    }
    if( "eOpaqueWin32Kmt" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eOpaqueWin32Kmt ;
      return;
    }
    if( "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eOpaqueWin32Kmt ;
      return;
    }
    if( "D3D12Fence" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eD3D12Fence ;
      return;
    }
    if( "eD3D12Fence" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eD3D12Fence ;
      return;
    }
    if( "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eD3D12Fence ;
      return;
    }
    if( "SyncFd" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eSyncFd ;
      return;
    }
    if( "eSyncFd" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eSyncFd ;
      return;
    }
    if( "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eSyncFd ;
      return;
    }
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "ZirconEventFUCHSIA" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eZirconEventFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "eZirconEventFUCHSIA" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eZirconEventFUCHSIA ;
      return;
    }
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if( "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA" == j.get< std::string >() ) {
      p = ExternalSemaphoreHandleTypeFlagBits :: eZirconEventFUCHSIA ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for ExternalSemaphoreHandleTypeFlagBits" );
  }
  if( j.is_number() ) {
    p = ExternalSemaphoreHandleTypeFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ExternalSemaphoreHandleTypeFlagBits" );
}
inline void to_json( nlohmann::json &j, const ExternalSemaphoreHandleTypeFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ExternalSemaphoreHandleTypeFlagBits ) * 8u; ++n ) {
    if( p & ExternalSemaphoreHandleTypeFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ExternalSemaphoreHandleTypeFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ExternalSemaphoreHandleTypeFlags &p ) {
  if( j.is_array() ) {
    p = ExternalSemaphoreHandleTypeFlags ( 0 );
    for( auto &e:  j ) {
      ExternalSemaphoreHandleTypeFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ExternalSemaphoreHandleTypeFlags" );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const ExternalSemaphoreFeatureFlagBits &p ) {
  if( ExternalSemaphoreFeatureFlagBits :: eExportable == p ) {
    j = "Exportable";
    return;
  }
}
inline void from_json( const nlohmann::json &j, ExternalSemaphoreFeatureFlagBits &p ) {
  if( j.is_string() ) {
    if( "Exportable" == j.get< std::string >() ) {
      p = ExternalSemaphoreFeatureFlagBits :: eExportable ;
      return;
    }
    if( "eExportable" == j.get< std::string >() ) {
      p = ExternalSemaphoreFeatureFlagBits :: eExportable ;
      return;
    }
    if( "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT" == j.get< std::string >() ) {
      p = ExternalSemaphoreFeatureFlagBits :: eExportable ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ExternalSemaphoreFeatureFlagBits" );
  }
  if( j.is_number() ) {
    p = ExternalSemaphoreFeatureFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ExternalSemaphoreFeatureFlagBits" );
}
inline void to_json( nlohmann::json &j, const ExternalSemaphoreFeatureFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ExternalSemaphoreFeatureFlagBits ) * 8u; ++n ) {
    if( p & ExternalSemaphoreFeatureFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ExternalSemaphoreFeatureFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ExternalSemaphoreFeatureFlags &p ) {
  if( j.is_array() ) {
    p = ExternalSemaphoreFeatureFlags ( 0 );
    for( auto &e:  j ) {
      ExternalSemaphoreFeatureFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ExternalSemaphoreFeatureFlags" );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const CommandPoolTrimFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, CommandPoolTrimFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for CommandPoolTrimFlagBits" );
  }
  if( j.is_number() ) {
    p = CommandPoolTrimFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CommandPoolTrimFlagBits" );
}
inline void to_json( nlohmann::json &j, const CommandPoolTrimFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( CommandPoolTrimFlagBits ) * 8u; ++n ) {
    if( p & CommandPoolTrimFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, CommandPoolTrimFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, CommandPoolTrimFlags &p ) {
  if( j.is_array() ) {
    p = CommandPoolTrimFlags ( 0 );
    for( auto &e:  j ) {
      CommandPoolTrimFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for CommandPoolTrimFlags" );
}
#endif

#ifdef VK_VERSION_1_1
inline void to_json( nlohmann::json &j, const DescriptorUpdateTemplateCreateFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, DescriptorUpdateTemplateCreateFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DescriptorUpdateTemplateCreateFlagBits" );
  }
  if( j.is_number() ) {
    p = DescriptorUpdateTemplateCreateFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DescriptorUpdateTemplateCreateFlagBits" );
}
inline void to_json( nlohmann::json &j, const DescriptorUpdateTemplateCreateFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DescriptorUpdateTemplateCreateFlagBits ) * 8u; ++n ) {
    if( p & DescriptorUpdateTemplateCreateFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DescriptorUpdateTemplateCreateFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DescriptorUpdateTemplateCreateFlags &p ) {
  if( j.is_array() ) {
    p = DescriptorUpdateTemplateCreateFlags ( 0 );
    for( auto &e:  j ) {
      DescriptorUpdateTemplateCreateFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DescriptorUpdateTemplateCreateFlags" );
}
#endif

#ifdef VK_VERSION_1_2
inline void to_json( nlohmann::json &j, const DescriptorBindingFlagBits &p ) {
  if( DescriptorBindingFlagBits :: eUpdateAfterBind == p ) {
    j = "UpdateAfterBind";
    return;
  }
  if( DescriptorBindingFlagBits :: eUpdateUnusedWhilePending == p ) {
    j = "UpdateUnusedWhilePending";
    return;
  }
  if( DescriptorBindingFlagBits :: ePartiallyBound == p ) {
    j = "PartiallyBound";
    return;
  }
}
inline void from_json( const nlohmann::json &j, DescriptorBindingFlagBits &p ) {
  if( j.is_string() ) {
    if( "UpdateAfterBind" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: eUpdateAfterBind ;
      return;
    }
    if( "eUpdateAfterBind" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: eUpdateAfterBind ;
      return;
    }
    if( "VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: eUpdateAfterBind ;
      return;
    }
    if( "UpdateUnusedWhilePending" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: eUpdateUnusedWhilePending ;
      return;
    }
    if( "eUpdateUnusedWhilePending" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: eUpdateUnusedWhilePending ;
      return;
    }
    if( "VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: eUpdateUnusedWhilePending ;
      return;
    }
    if( "PartiallyBound" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: ePartiallyBound ;
      return;
    }
    if( "ePartiallyBound" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: ePartiallyBound ;
      return;
    }
    if( "VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT" == j.get< std::string >() ) {
      p = DescriptorBindingFlagBits :: ePartiallyBound ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DescriptorBindingFlagBits" );
  }
  if( j.is_number() ) {
    p = DescriptorBindingFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DescriptorBindingFlagBits" );
}
inline void to_json( nlohmann::json &j, const DescriptorBindingFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DescriptorBindingFlagBits ) * 8u; ++n ) {
    if( p & DescriptorBindingFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DescriptorBindingFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DescriptorBindingFlags &p ) {
  if( j.is_array() ) {
    p = DescriptorBindingFlags ( 0 );
    for( auto &e:  j ) {
      DescriptorBindingFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DescriptorBindingFlags" );
}
#endif

#ifdef VK_VERSION_1_2
inline void to_json( nlohmann::json &j, const ResolveModeFlagBits &p ) {
  if( ResolveModeFlagBits :: eNone == p ) {
    j = "None";
    return;
  }
  if( ResolveModeFlagBits :: eSampleZero == p ) {
    j = "SampleZero";
    return;
  }
  if( ResolveModeFlagBits :: eAverage == p ) {
    j = "Average";
    return;
  }
  if( ResolveModeFlagBits :: eMin == p ) {
    j = "Min";
    return;
  }
}
inline void from_json( const nlohmann::json &j, ResolveModeFlagBits &p ) {
  if( j.is_string() ) {
    if( "None" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eNone ;
      return;
    }
    if( "eNone" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eNone ;
      return;
    }
    if( "VK_RESOLVE_MODE_NONE" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eNone ;
      return;
    }
    if( "SampleZero" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eSampleZero ;
      return;
    }
    if( "eSampleZero" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eSampleZero ;
      return;
    }
    if( "VK_RESOLVE_MODE_SAMPLE_ZERO_BIT" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eSampleZero ;
      return;
    }
    if( "Average" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eAverage ;
      return;
    }
    if( "eAverage" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eAverage ;
      return;
    }
    if( "VK_RESOLVE_MODE_AVERAGE_BIT" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eAverage ;
      return;
    }
    if( "Min" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eMin ;
      return;
    }
    if( "eMin" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eMin ;
      return;
    }
    if( "VK_RESOLVE_MODE_MIN_BIT" == j.get< std::string >() ) {
      p = ResolveModeFlagBits :: eMin ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ResolveModeFlagBits" );
  }
  if( j.is_number() ) {
    p = ResolveModeFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ResolveModeFlagBits" );
}
inline void to_json( nlohmann::json &j, const ResolveModeFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ResolveModeFlagBits ) * 8u; ++n ) {
    if( p & ResolveModeFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ResolveModeFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ResolveModeFlags &p ) {
  if( j.is_array() ) {
    p = ResolveModeFlags ( 0 );
    for( auto &e:  j ) {
      ResolveModeFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ResolveModeFlags" );
}
#endif

#ifdef VK_VERSION_1_2
inline void to_json( nlohmann::json &j, const SemaphoreWaitFlagBits &p ) {
}
inline void from_json( const nlohmann::json &j, SemaphoreWaitFlagBits &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for SemaphoreWaitFlagBits" );
  }
  if( j.is_number() ) {
    p = SemaphoreWaitFlagBits ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SemaphoreWaitFlagBits" );
}
inline void to_json( nlohmann::json &j, const SemaphoreWaitFlags &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SemaphoreWaitFlagBits ) * 8u; ++n ) {
    if( p & SemaphoreWaitFlags ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SemaphoreWaitFlagBits ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, SemaphoreWaitFlags &p ) {
  if( j.is_array() ) {
    p = SemaphoreWaitFlags ( 0 );
    for( auto &e:  j ) {
      SemaphoreWaitFlagBits temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SemaphoreWaitFlags" );
}
#endif

#ifdef VK_KHR_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const SurfaceTransformFlagBitsKHR &p ) {
  if( SurfaceTransformFlagBitsKHR :: eIdentity == p ) {
    j = "Identity";
    return;
  }
  if( SurfaceTransformFlagBitsKHR :: eRotate90 == p ) {
    j = "Rotate90";
    return;
  }
  if( SurfaceTransformFlagBitsKHR :: eRotate180 == p ) {
    j = "Rotate180";
    return;
  }
  if( SurfaceTransformFlagBitsKHR :: eRotate270 == p ) {
    j = "Rotate270";
    return;
  }
  if( SurfaceTransformFlagBitsKHR :: eHorizontalMirror == p ) {
    j = "HorizontalMirror";
    return;
  }
  if( SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate90 == p ) {
    j = "HorizontalMirrorRotate90";
    return;
  }
  if( SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate180 == p ) {
    j = "HorizontalMirrorRotate180";
    return;
  }
  if( SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate270 == p ) {
    j = "HorizontalMirrorRotate270";
    return;
  }
}
inline void from_json( const nlohmann::json &j, SurfaceTransformFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "Identity" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eIdentity ;
      return;
    }
    if( "eIdentity" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eIdentity ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eIdentity ;
      return;
    }
    if( "Rotate90" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate90 ;
      return;
    }
    if( "eRotate90" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate90 ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate90 ;
      return;
    }
    if( "Rotate180" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate180 ;
      return;
    }
    if( "eRotate180" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate180 ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate180 ;
      return;
    }
    if( "Rotate270" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate270 ;
      return;
    }
    if( "eRotate270" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate270 ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eRotate270 ;
      return;
    }
    if( "HorizontalMirror" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirror ;
      return;
    }
    if( "eHorizontalMirror" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirror ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirror ;
      return;
    }
    if( "HorizontalMirrorRotate90" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate90 ;
      return;
    }
    if( "eHorizontalMirrorRotate90" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate90 ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate90 ;
      return;
    }
    if( "HorizontalMirrorRotate180" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate180 ;
      return;
    }
    if( "eHorizontalMirrorRotate180" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate180 ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate180 ;
      return;
    }
    if( "HorizontalMirrorRotate270" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate270 ;
      return;
    }
    if( "eHorizontalMirrorRotate270" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate270 ;
      return;
    }
    if( "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR" == j.get< std::string >() ) {
      p = SurfaceTransformFlagBitsKHR :: eHorizontalMirrorRotate270 ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SurfaceTransformFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = SurfaceTransformFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SurfaceTransformFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const SurfaceTransformFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SurfaceTransformFlagBitsKHR ) * 8u; ++n ) {
    if( p & SurfaceTransformFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SurfaceTransformFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, SurfaceTransformFlagsKHR &p ) {
  if( j.is_array() ) {
    p = SurfaceTransformFlagsKHR ( 0 );
    for( auto &e:  j ) {
      SurfaceTransformFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SurfaceTransformFlagsKHR" );
}
#endif

#ifdef VK_KHR_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const CompositeAlphaFlagBitsKHR &p ) {
  if( CompositeAlphaFlagBitsKHR :: eOpaque == p ) {
    j = "Opaque";
    return;
  }
  if( CompositeAlphaFlagBitsKHR :: ePreMultiplied == p ) {
    j = "PreMultiplied";
    return;
  }
  if( CompositeAlphaFlagBitsKHR :: ePostMultiplied == p ) {
    j = "PostMultiplied";
    return;
  }
}
inline void from_json( const nlohmann::json &j, CompositeAlphaFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "Opaque" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "eOpaque" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "PreMultiplied" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: ePreMultiplied ;
      return;
    }
    if( "ePreMultiplied" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: ePreMultiplied ;
      return;
    }
    if( "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: ePreMultiplied ;
      return;
    }
    if( "PostMultiplied" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: ePostMultiplied ;
      return;
    }
    if( "ePostMultiplied" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: ePostMultiplied ;
      return;
    }
    if( "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR" == j.get< std::string >() ) {
      p = CompositeAlphaFlagBitsKHR :: ePostMultiplied ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for CompositeAlphaFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = CompositeAlphaFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for CompositeAlphaFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const CompositeAlphaFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( CompositeAlphaFlagBitsKHR ) * 8u; ++n ) {
    if( p & CompositeAlphaFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, CompositeAlphaFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, CompositeAlphaFlagsKHR &p ) {
  if( j.is_array() ) {
    p = CompositeAlphaFlagsKHR ( 0 );
    for( auto &e:  j ) {
      CompositeAlphaFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for CompositeAlphaFlagsKHR" );
}
#endif

#ifdef VK_KHR_SWAPCHAIN_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const SwapchainCreateFlagBitsKHR &p ) {
  if( SwapchainCreateFlagBitsKHR :: eSplitInstanceBindRegions == p ) {
    j = "SplitInstanceBindRegions";
    return;
  }
  if( SwapchainCreateFlagBitsKHR :: eProtected == p ) {
    j = "Protected";
    return;
  }
}
inline void from_json( const nlohmann::json &j, SwapchainCreateFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "SplitInstanceBindRegions" == j.get< std::string >() ) {
      p = SwapchainCreateFlagBitsKHR :: eSplitInstanceBindRegions ;
      return;
    }
    if( "eSplitInstanceBindRegions" == j.get< std::string >() ) {
      p = SwapchainCreateFlagBitsKHR :: eSplitInstanceBindRegions ;
      return;
    }
    if( "VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR" == j.get< std::string >() ) {
      p = SwapchainCreateFlagBitsKHR :: eSplitInstanceBindRegions ;
      return;
    }
    if( "Protected" == j.get< std::string >() ) {
      p = SwapchainCreateFlagBitsKHR :: eProtected ;
      return;
    }
    if( "eProtected" == j.get< std::string >() ) {
      p = SwapchainCreateFlagBitsKHR :: eProtected ;
      return;
    }
    if( "VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR" == j.get< std::string >() ) {
      p = SwapchainCreateFlagBitsKHR :: eProtected ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for SwapchainCreateFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = SwapchainCreateFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SwapchainCreateFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const SwapchainCreateFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SwapchainCreateFlagBitsKHR ) * 8u; ++n ) {
    if( p & SwapchainCreateFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SwapchainCreateFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, SwapchainCreateFlagsKHR &p ) {
  if( j.is_array() ) {
    p = SwapchainCreateFlagsKHR ( 0 );
    for( auto &e:  j ) {
      SwapchainCreateFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SwapchainCreateFlagsKHR" );
}
#endif

#ifdef VK_KHR_SWAPCHAIN_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DeviceGroupPresentModeFlagBitsKHR &p ) {
  if( DeviceGroupPresentModeFlagBitsKHR :: eLocal == p ) {
    j = "Local";
    return;
  }
  if( DeviceGroupPresentModeFlagBitsKHR :: eRemote == p ) {
    j = "Remote";
    return;
  }
  if( DeviceGroupPresentModeFlagBitsKHR :: eSum == p ) {
    j = "Sum";
    return;
  }
}
inline void from_json( const nlohmann::json &j, DeviceGroupPresentModeFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "Local" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eLocal ;
      return;
    }
    if( "eLocal" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eLocal ;
      return;
    }
    if( "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eLocal ;
      return;
    }
    if( "Remote" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eRemote ;
      return;
    }
    if( "eRemote" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eRemote ;
      return;
    }
    if( "VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eRemote ;
      return;
    }
    if( "Sum" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eSum ;
      return;
    }
    if( "eSum" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eSum ;
      return;
    }
    if( "VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR" == j.get< std::string >() ) {
      p = DeviceGroupPresentModeFlagBitsKHR :: eSum ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DeviceGroupPresentModeFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = DeviceGroupPresentModeFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DeviceGroupPresentModeFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const DeviceGroupPresentModeFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DeviceGroupPresentModeFlagBitsKHR ) * 8u; ++n ) {
    if( p & DeviceGroupPresentModeFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DeviceGroupPresentModeFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DeviceGroupPresentModeFlagsKHR &p ) {
  if( j.is_array() ) {
    p = DeviceGroupPresentModeFlagsKHR ( 0 );
    for( auto &e:  j ) {
      DeviceGroupPresentModeFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DeviceGroupPresentModeFlagsKHR" );
}
#endif

#ifdef VK_KHR_DISPLAY_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DisplayPlaneAlphaFlagBitsKHR &p ) {
  if( DisplayPlaneAlphaFlagBitsKHR :: eOpaque == p ) {
    j = "Opaque";
    return;
  }
  if( DisplayPlaneAlphaFlagBitsKHR :: eGlobal == p ) {
    j = "Global";
    return;
  }
  if( DisplayPlaneAlphaFlagBitsKHR :: ePerPixel == p ) {
    j = "PerPixel";
    return;
  }
}
inline void from_json( const nlohmann::json &j, DisplayPlaneAlphaFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "Opaque" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "eOpaque" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "Global" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: eGlobal ;
      return;
    }
    if( "eGlobal" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: eGlobal ;
      return;
    }
    if( "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: eGlobal ;
      return;
    }
    if( "PerPixel" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: ePerPixel ;
      return;
    }
    if( "ePerPixel" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: ePerPixel ;
      return;
    }
    if( "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR" == j.get< std::string >() ) {
      p = DisplayPlaneAlphaFlagBitsKHR :: ePerPixel ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DisplayPlaneAlphaFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = DisplayPlaneAlphaFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DisplayPlaneAlphaFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const DisplayPlaneAlphaFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DisplayPlaneAlphaFlagBitsKHR ) * 8u; ++n ) {
    if( p & DisplayPlaneAlphaFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DisplayPlaneAlphaFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DisplayPlaneAlphaFlagsKHR &p ) {
  if( j.is_array() ) {
    p = DisplayPlaneAlphaFlagsKHR ( 0 );
    for( auto &e:  j ) {
      DisplayPlaneAlphaFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DisplayPlaneAlphaFlagsKHR" );
}
#endif

#ifdef VK_KHR_DISPLAY_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DisplayModeCreateFlagBitsKHR &p ) {
}
inline void from_json( const nlohmann::json &j, DisplayModeCreateFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DisplayModeCreateFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = DisplayModeCreateFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DisplayModeCreateFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const DisplayModeCreateFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DisplayModeCreateFlagBitsKHR ) * 8u; ++n ) {
    if( p & DisplayModeCreateFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DisplayModeCreateFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DisplayModeCreateFlagsKHR &p ) {
  if( j.is_array() ) {
    p = DisplayModeCreateFlagsKHR ( 0 );
    for( auto &e:  j ) {
      DisplayModeCreateFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DisplayModeCreateFlagsKHR" );
}
#endif

#ifdef VK_KHR_DISPLAY_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DisplaySurfaceCreateFlagBitsKHR &p ) {
}
inline void from_json( const nlohmann::json &j, DisplaySurfaceCreateFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DisplaySurfaceCreateFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = DisplaySurfaceCreateFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DisplaySurfaceCreateFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const DisplaySurfaceCreateFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DisplaySurfaceCreateFlagBitsKHR ) * 8u; ++n ) {
    if( p & DisplaySurfaceCreateFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DisplaySurfaceCreateFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DisplaySurfaceCreateFlagsKHR &p ) {
  if( j.is_array() ) {
    p = DisplaySurfaceCreateFlagsKHR ( 0 );
    for( auto &e:  j ) {
      DisplaySurfaceCreateFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DisplaySurfaceCreateFlagsKHR" );
}
#endif

#ifdef VK_KHR_XLIB_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const XlibSurfaceCreateFlagBitsKHR &p ) {
}
inline void from_json( const nlohmann::json &j, XlibSurfaceCreateFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for XlibSurfaceCreateFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = XlibSurfaceCreateFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for XlibSurfaceCreateFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const XlibSurfaceCreateFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( XlibSurfaceCreateFlagBitsKHR ) * 8u; ++n ) {
    if( p & XlibSurfaceCreateFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, XlibSurfaceCreateFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, XlibSurfaceCreateFlagsKHR &p ) {
  if( j.is_array() ) {
    p = XlibSurfaceCreateFlagsKHR ( 0 );
    for( auto &e:  j ) {
      XlibSurfaceCreateFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for XlibSurfaceCreateFlagsKHR" );
}
#endif

#ifdef VK_KHR_XCB_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const XcbSurfaceCreateFlagBitsKHR &p ) {
}
inline void from_json( const nlohmann::json &j, XcbSurfaceCreateFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for XcbSurfaceCreateFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = XcbSurfaceCreateFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for XcbSurfaceCreateFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const XcbSurfaceCreateFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( XcbSurfaceCreateFlagBitsKHR ) * 8u; ++n ) {
    if( p & XcbSurfaceCreateFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, XcbSurfaceCreateFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, XcbSurfaceCreateFlagsKHR &p ) {
  if( j.is_array() ) {
    p = XcbSurfaceCreateFlagsKHR ( 0 );
    for( auto &e:  j ) {
      XcbSurfaceCreateFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for XcbSurfaceCreateFlagsKHR" );
}
#endif

#ifdef VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const WaylandSurfaceCreateFlagBitsKHR &p ) {
}
inline void from_json( const nlohmann::json &j, WaylandSurfaceCreateFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for WaylandSurfaceCreateFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = WaylandSurfaceCreateFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for WaylandSurfaceCreateFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const WaylandSurfaceCreateFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( WaylandSurfaceCreateFlagBitsKHR ) * 8u; ++n ) {
    if( p & WaylandSurfaceCreateFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, WaylandSurfaceCreateFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, WaylandSurfaceCreateFlagsKHR &p ) {
  if( j.is_array() ) {
    p = WaylandSurfaceCreateFlagsKHR ( 0 );
    for( auto &e:  j ) {
      WaylandSurfaceCreateFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for WaylandSurfaceCreateFlagsKHR" );
}
#endif

#ifdef VK_KHR_ANDROID_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const AndroidSurfaceCreateFlagBitsKHR &p ) {
}
inline void from_json( const nlohmann::json &j, AndroidSurfaceCreateFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for AndroidSurfaceCreateFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = AndroidSurfaceCreateFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AndroidSurfaceCreateFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const AndroidSurfaceCreateFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( AndroidSurfaceCreateFlagBitsKHR ) * 8u; ++n ) {
    if( p & AndroidSurfaceCreateFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, AndroidSurfaceCreateFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, AndroidSurfaceCreateFlagsKHR &p ) {
  if( j.is_array() ) {
    p = AndroidSurfaceCreateFlagsKHR ( 0 );
    for( auto &e:  j ) {
      AndroidSurfaceCreateFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for AndroidSurfaceCreateFlagsKHR" );
}
#endif

#ifdef VK_KHR_WIN32_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const Win32SurfaceCreateFlagBitsKHR &p ) {
}
inline void from_json( const nlohmann::json &j, Win32SurfaceCreateFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for Win32SurfaceCreateFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = Win32SurfaceCreateFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for Win32SurfaceCreateFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const Win32SurfaceCreateFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( Win32SurfaceCreateFlagBitsKHR ) * 8u; ++n ) {
    if( p & Win32SurfaceCreateFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, Win32SurfaceCreateFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, Win32SurfaceCreateFlagsKHR &p ) {
  if( j.is_array() ) {
    p = Win32SurfaceCreateFlagsKHR ( 0 );
    for( auto &e:  j ) {
      Win32SurfaceCreateFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for Win32SurfaceCreateFlagsKHR" );
}
#endif

#ifdef VK_EXT_DEBUG_REPORT_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DebugReportFlagBitsEXT &p ) {
  if( DebugReportFlagBitsEXT :: eInformation == p ) {
    j = "Information";
    return;
  }
  if( DebugReportFlagBitsEXT :: eWarning == p ) {
    j = "Warning";
    return;
  }
  if( DebugReportFlagBitsEXT :: ePerformanceWarning == p ) {
    j = "PerformanceWarning";
    return;
  }
  if( DebugReportFlagBitsEXT :: eError == p ) {
    j = "Error";
    return;
  }
}
inline void from_json( const nlohmann::json &j, DebugReportFlagBitsEXT &p ) {
  if( j.is_string() ) {
    if( "Information" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eInformation ;
      return;
    }
    if( "eInformation" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eInformation ;
      return;
    }
    if( "VK_DEBUG_REPORT_INFORMATION_BIT_EXT" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eInformation ;
      return;
    }
    if( "Warning" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eWarning ;
      return;
    }
    if( "eWarning" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eWarning ;
      return;
    }
    if( "VK_DEBUG_REPORT_WARNING_BIT_EXT" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eWarning ;
      return;
    }
    if( "PerformanceWarning" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: ePerformanceWarning ;
      return;
    }
    if( "ePerformanceWarning" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: ePerformanceWarning ;
      return;
    }
    if( "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: ePerformanceWarning ;
      return;
    }
    if( "Error" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eError ;
      return;
    }
    if( "eError" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eError ;
      return;
    }
    if( "VK_DEBUG_REPORT_ERROR_BIT_EXT" == j.get< std::string >() ) {
      p = DebugReportFlagBitsEXT :: eError ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DebugReportFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = DebugReportFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DebugReportFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const DebugReportFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DebugReportFlagBitsEXT ) * 8u; ++n ) {
    if( p & DebugReportFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DebugReportFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DebugReportFlagsEXT &p ) {
  if( j.is_array() ) {
    p = DebugReportFlagsEXT ( 0 );
    for( auto &e:  j ) {
      DebugReportFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DebugReportFlagsEXT" );
}
#endif

#ifdef VK_KHR_VIDEO_QUEUE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoCodecOperationFlagBitsKHR &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoCodecOperationFlagBitsKHR :: eInvalid == p ) {
    j = "Invalid";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoCodecOperationFlagBitsKHR :: eEncodeH264EXT == p ) {
    j = "EncodeH264EXT";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoCodecOperationFlagBitsKHR :: eDecodeH264EXT == p ) {
    j = "DecodeH264EXT";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoCodecOperationFlagBitsKHR &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Invalid" == j.get< std::string >() ) {
      p = VideoCodecOperationFlagBitsKHR :: eInvalid ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eInvalid" == j.get< std::string >() ) {
      p = VideoCodecOperationFlagBitsKHR :: eInvalid ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_CODEC_OPERATION_INVALID_BIT_KHR" == j.get< std::string >() ) {
      p = VideoCodecOperationFlagBitsKHR :: eInvalid ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "EncodeH264EXT" == j.get< std::string >() ) {
      p = VideoCodecOperationFlagBitsKHR :: eEncodeH264EXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eEncodeH264EXT" == j.get< std::string >() ) {
      p = VideoCodecOperationFlagBitsKHR :: eEncodeH264EXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT" == j.get< std::string >() ) {
      p = VideoCodecOperationFlagBitsKHR :: eEncodeH264EXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "DecodeH264EXT" == j.get< std::string >() ) {
      p = VideoCodecOperationFlagBitsKHR :: eDecodeH264EXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eDecodeH264EXT" == j.get< std::string >() ) {
      p = VideoCodecOperationFlagBitsKHR :: eDecodeH264EXT ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_EXT" == j.get< std::string >() ) {
      p = VideoCodecOperationFlagBitsKHR :: eDecodeH264EXT ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoCodecOperationFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = VideoCodecOperationFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoCodecOperationFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const VideoCodecOperationFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoCodecOperationFlagBitsKHR ) * 8u; ++n ) {
    if( p & VideoCodecOperationFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoCodecOperationFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoCodecOperationFlagsKHR &p ) {
  if( j.is_array() ) {
    p = VideoCodecOperationFlagsKHR ( 0 );
    for( auto &e:  j ) {
      VideoCodecOperationFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoCodecOperationFlagsKHR" );
}
#endif

#ifdef VK_KHR_VIDEO_QUEUE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoChromaSubsamplingFlagBitsKHR &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoChromaSubsamplingFlagBitsKHR :: eInvalid == p ) {
    j = "Invalid";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoChromaSubsamplingFlagBitsKHR :: eMonochrome == p ) {
    j = "Monochrome";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoChromaSubsamplingFlagBitsKHR :: e420 == p ) {
    j = "420";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoChromaSubsamplingFlagBitsKHR :: e422 == p ) {
    j = "422";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoChromaSubsamplingFlagBitsKHR &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Invalid" == j.get< std::string >() ) {
      p = VideoChromaSubsamplingFlagBitsKHR :: eInvalid ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eInvalid" == j.get< std::string >() ) {
      p = VideoChromaSubsamplingFlagBitsKHR :: eInvalid ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_BIT_KHR" == j.get< std::string >() ) {
      p = VideoChromaSubsamplingFlagBitsKHR :: eInvalid ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Monochrome" == j.get< std::string >() ) {
      p = VideoChromaSubsamplingFlagBitsKHR :: eMonochrome ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eMonochrome" == j.get< std::string >() ) {
      p = VideoChromaSubsamplingFlagBitsKHR :: eMonochrome ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR" == j.get< std::string >() ) {
      p = VideoChromaSubsamplingFlagBitsKHR :: eMonochrome ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "420" == j.get< std::string >() ) {
      p = VideoChromaSubsamplingFlagBitsKHR :: e420 ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "e420" == j.get< std::string >() ) {
      p = VideoChromaSubsamplingFlagBitsKHR :: e420 ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR" == j.get< std::string >() ) {
      p = VideoChromaSubsamplingFlagBitsKHR :: e420 ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "422" == j.get< std::string >() ) {
      p = VideoChromaSubsamplingFlagBitsKHR :: e422 ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "e422" == j.get< std::string >() ) {
      p = VideoChromaSubsamplingFlagBitsKHR :: e422 ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR" == j.get< std::string >() ) {
      p = VideoChromaSubsamplingFlagBitsKHR :: e422 ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoChromaSubsamplingFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = VideoChromaSubsamplingFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoChromaSubsamplingFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const VideoChromaSubsamplingFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoChromaSubsamplingFlagBitsKHR ) * 8u; ++n ) {
    if( p & VideoChromaSubsamplingFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoChromaSubsamplingFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoChromaSubsamplingFlagsKHR &p ) {
  if( j.is_array() ) {
    p = VideoChromaSubsamplingFlagsKHR ( 0 );
    for( auto &e:  j ) {
      VideoChromaSubsamplingFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoChromaSubsamplingFlagsKHR" );
}
#endif

#ifdef VK_KHR_VIDEO_QUEUE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoComponentBitDepthFlagBitsKHR &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoComponentBitDepthFlagBitsKHR :: eInvalid == p ) {
    j = "Invalid";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoComponentBitDepthFlagBitsKHR :: e8 == p ) {
    j = "8";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoComponentBitDepthFlagBitsKHR :: e10 == p ) {
    j = "10";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoComponentBitDepthFlagBitsKHR &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Invalid" == j.get< std::string >() ) {
      p = VideoComponentBitDepthFlagBitsKHR :: eInvalid ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eInvalid" == j.get< std::string >() ) {
      p = VideoComponentBitDepthFlagBitsKHR :: eInvalid ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR" == j.get< std::string >() ) {
      p = VideoComponentBitDepthFlagBitsKHR :: eInvalid ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "8" == j.get< std::string >() ) {
      p = VideoComponentBitDepthFlagBitsKHR :: e8 ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "e8" == j.get< std::string >() ) {
      p = VideoComponentBitDepthFlagBitsKHR :: e8 ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR" == j.get< std::string >() ) {
      p = VideoComponentBitDepthFlagBitsKHR :: e8 ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "10" == j.get< std::string >() ) {
      p = VideoComponentBitDepthFlagBitsKHR :: e10 ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "e10" == j.get< std::string >() ) {
      p = VideoComponentBitDepthFlagBitsKHR :: e10 ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR" == j.get< std::string >() ) {
      p = VideoComponentBitDepthFlagBitsKHR :: e10 ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoComponentBitDepthFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = VideoComponentBitDepthFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoComponentBitDepthFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const VideoComponentBitDepthFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoComponentBitDepthFlagBitsKHR ) * 8u; ++n ) {
    if( p & VideoComponentBitDepthFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoComponentBitDepthFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoComponentBitDepthFlagsKHR &p ) {
  if( j.is_array() ) {
    p = VideoComponentBitDepthFlagsKHR ( 0 );
    for( auto &e:  j ) {
      VideoComponentBitDepthFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoComponentBitDepthFlagsKHR" );
}
#endif

#ifdef VK_KHR_VIDEO_QUEUE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoCapabilitiesFlagBitsKHR &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoCapabilitiesFlagBitsKHR :: eProtectedContent == p ) {
    j = "ProtectedContent";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoCapabilitiesFlagBitsKHR &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "ProtectedContent" == j.get< std::string >() ) {
      p = VideoCapabilitiesFlagBitsKHR :: eProtectedContent ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eProtectedContent" == j.get< std::string >() ) {
      p = VideoCapabilitiesFlagBitsKHR :: eProtectedContent ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_CAPABILITIES_PROTECTED_CONTENT_BIT_KHR" == j.get< std::string >() ) {
      p = VideoCapabilitiesFlagBitsKHR :: eProtectedContent ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoCapabilitiesFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = VideoCapabilitiesFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoCapabilitiesFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const VideoCapabilitiesFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoCapabilitiesFlagBitsKHR ) * 8u; ++n ) {
    if( p & VideoCapabilitiesFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoCapabilitiesFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoCapabilitiesFlagsKHR &p ) {
  if( j.is_array() ) {
    p = VideoCapabilitiesFlagsKHR ( 0 );
    for( auto &e:  j ) {
      VideoCapabilitiesFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoCapabilitiesFlagsKHR" );
}
#endif

#ifdef VK_KHR_VIDEO_QUEUE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoSessionCreateFlagBitsKHR &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoSessionCreateFlagBitsKHR :: eDefault == p ) {
    j = "Default";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoSessionCreateFlagBitsKHR &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Default" == j.get< std::string >() ) {
      p = VideoSessionCreateFlagBitsKHR :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eDefault" == j.get< std::string >() ) {
      p = VideoSessionCreateFlagBitsKHR :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_SESSION_CREATE_DEFAULT_KHR" == j.get< std::string >() ) {
      p = VideoSessionCreateFlagBitsKHR :: eDefault ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoSessionCreateFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = VideoSessionCreateFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoSessionCreateFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const VideoSessionCreateFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoSessionCreateFlagBitsKHR ) * 8u; ++n ) {
    if( p & VideoSessionCreateFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoSessionCreateFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoSessionCreateFlagsKHR &p ) {
  if( j.is_array() ) {
    p = VideoSessionCreateFlagsKHR ( 0 );
    for( auto &e:  j ) {
      VideoSessionCreateFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoSessionCreateFlagsKHR" );
}
#endif

#ifdef VK_KHR_VIDEO_QUEUE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoCodingControlFlagBitsKHR &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoCodingControlFlagBitsKHR :: eDefault == p ) {
    j = "Default";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoCodingControlFlagBitsKHR &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Default" == j.get< std::string >() ) {
      p = VideoCodingControlFlagBitsKHR :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eDefault" == j.get< std::string >() ) {
      p = VideoCodingControlFlagBitsKHR :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_CODING_CONTROL_DEFAULT_KHR" == j.get< std::string >() ) {
      p = VideoCodingControlFlagBitsKHR :: eDefault ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoCodingControlFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = VideoCodingControlFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoCodingControlFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const VideoCodingControlFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoCodingControlFlagBitsKHR ) * 8u; ++n ) {
    if( p & VideoCodingControlFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoCodingControlFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoCodingControlFlagsKHR &p ) {
  if( j.is_array() ) {
    p = VideoCodingControlFlagsKHR ( 0 );
    for( auto &e:  j ) {
      VideoCodingControlFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoCodingControlFlagsKHR" );
}
#endif

#ifdef VK_KHR_VIDEO_QUEUE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoCodingQualityPresetFlagBitsKHR &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoCodingQualityPresetFlagBitsKHR :: eDefault == p ) {
    j = "Default";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoCodingQualityPresetFlagBitsKHR :: eNormal == p ) {
    j = "Normal";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoCodingQualityPresetFlagBitsKHR :: ePower == p ) {
    j = "Power";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoCodingQualityPresetFlagBitsKHR &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Default" == j.get< std::string >() ) {
      p = VideoCodingQualityPresetFlagBitsKHR :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eDefault" == j.get< std::string >() ) {
      p = VideoCodingQualityPresetFlagBitsKHR :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_CODING_QUALITY_PRESET_DEFAULT_BIT_KHR" == j.get< std::string >() ) {
      p = VideoCodingQualityPresetFlagBitsKHR :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Normal" == j.get< std::string >() ) {
      p = VideoCodingQualityPresetFlagBitsKHR :: eNormal ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eNormal" == j.get< std::string >() ) {
      p = VideoCodingQualityPresetFlagBitsKHR :: eNormal ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_CODING_QUALITY_PRESET_NORMAL_BIT_KHR" == j.get< std::string >() ) {
      p = VideoCodingQualityPresetFlagBitsKHR :: eNormal ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Power" == j.get< std::string >() ) {
      p = VideoCodingQualityPresetFlagBitsKHR :: ePower ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "ePower" == j.get< std::string >() ) {
      p = VideoCodingQualityPresetFlagBitsKHR :: ePower ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_CODING_QUALITY_PRESET_POWER_BIT_KHR" == j.get< std::string >() ) {
      p = VideoCodingQualityPresetFlagBitsKHR :: ePower ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoCodingQualityPresetFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = VideoCodingQualityPresetFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoCodingQualityPresetFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const VideoCodingQualityPresetFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoCodingQualityPresetFlagBitsKHR ) * 8u; ++n ) {
    if( p & VideoCodingQualityPresetFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoCodingQualityPresetFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoCodingQualityPresetFlagsKHR &p ) {
  if( j.is_array() ) {
    p = VideoCodingQualityPresetFlagsKHR ( 0 );
    for( auto &e:  j ) {
      VideoCodingQualityPresetFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoCodingQualityPresetFlagsKHR" );
}
#endif

#ifdef VK_KHR_VIDEO_QUEUE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoBeginCodingFlagBitsKHR &p ) {
}
inline void from_json( const nlohmann::json &j, VideoBeginCodingFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoBeginCodingFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = VideoBeginCodingFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoBeginCodingFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const VideoBeginCodingFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoBeginCodingFlagBitsKHR ) * 8u; ++n ) {
    if( p & VideoBeginCodingFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoBeginCodingFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoBeginCodingFlagsKHR &p ) {
  if( j.is_array() ) {
    p = VideoBeginCodingFlagsKHR ( 0 );
    for( auto &e:  j ) {
      VideoBeginCodingFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoBeginCodingFlagsKHR" );
}
#endif

#ifdef VK_KHR_VIDEO_QUEUE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoEndCodingFlagBitsKHR &p ) {
}
inline void from_json( const nlohmann::json &j, VideoEndCodingFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoEndCodingFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = VideoEndCodingFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoEndCodingFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const VideoEndCodingFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoEndCodingFlagBitsKHR ) * 8u; ++n ) {
    if( p & VideoEndCodingFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoEndCodingFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoEndCodingFlagsKHR &p ) {
  if( j.is_array() ) {
    p = VideoEndCodingFlagsKHR ( 0 );
    for( auto &e:  j ) {
      VideoEndCodingFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoEndCodingFlagsKHR" );
}
#endif

#ifdef VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoDecodeFlagBitsKHR &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoDecodeFlagBitsKHR :: eDefault == p ) {
    j = "Default";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoDecodeFlagBitsKHR &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Default" == j.get< std::string >() ) {
      p = VideoDecodeFlagBitsKHR :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eDefault" == j.get< std::string >() ) {
      p = VideoDecodeFlagBitsKHR :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_DECODE_DEFAULT_KHR" == j.get< std::string >() ) {
      p = VideoDecodeFlagBitsKHR :: eDefault ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoDecodeFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = VideoDecodeFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoDecodeFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const VideoDecodeFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoDecodeFlagBitsKHR ) * 8u; ++n ) {
    if( p & VideoDecodeFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoDecodeFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoDecodeFlagsKHR &p ) {
  if( j.is_array() ) {
    p = VideoDecodeFlagsKHR ( 0 );
    for( auto &e:  j ) {
      VideoDecodeFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoDecodeFlagsKHR" );
}
#endif

#ifdef VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PipelineRasterizationStateStreamCreateFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationStateStreamCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineRasterizationStateStreamCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = PipelineRasterizationStateStreamCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineRasterizationStateStreamCreateFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const PipelineRasterizationStateStreamCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineRasterizationStateStreamCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & PipelineRasterizationStateStreamCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineRasterizationStateStreamCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationStateStreamCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = PipelineRasterizationStateStreamCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      PipelineRasterizationStateStreamCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineRasterizationStateStreamCreateFlagsEXT" );
}
#endif

#ifdef VK_EXT_VIDEO_ENCODE_H264_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoEncodeH264CapabilitiesFlagBitsEXT &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityCabac == p ) {
    j = "VkVideoEncodeH264CapabilityCabac";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityCavlc == p ) {
    j = "VkVideoEncodeH264CapabilityCavlc";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityTransform8X8 == p ) {
    j = "VkVideoEncodeH264CapabilityTransform8X8";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityChromaQpOffset == p ) {
    j = "VkVideoEncodeH264CapabilityChromaQpOffset";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilitySecondChromaQpOffset == p ) {
    j = "VkVideoEncodeH264CapabilitySecondChromaQpOffset";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264CapabilitiesFlagBitsEXT &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VkVideoEncodeH264CapabilityCabac" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityCabac ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVkVideoEncodeH264CapabilityCabac" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityCabac ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_ENCODE_H264_CAPABILITY_CABAC_BIT_EXT" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityCabac ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VkVideoEncodeH264CapabilityCavlc" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityCavlc ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVkVideoEncodeH264CapabilityCavlc" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityCavlc ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_ENCODE_H264_CAPABILITY_CAVLC_BIT_EXT" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityCavlc ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VkVideoEncodeH264CapabilityTransform8X8" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityTransform8X8 ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVkVideoEncodeH264CapabilityTransform8X8" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityTransform8X8 ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_ENCODE_H264_CAPABILITY_TRANSFORM_8X8_BIT_EXT" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityTransform8X8 ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VkVideoEncodeH264CapabilityChromaQpOffset" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityChromaQpOffset ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVkVideoEncodeH264CapabilityChromaQpOffset" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityChromaQpOffset ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_ENCODE_H264_CAPABILITY_CHROMA_QP_OFFSET_BIT_EXT" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilityChromaQpOffset ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VkVideoEncodeH264CapabilitySecondChromaQpOffset" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilitySecondChromaQpOffset ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVkVideoEncodeH264CapabilitySecondChromaQpOffset" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilitySecondChromaQpOffset ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_ENCODE_H264_CAPABILITY_SECOND_CHROMA_QP_OFFSET_BIT_EXT" == j.get< std::string >() ) {
      p = VideoEncodeH264CapabilitiesFlagBitsEXT :: eVkVideoEncodeH264CapabilitySecondChromaQpOffset ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoEncodeH264CapabilitiesFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = VideoEncodeH264CapabilitiesFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoEncodeH264CapabilitiesFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const VideoEncodeH264CapabilitiesFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoEncodeH264CapabilitiesFlagBitsEXT ) * 8u; ++n ) {
    if( p & VideoEncodeH264CapabilitiesFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoEncodeH264CapabilitiesFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264CapabilitiesFlagsEXT &p ) {
  if( j.is_array() ) {
    p = VideoEncodeH264CapabilitiesFlagsEXT ( 0 );
    for( auto &e:  j ) {
      VideoEncodeH264CapabilitiesFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoEncodeH264CapabilitiesFlagsEXT" );
}
#endif

#ifdef VK_EXT_VIDEO_ENCODE_H264_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoEncodeH264InputModeFlagBitsEXT &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoEncodeH264InputModeFlagBitsEXT :: eFrame == p ) {
    j = "Frame";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoEncodeH264InputModeFlagBitsEXT :: eSlice == p ) {
    j = "Slice";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264InputModeFlagBitsEXT &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Frame" == j.get< std::string >() ) {
      p = VideoEncodeH264InputModeFlagBitsEXT :: eFrame ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eFrame" == j.get< std::string >() ) {
      p = VideoEncodeH264InputModeFlagBitsEXT :: eFrame ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_ENCODE_H264_INPUT_MODE_FRAME_BIT_EXT" == j.get< std::string >() ) {
      p = VideoEncodeH264InputModeFlagBitsEXT :: eFrame ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Slice" == j.get< std::string >() ) {
      p = VideoEncodeH264InputModeFlagBitsEXT :: eSlice ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eSlice" == j.get< std::string >() ) {
      p = VideoEncodeH264InputModeFlagBitsEXT :: eSlice ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_ENCODE_H264_INPUT_MODE_SLICE_BIT_EXT" == j.get< std::string >() ) {
      p = VideoEncodeH264InputModeFlagBitsEXT :: eSlice ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoEncodeH264InputModeFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = VideoEncodeH264InputModeFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoEncodeH264InputModeFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const VideoEncodeH264InputModeFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoEncodeH264InputModeFlagBitsEXT ) * 8u; ++n ) {
    if( p & VideoEncodeH264InputModeFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoEncodeH264InputModeFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264InputModeFlagsEXT &p ) {
  if( j.is_array() ) {
    p = VideoEncodeH264InputModeFlagsEXT ( 0 );
    for( auto &e:  j ) {
      VideoEncodeH264InputModeFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoEncodeH264InputModeFlagsEXT" );
}
#endif

#ifdef VK_EXT_VIDEO_ENCODE_H264_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoEncodeH264OutputModeFlagBitsEXT &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoEncodeH264OutputModeFlagBitsEXT :: eFrame == p ) {
    j = "Frame";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoEncodeH264OutputModeFlagBitsEXT :: eSlice == p ) {
    j = "Slice";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264OutputModeFlagBitsEXT &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Frame" == j.get< std::string >() ) {
      p = VideoEncodeH264OutputModeFlagBitsEXT :: eFrame ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eFrame" == j.get< std::string >() ) {
      p = VideoEncodeH264OutputModeFlagBitsEXT :: eFrame ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_ENCODE_H264_OUTPUT_MODE_FRAME_BIT_EXT" == j.get< std::string >() ) {
      p = VideoEncodeH264OutputModeFlagBitsEXT :: eFrame ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Slice" == j.get< std::string >() ) {
      p = VideoEncodeH264OutputModeFlagBitsEXT :: eSlice ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eSlice" == j.get< std::string >() ) {
      p = VideoEncodeH264OutputModeFlagBitsEXT :: eSlice ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_ENCODE_H264_OUTPUT_MODE_SLICE_BIT_EXT" == j.get< std::string >() ) {
      p = VideoEncodeH264OutputModeFlagBitsEXT :: eSlice ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoEncodeH264OutputModeFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = VideoEncodeH264OutputModeFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoEncodeH264OutputModeFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const VideoEncodeH264OutputModeFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoEncodeH264OutputModeFlagBitsEXT ) * 8u; ++n ) {
    if( p & VideoEncodeH264OutputModeFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoEncodeH264OutputModeFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264OutputModeFlagsEXT &p ) {
  if( j.is_array() ) {
    p = VideoEncodeH264OutputModeFlagsEXT ( 0 );
    for( auto &e:  j ) {
      VideoEncodeH264OutputModeFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoEncodeH264OutputModeFlagsEXT" );
}
#endif

#ifdef VK_EXT_VIDEO_ENCODE_H264_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoEncodeH264CreateFlagBitsEXT &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoEncodeH264CreateFlagBitsEXT :: eDefault == p ) {
    j = "Default";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264CreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Default" == j.get< std::string >() ) {
      p = VideoEncodeH264CreateFlagBitsEXT :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eDefault" == j.get< std::string >() ) {
      p = VideoEncodeH264CreateFlagBitsEXT :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_ENCODE_H264_CREATE_DEFAULT_EXT" == j.get< std::string >() ) {
      p = VideoEncodeH264CreateFlagBitsEXT :: eDefault ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoEncodeH264CreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = VideoEncodeH264CreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoEncodeH264CreateFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const VideoEncodeH264CreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoEncodeH264CreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & VideoEncodeH264CreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoEncodeH264CreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264CreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = VideoEncodeH264CreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      VideoEncodeH264CreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoEncodeH264CreateFlagsEXT" );
}
#endif

#ifdef VK_EXT_VIDEO_DECODE_H264_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoDecodeH264FieldLayoutFlagBitsEXT &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoDecodeH264FieldLayoutFlagBitsEXT :: eVkVideoDecodeH264ProgressivePicturesOnly == p ) {
    j = "VkVideoDecodeH264ProgressivePicturesOnly";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoDecodeH264FieldLayoutFlagBitsEXT :: eLineInterlacedPlane == p ) {
    j = "LineInterlacedPlane";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoDecodeH264FieldLayoutFlagBitsEXT &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VkVideoDecodeH264ProgressivePicturesOnly" == j.get< std::string >() ) {
      p = VideoDecodeH264FieldLayoutFlagBitsEXT :: eVkVideoDecodeH264ProgressivePicturesOnly ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVkVideoDecodeH264ProgressivePicturesOnly" == j.get< std::string >() ) {
      p = VideoDecodeH264FieldLayoutFlagBitsEXT :: eVkVideoDecodeH264ProgressivePicturesOnly ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_DECODE_H264_PROGRESSIVE_PICTURES_ONLY_EXT" == j.get< std::string >() ) {
      p = VideoDecodeH264FieldLayoutFlagBitsEXT :: eVkVideoDecodeH264ProgressivePicturesOnly ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "LineInterlacedPlane" == j.get< std::string >() ) {
      p = VideoDecodeH264FieldLayoutFlagBitsEXT :: eLineInterlacedPlane ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eLineInterlacedPlane" == j.get< std::string >() ) {
      p = VideoDecodeH264FieldLayoutFlagBitsEXT :: eLineInterlacedPlane ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_DECODE_H264_FIELD_LAYOUT_LINE_INTERLACED_PLANE_BIT_EXT" == j.get< std::string >() ) {
      p = VideoDecodeH264FieldLayoutFlagBitsEXT :: eLineInterlacedPlane ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoDecodeH264FieldLayoutFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = VideoDecodeH264FieldLayoutFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoDecodeH264FieldLayoutFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const VideoDecodeH264FieldLayoutFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoDecodeH264FieldLayoutFlagBitsEXT ) * 8u; ++n ) {
    if( p & VideoDecodeH264FieldLayoutFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoDecodeH264FieldLayoutFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoDecodeH264FieldLayoutFlagsEXT &p ) {
  if( j.is_array() ) {
    p = VideoDecodeH264FieldLayoutFlagsEXT ( 0 );
    for( auto &e:  j ) {
      VideoDecodeH264FieldLayoutFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoDecodeH264FieldLayoutFlagsEXT" );
}
#endif

#ifdef VK_EXT_VIDEO_DECODE_H264_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoDecodeH264CreateFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, VideoDecodeH264CreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoDecodeH264CreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = VideoDecodeH264CreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoDecodeH264CreateFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const VideoDecodeH264CreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoDecodeH264CreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & VideoDecodeH264CreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoDecodeH264CreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoDecodeH264CreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = VideoDecodeH264CreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      VideoDecodeH264CreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoDecodeH264CreateFlagsEXT" );
}
#endif

#ifdef VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const StreamDescriptorSurfaceCreateFlagBitsGGP &p ) {
}
inline void from_json( const nlohmann::json &j, StreamDescriptorSurfaceCreateFlagBitsGGP &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for StreamDescriptorSurfaceCreateFlagBitsGGP" );
  }
  if( j.is_number() ) {
    p = StreamDescriptorSurfaceCreateFlagBitsGGP ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for StreamDescriptorSurfaceCreateFlagBitsGGP" );
}
inline void to_json( nlohmann::json &j, const StreamDescriptorSurfaceCreateFlagsGGP &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( StreamDescriptorSurfaceCreateFlagBitsGGP ) * 8u; ++n ) {
    if( p & StreamDescriptorSurfaceCreateFlagsGGP ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, StreamDescriptorSurfaceCreateFlagBitsGGP ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, StreamDescriptorSurfaceCreateFlagsGGP &p ) {
  if( j.is_array() ) {
    p = StreamDescriptorSurfaceCreateFlagsGGP ( 0 );
    for( auto &e:  j ) {
      StreamDescriptorSurfaceCreateFlagBitsGGP temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for StreamDescriptorSurfaceCreateFlagsGGP" );
}
#endif

#ifdef VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ExternalMemoryHandleTypeFlagBitsNV &p ) {
  if( ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32 == p ) {
    j = "OpaqueWin32";
    return;
  }
  if( ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32Kmt == p ) {
    j = "OpaqueWin32Kmt";
    return;
  }
  if( ExternalMemoryHandleTypeFlagBitsNV :: eD3D11Image == p ) {
    j = "D3D11Image";
    return;
  }
}
inline void from_json( const nlohmann::json &j, ExternalMemoryHandleTypeFlagBitsNV &p ) {
  if( j.is_string() ) {
    if( "OpaqueWin32" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32 ;
      return;
    }
    if( "eOpaqueWin32" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32 ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32 ;
      return;
    }
    if( "OpaqueWin32Kmt" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32Kmt ;
      return;
    }
    if( "eOpaqueWin32Kmt" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32Kmt ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eOpaqueWin32Kmt ;
      return;
    }
    if( "D3D11Image" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eD3D11Image ;
      return;
    }
    if( "eD3D11Image" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eD3D11Image ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV" == j.get< std::string >() ) {
      p = ExternalMemoryHandleTypeFlagBitsNV :: eD3D11Image ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ExternalMemoryHandleTypeFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = ExternalMemoryHandleTypeFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ExternalMemoryHandleTypeFlagBitsNV" );
}
inline void to_json( nlohmann::json &j, const ExternalMemoryHandleTypeFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ExternalMemoryHandleTypeFlagBitsNV ) * 8u; ++n ) {
    if( p & ExternalMemoryHandleTypeFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ExternalMemoryHandleTypeFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ExternalMemoryHandleTypeFlagsNV &p ) {
  if( j.is_array() ) {
    p = ExternalMemoryHandleTypeFlagsNV ( 0 );
    for( auto &e:  j ) {
      ExternalMemoryHandleTypeFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ExternalMemoryHandleTypeFlagsNV" );
}
#endif

#ifdef VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ExternalMemoryFeatureFlagBitsNV &p ) {
  if( ExternalMemoryFeatureFlagBitsNV :: eDedicatedOnly == p ) {
    j = "DedicatedOnly";
    return;
  }
  if( ExternalMemoryFeatureFlagBitsNV :: eExportable == p ) {
    j = "Exportable";
    return;
  }
}
inline void from_json( const nlohmann::json &j, ExternalMemoryFeatureFlagBitsNV &p ) {
  if( j.is_string() ) {
    if( "DedicatedOnly" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBitsNV :: eDedicatedOnly ;
      return;
    }
    if( "eDedicatedOnly" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBitsNV :: eDedicatedOnly ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBitsNV :: eDedicatedOnly ;
      return;
    }
    if( "Exportable" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBitsNV :: eExportable ;
      return;
    }
    if( "eExportable" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBitsNV :: eExportable ;
      return;
    }
    if( "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV" == j.get< std::string >() ) {
      p = ExternalMemoryFeatureFlagBitsNV :: eExportable ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ExternalMemoryFeatureFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = ExternalMemoryFeatureFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ExternalMemoryFeatureFlagBitsNV" );
}
inline void to_json( nlohmann::json &j, const ExternalMemoryFeatureFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ExternalMemoryFeatureFlagBitsNV ) * 8u; ++n ) {
    if( p & ExternalMemoryFeatureFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ExternalMemoryFeatureFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ExternalMemoryFeatureFlagsNV &p ) {
  if( j.is_array() ) {
    p = ExternalMemoryFeatureFlagsNV ( 0 );
    for( auto &e:  j ) {
      ExternalMemoryFeatureFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ExternalMemoryFeatureFlagsNV" );
}
#endif

#ifdef VK_NN_VI_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ViSurfaceCreateFlagBitsNN &p ) {
}
inline void from_json( const nlohmann::json &j, ViSurfaceCreateFlagBitsNN &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for ViSurfaceCreateFlagBitsNN" );
  }
  if( j.is_number() ) {
    p = ViSurfaceCreateFlagBitsNN ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ViSurfaceCreateFlagBitsNN" );
}
inline void to_json( nlohmann::json &j, const ViSurfaceCreateFlagsNN &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ViSurfaceCreateFlagBitsNN ) * 8u; ++n ) {
    if( p & ViSurfaceCreateFlagsNN ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ViSurfaceCreateFlagBitsNN ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ViSurfaceCreateFlagsNN &p ) {
  if( j.is_array() ) {
    p = ViSurfaceCreateFlagsNN ( 0 );
    for( auto &e:  j ) {
      ViSurfaceCreateFlagBitsNN temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ViSurfaceCreateFlagsNN" );
}
#endif

#ifdef VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ConditionalRenderingFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, ConditionalRenderingFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for ConditionalRenderingFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = ConditionalRenderingFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ConditionalRenderingFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const ConditionalRenderingFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ConditionalRenderingFlagBitsEXT ) * 8u; ++n ) {
    if( p & ConditionalRenderingFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ConditionalRenderingFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ConditionalRenderingFlagsEXT &p ) {
  if( j.is_array() ) {
    p = ConditionalRenderingFlagsEXT ( 0 );
    for( auto &e:  j ) {
      ConditionalRenderingFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ConditionalRenderingFlagsEXT" );
}
#endif

#ifdef VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const SurfaceCounterFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, SurfaceCounterFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for SurfaceCounterFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = SurfaceCounterFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SurfaceCounterFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const SurfaceCounterFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SurfaceCounterFlagBitsEXT ) * 8u; ++n ) {
    if( p & SurfaceCounterFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SurfaceCounterFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, SurfaceCounterFlagsEXT &p ) {
  if( j.is_array() ) {
    p = SurfaceCounterFlagsEXT ( 0 );
    for( auto &e:  j ) {
      SurfaceCounterFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SurfaceCounterFlagsEXT" );
}
#endif

#ifdef VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PipelineViewportSwizzleStateCreateFlagBitsNV &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineViewportSwizzleStateCreateFlagBitsNV &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineViewportSwizzleStateCreateFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = PipelineViewportSwizzleStateCreateFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineViewportSwizzleStateCreateFlagBitsNV" );
}
inline void to_json( nlohmann::json &j, const PipelineViewportSwizzleStateCreateFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineViewportSwizzleStateCreateFlagBitsNV ) * 8u; ++n ) {
    if( p & PipelineViewportSwizzleStateCreateFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineViewportSwizzleStateCreateFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineViewportSwizzleStateCreateFlagsNV &p ) {
  if( j.is_array() ) {
    p = PipelineViewportSwizzleStateCreateFlagsNV ( 0 );
    for( auto &e:  j ) {
      PipelineViewportSwizzleStateCreateFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineViewportSwizzleStateCreateFlagsNV" );
}
#endif

#ifdef VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PipelineDiscardRectangleStateCreateFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineDiscardRectangleStateCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineDiscardRectangleStateCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = PipelineDiscardRectangleStateCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineDiscardRectangleStateCreateFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const PipelineDiscardRectangleStateCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineDiscardRectangleStateCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & PipelineDiscardRectangleStateCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineDiscardRectangleStateCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineDiscardRectangleStateCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = PipelineDiscardRectangleStateCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      PipelineDiscardRectangleStateCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineDiscardRectangleStateCreateFlagsEXT" );
}
#endif

#ifdef VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PipelineRasterizationConservativeStateCreateFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationConservativeStateCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineRasterizationConservativeStateCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = PipelineRasterizationConservativeStateCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineRasterizationConservativeStateCreateFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const PipelineRasterizationConservativeStateCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineRasterizationConservativeStateCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & PipelineRasterizationConservativeStateCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineRasterizationConservativeStateCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationConservativeStateCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = PipelineRasterizationConservativeStateCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      PipelineRasterizationConservativeStateCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineRasterizationConservativeStateCreateFlagsEXT" );
}
#endif

#ifdef VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PipelineRasterizationDepthClipStateCreateFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationDepthClipStateCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineRasterizationDepthClipStateCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = PipelineRasterizationDepthClipStateCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineRasterizationDepthClipStateCreateFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const PipelineRasterizationDepthClipStateCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineRasterizationDepthClipStateCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & PipelineRasterizationDepthClipStateCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineRasterizationDepthClipStateCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationDepthClipStateCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = PipelineRasterizationDepthClipStateCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      PipelineRasterizationDepthClipStateCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineRasterizationDepthClipStateCreateFlagsEXT" );
}
#endif

#ifdef VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PerformanceCounterDescriptionFlagBitsKHR &p ) {
  if( PerformanceCounterDescriptionFlagBitsKHR :: ePerformanceImpacting == p ) {
    j = "PerformanceImpacting";
    return;
  }
}
inline void from_json( const nlohmann::json &j, PerformanceCounterDescriptionFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "PerformanceImpacting" == j.get< std::string >() ) {
      p = PerformanceCounterDescriptionFlagBitsKHR :: ePerformanceImpacting ;
      return;
    }
    if( "ePerformanceImpacting" == j.get< std::string >() ) {
      p = PerformanceCounterDescriptionFlagBitsKHR :: ePerformanceImpacting ;
      return;
    }
    if( "VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR" == j.get< std::string >() ) {
      p = PerformanceCounterDescriptionFlagBitsKHR :: ePerformanceImpacting ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PerformanceCounterDescriptionFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = PerformanceCounterDescriptionFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PerformanceCounterDescriptionFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const PerformanceCounterDescriptionFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PerformanceCounterDescriptionFlagBitsKHR ) * 8u; ++n ) {
    if( p & PerformanceCounterDescriptionFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PerformanceCounterDescriptionFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PerformanceCounterDescriptionFlagsKHR &p ) {
  if( j.is_array() ) {
    p = PerformanceCounterDescriptionFlagsKHR ( 0 );
    for( auto &e:  j ) {
      PerformanceCounterDescriptionFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PerformanceCounterDescriptionFlagsKHR" );
}
#endif

#ifdef VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const AcquireProfilingLockFlagBitsKHR &p ) {
}
inline void from_json( const nlohmann::json &j, AcquireProfilingLockFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for AcquireProfilingLockFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = AcquireProfilingLockFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AcquireProfilingLockFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const AcquireProfilingLockFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( AcquireProfilingLockFlagBitsKHR ) * 8u; ++n ) {
    if( p & AcquireProfilingLockFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, AcquireProfilingLockFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, AcquireProfilingLockFlagsKHR &p ) {
  if( j.is_array() ) {
    p = AcquireProfilingLockFlagsKHR ( 0 );
    for( auto &e:  j ) {
      AcquireProfilingLockFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for AcquireProfilingLockFlagsKHR" );
}
#endif

#ifdef VK_MVK_IOS_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const IOSSurfaceCreateFlagBitsMVK &p ) {
}
inline void from_json( const nlohmann::json &j, IOSSurfaceCreateFlagBitsMVK &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for IOSSurfaceCreateFlagBitsMVK" );
  }
  if( j.is_number() ) {
    p = IOSSurfaceCreateFlagBitsMVK ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for IOSSurfaceCreateFlagBitsMVK" );
}
inline void to_json( nlohmann::json &j, const IOSSurfaceCreateFlagsMVK &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( IOSSurfaceCreateFlagBitsMVK ) * 8u; ++n ) {
    if( p & IOSSurfaceCreateFlagsMVK ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, IOSSurfaceCreateFlagBitsMVK ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, IOSSurfaceCreateFlagsMVK &p ) {
  if( j.is_array() ) {
    p = IOSSurfaceCreateFlagsMVK ( 0 );
    for( auto &e:  j ) {
      IOSSurfaceCreateFlagBitsMVK temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for IOSSurfaceCreateFlagsMVK" );
}
#endif

#ifdef VK_MVK_MACOS_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const MacOSSurfaceCreateFlagBitsMVK &p ) {
}
inline void from_json( const nlohmann::json &j, MacOSSurfaceCreateFlagBitsMVK &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for MacOSSurfaceCreateFlagBitsMVK" );
  }
  if( j.is_number() ) {
    p = MacOSSurfaceCreateFlagBitsMVK ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for MacOSSurfaceCreateFlagBitsMVK" );
}
inline void to_json( nlohmann::json &j, const MacOSSurfaceCreateFlagsMVK &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( MacOSSurfaceCreateFlagBitsMVK ) * 8u; ++n ) {
    if( p & MacOSSurfaceCreateFlagsMVK ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, MacOSSurfaceCreateFlagBitsMVK ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, MacOSSurfaceCreateFlagsMVK &p ) {
  if( j.is_array() ) {
    p = MacOSSurfaceCreateFlagsMVK ( 0 );
    for( auto &e:  j ) {
      MacOSSurfaceCreateFlagBitsMVK temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for MacOSSurfaceCreateFlagsMVK" );
}
#endif

#ifdef VK_EXT_DEBUG_UTILS_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DebugUtilsMessageSeverityFlagBitsEXT &p ) {
  if( DebugUtilsMessageSeverityFlagBitsEXT :: eVerbose == p ) {
    j = "Verbose";
    return;
  }
  if( DebugUtilsMessageSeverityFlagBitsEXT :: eInfo == p ) {
    j = "Info";
    return;
  }
  if( DebugUtilsMessageSeverityFlagBitsEXT :: eWarning == p ) {
    j = "Warning";
    return;
  }
}
inline void from_json( const nlohmann::json &j, DebugUtilsMessageSeverityFlagBitsEXT &p ) {
  if( j.is_string() ) {
    if( "Verbose" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eVerbose ;
      return;
    }
    if( "eVerbose" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eVerbose ;
      return;
    }
    if( "VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eVerbose ;
      return;
    }
    if( "Info" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eInfo ;
      return;
    }
    if( "eInfo" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eInfo ;
      return;
    }
    if( "VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eInfo ;
      return;
    }
    if( "Warning" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eWarning ;
      return;
    }
    if( "eWarning" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eWarning ;
      return;
    }
    if( "VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT" == j.get< std::string >() ) {
      p = DebugUtilsMessageSeverityFlagBitsEXT :: eWarning ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DebugUtilsMessageSeverityFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = DebugUtilsMessageSeverityFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DebugUtilsMessageSeverityFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const DebugUtilsMessageSeverityFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DebugUtilsMessageSeverityFlagBitsEXT ) * 8u; ++n ) {
    if( p & DebugUtilsMessageSeverityFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DebugUtilsMessageSeverityFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DebugUtilsMessageSeverityFlagsEXT &p ) {
  if( j.is_array() ) {
    p = DebugUtilsMessageSeverityFlagsEXT ( 0 );
    for( auto &e:  j ) {
      DebugUtilsMessageSeverityFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DebugUtilsMessageSeverityFlagsEXT" );
}
#endif

#ifdef VK_EXT_DEBUG_UTILS_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DebugUtilsMessageTypeFlagBitsEXT &p ) {
  if( DebugUtilsMessageTypeFlagBitsEXT :: eGeneral == p ) {
    j = "General";
    return;
  }
  if( DebugUtilsMessageTypeFlagBitsEXT :: eValidation == p ) {
    j = "Validation";
    return;
  }
}
inline void from_json( const nlohmann::json &j, DebugUtilsMessageTypeFlagBitsEXT &p ) {
  if( j.is_string() ) {
    if( "General" == j.get< std::string >() ) {
      p = DebugUtilsMessageTypeFlagBitsEXT :: eGeneral ;
      return;
    }
    if( "eGeneral" == j.get< std::string >() ) {
      p = DebugUtilsMessageTypeFlagBitsEXT :: eGeneral ;
      return;
    }
    if( "VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT" == j.get< std::string >() ) {
      p = DebugUtilsMessageTypeFlagBitsEXT :: eGeneral ;
      return;
    }
    if( "Validation" == j.get< std::string >() ) {
      p = DebugUtilsMessageTypeFlagBitsEXT :: eValidation ;
      return;
    }
    if( "eValidation" == j.get< std::string >() ) {
      p = DebugUtilsMessageTypeFlagBitsEXT :: eValidation ;
      return;
    }
    if( "VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT" == j.get< std::string >() ) {
      p = DebugUtilsMessageTypeFlagBitsEXT :: eValidation ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DebugUtilsMessageTypeFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = DebugUtilsMessageTypeFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DebugUtilsMessageTypeFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const DebugUtilsMessageTypeFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DebugUtilsMessageTypeFlagBitsEXT ) * 8u; ++n ) {
    if( p & DebugUtilsMessageTypeFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DebugUtilsMessageTypeFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DebugUtilsMessageTypeFlagsEXT &p ) {
  if( j.is_array() ) {
    p = DebugUtilsMessageTypeFlagsEXT ( 0 );
    for( auto &e:  j ) {
      DebugUtilsMessageTypeFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DebugUtilsMessageTypeFlagsEXT" );
}
#endif

#ifdef VK_EXT_DEBUG_UTILS_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DebugUtilsMessengerCallbackDataFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, DebugUtilsMessengerCallbackDataFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DebugUtilsMessengerCallbackDataFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = DebugUtilsMessengerCallbackDataFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DebugUtilsMessengerCallbackDataFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const DebugUtilsMessengerCallbackDataFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DebugUtilsMessengerCallbackDataFlagBitsEXT ) * 8u; ++n ) {
    if( p & DebugUtilsMessengerCallbackDataFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DebugUtilsMessengerCallbackDataFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DebugUtilsMessengerCallbackDataFlagsEXT &p ) {
  if( j.is_array() ) {
    p = DebugUtilsMessengerCallbackDataFlagsEXT ( 0 );
    for( auto &e:  j ) {
      DebugUtilsMessengerCallbackDataFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DebugUtilsMessengerCallbackDataFlagsEXT" );
}
#endif

#ifdef VK_EXT_DEBUG_UTILS_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DebugUtilsMessengerCreateFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, DebugUtilsMessengerCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DebugUtilsMessengerCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = DebugUtilsMessengerCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DebugUtilsMessengerCreateFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const DebugUtilsMessengerCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DebugUtilsMessengerCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & DebugUtilsMessengerCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DebugUtilsMessengerCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DebugUtilsMessengerCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = DebugUtilsMessengerCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      DebugUtilsMessengerCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DebugUtilsMessengerCreateFlagsEXT" );
}
#endif

#ifdef VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PipelineCoverageToColorStateCreateFlagBitsNV &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineCoverageToColorStateCreateFlagBitsNV &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCoverageToColorStateCreateFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = PipelineCoverageToColorStateCreateFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCoverageToColorStateCreateFlagBitsNV" );
}
inline void to_json( nlohmann::json &j, const PipelineCoverageToColorStateCreateFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineCoverageToColorStateCreateFlagBitsNV ) * 8u; ++n ) {
    if( p & PipelineCoverageToColorStateCreateFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineCoverageToColorStateCreateFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineCoverageToColorStateCreateFlagsNV &p ) {
  if( j.is_array() ) {
    p = PipelineCoverageToColorStateCreateFlagsNV ( 0 );
    for( auto &e:  j ) {
      PipelineCoverageToColorStateCreateFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineCoverageToColorStateCreateFlagsNV" );
}
#endif

#ifdef VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const GeometryFlagBitsKHR &p ) {
  if( GeometryFlagBitsKHR :: eOpaque == p ) {
    j = "Opaque";
    return;
  }
}
inline void from_json( const nlohmann::json &j, GeometryFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "Opaque" == j.get< std::string >() ) {
      p = GeometryFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "eOpaque" == j.get< std::string >() ) {
      p = GeometryFlagBitsKHR :: eOpaque ;
      return;
    }
    if( "VK_GEOMETRY_OPAQUE_BIT_KHR" == j.get< std::string >() ) {
      p = GeometryFlagBitsKHR :: eOpaque ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for GeometryFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = GeometryFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for GeometryFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const GeometryFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( GeometryFlagBitsKHR ) * 8u; ++n ) {
    if( p & GeometryFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, GeometryFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, GeometryFlagsKHR &p ) {
  if( j.is_array() ) {
    p = GeometryFlagsKHR ( 0 );
    for( auto &e:  j ) {
      GeometryFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for GeometryFlagsKHR" );
}
#endif

#ifdef VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const GeometryInstanceFlagBitsKHR &p ) {
  if( GeometryInstanceFlagBitsKHR :: eTriangleFacingCullDisable == p ) {
    j = "TriangleFacingCullDisable";
    return;
  }
  if( GeometryInstanceFlagBitsKHR :: eTriangleFrontCounterclockwise == p ) {
    j = "TriangleFrontCounterclockwise";
    return;
  }
  if( GeometryInstanceFlagBitsKHR :: eForceOpaque == p ) {
    j = "ForceOpaque";
    return;
  }
  if( GeometryInstanceFlagBitsKHR :: eForceNoOpaque == p ) {
    j = "ForceNoOpaque";
    return;
  }
}
inline void from_json( const nlohmann::json &j, GeometryInstanceFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "TriangleFacingCullDisable" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eTriangleFacingCullDisable ;
      return;
    }
    if( "eTriangleFacingCullDisable" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eTriangleFacingCullDisable ;
      return;
    }
    if( "VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eTriangleFacingCullDisable ;
      return;
    }
    if( "TriangleFrontCounterclockwise" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eTriangleFrontCounterclockwise ;
      return;
    }
    if( "eTriangleFrontCounterclockwise" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eTriangleFrontCounterclockwise ;
      return;
    }
    if( "VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eTriangleFrontCounterclockwise ;
      return;
    }
    if( "ForceOpaque" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eForceOpaque ;
      return;
    }
    if( "eForceOpaque" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eForceOpaque ;
      return;
    }
    if( "VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eForceOpaque ;
      return;
    }
    if( "ForceNoOpaque" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eForceNoOpaque ;
      return;
    }
    if( "eForceNoOpaque" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eForceNoOpaque ;
      return;
    }
    if( "VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR" == j.get< std::string >() ) {
      p = GeometryInstanceFlagBitsKHR :: eForceNoOpaque ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for GeometryInstanceFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = GeometryInstanceFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for GeometryInstanceFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const GeometryInstanceFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( GeometryInstanceFlagBitsKHR ) * 8u; ++n ) {
    if( p & GeometryInstanceFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, GeometryInstanceFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, GeometryInstanceFlagsKHR &p ) {
  if( j.is_array() ) {
    p = GeometryInstanceFlagsKHR ( 0 );
    for( auto &e:  j ) {
      GeometryInstanceFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for GeometryInstanceFlagsKHR" );
}
#endif

#ifdef VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const BuildAccelerationStructureFlagBitsKHR &p ) {
  if( BuildAccelerationStructureFlagBitsKHR :: eAllowUpdate == p ) {
    j = "AllowUpdate";
    return;
  }
  if( BuildAccelerationStructureFlagBitsKHR :: eAllowCompaction == p ) {
    j = "AllowCompaction";
    return;
  }
  if( BuildAccelerationStructureFlagBitsKHR :: ePreferFastTrace == p ) {
    j = "PreferFastTrace";
    return;
  }
  if( BuildAccelerationStructureFlagBitsKHR :: ePreferFastBuild == p ) {
    j = "PreferFastBuild";
    return;
  }
  if( BuildAccelerationStructureFlagBitsKHR :: eLowMemory == p ) {
    j = "LowMemory";
    return;
  }
}
inline void from_json( const nlohmann::json &j, BuildAccelerationStructureFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "AllowUpdate" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eAllowUpdate ;
      return;
    }
    if( "eAllowUpdate" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eAllowUpdate ;
      return;
    }
    if( "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eAllowUpdate ;
      return;
    }
    if( "AllowCompaction" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eAllowCompaction ;
      return;
    }
    if( "eAllowCompaction" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eAllowCompaction ;
      return;
    }
    if( "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eAllowCompaction ;
      return;
    }
    if( "PreferFastTrace" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: ePreferFastTrace ;
      return;
    }
    if( "ePreferFastTrace" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: ePreferFastTrace ;
      return;
    }
    if( "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: ePreferFastTrace ;
      return;
    }
    if( "PreferFastBuild" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: ePreferFastBuild ;
      return;
    }
    if( "ePreferFastBuild" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: ePreferFastBuild ;
      return;
    }
    if( "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: ePreferFastBuild ;
      return;
    }
    if( "LowMemory" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eLowMemory ;
      return;
    }
    if( "eLowMemory" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eLowMemory ;
      return;
    }
    if( "VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR" == j.get< std::string >() ) {
      p = BuildAccelerationStructureFlagBitsKHR :: eLowMemory ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for BuildAccelerationStructureFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = BuildAccelerationStructureFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for BuildAccelerationStructureFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const BuildAccelerationStructureFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( BuildAccelerationStructureFlagBitsKHR ) * 8u; ++n ) {
    if( p & BuildAccelerationStructureFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, BuildAccelerationStructureFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, BuildAccelerationStructureFlagsKHR &p ) {
  if( j.is_array() ) {
    p = BuildAccelerationStructureFlagsKHR ( 0 );
    for( auto &e:  j ) {
      BuildAccelerationStructureFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for BuildAccelerationStructureFlagsKHR" );
}
#endif

#ifdef VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const AccelerationStructureCreateFlagBitsKHR &p ) {
  if( AccelerationStructureCreateFlagBitsKHR :: eDeviceAddressCaptureReplay == p ) {
    j = "DeviceAddressCaptureReplay";
    return;
  }
}
inline void from_json( const nlohmann::json &j, AccelerationStructureCreateFlagBitsKHR &p ) {
  if( j.is_string() ) {
    if( "DeviceAddressCaptureReplay" == j.get< std::string >() ) {
      p = AccelerationStructureCreateFlagBitsKHR :: eDeviceAddressCaptureReplay ;
      return;
    }
    if( "eDeviceAddressCaptureReplay" == j.get< std::string >() ) {
      p = AccelerationStructureCreateFlagBitsKHR :: eDeviceAddressCaptureReplay ;
      return;
    }
    if( "VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR" == j.get< std::string >() ) {
      p = AccelerationStructureCreateFlagBitsKHR :: eDeviceAddressCaptureReplay ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureCreateFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureCreateFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureCreateFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const AccelerationStructureCreateFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( AccelerationStructureCreateFlagBitsKHR ) * 8u; ++n ) {
    if( p & AccelerationStructureCreateFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, AccelerationStructureCreateFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, AccelerationStructureCreateFlagsKHR &p ) {
  if( j.is_array() ) {
    p = AccelerationStructureCreateFlagsKHR ( 0 );
    for( auto &e:  j ) {
      AccelerationStructureCreateFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for AccelerationStructureCreateFlagsKHR" );
}
#endif

#ifdef VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PipelineCoverageModulationStateCreateFlagBitsNV &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineCoverageModulationStateCreateFlagBitsNV &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCoverageModulationStateCreateFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = PipelineCoverageModulationStateCreateFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCoverageModulationStateCreateFlagBitsNV" );
}
inline void to_json( nlohmann::json &j, const PipelineCoverageModulationStateCreateFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineCoverageModulationStateCreateFlagBitsNV ) * 8u; ++n ) {
    if( p & PipelineCoverageModulationStateCreateFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineCoverageModulationStateCreateFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineCoverageModulationStateCreateFlagsNV &p ) {
  if( j.is_array() ) {
    p = PipelineCoverageModulationStateCreateFlagsNV ( 0 );
    for( auto &e:  j ) {
      PipelineCoverageModulationStateCreateFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineCoverageModulationStateCreateFlagsNV" );
}
#endif

#ifdef VK_EXT_VALIDATION_CACHE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ValidationCacheCreateFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, ValidationCacheCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for ValidationCacheCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = ValidationCacheCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ValidationCacheCreateFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const ValidationCacheCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ValidationCacheCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & ValidationCacheCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ValidationCacheCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ValidationCacheCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = ValidationCacheCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      ValidationCacheCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ValidationCacheCreateFlagsEXT" );
}
#endif

#ifdef VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PipelineCompilerControlFlagBitsAMD &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineCompilerControlFlagBitsAMD &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCompilerControlFlagBitsAMD" );
  }
  if( j.is_number() ) {
    p = PipelineCompilerControlFlagBitsAMD ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCompilerControlFlagBitsAMD" );
}
inline void to_json( nlohmann::json &j, const PipelineCompilerControlFlagsAMD &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineCompilerControlFlagBitsAMD ) * 8u; ++n ) {
    if( p & PipelineCompilerControlFlagsAMD ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineCompilerControlFlagBitsAMD ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineCompilerControlFlagsAMD &p ) {
  if( j.is_array() ) {
    p = PipelineCompilerControlFlagsAMD ( 0 );
    for( auto &e:  j ) {
      PipelineCompilerControlFlagBitsAMD temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineCompilerControlFlagsAMD" );
}
#endif

#ifdef VK_EXT_VIDEO_DECODE_H265_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoDecodeH265CreateFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, VideoDecodeH265CreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoDecodeH265CreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = VideoDecodeH265CreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoDecodeH265CreateFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const VideoDecodeH265CreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoDecodeH265CreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & VideoDecodeH265CreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoDecodeH265CreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoDecodeH265CreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = VideoDecodeH265CreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      VideoDecodeH265CreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoDecodeH265CreateFlagsEXT" );
}
#endif

#ifdef VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PipelineCreationFeedbackFlagBitsEXT &p ) {
  if( PipelineCreationFeedbackFlagBitsEXT :: eValid == p ) {
    j = "Valid";
    return;
  }
  if( PipelineCreationFeedbackFlagBitsEXT :: eApplicationPipelineCacheHit == p ) {
    j = "ApplicationPipelineCacheHit";
    return;
  }
}
inline void from_json( const nlohmann::json &j, PipelineCreationFeedbackFlagBitsEXT &p ) {
  if( j.is_string() ) {
    if( "Valid" == j.get< std::string >() ) {
      p = PipelineCreationFeedbackFlagBitsEXT :: eValid ;
      return;
    }
    if( "eValid" == j.get< std::string >() ) {
      p = PipelineCreationFeedbackFlagBitsEXT :: eValid ;
      return;
    }
    if( "VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineCreationFeedbackFlagBitsEXT :: eValid ;
      return;
    }
    if( "ApplicationPipelineCacheHit" == j.get< std::string >() ) {
      p = PipelineCreationFeedbackFlagBitsEXT :: eApplicationPipelineCacheHit ;
      return;
    }
    if( "eApplicationPipelineCacheHit" == j.get< std::string >() ) {
      p = PipelineCreationFeedbackFlagBitsEXT :: eApplicationPipelineCacheHit ;
      return;
    }
    if( "VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineCreationFeedbackFlagBitsEXT :: eApplicationPipelineCacheHit ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCreationFeedbackFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = PipelineCreationFeedbackFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCreationFeedbackFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const PipelineCreationFeedbackFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineCreationFeedbackFlagBitsEXT ) * 8u; ++n ) {
    if( p & PipelineCreationFeedbackFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineCreationFeedbackFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineCreationFeedbackFlagsEXT &p ) {
  if( j.is_array() ) {
    p = PipelineCreationFeedbackFlagsEXT ( 0 );
    for( auto &e:  j ) {
      PipelineCreationFeedbackFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineCreationFeedbackFlagsEXT" );
}
#endif

#ifdef VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ImagePipeSurfaceCreateFlagBitsFUCHSIA &p ) {
}
inline void from_json( const nlohmann::json &j, ImagePipeSurfaceCreateFlagBitsFUCHSIA &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for ImagePipeSurfaceCreateFlagBitsFUCHSIA" );
  }
  if( j.is_number() ) {
    p = ImagePipeSurfaceCreateFlagBitsFUCHSIA ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ImagePipeSurfaceCreateFlagBitsFUCHSIA" );
}
inline void to_json( nlohmann::json &j, const ImagePipeSurfaceCreateFlagsFUCHSIA &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ImagePipeSurfaceCreateFlagBitsFUCHSIA ) * 8u; ++n ) {
    if( p & ImagePipeSurfaceCreateFlagsFUCHSIA ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ImagePipeSurfaceCreateFlagBitsFUCHSIA ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ImagePipeSurfaceCreateFlagsFUCHSIA &p ) {
  if( j.is_array() ) {
    p = ImagePipeSurfaceCreateFlagsFUCHSIA ( 0 );
    for( auto &e:  j ) {
      ImagePipeSurfaceCreateFlagBitsFUCHSIA temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ImagePipeSurfaceCreateFlagsFUCHSIA" );
}
#endif

#ifdef VK_EXT_METAL_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const MetalSurfaceCreateFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, MetalSurfaceCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for MetalSurfaceCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = MetalSurfaceCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for MetalSurfaceCreateFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const MetalSurfaceCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( MetalSurfaceCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & MetalSurfaceCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, MetalSurfaceCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, MetalSurfaceCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = MetalSurfaceCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      MetalSurfaceCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for MetalSurfaceCreateFlagsEXT" );
}
#endif

#ifdef VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ShaderCorePropertiesFlagBitsAMD &p ) {
}
inline void from_json( const nlohmann::json &j, ShaderCorePropertiesFlagBitsAMD &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for ShaderCorePropertiesFlagBitsAMD" );
  }
  if( j.is_number() ) {
    p = ShaderCorePropertiesFlagBitsAMD ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ShaderCorePropertiesFlagBitsAMD" );
}
inline void to_json( nlohmann::json &j, const ShaderCorePropertiesFlagsAMD &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ShaderCorePropertiesFlagBitsAMD ) * 8u; ++n ) {
    if( p & ShaderCorePropertiesFlagsAMD ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ShaderCorePropertiesFlagBitsAMD ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ShaderCorePropertiesFlagsAMD &p ) {
  if( j.is_array() ) {
    p = ShaderCorePropertiesFlagsAMD ( 0 );
    for( auto &e:  j ) {
      ShaderCorePropertiesFlagBitsAMD temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ShaderCorePropertiesFlagsAMD" );
}
#endif

#ifdef VK_EXT_TOOLING_INFO_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ToolPurposeFlagBitsEXT &p ) {
  if( ToolPurposeFlagBitsEXT :: eValidation == p ) {
    j = "Validation";
    return;
  }
  if( ToolPurposeFlagBitsEXT :: eProfiling == p ) {
    j = "Profiling";
    return;
  }
  if( ToolPurposeFlagBitsEXT :: eTracing == p ) {
    j = "Tracing";
    return;
  }
  if( ToolPurposeFlagBitsEXT :: eAdditionalFeatures == p ) {
    j = "AdditionalFeatures";
    return;
  }
  if( ToolPurposeFlagBitsEXT :: eModifyingFeatures == p ) {
    j = "ModifyingFeatures";
    return;
  }
  if( ToolPurposeFlagBitsEXT :: eDebugReporting == p ) {
    j = "DebugReporting";
    return;
  }
}
inline void from_json( const nlohmann::json &j, ToolPurposeFlagBitsEXT &p ) {
  if( j.is_string() ) {
    if( "Validation" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eValidation ;
      return;
    }
    if( "eValidation" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eValidation ;
      return;
    }
    if( "VK_TOOL_PURPOSE_VALIDATION_BIT_EXT" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eValidation ;
      return;
    }
    if( "Profiling" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eProfiling ;
      return;
    }
    if( "eProfiling" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eProfiling ;
      return;
    }
    if( "VK_TOOL_PURPOSE_PROFILING_BIT_EXT" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eProfiling ;
      return;
    }
    if( "Tracing" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eTracing ;
      return;
    }
    if( "eTracing" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eTracing ;
      return;
    }
    if( "VK_TOOL_PURPOSE_TRACING_BIT_EXT" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eTracing ;
      return;
    }
    if( "AdditionalFeatures" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eAdditionalFeatures ;
      return;
    }
    if( "eAdditionalFeatures" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eAdditionalFeatures ;
      return;
    }
    if( "VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eAdditionalFeatures ;
      return;
    }
    if( "ModifyingFeatures" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eModifyingFeatures ;
      return;
    }
    if( "eModifyingFeatures" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eModifyingFeatures ;
      return;
    }
    if( "VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eModifyingFeatures ;
      return;
    }
    if( "DebugReporting" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eDebugReporting ;
      return;
    }
    if( "eDebugReporting" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eDebugReporting ;
      return;
    }
    if( "VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT" == j.get< std::string >() ) {
      p = ToolPurposeFlagBitsEXT :: eDebugReporting ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for ToolPurposeFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = ToolPurposeFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ToolPurposeFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const ToolPurposeFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ToolPurposeFlagBitsEXT ) * 8u; ++n ) {
    if( p & ToolPurposeFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ToolPurposeFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ToolPurposeFlagsEXT &p ) {
  if( j.is_array() ) {
    p = ToolPurposeFlagsEXT ( 0 );
    for( auto &e:  j ) {
      ToolPurposeFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ToolPurposeFlagsEXT" );
}
#endif

#ifdef VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PipelineCoverageReductionStateCreateFlagBitsNV &p ) {
}
inline void from_json( const nlohmann::json &j, PipelineCoverageReductionStateCreateFlagBitsNV &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineCoverageReductionStateCreateFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = PipelineCoverageReductionStateCreateFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineCoverageReductionStateCreateFlagBitsNV" );
}
inline void to_json( nlohmann::json &j, const PipelineCoverageReductionStateCreateFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineCoverageReductionStateCreateFlagBitsNV ) * 8u; ++n ) {
    if( p & PipelineCoverageReductionStateCreateFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineCoverageReductionStateCreateFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineCoverageReductionStateCreateFlagsNV &p ) {
  if( j.is_array() ) {
    p = PipelineCoverageReductionStateCreateFlagsNV ( 0 );
    for( auto &e:  j ) {
      PipelineCoverageReductionStateCreateFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineCoverageReductionStateCreateFlagsNV" );
}
#endif

#ifdef VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const HeadlessSurfaceCreateFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, HeadlessSurfaceCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for HeadlessSurfaceCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = HeadlessSurfaceCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for HeadlessSurfaceCreateFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const HeadlessSurfaceCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( HeadlessSurfaceCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & HeadlessSurfaceCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, HeadlessSurfaceCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, HeadlessSurfaceCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = HeadlessSurfaceCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      HeadlessSurfaceCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for HeadlessSurfaceCreateFlagsEXT" );
}
#endif

#ifdef VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const IndirectStateFlagBitsNV &p ) {
}
inline void from_json( const nlohmann::json &j, IndirectStateFlagBitsNV &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for IndirectStateFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = IndirectStateFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for IndirectStateFlagBitsNV" );
}
inline void to_json( nlohmann::json &j, const IndirectStateFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( IndirectStateFlagBitsNV ) * 8u; ++n ) {
    if( p & IndirectStateFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, IndirectStateFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, IndirectStateFlagsNV &p ) {
  if( j.is_array() ) {
    p = IndirectStateFlagsNV ( 0 );
    for( auto &e:  j ) {
      IndirectStateFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for IndirectStateFlagsNV" );
}
#endif

#ifdef VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const IndirectCommandsLayoutUsageFlagBitsNV &p ) {
  if( IndirectCommandsLayoutUsageFlagBitsNV :: eExplicitPreprocess == p ) {
    j = "ExplicitPreprocess";
    return;
  }
  if( IndirectCommandsLayoutUsageFlagBitsNV :: eIndexedSequences == p ) {
    j = "IndexedSequences";
    return;
  }
}
inline void from_json( const nlohmann::json &j, IndirectCommandsLayoutUsageFlagBitsNV &p ) {
  if( j.is_string() ) {
    if( "ExplicitPreprocess" == j.get< std::string >() ) {
      p = IndirectCommandsLayoutUsageFlagBitsNV :: eExplicitPreprocess ;
      return;
    }
    if( "eExplicitPreprocess" == j.get< std::string >() ) {
      p = IndirectCommandsLayoutUsageFlagBitsNV :: eExplicitPreprocess ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV" == j.get< std::string >() ) {
      p = IndirectCommandsLayoutUsageFlagBitsNV :: eExplicitPreprocess ;
      return;
    }
    if( "IndexedSequences" == j.get< std::string >() ) {
      p = IndirectCommandsLayoutUsageFlagBitsNV :: eIndexedSequences ;
      return;
    }
    if( "eIndexedSequences" == j.get< std::string >() ) {
      p = IndirectCommandsLayoutUsageFlagBitsNV :: eIndexedSequences ;
      return;
    }
    if( "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV" == j.get< std::string >() ) {
      p = IndirectCommandsLayoutUsageFlagBitsNV :: eIndexedSequences ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for IndirectCommandsLayoutUsageFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = IndirectCommandsLayoutUsageFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for IndirectCommandsLayoutUsageFlagBitsNV" );
}
inline void to_json( nlohmann::json &j, const IndirectCommandsLayoutUsageFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( IndirectCommandsLayoutUsageFlagBitsNV ) * 8u; ++n ) {
    if( p & IndirectCommandsLayoutUsageFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, IndirectCommandsLayoutUsageFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, IndirectCommandsLayoutUsageFlagsNV &p ) {
  if( j.is_array() ) {
    p = IndirectCommandsLayoutUsageFlagsNV ( 0 );
    for( auto &e:  j ) {
      IndirectCommandsLayoutUsageFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for IndirectCommandsLayoutUsageFlagsNV" );
}
#endif

#ifdef VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DeviceMemoryReportFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, DeviceMemoryReportFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DeviceMemoryReportFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = DeviceMemoryReportFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DeviceMemoryReportFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const DeviceMemoryReportFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DeviceMemoryReportFlagBitsEXT ) * 8u; ++n ) {
    if( p & DeviceMemoryReportFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DeviceMemoryReportFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DeviceMemoryReportFlagsEXT &p ) {
  if( j.is_array() ) {
    p = DeviceMemoryReportFlagsEXT ( 0 );
    for( auto &e:  j ) {
      DeviceMemoryReportFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DeviceMemoryReportFlagsEXT" );
}
#endif

#ifdef VK_EXT_PRIVATE_DATA_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PrivateDataSlotCreateFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, PrivateDataSlotCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for PrivateDataSlotCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = PrivateDataSlotCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PrivateDataSlotCreateFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const PrivateDataSlotCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PrivateDataSlotCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & PrivateDataSlotCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PrivateDataSlotCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PrivateDataSlotCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = PrivateDataSlotCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      PrivateDataSlotCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PrivateDataSlotCreateFlagsEXT" );
}
#endif

#ifdef VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoEncodeFlagBitsKHR &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoEncodeFlagBitsKHR :: eDefault == p ) {
    j = "Default";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoEncodeFlagBitsKHR &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Default" == j.get< std::string >() ) {
      p = VideoEncodeFlagBitsKHR :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eDefault" == j.get< std::string >() ) {
      p = VideoEncodeFlagBitsKHR :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_ENCODE_DEFAULT_KHR" == j.get< std::string >() ) {
      p = VideoEncodeFlagBitsKHR :: eDefault ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoEncodeFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = VideoEncodeFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoEncodeFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const VideoEncodeFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoEncodeFlagBitsKHR ) * 8u; ++n ) {
    if( p & VideoEncodeFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoEncodeFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoEncodeFlagsKHR &p ) {
  if( j.is_array() ) {
    p = VideoEncodeFlagsKHR ( 0 );
    for( auto &e:  j ) {
      VideoEncodeFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoEncodeFlagsKHR" );
}
#endif

#ifdef VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoEncodeRateControlFlagBitsKHR &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoEncodeRateControlFlagBitsKHR :: eDefault == p ) {
    j = "Default";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoEncodeRateControlFlagBitsKHR &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Default" == j.get< std::string >() ) {
      p = VideoEncodeRateControlFlagBitsKHR :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eDefault" == j.get< std::string >() ) {
      p = VideoEncodeRateControlFlagBitsKHR :: eDefault ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_ENCODE_RATE_CONTROL_DEFAULT_KHR" == j.get< std::string >() ) {
      p = VideoEncodeRateControlFlagBitsKHR :: eDefault ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoEncodeRateControlFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = VideoEncodeRateControlFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoEncodeRateControlFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const VideoEncodeRateControlFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoEncodeRateControlFlagBitsKHR ) * 8u; ++n ) {
    if( p & VideoEncodeRateControlFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoEncodeRateControlFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoEncodeRateControlFlagsKHR &p ) {
  if( j.is_array() ) {
    p = VideoEncodeRateControlFlagsKHR ( 0 );
    for( auto &e:  j ) {
      VideoEncodeRateControlFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoEncodeRateControlFlagsKHR" );
}
#endif

#ifdef VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const VideoEncodeRateControlModeFlagBitsKHR &p ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoEncodeRateControlModeFlagBitsKHR :: eNone == p ) {
    j = "None";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( VideoEncodeRateControlModeFlagBitsKHR :: eCbr == p ) {
    j = "Cbr";
    return;
  }
#endif
}
inline void from_json( const nlohmann::json &j, VideoEncodeRateControlModeFlagBitsKHR &p ) {
  if( j.is_string() ) {
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "None" == j.get< std::string >() ) {
      p = VideoEncodeRateControlModeFlagBitsKHR :: eNone ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eNone" == j.get< std::string >() ) {
      p = VideoEncodeRateControlModeFlagBitsKHR :: eNone ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR" == j.get< std::string >() ) {
      p = VideoEncodeRateControlModeFlagBitsKHR :: eNone ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "Cbr" == j.get< std::string >() ) {
      p = VideoEncodeRateControlModeFlagBitsKHR :: eCbr ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eCbr" == j.get< std::string >() ) {
      p = VideoEncodeRateControlModeFlagBitsKHR :: eCbr ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR" == j.get< std::string >() ) {
      p = VideoEncodeRateControlModeFlagBitsKHR :: eCbr ;
      return;
    }
#endif
    throw vulkan2json::invalid_enum_value( "unknown enum name for VideoEncodeRateControlModeFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = VideoEncodeRateControlModeFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for VideoEncodeRateControlModeFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const VideoEncodeRateControlModeFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( VideoEncodeRateControlModeFlagBitsKHR ) * 8u; ++n ) {
    if( p & VideoEncodeRateControlModeFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, VideoEncodeRateControlModeFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, VideoEncodeRateControlModeFlagsKHR &p ) {
  if( j.is_array() ) {
    p = VideoEncodeRateControlModeFlagsKHR ( 0 );
    for( auto &e:  j ) {
      VideoEncodeRateControlModeFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for VideoEncodeRateControlModeFlagsKHR" );
}
#endif

#ifdef VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DeviceDiagnosticsConfigFlagBitsNV &p ) {
  if( DeviceDiagnosticsConfigFlagBitsNV :: eEnableShaderDebugInfo == p ) {
    j = "EnableShaderDebugInfo";
    return;
  }
  if( DeviceDiagnosticsConfigFlagBitsNV :: eEnableResourceTracking == p ) {
    j = "EnableResourceTracking";
    return;
  }
}
inline void from_json( const nlohmann::json &j, DeviceDiagnosticsConfigFlagBitsNV &p ) {
  if( j.is_string() ) {
    if( "EnableShaderDebugInfo" == j.get< std::string >() ) {
      p = DeviceDiagnosticsConfigFlagBitsNV :: eEnableShaderDebugInfo ;
      return;
    }
    if( "eEnableShaderDebugInfo" == j.get< std::string >() ) {
      p = DeviceDiagnosticsConfigFlagBitsNV :: eEnableShaderDebugInfo ;
      return;
    }
    if( "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV" == j.get< std::string >() ) {
      p = DeviceDiagnosticsConfigFlagBitsNV :: eEnableShaderDebugInfo ;
      return;
    }
    if( "EnableResourceTracking" == j.get< std::string >() ) {
      p = DeviceDiagnosticsConfigFlagBitsNV :: eEnableResourceTracking ;
      return;
    }
    if( "eEnableResourceTracking" == j.get< std::string >() ) {
      p = DeviceDiagnosticsConfigFlagBitsNV :: eEnableResourceTracking ;
      return;
    }
    if( "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV" == j.get< std::string >() ) {
      p = DeviceDiagnosticsConfigFlagBitsNV :: eEnableResourceTracking ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for DeviceDiagnosticsConfigFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = DeviceDiagnosticsConfigFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DeviceDiagnosticsConfigFlagBitsNV" );
}
inline void to_json( nlohmann::json &j, const DeviceDiagnosticsConfigFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DeviceDiagnosticsConfigFlagBitsNV ) * 8u; ++n ) {
    if( p & DeviceDiagnosticsConfigFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DeviceDiagnosticsConfigFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DeviceDiagnosticsConfigFlagsNV &p ) {
  if( j.is_array() ) {
    p = DeviceDiagnosticsConfigFlagsNV ( 0 );
    for( auto &e:  j ) {
      DeviceDiagnosticsConfigFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DeviceDiagnosticsConfigFlagsNV" );
}
#endif

#ifdef VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const PipelineStageFlagBits2KHR &p ) {
  if( PipelineStageFlagBits2KHR :: eNone == p ) {
    j = "None";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eTopOfPipe == p ) {
    j = "TopOfPipe";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eDrawIndirect == p ) {
    j = "DrawIndirect";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eVertexInput == p ) {
    j = "VertexInput";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eVertexShader == p ) {
    j = "VertexShader";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eTessellationControlShader == p ) {
    j = "TessellationControlShader";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eTessellationEvaluationShader == p ) {
    j = "TessellationEvaluationShader";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eGeometryShader == p ) {
    j = "GeometryShader";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eFragmentShader == p ) {
    j = "FragmentShader";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eEarlyFragmentTests == p ) {
    j = "EarlyFragmentTests";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eLateFragmentTests == p ) {
    j = "LateFragmentTests";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eColorAttachmentOutput == p ) {
    j = "ColorAttachmentOutput";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eComputeShader == p ) {
    j = "ComputeShader";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eAllTransfer == p ) {
    j = "AllTransfer";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eBottomOfPipe == p ) {
    j = "BottomOfPipe";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eHost == p ) {
    j = "Host";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eAllGraphics == p ) {
    j = "AllGraphics";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eAllCommands == p ) {
    j = "AllCommands";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eCopy == p ) {
    j = "Copy";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eResolve == p ) {
    j = "Resolve";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eBlit == p ) {
    j = "Blit";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eClear == p ) {
    j = "Clear";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eIndexInput == p ) {
    j = "IndexInput";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eVertexAttributeInput == p ) {
    j = "VertexAttributeInput";
    return;
  }
  if( PipelineStageFlagBits2KHR :: ePreRasterizationShaders == p ) {
    j = "PreRasterizationShaders";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( PipelineStageFlagBits2KHR :: eVideoDecode == p ) {
    j = "VideoDecode";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( PipelineStageFlagBits2KHR :: eVideoEncode == p ) {
    j = "VideoEncode";
    return;
  }
#endif
  if( PipelineStageFlagBits2KHR :: eTransformFeedbackEXT == p ) {
    j = "TransformFeedbackEXT";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eConditionalRenderingEXT == p ) {
    j = "ConditionalRenderingEXT";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eCommandPreprocessNV == p ) {
    j = "CommandPreprocessNV";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eFragmentShadingRateAttachment == p ) {
    j = "FragmentShadingRateAttachment";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eAccelerationStructureBuild == p ) {
    j = "AccelerationStructureBuild";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eRayTracingShader == p ) {
    j = "RayTracingShader";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eFragmentDensityProcessEXT == p ) {
    j = "FragmentDensityProcessEXT";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eTaskShaderNV == p ) {
    j = "TaskShaderNV";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eMeshShaderNV == p ) {
    j = "MeshShaderNV";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eSubpassShadingHUAWEI == p ) {
    j = "SubpassShadingHUAWEI";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eAccelerationStructureBuildNV == p ) {
    j = "AccelerationStructureBuildNV";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eRayTracingShaderNV == p ) {
    j = "RayTracingShaderNV";
    return;
  }
  if( PipelineStageFlagBits2KHR :: eShadingRateImageNV == p ) {
    j = "ShadingRateImageNV";
    return;
  }
}
inline void from_json( const nlohmann::json &j, PipelineStageFlagBits2KHR &p ) {
  if( j.is_string() ) {
    if( "None" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eNone ;
      return;
    }
    if( "eNone" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eNone ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_NONE_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eNone ;
      return;
    }
    if( "TopOfPipe" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTopOfPipe ;
      return;
    }
    if( "eTopOfPipe" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTopOfPipe ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTopOfPipe ;
      return;
    }
    if( "DrawIndirect" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eDrawIndirect ;
      return;
    }
    if( "eDrawIndirect" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eDrawIndirect ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eDrawIndirect ;
      return;
    }
    if( "VertexInput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVertexInput ;
      return;
    }
    if( "eVertexInput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVertexInput ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVertexInput ;
      return;
    }
    if( "VertexShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVertexShader ;
      return;
    }
    if( "eVertexShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVertexShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVertexShader ;
      return;
    }
    if( "TessellationControlShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTessellationControlShader ;
      return;
    }
    if( "eTessellationControlShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTessellationControlShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTessellationControlShader ;
      return;
    }
    if( "TessellationEvaluationShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTessellationEvaluationShader ;
      return;
    }
    if( "eTessellationEvaluationShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTessellationEvaluationShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTessellationEvaluationShader ;
      return;
    }
    if( "GeometryShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eGeometryShader ;
      return;
    }
    if( "eGeometryShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eGeometryShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eGeometryShader ;
      return;
    }
    if( "FragmentShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eFragmentShader ;
      return;
    }
    if( "eFragmentShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eFragmentShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eFragmentShader ;
      return;
    }
    if( "EarlyFragmentTests" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eEarlyFragmentTests ;
      return;
    }
    if( "eEarlyFragmentTests" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eEarlyFragmentTests ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eEarlyFragmentTests ;
      return;
    }
    if( "LateFragmentTests" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eLateFragmentTests ;
      return;
    }
    if( "eLateFragmentTests" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eLateFragmentTests ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eLateFragmentTests ;
      return;
    }
    if( "ColorAttachmentOutput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eColorAttachmentOutput ;
      return;
    }
    if( "eColorAttachmentOutput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eColorAttachmentOutput ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eColorAttachmentOutput ;
      return;
    }
    if( "ComputeShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eComputeShader ;
      return;
    }
    if( "eComputeShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eComputeShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eComputeShader ;
      return;
    }
    if( "AllTransfer" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAllTransfer ;
      return;
    }
    if( "eAllTransfer" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAllTransfer ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAllTransfer ;
      return;
    }
    if( "BottomOfPipe" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eBottomOfPipe ;
      return;
    }
    if( "eBottomOfPipe" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eBottomOfPipe ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eBottomOfPipe ;
      return;
    }
    if( "Host" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eHost ;
      return;
    }
    if( "eHost" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eHost ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_HOST_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eHost ;
      return;
    }
    if( "AllGraphics" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAllGraphics ;
      return;
    }
    if( "eAllGraphics" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAllGraphics ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAllGraphics ;
      return;
    }
    if( "AllCommands" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAllCommands ;
      return;
    }
    if( "eAllCommands" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAllCommands ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAllCommands ;
      return;
    }
    if( "Copy" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eCopy ;
      return;
    }
    if( "eCopy" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eCopy ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_COPY_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eCopy ;
      return;
    }
    if( "Resolve" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eResolve ;
      return;
    }
    if( "eResolve" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eResolve ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eResolve ;
      return;
    }
    if( "Blit" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eBlit ;
      return;
    }
    if( "eBlit" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eBlit ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_BLIT_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eBlit ;
      return;
    }
    if( "Clear" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eClear ;
      return;
    }
    if( "eClear" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eClear ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eClear ;
      return;
    }
    if( "IndexInput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eIndexInput ;
      return;
    }
    if( "eIndexInput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eIndexInput ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eIndexInput ;
      return;
    }
    if( "VertexAttributeInput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVertexAttributeInput ;
      return;
    }
    if( "eVertexAttributeInput" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVertexAttributeInput ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVertexAttributeInput ;
      return;
    }
    if( "PreRasterizationShaders" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: ePreRasterizationShaders ;
      return;
    }
    if( "ePreRasterizationShaders" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: ePreRasterizationShaders ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: ePreRasterizationShaders ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecode" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVideoDecode ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecode" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVideoDecode ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVideoDecode ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncode" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVideoEncode ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncode" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVideoEncode ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eVideoEncode ;
      return;
    }
#endif
    if( "TransformFeedbackEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTransformFeedbackEXT ;
      return;
    }
    if( "eTransformFeedbackEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTransformFeedbackEXT ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTransformFeedbackEXT ;
      return;
    }
    if( "ConditionalRenderingEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eConditionalRenderingEXT ;
      return;
    }
    if( "eConditionalRenderingEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eConditionalRenderingEXT ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eConditionalRenderingEXT ;
      return;
    }
    if( "CommandPreprocessNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eCommandPreprocessNV ;
      return;
    }
    if( "eCommandPreprocessNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eCommandPreprocessNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eCommandPreprocessNV ;
      return;
    }
    if( "FragmentShadingRateAttachment" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eFragmentShadingRateAttachment ;
      return;
    }
    if( "eFragmentShadingRateAttachment" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eFragmentShadingRateAttachment ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eFragmentShadingRateAttachment ;
      return;
    }
    if( "AccelerationStructureBuild" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAccelerationStructureBuild ;
      return;
    }
    if( "eAccelerationStructureBuild" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAccelerationStructureBuild ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAccelerationStructureBuild ;
      return;
    }
    if( "RayTracingShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eRayTracingShader ;
      return;
    }
    if( "eRayTracingShader" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eRayTracingShader ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eRayTracingShader ;
      return;
    }
    if( "FragmentDensityProcessEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eFragmentDensityProcessEXT ;
      return;
    }
    if( "eFragmentDensityProcessEXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eFragmentDensityProcessEXT ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eFragmentDensityProcessEXT ;
      return;
    }
    if( "TaskShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTaskShaderNV ;
      return;
    }
    if( "eTaskShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTaskShaderNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eTaskShaderNV ;
      return;
    }
    if( "MeshShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eMeshShaderNV ;
      return;
    }
    if( "eMeshShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eMeshShaderNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eMeshShaderNV ;
      return;
    }
    if( "SubpassShadingHUAWEI" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eSubpassShadingHUAWEI ;
      return;
    }
    if( "eSubpassShadingHUAWEI" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eSubpassShadingHUAWEI ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eSubpassShadingHUAWEI ;
      return;
    }
    if( "AccelerationStructureBuildNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAccelerationStructureBuildNV ;
      return;
    }
    if( "eAccelerationStructureBuildNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAccelerationStructureBuildNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eAccelerationStructureBuildNV ;
      return;
    }
    if( "RayTracingShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eRayTracingShaderNV ;
      return;
    }
    if( "eRayTracingShaderNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eRayTracingShaderNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eRayTracingShaderNV ;
      return;
    }
    if( "ShadingRateImageNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eShadingRateImageNV ;
      return;
    }
    if( "eShadingRateImageNV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eShadingRateImageNV ;
      return;
    }
    if( "VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV" == j.get< std::string >() ) {
      p = PipelineStageFlagBits2KHR :: eShadingRateImageNV ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for PipelineStageFlagBits2KHR" );
  }
  if( j.is_number() ) {
    p = PipelineStageFlagBits2KHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for PipelineStageFlagBits2KHR" );
}
inline void to_json( nlohmann::json &j, const PipelineStageFlags2KHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( PipelineStageFlagBits2KHR ) * 8u; ++n ) {
    if( p & PipelineStageFlags2KHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, PipelineStageFlagBits2KHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, PipelineStageFlags2KHR &p ) {
  if( j.is_array() ) {
    p = PipelineStageFlags2KHR ( 0 );
    for( auto &e:  j ) {
      PipelineStageFlagBits2KHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for PipelineStageFlags2KHR" );
}
#endif

#ifdef VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const AccessFlagBits2KHR &p ) {
  if( AccessFlagBits2KHR :: eNone == p ) {
    j = "None";
    return;
  }
  if( AccessFlagBits2KHR :: eIndirectCommandRead == p ) {
    j = "IndirectCommandRead";
    return;
  }
  if( AccessFlagBits2KHR :: eIndexRead == p ) {
    j = "IndexRead";
    return;
  }
  if( AccessFlagBits2KHR :: eVertexAttributeRead == p ) {
    j = "VertexAttributeRead";
    return;
  }
  if( AccessFlagBits2KHR :: eUniformRead == p ) {
    j = "UniformRead";
    return;
  }
  if( AccessFlagBits2KHR :: eInputAttachmentRead == p ) {
    j = "InputAttachmentRead";
    return;
  }
  if( AccessFlagBits2KHR :: eShaderRead == p ) {
    j = "ShaderRead";
    return;
  }
  if( AccessFlagBits2KHR :: eShaderWrite == p ) {
    j = "ShaderWrite";
    return;
  }
  if( AccessFlagBits2KHR :: eColorAttachmentRead == p ) {
    j = "ColorAttachmentRead";
    return;
  }
  if( AccessFlagBits2KHR :: eColorAttachmentWrite == p ) {
    j = "ColorAttachmentWrite";
    return;
  }
  if( AccessFlagBits2KHR :: eDepthStencilAttachmentRead == p ) {
    j = "DepthStencilAttachmentRead";
    return;
  }
  if( AccessFlagBits2KHR :: eDepthStencilAttachmentWrite == p ) {
    j = "DepthStencilAttachmentWrite";
    return;
  }
  if( AccessFlagBits2KHR :: eTransferRead == p ) {
    j = "TransferRead";
    return;
  }
  if( AccessFlagBits2KHR :: eTransferWrite == p ) {
    j = "TransferWrite";
    return;
  }
  if( AccessFlagBits2KHR :: eHostRead == p ) {
    j = "HostRead";
    return;
  }
  if( AccessFlagBits2KHR :: eHostWrite == p ) {
    j = "HostWrite";
    return;
  }
  if( AccessFlagBits2KHR :: eMemoryRead == p ) {
    j = "MemoryRead";
    return;
  }
  if( AccessFlagBits2KHR :: eMemoryWrite == p ) {
    j = "MemoryWrite";
    return;
  }
  if( AccessFlagBits2KHR :: eShaderSampledRead == p ) {
    j = "ShaderSampledRead";
    return;
  }
  if( AccessFlagBits2KHR :: eShaderStorageRead == p ) {
    j = "ShaderStorageRead";
    return;
  }
  if( AccessFlagBits2KHR :: eShaderStorageWrite == p ) {
    j = "ShaderStorageWrite";
    return;
  }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( AccessFlagBits2KHR :: eVideoDecodeRead == p ) {
    j = "VideoDecodeRead";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( AccessFlagBits2KHR :: eVideoDecodeWrite == p ) {
    j = "VideoDecodeWrite";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( AccessFlagBits2KHR :: eVideoEncodeRead == p ) {
    j = "VideoEncodeRead";
    return;
  }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
  if( AccessFlagBits2KHR :: eVideoEncodeWrite == p ) {
    j = "VideoEncodeWrite";
    return;
  }
#endif
  if( AccessFlagBits2KHR :: eTransformFeedbackWriteEXT == p ) {
    j = "TransformFeedbackWriteEXT";
    return;
  }
  if( AccessFlagBits2KHR :: eTransformFeedbackCounterReadEXT == p ) {
    j = "TransformFeedbackCounterReadEXT";
    return;
  }
  if( AccessFlagBits2KHR :: eTransformFeedbackCounterWriteEXT == p ) {
    j = "TransformFeedbackCounterWriteEXT";
    return;
  }
  if( AccessFlagBits2KHR :: eConditionalRenderingReadEXT == p ) {
    j = "ConditionalRenderingReadEXT";
    return;
  }
  if( AccessFlagBits2KHR :: eCommandPreprocessReadNV == p ) {
    j = "CommandPreprocessReadNV";
    return;
  }
  if( AccessFlagBits2KHR :: eCommandPreprocessWriteNV == p ) {
    j = "CommandPreprocessWriteNV";
    return;
  }
  if( AccessFlagBits2KHR :: eFragmentShadingRateAttachmentRead == p ) {
    j = "FragmentShadingRateAttachmentRead";
    return;
  }
  if( AccessFlagBits2KHR :: eAccelerationStructureRead == p ) {
    j = "AccelerationStructureRead";
    return;
  }
  if( AccessFlagBits2KHR :: eAccelerationStructureWrite == p ) {
    j = "AccelerationStructureWrite";
    return;
  }
  if( AccessFlagBits2KHR :: eFragmentDensityMapReadEXT == p ) {
    j = "FragmentDensityMapReadEXT";
    return;
  }
  if( AccessFlagBits2KHR :: eColorAttachmentReadNoncoherentEXT == p ) {
    j = "ColorAttachmentReadNoncoherentEXT";
    return;
  }
  if( AccessFlagBits2KHR :: eAccelerationStructureReadNV == p ) {
    j = "AccelerationStructureReadNV";
    return;
  }
  if( AccessFlagBits2KHR :: eAccelerationStructureWriteNV == p ) {
    j = "AccelerationStructureWriteNV";
    return;
  }
}
inline void from_json( const nlohmann::json &j, AccessFlagBits2KHR &p ) {
  if( j.is_string() ) {
    if( "None" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eNone ;
      return;
    }
    if( "eNone" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eNone ;
      return;
    }
    if( "VK_ACCESS_2_NONE_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eNone ;
      return;
    }
    if( "IndirectCommandRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eIndirectCommandRead ;
      return;
    }
    if( "eIndirectCommandRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eIndirectCommandRead ;
      return;
    }
    if( "VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eIndirectCommandRead ;
      return;
    }
    if( "IndexRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eIndexRead ;
      return;
    }
    if( "eIndexRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eIndexRead ;
      return;
    }
    if( "VK_ACCESS_2_INDEX_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eIndexRead ;
      return;
    }
    if( "VertexAttributeRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVertexAttributeRead ;
      return;
    }
    if( "eVertexAttributeRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVertexAttributeRead ;
      return;
    }
    if( "VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVertexAttributeRead ;
      return;
    }
    if( "UniformRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eUniformRead ;
      return;
    }
    if( "eUniformRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eUniformRead ;
      return;
    }
    if( "VK_ACCESS_2_UNIFORM_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eUniformRead ;
      return;
    }
    if( "InputAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eInputAttachmentRead ;
      return;
    }
    if( "eInputAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eInputAttachmentRead ;
      return;
    }
    if( "VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eInputAttachmentRead ;
      return;
    }
    if( "ShaderRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderRead ;
      return;
    }
    if( "eShaderRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderRead ;
      return;
    }
    if( "VK_ACCESS_2_SHADER_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderRead ;
      return;
    }
    if( "ShaderWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderWrite ;
      return;
    }
    if( "eShaderWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderWrite ;
      return;
    }
    if( "VK_ACCESS_2_SHADER_WRITE_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderWrite ;
      return;
    }
    if( "ColorAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eColorAttachmentRead ;
      return;
    }
    if( "eColorAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eColorAttachmentRead ;
      return;
    }
    if( "VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eColorAttachmentRead ;
      return;
    }
    if( "ColorAttachmentWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eColorAttachmentWrite ;
      return;
    }
    if( "eColorAttachmentWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eColorAttachmentWrite ;
      return;
    }
    if( "VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eColorAttachmentWrite ;
      return;
    }
    if( "DepthStencilAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eDepthStencilAttachmentRead ;
      return;
    }
    if( "eDepthStencilAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eDepthStencilAttachmentRead ;
      return;
    }
    if( "VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eDepthStencilAttachmentRead ;
      return;
    }
    if( "DepthStencilAttachmentWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eDepthStencilAttachmentWrite ;
      return;
    }
    if( "eDepthStencilAttachmentWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eDepthStencilAttachmentWrite ;
      return;
    }
    if( "VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eDepthStencilAttachmentWrite ;
      return;
    }
    if( "TransferRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransferRead ;
      return;
    }
    if( "eTransferRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransferRead ;
      return;
    }
    if( "VK_ACCESS_2_TRANSFER_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransferRead ;
      return;
    }
    if( "TransferWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransferWrite ;
      return;
    }
    if( "eTransferWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransferWrite ;
      return;
    }
    if( "VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransferWrite ;
      return;
    }
    if( "HostRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eHostRead ;
      return;
    }
    if( "eHostRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eHostRead ;
      return;
    }
    if( "VK_ACCESS_2_HOST_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eHostRead ;
      return;
    }
    if( "HostWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eHostWrite ;
      return;
    }
    if( "eHostWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eHostWrite ;
      return;
    }
    if( "VK_ACCESS_2_HOST_WRITE_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eHostWrite ;
      return;
    }
    if( "MemoryRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eMemoryRead ;
      return;
    }
    if( "eMemoryRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eMemoryRead ;
      return;
    }
    if( "VK_ACCESS_2_MEMORY_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eMemoryRead ;
      return;
    }
    if( "MemoryWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eMemoryWrite ;
      return;
    }
    if( "eMemoryWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eMemoryWrite ;
      return;
    }
    if( "VK_ACCESS_2_MEMORY_WRITE_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eMemoryWrite ;
      return;
    }
    if( "ShaderSampledRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderSampledRead ;
      return;
    }
    if( "eShaderSampledRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderSampledRead ;
      return;
    }
    if( "VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderSampledRead ;
      return;
    }
    if( "ShaderStorageRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderStorageRead ;
      return;
    }
    if( "eShaderStorageRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderStorageRead ;
      return;
    }
    if( "VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderStorageRead ;
      return;
    }
    if( "ShaderStorageWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderStorageWrite ;
      return;
    }
    if( "eShaderStorageWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderStorageWrite ;
      return;
    }
    if( "VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eShaderStorageWrite ;
      return;
    }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVideoDecodeRead ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVideoDecodeRead ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVideoDecodeRead ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoDecodeWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVideoDecodeWrite ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoDecodeWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVideoDecodeWrite ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVideoDecodeWrite ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVideoEncodeRead ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVideoEncodeRead ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVideoEncodeRead ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VideoEncodeWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVideoEncodeWrite ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "eVideoEncodeWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVideoEncodeWrite ;
      return;
    }
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if( "VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eVideoEncodeWrite ;
      return;
    }
#endif
    if( "TransformFeedbackWriteEXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransformFeedbackWriteEXT ;
      return;
    }
    if( "eTransformFeedbackWriteEXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransformFeedbackWriteEXT ;
      return;
    }
    if( "VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransformFeedbackWriteEXT ;
      return;
    }
    if( "TransformFeedbackCounterReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransformFeedbackCounterReadEXT ;
      return;
    }
    if( "eTransformFeedbackCounterReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransformFeedbackCounterReadEXT ;
      return;
    }
    if( "VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransformFeedbackCounterReadEXT ;
      return;
    }
    if( "TransformFeedbackCounterWriteEXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransformFeedbackCounterWriteEXT ;
      return;
    }
    if( "eTransformFeedbackCounterWriteEXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransformFeedbackCounterWriteEXT ;
      return;
    }
    if( "VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eTransformFeedbackCounterWriteEXT ;
      return;
    }
    if( "ConditionalRenderingReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eConditionalRenderingReadEXT ;
      return;
    }
    if( "eConditionalRenderingReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eConditionalRenderingReadEXT ;
      return;
    }
    if( "VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eConditionalRenderingReadEXT ;
      return;
    }
    if( "CommandPreprocessReadNV" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eCommandPreprocessReadNV ;
      return;
    }
    if( "eCommandPreprocessReadNV" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eCommandPreprocessReadNV ;
      return;
    }
    if( "VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eCommandPreprocessReadNV ;
      return;
    }
    if( "CommandPreprocessWriteNV" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eCommandPreprocessWriteNV ;
      return;
    }
    if( "eCommandPreprocessWriteNV" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eCommandPreprocessWriteNV ;
      return;
    }
    if( "VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eCommandPreprocessWriteNV ;
      return;
    }
    if( "FragmentShadingRateAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eFragmentShadingRateAttachmentRead ;
      return;
    }
    if( "eFragmentShadingRateAttachmentRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eFragmentShadingRateAttachmentRead ;
      return;
    }
    if( "VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eFragmentShadingRateAttachmentRead ;
      return;
    }
    if( "AccelerationStructureRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eAccelerationStructureRead ;
      return;
    }
    if( "eAccelerationStructureRead" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eAccelerationStructureRead ;
      return;
    }
    if( "VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eAccelerationStructureRead ;
      return;
    }
    if( "AccelerationStructureWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eAccelerationStructureWrite ;
      return;
    }
    if( "eAccelerationStructureWrite" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eAccelerationStructureWrite ;
      return;
    }
    if( "VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eAccelerationStructureWrite ;
      return;
    }
    if( "FragmentDensityMapReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eFragmentDensityMapReadEXT ;
      return;
    }
    if( "eFragmentDensityMapReadEXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eFragmentDensityMapReadEXT ;
      return;
    }
    if( "VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eFragmentDensityMapReadEXT ;
      return;
    }
    if( "ColorAttachmentReadNoncoherentEXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eColorAttachmentReadNoncoherentEXT ;
      return;
    }
    if( "eColorAttachmentReadNoncoherentEXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eColorAttachmentReadNoncoherentEXT ;
      return;
    }
    if( "VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eColorAttachmentReadNoncoherentEXT ;
      return;
    }
    if( "AccelerationStructureReadNV" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eAccelerationStructureReadNV ;
      return;
    }
    if( "eAccelerationStructureReadNV" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eAccelerationStructureReadNV ;
      return;
    }
    if( "VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eAccelerationStructureReadNV ;
      return;
    }
    if( "AccelerationStructureWriteNV" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eAccelerationStructureWriteNV ;
      return;
    }
    if( "eAccelerationStructureWriteNV" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eAccelerationStructureWriteNV ;
      return;
    }
    if( "VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV" == j.get< std::string >() ) {
      p = AccessFlagBits2KHR :: eAccelerationStructureWriteNV ;
      return;
    }
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccessFlagBits2KHR" );
  }
  if( j.is_number() ) {
    p = AccessFlagBits2KHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccessFlagBits2KHR" );
}
inline void to_json( nlohmann::json &j, const AccessFlags2KHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( AccessFlagBits2KHR ) * 8u; ++n ) {
    if( p & AccessFlags2KHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, AccessFlagBits2KHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, AccessFlags2KHR &p ) {
  if( j.is_array() ) {
    p = AccessFlags2KHR ( 0 );
    for( auto &e:  j ) {
      AccessFlagBits2KHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for AccessFlags2KHR" );
}
#endif

#ifdef VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const SubmitFlagBitsKHR &p ) {
}
inline void from_json( const nlohmann::json &j, SubmitFlagBitsKHR &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for SubmitFlagBitsKHR" );
  }
  if( j.is_number() ) {
    p = SubmitFlagBitsKHR ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for SubmitFlagBitsKHR" );
}
inline void to_json( nlohmann::json &j, const SubmitFlagsKHR &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( SubmitFlagBitsKHR ) * 8u; ++n ) {
    if( p & SubmitFlagsKHR ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, SubmitFlagBitsKHR ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, SubmitFlagsKHR &p ) {
  if( j.is_array() ) {
    p = SubmitFlagsKHR ( 0 );
    for( auto &e:  j ) {
      SubmitFlagBitsKHR temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for SubmitFlagsKHR" );
}
#endif

#ifdef VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const AccelerationStructureMotionInfoFlagBitsNV &p ) {
}
inline void from_json( const nlohmann::json &j, AccelerationStructureMotionInfoFlagBitsNV &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureMotionInfoFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureMotionInfoFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureMotionInfoFlagBitsNV" );
}
inline void to_json( nlohmann::json &j, const AccelerationStructureMotionInfoFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( AccelerationStructureMotionInfoFlagBitsNV ) * 8u; ++n ) {
    if( p & AccelerationStructureMotionInfoFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, AccelerationStructureMotionInfoFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, AccelerationStructureMotionInfoFlagsNV &p ) {
  if( j.is_array() ) {
    p = AccelerationStructureMotionInfoFlagsNV ( 0 );
    for( auto &e:  j ) {
      AccelerationStructureMotionInfoFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for AccelerationStructureMotionInfoFlagsNV" );
}
#endif

#ifdef VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const AccelerationStructureMotionInstanceFlagBitsNV &p ) {
}
inline void from_json( const nlohmann::json &j, AccelerationStructureMotionInstanceFlagBitsNV &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for AccelerationStructureMotionInstanceFlagBitsNV" );
  }
  if( j.is_number() ) {
    p = AccelerationStructureMotionInstanceFlagBitsNV ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for AccelerationStructureMotionInstanceFlagBitsNV" );
}
inline void to_json( nlohmann::json &j, const AccelerationStructureMotionInstanceFlagsNV &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( AccelerationStructureMotionInstanceFlagBitsNV ) * 8u; ++n ) {
    if( p & AccelerationStructureMotionInstanceFlagsNV ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, AccelerationStructureMotionInstanceFlagBitsNV ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, AccelerationStructureMotionInstanceFlagsNV &p ) {
  if( j.is_array() ) {
    p = AccelerationStructureMotionInstanceFlagsNV ( 0 );
    for( auto &e:  j ) {
      AccelerationStructureMotionInstanceFlagBitsNV temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for AccelerationStructureMotionInstanceFlagsNV" );
}
#endif

#ifdef VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const DirectFBSurfaceCreateFlagBitsEXT &p ) {
}
inline void from_json( const nlohmann::json &j, DirectFBSurfaceCreateFlagBitsEXT &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for DirectFBSurfaceCreateFlagBitsEXT" );
  }
  if( j.is_number() ) {
    p = DirectFBSurfaceCreateFlagBitsEXT ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for DirectFBSurfaceCreateFlagBitsEXT" );
}
inline void to_json( nlohmann::json &j, const DirectFBSurfaceCreateFlagsEXT &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( DirectFBSurfaceCreateFlagBitsEXT ) * 8u; ++n ) {
    if( p & DirectFBSurfaceCreateFlagsEXT ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, DirectFBSurfaceCreateFlagBitsEXT ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, DirectFBSurfaceCreateFlagsEXT &p ) {
  if( j.is_array() ) {
    p = DirectFBSurfaceCreateFlagsEXT ( 0 );
    for( auto &e:  j ) {
      DirectFBSurfaceCreateFlagBitsEXT temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for DirectFBSurfaceCreateFlagsEXT" );
}
#endif

#ifdef VK_QNX_SCREEN_SURFACE_EXTENSION_NAME
inline void to_json( nlohmann::json &j, const ScreenSurfaceCreateFlagBitsQNX &p ) {
}
inline void from_json( const nlohmann::json &j, ScreenSurfaceCreateFlagBitsQNX &p ) {
  if( j.is_string() ) {
    throw vulkan2json::invalid_enum_value( "unknown enum name for ScreenSurfaceCreateFlagBitsQNX" );
  }
  if( j.is_number() ) {
    p = ScreenSurfaceCreateFlagBitsQNX ( j.get< std::int64_t >() );
  }
  throw vulkan2json::invalid_enum_value( "incompatible value for ScreenSurfaceCreateFlagBitsQNX" );
}
inline void to_json( nlohmann::json &j, const ScreenSurfaceCreateFlagsQNX &p ) {
  j = nlohmann::json::array();
  for( unsigned int n = 0u; n != sizeof( ScreenSurfaceCreateFlagBitsQNX ) * 8u; ++n ) {
    if( p & ScreenSurfaceCreateFlagsQNX ( 1 << n ) ) {
      nlohmann::json temp;
      to_json( temp, ScreenSurfaceCreateFlagBitsQNX ( 1 << n ) );
      j.push_back( temp );
    }
  }
}
inline void from_json( const nlohmann::json &j, ScreenSurfaceCreateFlagsQNX &p ) {
  if( j.is_array() ) {
    p = ScreenSurfaceCreateFlagsQNX ( 0 );
    for( auto &e:  j ) {
      ScreenSurfaceCreateFlagBitsQNX temp;
      from_json( e, temp );
      p |= temp;
    }
  }
  else throw vulkan2json::invalid_flag_value( "incompatible value for ScreenSurfaceCreateFlagsQNX" );
}
#endif

inline void to_json( nlohmann::json &j, const AabbPositionsKHR &p ) {
  j = nlohmann::json::object();
  j[ "minX" ] = p.minX;
  j[ "minY" ] = p.minY;
  j[ "minZ" ] = p.minZ;
  j[ "maxX" ] = p.maxX;
  j[ "maxY" ] = p.maxY;
  j[ "maxZ" ] = p.maxZ;
}
inline void to_json( nlohmann::json &j, const VkAabbPositionsKHR &p ) {
  to_json( j, AabbPositionsKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AabbPositionsKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AabbPositionsKHR" );
  p.minX = j[ "minX" ];
  p.minY = j[ "minY" ];
  p.minZ = j[ "minZ" ];
  p.maxX = j[ "maxX" ];
  p.maxY = j[ "maxY" ];
  p.maxZ = j[ "maxZ" ];
}
inline void from_json( const nlohmann::json &j, VkAabbPositionsKHR &p ) {
  AabbPositionsKHR temp;
  from_json( j, temp );
  p = VkAabbPositionsKHR ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureGeometryTrianglesDataKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "vertexFormat" ] = p.vertexFormat;
  j[ "vertexStride" ] = p.vertexStride;
  j[ "maxVertex" ] = p.maxVertex;
  j[ "indexType" ] = p.indexType;
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureGeometryTrianglesDataKHR &p ) {
  to_json( j, AccelerationStructureGeometryTrianglesDataKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureGeometryTrianglesDataKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureGeometryTrianglesDataKHR" );
  p.vertexFormat = j[ "vertexFormat" ];
  p.vertexStride = j[ "vertexStride" ];
  p.maxVertex = j[ "maxVertex" ];
  p.indexType = j[ "indexType" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureGeometryTrianglesDataKHR &p ) {
  AccelerationStructureGeometryTrianglesDataKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureGeometryTrianglesDataKHR ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureGeometryAabbsDataKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stride" ] = p.stride;
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureGeometryAabbsDataKHR &p ) {
  to_json( j, AccelerationStructureGeometryAabbsDataKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureGeometryAabbsDataKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureGeometryAabbsDataKHR" );
  p.stride = j[ "stride" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureGeometryAabbsDataKHR &p ) {
  AccelerationStructureGeometryAabbsDataKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureGeometryAabbsDataKHR ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureGeometryInstancesDataKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "arrayOfPointers" ] = bool( p.arrayOfPointers );
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureGeometryInstancesDataKHR &p ) {
  to_json( j, AccelerationStructureGeometryInstancesDataKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureGeometryInstancesDataKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureGeometryInstancesDataKHR" );
  p.arrayOfPointers = j[ "arrayOfPointers" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureGeometryInstancesDataKHR &p ) {
  AccelerationStructureGeometryInstancesDataKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureGeometryInstancesDataKHR ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureGeometryKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "geometryType" ] = p.geometryType;
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureGeometryKHR &p ) {
  to_json( j, AccelerationStructureGeometryKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureGeometryKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureGeometryKHR" );
  p.geometryType = j[ "geometryType" ];
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureGeometryKHR &p ) {
  AccelerationStructureGeometryKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureGeometryKHR ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureBuildGeometryInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "type" ] = p.type;
  j[ "flags" ] = p.flags;
  j[ "mode" ] = p.mode;
  j[ "geometryCount" ] = p.geometryCount;
  j[ "pGeometries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pGeometries ) );
  j[ "ppGeometries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.ppGeometries ) );
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureBuildGeometryInfoKHR &p ) {
  to_json( j, AccelerationStructureBuildGeometryInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureBuildGeometryInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureBuildGeometryInfoKHR" );
  p.type = j[ "type" ];
  p.flags = j[ "flags" ];
  p.mode = j[ "mode" ];
  p.geometryCount = j[ "geometryCount" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureBuildGeometryInfoKHR &p ) {
  AccelerationStructureBuildGeometryInfoKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureBuildGeometryInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureBuildRangeInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "primitiveCount" ] = p.primitiveCount;
  j[ "primitiveOffset" ] = p.primitiveOffset;
  j[ "firstVertex" ] = p.firstVertex;
  j[ "transformOffset" ] = p.transformOffset;
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureBuildRangeInfoKHR &p ) {
  to_json( j, AccelerationStructureBuildRangeInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureBuildRangeInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureBuildRangeInfoKHR" );
  p.primitiveCount = j[ "primitiveCount" ];
  p.primitiveOffset = j[ "primitiveOffset" ];
  p.firstVertex = j[ "firstVertex" ];
  p.transformOffset = j[ "transformOffset" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureBuildRangeInfoKHR &p ) {
  AccelerationStructureBuildRangeInfoKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureBuildRangeInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureBuildSizesInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "accelerationStructureSize" ] = p.accelerationStructureSize;
  j[ "updateScratchSize" ] = p.updateScratchSize;
  j[ "buildScratchSize" ] = p.buildScratchSize;
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureBuildSizesInfoKHR &p ) {
  to_json( j, AccelerationStructureBuildSizesInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureBuildSizesInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureBuildSizesInfoKHR" );
  p.accelerationStructureSize = j[ "accelerationStructureSize" ];
  p.updateScratchSize = j[ "updateScratchSize" ];
  p.buildScratchSize = j[ "buildScratchSize" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureBuildSizesInfoKHR &p ) {
  AccelerationStructureBuildSizesInfoKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureBuildSizesInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "createFlags" ] = p.createFlags;
  j[ "offset" ] = p.offset;
  j[ "size" ] = p.size;
  j[ "type" ] = p.type;
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureCreateInfoKHR &p ) {
  to_json( j, AccelerationStructureCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureCreateInfoKHR" );
  p.createFlags = j[ "createFlags" ];
  p.offset = j[ "offset" ];
  p.size = j[ "size" ];
  p.type = j[ "type" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureCreateInfoKHR &p ) {
  AccelerationStructureCreateInfoKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureCreateInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const GeometryTrianglesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "vertexOffset" ] = p.vertexOffset;
  j[ "vertexCount" ] = p.vertexCount;
  j[ "vertexStride" ] = p.vertexStride;
  j[ "vertexFormat" ] = p.vertexFormat;
  j[ "indexOffset" ] = p.indexOffset;
  j[ "indexCount" ] = p.indexCount;
  j[ "indexType" ] = p.indexType;
  j[ "transformOffset" ] = p.transformOffset;
}
inline void to_json( nlohmann::json &j, const VkGeometryTrianglesNV &p ) {
  to_json( j, GeometryTrianglesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, GeometryTrianglesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GeometryTrianglesNV" );
  p.vertexOffset = j[ "vertexOffset" ];
  p.vertexCount = j[ "vertexCount" ];
  p.vertexStride = j[ "vertexStride" ];
  p.vertexFormat = j[ "vertexFormat" ];
  p.indexOffset = j[ "indexOffset" ];
  p.indexCount = j[ "indexCount" ];
  p.indexType = j[ "indexType" ];
  p.transformOffset = j[ "transformOffset" ];
}
inline void from_json( const nlohmann::json &j, VkGeometryTrianglesNV &p ) {
  GeometryTrianglesNV temp;
  from_json( j, temp );
  p = VkGeometryTrianglesNV ( temp );
}

inline void to_json( nlohmann::json &j, const GeometryAABBNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "numAABBs" ] = p.numAABBs;
  j[ "stride" ] = p.stride;
  j[ "offset" ] = p.offset;
}
inline void to_json( nlohmann::json &j, const VkGeometryAABBNV &p ) {
  to_json( j, GeometryAABBNV ( p ) );
}
inline void from_json( const nlohmann::json &j, GeometryAABBNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GeometryAABBNV" );
  p.numAABBs = j[ "numAABBs" ];
  p.stride = j[ "stride" ];
  p.offset = j[ "offset" ];
}
inline void from_json( const nlohmann::json &j, VkGeometryAABBNV &p ) {
  GeometryAABBNV temp;
  from_json( j, temp );
  p = VkGeometryAABBNV ( temp );
}

inline void to_json( nlohmann::json &j, const GeometryDataNV &p ) {
  j = nlohmann::json::object();
  j[ "triangles" ] = p.triangles;
  j[ "aabbs" ] = p.aabbs;
}
inline void to_json( nlohmann::json &j, const VkGeometryDataNV &p ) {
  to_json( j, GeometryDataNV ( p ) );
}
inline void from_json( const nlohmann::json &j, GeometryDataNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GeometryDataNV" );
  p.triangles = j[ "triangles" ];
  p.aabbs = j[ "aabbs" ];
}
inline void from_json( const nlohmann::json &j, VkGeometryDataNV &p ) {
  GeometryDataNV temp;
  from_json( j, temp );
  p = VkGeometryDataNV ( temp );
}

inline void to_json( nlohmann::json &j, const GeometryNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "geometryType" ] = p.geometryType;
  j[ "geometry" ] = p.geometry;
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkGeometryNV &p ) {
  to_json( j, GeometryNV ( p ) );
}
inline void from_json( const nlohmann::json &j, GeometryNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GeometryNV" );
  p.geometryType = j[ "geometryType" ];
  p.geometry = j[ "geometry" ];
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkGeometryNV &p ) {
  GeometryNV temp;
  from_json( j, temp );
  p = VkGeometryNV ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "type" ] = p.type;
  j[ "flags" ] = p.flags;
  j[ "instanceCount" ] = p.instanceCount;
  j[ "geometryCount" ] = p.geometryCount;
  j[ "pGeometries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pGeometries ) );
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureInfoNV &p ) {
  to_json( j, AccelerationStructureInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureInfoNV" );
  p.type = j[ "type" ];
  p.flags = j[ "flags" ];
  p.instanceCount = j[ "instanceCount" ];
  p.geometryCount = j[ "geometryCount" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureInfoNV &p ) {
  AccelerationStructureInfoNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "compactedSize" ] = p.compactedSize;
  j[ "info" ] = p.info;
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureCreateInfoNV &p ) {
  to_json( j, AccelerationStructureCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureCreateInfoNV" );
  p.compactedSize = j[ "compactedSize" ];
  p.info = j[ "info" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureCreateInfoNV &p ) {
  AccelerationStructureCreateInfoNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureDeviceAddressInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureDeviceAddressInfoKHR &p ) {
  to_json( j, AccelerationStructureDeviceAddressInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureDeviceAddressInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureDeviceAddressInfoKHR" );
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureDeviceAddressInfoKHR &p ) {
  AccelerationStructureDeviceAddressInfoKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureDeviceAddressInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureGeometryMotionTrianglesDataNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureGeometryMotionTrianglesDataNV &p ) {
  to_json( j, AccelerationStructureGeometryMotionTrianglesDataNV ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureGeometryMotionTrianglesDataNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureGeometryMotionTrianglesDataNV" );
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureGeometryMotionTrianglesDataNV &p ) {
  AccelerationStructureGeometryMotionTrianglesDataNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureGeometryMotionTrianglesDataNV ( temp );
}

inline void to_json( nlohmann::json &j, const TransformMatrixKHR &p ) {
  j = nlohmann::json::object();
  j[ "matrix" ] = nlohmann::json::array();
  for( auto &e: p.matrix ) {
    auto temp = nlohmann::json::array();
    std::copy( e.begin(), e.end(), std::back_inserter( temp ) );
    j[ "matrix" ].push_back( std::move( temp ) );
  }
}
inline void to_json( nlohmann::json &j, const VkTransformMatrixKHR &p ) {
  to_json( j, TransformMatrixKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, TransformMatrixKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for TransformMatrixKHR" );
  if( !j[ "matrix" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for TransformMatrixKHR.matrix" );
  if( !j[ "matrix" ].size() > p.matrix.size() ) throw vulkan2json::invalid_array_value( "too many values in array for TransformMatrixKHR.matrix" );
  for( std::size_t i = 0u; i != j[ "matrix" ].size(); ++i ) {
    if( !j[ "matrix" ][ i ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for TransformMatrixKHR.matrix" );
    if( !j[ "matrix" ][ i ].size() > p.matrix[ i ].size() ) throw vulkan2json::invalid_array_value( "too many values in array for TransformMatrixKHR.matrix" );
    std::fill( p.matrix[ i ].begin(), p.matrix[ i ].end(), 0 );
    std::copy( j[ "matrix" ][ i ].begin(), j[ "matrix" ][ i ].end(), p.matrix[ i ].begin() );
  }
  for( std::size_t i = j[ "matrix" ].size(); i != p.matrix.size(); ++i ) {
    std::fill( p.matrix[ i ].begin(), p.matrix[ i ].end(), 0 );
  }
}
inline void from_json( const nlohmann::json &j, VkTransformMatrixKHR &p ) {
  TransformMatrixKHR temp;
  from_json( j, temp );
  p = VkTransformMatrixKHR ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureInstanceKHR &p ) {
  j = nlohmann::json::object();
  j[ "transform" ] = p.transform;
  j[ "instanceCustomIndex" ] = p.instanceCustomIndex;
  j[ "mask" ] = p.mask;
  j[ "instanceShaderBindingTableRecordOffset" ] = p.instanceShaderBindingTableRecordOffset;
  j[ "accelerationStructureReference" ] = p.accelerationStructureReference;
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureInstanceKHR &p ) {
  to_json( j, AccelerationStructureInstanceKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureInstanceKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureInstanceKHR" );
  p.transform = j[ "transform" ];
  p.instanceCustomIndex = j[ "instanceCustomIndex" ];
  p.mask = j[ "mask" ];
  p.instanceShaderBindingTableRecordOffset = j[ "instanceShaderBindingTableRecordOffset" ];
  p.accelerationStructureReference = j[ "accelerationStructureReference" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureInstanceKHR &p ) {
  AccelerationStructureInstanceKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureInstanceKHR ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureMatrixMotionInstanceNV &p ) {
  j = nlohmann::json::object();
  j[ "transformT0" ] = p.transformT0;
  j[ "transformT1" ] = p.transformT1;
  j[ "instanceCustomIndex" ] = p.instanceCustomIndex;
  j[ "mask" ] = p.mask;
  j[ "instanceShaderBindingTableRecordOffset" ] = p.instanceShaderBindingTableRecordOffset;
  j[ "accelerationStructureReference" ] = p.accelerationStructureReference;
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureMatrixMotionInstanceNV &p ) {
  to_json( j, AccelerationStructureMatrixMotionInstanceNV ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureMatrixMotionInstanceNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureMatrixMotionInstanceNV" );
  p.transformT0 = j[ "transformT0" ];
  p.transformT1 = j[ "transformT1" ];
  p.instanceCustomIndex = j[ "instanceCustomIndex" ];
  p.mask = j[ "mask" ];
  p.instanceShaderBindingTableRecordOffset = j[ "instanceShaderBindingTableRecordOffset" ];
  p.accelerationStructureReference = j[ "accelerationStructureReference" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureMatrixMotionInstanceNV &p ) {
  AccelerationStructureMatrixMotionInstanceNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureMatrixMotionInstanceNV ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureMemoryRequirementsInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "type" ] = p.type;
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureMemoryRequirementsInfoNV &p ) {
  to_json( j, AccelerationStructureMemoryRequirementsInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureMemoryRequirementsInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureMemoryRequirementsInfoNV" );
  p.type = j[ "type" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureMemoryRequirementsInfoNV &p ) {
  AccelerationStructureMemoryRequirementsInfoNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureMemoryRequirementsInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureMotionInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxInstances" ] = p.maxInstances;
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureMotionInfoNV &p ) {
  to_json( j, AccelerationStructureMotionInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureMotionInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureMotionInfoNV" );
  p.maxInstances = j[ "maxInstances" ];
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureMotionInfoNV &p ) {
  AccelerationStructureMotionInfoNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureMotionInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const SRTDataNV &p ) {
  j = nlohmann::json::object();
  j[ "sx" ] = p.sx;
  j[ "a" ] = p.a;
  j[ "b" ] = p.b;
  j[ "pvx" ] = p.pvx;
  j[ "sy" ] = p.sy;
  j[ "c" ] = p.c;
  j[ "pvy" ] = p.pvy;
  j[ "sz" ] = p.sz;
  j[ "pvz" ] = p.pvz;
  j[ "qx" ] = p.qx;
  j[ "qy" ] = p.qy;
  j[ "qz" ] = p.qz;
  j[ "qw" ] = p.qw;
  j[ "tx" ] = p.tx;
  j[ "ty" ] = p.ty;
  j[ "tz" ] = p.tz;
}
inline void to_json( nlohmann::json &j, const VkSRTDataNV &p ) {
  to_json( j, SRTDataNV ( p ) );
}
inline void from_json( const nlohmann::json &j, SRTDataNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SRTDataNV" );
  p.sx = j[ "sx" ];
  p.a = j[ "a" ];
  p.b = j[ "b" ];
  p.pvx = j[ "pvx" ];
  p.sy = j[ "sy" ];
  p.c = j[ "c" ];
  p.pvy = j[ "pvy" ];
  p.sz = j[ "sz" ];
  p.pvz = j[ "pvz" ];
  p.qx = j[ "qx" ];
  p.qy = j[ "qy" ];
  p.qz = j[ "qz" ];
  p.qw = j[ "qw" ];
  p.tx = j[ "tx" ];
  p.ty = j[ "ty" ];
  p.tz = j[ "tz" ];
}
inline void from_json( const nlohmann::json &j, VkSRTDataNV &p ) {
  SRTDataNV temp;
  from_json( j, temp );
  p = VkSRTDataNV ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureSRTMotionInstanceNV &p ) {
  j = nlohmann::json::object();
  j[ "transformT0" ] = p.transformT0;
  j[ "transformT1" ] = p.transformT1;
  j[ "instanceCustomIndex" ] = p.instanceCustomIndex;
  j[ "mask" ] = p.mask;
  j[ "instanceShaderBindingTableRecordOffset" ] = p.instanceShaderBindingTableRecordOffset;
  j[ "accelerationStructureReference" ] = p.accelerationStructureReference;
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureSRTMotionInstanceNV &p ) {
  to_json( j, AccelerationStructureSRTMotionInstanceNV ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureSRTMotionInstanceNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureSRTMotionInstanceNV" );
  p.transformT0 = j[ "transformT0" ];
  p.transformT1 = j[ "transformT1" ];
  p.instanceCustomIndex = j[ "instanceCustomIndex" ];
  p.mask = j[ "mask" ];
  p.instanceShaderBindingTableRecordOffset = j[ "instanceShaderBindingTableRecordOffset" ];
  p.accelerationStructureReference = j[ "accelerationStructureReference" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureSRTMotionInstanceNV &p ) {
  AccelerationStructureSRTMotionInstanceNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureSRTMotionInstanceNV ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureMotionInstanceNV &p ) {
  j = nlohmann::json::object();
  j[ "type" ] = p.type;
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureMotionInstanceNV &p ) {
  to_json( j, AccelerationStructureMotionInstanceNV ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureMotionInstanceNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureMotionInstanceNV" );
  p.type = j[ "type" ];
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureMotionInstanceNV &p ) {
  AccelerationStructureMotionInstanceNV temp;
  from_json( j, temp );
  p = VkAccelerationStructureMotionInstanceNV ( temp );
}

inline void to_json( nlohmann::json &j, const AccelerationStructureVersionInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pVersionData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pVersionData ) );
}
inline void to_json( nlohmann::json &j, const VkAccelerationStructureVersionInfoKHR &p ) {
  to_json( j, AccelerationStructureVersionInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AccelerationStructureVersionInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AccelerationStructureVersionInfoKHR" );
}
inline void from_json( const nlohmann::json &j, VkAccelerationStructureVersionInfoKHR &p ) {
  AccelerationStructureVersionInfoKHR temp;
  from_json( j, temp );
  p = VkAccelerationStructureVersionInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const AcquireNextImageInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "timeout" ] = p.timeout;
  j[ "deviceMask" ] = p.deviceMask;
}
inline void to_json( nlohmann::json &j, const VkAcquireNextImageInfoKHR &p ) {
  to_json( j, AcquireNextImageInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AcquireNextImageInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AcquireNextImageInfoKHR" );
  p.timeout = j[ "timeout" ];
  p.deviceMask = j[ "deviceMask" ];
}
inline void from_json( const nlohmann::json &j, VkAcquireNextImageInfoKHR &p ) {
  AcquireNextImageInfoKHR temp;
  from_json( j, temp );
  p = VkAcquireNextImageInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const AcquireProfilingLockInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "timeout" ] = p.timeout;
}
inline void to_json( nlohmann::json &j, const VkAcquireProfilingLockInfoKHR &p ) {
  to_json( j, AcquireProfilingLockInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AcquireProfilingLockInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AcquireProfilingLockInfoKHR" );
  p.flags = j[ "flags" ];
  p.timeout = j[ "timeout" ];
}
inline void from_json( const nlohmann::json &j, VkAcquireProfilingLockInfoKHR &p ) {
  AcquireProfilingLockInfoKHR temp;
  from_json( j, temp );
  p = VkAcquireProfilingLockInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const AllocationCallbacks &p ) {
  j = nlohmann::json::object();
  j[ "pUserData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pUserData ) );
  j[ "pfnAllocation" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnAllocation ) );
  j[ "pfnReallocation" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnReallocation ) );
  j[ "pfnFree" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnFree ) );
  j[ "pfnInternalAllocation" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnInternalAllocation ) );
  j[ "pfnInternalFree" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnInternalFree ) );
}
inline void to_json( nlohmann::json &j, const VkAllocationCallbacks &p ) {
  to_json( j, AllocationCallbacks ( p ) );
}
inline void from_json( const nlohmann::json &j, AllocationCallbacks &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AllocationCallbacks" );
}
inline void from_json( const nlohmann::json &j, VkAllocationCallbacks &p ) {
  AllocationCallbacks temp;
  from_json( j, temp );
  p = VkAllocationCallbacks ( temp );
}

inline void to_json( nlohmann::json &j, const ComponentMapping &p ) {
  j = nlohmann::json::object();
  j[ "r" ] = p.r;
  j[ "g" ] = p.g;
  j[ "b" ] = p.b;
  j[ "a" ] = p.a;
}
inline void to_json( nlohmann::json &j, const VkComponentMapping &p ) {
  to_json( j, ComponentMapping ( p ) );
}
inline void from_json( const nlohmann::json &j, ComponentMapping &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ComponentMapping" );
  p.r = j[ "r" ];
  p.g = j[ "g" ];
  p.b = j[ "b" ];
  p.a = j[ "a" ];
}
inline void from_json( const nlohmann::json &j, VkComponentMapping &p ) {
  ComponentMapping temp;
  from_json( j, temp );
  p = VkComponentMapping ( temp );
}

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
inline void to_json( nlohmann::json &j, const AndroidHardwareBufferFormatPropertiesANDROID &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "format" ] = p.format;
  j[ "externalFormat" ] = p.externalFormat;
  j[ "formatFeatures" ] = p.formatFeatures;
  j[ "samplerYcbcrConversionComponents" ] = p.samplerYcbcrConversionComponents;
  j[ "suggestedYcbcrModel" ] = p.suggestedYcbcrModel;
  j[ "suggestedYcbcrRange" ] = p.suggestedYcbcrRange;
  j[ "suggestedXChromaOffset" ] = p.suggestedXChromaOffset;
  j[ "suggestedYChromaOffset" ] = p.suggestedYChromaOffset;
}
inline void to_json( nlohmann::json &j, const VkAndroidHardwareBufferFormatPropertiesANDROID &p ) {
  to_json( j, AndroidHardwareBufferFormatPropertiesANDROID ( p ) );
}
inline void from_json( const nlohmann::json &j, AndroidHardwareBufferFormatPropertiesANDROID &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AndroidHardwareBufferFormatPropertiesANDROID" );
  p.format = j[ "format" ];
  p.externalFormat = j[ "externalFormat" ];
  p.formatFeatures = j[ "formatFeatures" ];
  p.samplerYcbcrConversionComponents = j[ "samplerYcbcrConversionComponents" ];
  p.suggestedYcbcrModel = j[ "suggestedYcbcrModel" ];
  p.suggestedYcbcrRange = j[ "suggestedYcbcrRange" ];
  p.suggestedXChromaOffset = j[ "suggestedXChromaOffset" ];
  p.suggestedYChromaOffset = j[ "suggestedYChromaOffset" ];
}
inline void from_json( const nlohmann::json &j, VkAndroidHardwareBufferFormatPropertiesANDROID &p ) {
  AndroidHardwareBufferFormatPropertiesANDROID temp;
  from_json( j, temp );
  p = VkAndroidHardwareBufferFormatPropertiesANDROID ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
inline void to_json( nlohmann::json &j, const AndroidHardwareBufferPropertiesANDROID &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "allocationSize" ] = p.allocationSize;
  j[ "memoryTypeBits" ] = p.memoryTypeBits;
}
inline void to_json( nlohmann::json &j, const VkAndroidHardwareBufferPropertiesANDROID &p ) {
  to_json( j, AndroidHardwareBufferPropertiesANDROID ( p ) );
}
inline void from_json( const nlohmann::json &j, AndroidHardwareBufferPropertiesANDROID &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AndroidHardwareBufferPropertiesANDROID" );
  p.allocationSize = j[ "allocationSize" ];
  p.memoryTypeBits = j[ "memoryTypeBits" ];
}
inline void from_json( const nlohmann::json &j, VkAndroidHardwareBufferPropertiesANDROID &p ) {
  AndroidHardwareBufferPropertiesANDROID temp;
  from_json( j, temp );
  p = VkAndroidHardwareBufferPropertiesANDROID ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
inline void to_json( nlohmann::json &j, const AndroidHardwareBufferUsageANDROID &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "androidHardwareBufferUsage" ] = p.androidHardwareBufferUsage;
}
inline void to_json( nlohmann::json &j, const VkAndroidHardwareBufferUsageANDROID &p ) {
  to_json( j, AndroidHardwareBufferUsageANDROID ( p ) );
}
inline void from_json( const nlohmann::json &j, AndroidHardwareBufferUsageANDROID &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AndroidHardwareBufferUsageANDROID" );
  p.androidHardwareBufferUsage = j[ "androidHardwareBufferUsage" ];
}
inline void from_json( const nlohmann::json &j, VkAndroidHardwareBufferUsageANDROID &p ) {
  AndroidHardwareBufferUsageANDROID temp;
  from_json( j, temp );
  p = VkAndroidHardwareBufferUsageANDROID ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
inline void to_json( nlohmann::json &j, const AndroidSurfaceCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "window" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.window ) );
}
inline void to_json( nlohmann::json &j, const VkAndroidSurfaceCreateInfoKHR &p ) {
  to_json( j, AndroidSurfaceCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, AndroidSurfaceCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AndroidSurfaceCreateInfoKHR" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkAndroidSurfaceCreateInfoKHR &p ) {
  AndroidSurfaceCreateInfoKHR temp;
  from_json( j, temp );
  p = VkAndroidSurfaceCreateInfoKHR ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const ApplicationInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  if( p.pApplicationName ) j[ "pApplicationName" ] = std::string( p.pApplicationName );
  j[ "applicationVersion" ] = p.applicationVersion;
  if( p.pEngineName ) j[ "pEngineName" ] = std::string( p.pEngineName );
  j[ "engineVersion" ] = p.engineVersion;
  j[ "apiVersion" ] = p.apiVersion;
}
inline void to_json( nlohmann::json &j, const VkApplicationInfo &p ) {
  to_json( j, ApplicationInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ApplicationInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ApplicationInfo" );
  p.applicationVersion = j[ "applicationVersion" ];
  p.engineVersion = j[ "engineVersion" ];
  p.apiVersion = j[ "apiVersion" ];
}
inline void from_json( const nlohmann::json &j, VkApplicationInfo &p ) {
  ApplicationInfo temp;
  from_json( j, temp );
  p = VkApplicationInfo ( temp );
}

inline void to_json( nlohmann::json &j, const AttachmentDescription &p ) {
  j = nlohmann::json::object();
  j[ "flags" ] = p.flags;
  j[ "format" ] = p.format;
  j[ "samples" ] = p.samples;
  j[ "loadOp" ] = p.loadOp;
  j[ "storeOp" ] = p.storeOp;
  j[ "stencilLoadOp" ] = p.stencilLoadOp;
  j[ "stencilStoreOp" ] = p.stencilStoreOp;
  j[ "initialLayout" ] = p.initialLayout;
  j[ "finalLayout" ] = p.finalLayout;
}
inline void to_json( nlohmann::json &j, const VkAttachmentDescription &p ) {
  to_json( j, AttachmentDescription ( p ) );
}
inline void from_json( const nlohmann::json &j, AttachmentDescription &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AttachmentDescription" );
  p.flags = j[ "flags" ];
  p.format = j[ "format" ];
  p.samples = j[ "samples" ];
  p.loadOp = j[ "loadOp" ];
  p.storeOp = j[ "storeOp" ];
  p.stencilLoadOp = j[ "stencilLoadOp" ];
  p.stencilStoreOp = j[ "stencilStoreOp" ];
  p.initialLayout = j[ "initialLayout" ];
  p.finalLayout = j[ "finalLayout" ];
}
inline void from_json( const nlohmann::json &j, VkAttachmentDescription &p ) {
  AttachmentDescription temp;
  from_json( j, temp );
  p = VkAttachmentDescription ( temp );
}

inline void to_json( nlohmann::json &j, const AttachmentDescription2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "format" ] = p.format;
  j[ "samples" ] = p.samples;
  j[ "loadOp" ] = p.loadOp;
  j[ "storeOp" ] = p.storeOp;
  j[ "stencilLoadOp" ] = p.stencilLoadOp;
  j[ "stencilStoreOp" ] = p.stencilStoreOp;
  j[ "initialLayout" ] = p.initialLayout;
  j[ "finalLayout" ] = p.finalLayout;
}
inline void to_json( nlohmann::json &j, const VkAttachmentDescription2 &p ) {
  to_json( j, AttachmentDescription2 ( p ) );
}
inline void from_json( const nlohmann::json &j, AttachmentDescription2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AttachmentDescription2" );
  p.flags = j[ "flags" ];
  p.format = j[ "format" ];
  p.samples = j[ "samples" ];
  p.loadOp = j[ "loadOp" ];
  p.storeOp = j[ "storeOp" ];
  p.stencilLoadOp = j[ "stencilLoadOp" ];
  p.stencilStoreOp = j[ "stencilStoreOp" ];
  p.initialLayout = j[ "initialLayout" ];
  p.finalLayout = j[ "finalLayout" ];
}
inline void from_json( const nlohmann::json &j, VkAttachmentDescription2 &p ) {
  AttachmentDescription2 temp;
  from_json( j, temp );
  p = VkAttachmentDescription2 ( temp );
}

inline void to_json( nlohmann::json &j, const AttachmentDescriptionStencilLayout &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stencilInitialLayout" ] = p.stencilInitialLayout;
  j[ "stencilFinalLayout" ] = p.stencilFinalLayout;
}
inline void to_json( nlohmann::json &j, const VkAttachmentDescriptionStencilLayout &p ) {
  to_json( j, AttachmentDescriptionStencilLayout ( p ) );
}
inline void from_json( const nlohmann::json &j, AttachmentDescriptionStencilLayout &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AttachmentDescriptionStencilLayout" );
  p.stencilInitialLayout = j[ "stencilInitialLayout" ];
  p.stencilFinalLayout = j[ "stencilFinalLayout" ];
}
inline void from_json( const nlohmann::json &j, VkAttachmentDescriptionStencilLayout &p ) {
  AttachmentDescriptionStencilLayout temp;
  from_json( j, temp );
  p = VkAttachmentDescriptionStencilLayout ( temp );
}

inline void to_json( nlohmann::json &j, const AttachmentReference &p ) {
  j = nlohmann::json::object();
  j[ "attachment" ] = p.attachment;
  j[ "layout" ] = p.layout;
}
inline void to_json( nlohmann::json &j, const VkAttachmentReference &p ) {
  to_json( j, AttachmentReference ( p ) );
}
inline void from_json( const nlohmann::json &j, AttachmentReference &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AttachmentReference" );
  p.attachment = j[ "attachment" ];
  p.layout = j[ "layout" ];
}
inline void from_json( const nlohmann::json &j, VkAttachmentReference &p ) {
  AttachmentReference temp;
  from_json( j, temp );
  p = VkAttachmentReference ( temp );
}

inline void to_json( nlohmann::json &j, const AttachmentReference2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "attachment" ] = p.attachment;
  j[ "layout" ] = p.layout;
  j[ "aspectMask" ] = p.aspectMask;
}
inline void to_json( nlohmann::json &j, const VkAttachmentReference2 &p ) {
  to_json( j, AttachmentReference2 ( p ) );
}
inline void from_json( const nlohmann::json &j, AttachmentReference2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AttachmentReference2" );
  p.attachment = j[ "attachment" ];
  p.layout = j[ "layout" ];
  p.aspectMask = j[ "aspectMask" ];
}
inline void from_json( const nlohmann::json &j, VkAttachmentReference2 &p ) {
  AttachmentReference2 temp;
  from_json( j, temp );
  p = VkAttachmentReference2 ( temp );
}

inline void to_json( nlohmann::json &j, const AttachmentReferenceStencilLayout &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stencilLayout" ] = p.stencilLayout;
}
inline void to_json( nlohmann::json &j, const VkAttachmentReferenceStencilLayout &p ) {
  to_json( j, AttachmentReferenceStencilLayout ( p ) );
}
inline void from_json( const nlohmann::json &j, AttachmentReferenceStencilLayout &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AttachmentReferenceStencilLayout" );
  p.stencilLayout = j[ "stencilLayout" ];
}
inline void from_json( const nlohmann::json &j, VkAttachmentReferenceStencilLayout &p ) {
  AttachmentReferenceStencilLayout temp;
  from_json( j, temp );
  p = VkAttachmentReferenceStencilLayout ( temp );
}

inline void to_json( nlohmann::json &j, const Extent2D &p ) {
  j = nlohmann::json::object();
  j[ "width" ] = p.width;
  j[ "height" ] = p.height;
}
inline void to_json( nlohmann::json &j, const VkExtent2D &p ) {
  to_json( j, Extent2D ( p ) );
}
inline void from_json( const nlohmann::json &j, Extent2D &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Extent2D" );
  p.width = j[ "width" ];
  p.height = j[ "height" ];
}
inline void from_json( const nlohmann::json &j, VkExtent2D &p ) {
  Extent2D temp;
  from_json( j, temp );
  p = VkExtent2D ( temp );
}

inline void to_json( nlohmann::json &j, const SampleLocationEXT &p ) {
  j = nlohmann::json::object();
  j[ "x" ] = p.x;
  j[ "y" ] = p.y;
}
inline void to_json( nlohmann::json &j, const VkSampleLocationEXT &p ) {
  to_json( j, SampleLocationEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, SampleLocationEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SampleLocationEXT" );
  p.x = j[ "x" ];
  p.y = j[ "y" ];
}
inline void from_json( const nlohmann::json &j, VkSampleLocationEXT &p ) {
  SampleLocationEXT temp;
  from_json( j, temp );
  p = VkSampleLocationEXT ( temp );
}

inline void to_json( nlohmann::json &j, const SampleLocationsInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "sampleLocationsPerPixel" ] = p.sampleLocationsPerPixel;
  j[ "sampleLocationGridSize" ] = p.sampleLocationGridSize;
  j[ "sampleLocationsCount" ] = p.sampleLocationsCount;
  j[ "pSampleLocations" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSampleLocations ) );
}
inline void to_json( nlohmann::json &j, const VkSampleLocationsInfoEXT &p ) {
  to_json( j, SampleLocationsInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, SampleLocationsInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SampleLocationsInfoEXT" );
  p.sampleLocationsPerPixel = j[ "sampleLocationsPerPixel" ];
  p.sampleLocationGridSize = j[ "sampleLocationGridSize" ];
  p.sampleLocationsCount = j[ "sampleLocationsCount" ];
}
inline void from_json( const nlohmann::json &j, VkSampleLocationsInfoEXT &p ) {
  SampleLocationsInfoEXT temp;
  from_json( j, temp );
  p = VkSampleLocationsInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const AttachmentSampleLocationsEXT &p ) {
  j = nlohmann::json::object();
  j[ "attachmentIndex" ] = p.attachmentIndex;
  j[ "sampleLocationsInfo" ] = p.sampleLocationsInfo;
}
inline void to_json( nlohmann::json &j, const VkAttachmentSampleLocationsEXT &p ) {
  to_json( j, AttachmentSampleLocationsEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, AttachmentSampleLocationsEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for AttachmentSampleLocationsEXT" );
  p.attachmentIndex = j[ "attachmentIndex" ];
  p.sampleLocationsInfo = j[ "sampleLocationsInfo" ];
}
inline void from_json( const nlohmann::json &j, VkAttachmentSampleLocationsEXT &p ) {
  AttachmentSampleLocationsEXT temp;
  from_json( j, temp );
  p = VkAttachmentSampleLocationsEXT ( temp );
}

inline void to_json( nlohmann::json &j, const BaseInStructure &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkBaseInStructure &p ) {
  to_json( j, BaseInStructure ( p ) );
}
inline void from_json( const nlohmann::json &j, BaseInStructure &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BaseInStructure" );
}
inline void from_json( const nlohmann::json &j, VkBaseInStructure &p ) {
  BaseInStructure temp;
  from_json( j, temp );
  p = VkBaseInStructure ( temp );
}

inline void to_json( nlohmann::json &j, const BaseOutStructure &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkBaseOutStructure &p ) {
  to_json( j, BaseOutStructure ( p ) );
}
inline void from_json( const nlohmann::json &j, BaseOutStructure &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BaseOutStructure" );
}
inline void from_json( const nlohmann::json &j, VkBaseOutStructure &p ) {
  BaseOutStructure temp;
  from_json( j, temp );
  p = VkBaseOutStructure ( temp );
}

inline void to_json( nlohmann::json &j, const BindAccelerationStructureMemoryInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryOffset" ] = p.memoryOffset;
  j[ "deviceIndexCount" ] = p.deviceIndexCount;
  j[ "pDeviceIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDeviceIndices ) );
}
inline void to_json( nlohmann::json &j, const VkBindAccelerationStructureMemoryInfoNV &p ) {
  to_json( j, BindAccelerationStructureMemoryInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, BindAccelerationStructureMemoryInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindAccelerationStructureMemoryInfoNV" );
  p.memoryOffset = j[ "memoryOffset" ];
  p.deviceIndexCount = j[ "deviceIndexCount" ];
}
inline void from_json( const nlohmann::json &j, VkBindAccelerationStructureMemoryInfoNV &p ) {
  BindAccelerationStructureMemoryInfoNV temp;
  from_json( j, temp );
  p = VkBindAccelerationStructureMemoryInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const BindBufferMemoryDeviceGroupInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceIndexCount" ] = p.deviceIndexCount;
  j[ "pDeviceIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDeviceIndices ) );
}
inline void to_json( nlohmann::json &j, const VkBindBufferMemoryDeviceGroupInfo &p ) {
  to_json( j, BindBufferMemoryDeviceGroupInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, BindBufferMemoryDeviceGroupInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindBufferMemoryDeviceGroupInfo" );
  p.deviceIndexCount = j[ "deviceIndexCount" ];
}
inline void from_json( const nlohmann::json &j, VkBindBufferMemoryDeviceGroupInfo &p ) {
  BindBufferMemoryDeviceGroupInfo temp;
  from_json( j, temp );
  p = VkBindBufferMemoryDeviceGroupInfo ( temp );
}

inline void to_json( nlohmann::json &j, const BindBufferMemoryInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryOffset" ] = p.memoryOffset;
}
inline void to_json( nlohmann::json &j, const VkBindBufferMemoryInfo &p ) {
  to_json( j, BindBufferMemoryInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, BindBufferMemoryInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindBufferMemoryInfo" );
  p.memoryOffset = j[ "memoryOffset" ];
}
inline void from_json( const nlohmann::json &j, VkBindBufferMemoryInfo &p ) {
  BindBufferMemoryInfo temp;
  from_json( j, temp );
  p = VkBindBufferMemoryInfo ( temp );
}

inline void to_json( nlohmann::json &j, const Offset2D &p ) {
  j = nlohmann::json::object();
  j[ "x" ] = p.x;
  j[ "y" ] = p.y;
}
inline void to_json( nlohmann::json &j, const VkOffset2D &p ) {
  to_json( j, Offset2D ( p ) );
}
inline void from_json( const nlohmann::json &j, Offset2D &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Offset2D" );
  p.x = j[ "x" ];
  p.y = j[ "y" ];
}
inline void from_json( const nlohmann::json &j, VkOffset2D &p ) {
  Offset2D temp;
  from_json( j, temp );
  p = VkOffset2D ( temp );
}

inline void to_json( nlohmann::json &j, const Rect2D &p ) {
  j = nlohmann::json::object();
  j[ "offset" ] = p.offset;
  j[ "extent" ] = p.extent;
}
inline void to_json( nlohmann::json &j, const VkRect2D &p ) {
  to_json( j, Rect2D ( p ) );
}
inline void from_json( const nlohmann::json &j, Rect2D &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Rect2D" );
  p.offset = j[ "offset" ];
  p.extent = j[ "extent" ];
}
inline void from_json( const nlohmann::json &j, VkRect2D &p ) {
  Rect2D temp;
  from_json( j, temp );
  p = VkRect2D ( temp );
}

inline void to_json( nlohmann::json &j, const BindImageMemoryDeviceGroupInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceIndexCount" ] = p.deviceIndexCount;
  j[ "pDeviceIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDeviceIndices ) );
  j[ "splitInstanceBindRegionCount" ] = p.splitInstanceBindRegionCount;
  j[ "pSplitInstanceBindRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSplitInstanceBindRegions ) );
}
inline void to_json( nlohmann::json &j, const VkBindImageMemoryDeviceGroupInfo &p ) {
  to_json( j, BindImageMemoryDeviceGroupInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, BindImageMemoryDeviceGroupInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindImageMemoryDeviceGroupInfo" );
  p.deviceIndexCount = j[ "deviceIndexCount" ];
  p.splitInstanceBindRegionCount = j[ "splitInstanceBindRegionCount" ];
}
inline void from_json( const nlohmann::json &j, VkBindImageMemoryDeviceGroupInfo &p ) {
  BindImageMemoryDeviceGroupInfo temp;
  from_json( j, temp );
  p = VkBindImageMemoryDeviceGroupInfo ( temp );
}

inline void to_json( nlohmann::json &j, const BindImageMemoryInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryOffset" ] = p.memoryOffset;
}
inline void to_json( nlohmann::json &j, const VkBindImageMemoryInfo &p ) {
  to_json( j, BindImageMemoryInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, BindImageMemoryInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindImageMemoryInfo" );
  p.memoryOffset = j[ "memoryOffset" ];
}
inline void from_json( const nlohmann::json &j, VkBindImageMemoryInfo &p ) {
  BindImageMemoryInfo temp;
  from_json( j, temp );
  p = VkBindImageMemoryInfo ( temp );
}

inline void to_json( nlohmann::json &j, const BindImageMemorySwapchainInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "imageIndex" ] = p.imageIndex;
}
inline void to_json( nlohmann::json &j, const VkBindImageMemorySwapchainInfoKHR &p ) {
  to_json( j, BindImageMemorySwapchainInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, BindImageMemorySwapchainInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindImageMemorySwapchainInfoKHR" );
  p.imageIndex = j[ "imageIndex" ];
}
inline void from_json( const nlohmann::json &j, VkBindImageMemorySwapchainInfoKHR &p ) {
  BindImageMemorySwapchainInfoKHR temp;
  from_json( j, temp );
  p = VkBindImageMemorySwapchainInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const BindImagePlaneMemoryInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "planeAspect" ] = p.planeAspect;
}
inline void to_json( nlohmann::json &j, const VkBindImagePlaneMemoryInfo &p ) {
  to_json( j, BindImagePlaneMemoryInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, BindImagePlaneMemoryInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindImagePlaneMemoryInfo" );
  p.planeAspect = j[ "planeAspect" ];
}
inline void from_json( const nlohmann::json &j, VkBindImagePlaneMemoryInfo &p ) {
  BindImagePlaneMemoryInfo temp;
  from_json( j, temp );
  p = VkBindImagePlaneMemoryInfo ( temp );
}

inline void to_json( nlohmann::json &j, const BindIndexBufferIndirectCommandNV &p ) {
  j = nlohmann::json::object();
  j[ "size" ] = p.size;
  j[ "indexType" ] = p.indexType;
}
inline void to_json( nlohmann::json &j, const VkBindIndexBufferIndirectCommandNV &p ) {
  to_json( j, BindIndexBufferIndirectCommandNV ( p ) );
}
inline void from_json( const nlohmann::json &j, BindIndexBufferIndirectCommandNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindIndexBufferIndirectCommandNV" );
  p.size = j[ "size" ];
  p.indexType = j[ "indexType" ];
}
inline void from_json( const nlohmann::json &j, VkBindIndexBufferIndirectCommandNV &p ) {
  BindIndexBufferIndirectCommandNV temp;
  from_json( j, temp );
  p = VkBindIndexBufferIndirectCommandNV ( temp );
}

inline void to_json( nlohmann::json &j, const BindShaderGroupIndirectCommandNV &p ) {
  j = nlohmann::json::object();
  j[ "groupIndex" ] = p.groupIndex;
}
inline void to_json( nlohmann::json &j, const VkBindShaderGroupIndirectCommandNV &p ) {
  to_json( j, BindShaderGroupIndirectCommandNV ( p ) );
}
inline void from_json( const nlohmann::json &j, BindShaderGroupIndirectCommandNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindShaderGroupIndirectCommandNV" );
  p.groupIndex = j[ "groupIndex" ];
}
inline void from_json( const nlohmann::json &j, VkBindShaderGroupIndirectCommandNV &p ) {
  BindShaderGroupIndirectCommandNV temp;
  from_json( j, temp );
  p = VkBindShaderGroupIndirectCommandNV ( temp );
}

inline void to_json( nlohmann::json &j, const SparseMemoryBind &p ) {
  j = nlohmann::json::object();
  j[ "resourceOffset" ] = p.resourceOffset;
  j[ "size" ] = p.size;
  j[ "memoryOffset" ] = p.memoryOffset;
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkSparseMemoryBind &p ) {
  to_json( j, SparseMemoryBind ( p ) );
}
inline void from_json( const nlohmann::json &j, SparseMemoryBind &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseMemoryBind" );
  p.resourceOffset = j[ "resourceOffset" ];
  p.size = j[ "size" ];
  p.memoryOffset = j[ "memoryOffset" ];
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkSparseMemoryBind &p ) {
  SparseMemoryBind temp;
  from_json( j, temp );
  p = VkSparseMemoryBind ( temp );
}

inline void to_json( nlohmann::json &j, const SparseBufferMemoryBindInfo &p ) {
  j = nlohmann::json::object();
  j[ "bindCount" ] = p.bindCount;
  j[ "pBinds" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBinds ) );
}
inline void to_json( nlohmann::json &j, const VkSparseBufferMemoryBindInfo &p ) {
  to_json( j, SparseBufferMemoryBindInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SparseBufferMemoryBindInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseBufferMemoryBindInfo" );
  p.bindCount = j[ "bindCount" ];
}
inline void from_json( const nlohmann::json &j, VkSparseBufferMemoryBindInfo &p ) {
  SparseBufferMemoryBindInfo temp;
  from_json( j, temp );
  p = VkSparseBufferMemoryBindInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SparseImageOpaqueMemoryBindInfo &p ) {
  j = nlohmann::json::object();
  j[ "bindCount" ] = p.bindCount;
  j[ "pBinds" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBinds ) );
}
inline void to_json( nlohmann::json &j, const VkSparseImageOpaqueMemoryBindInfo &p ) {
  to_json( j, SparseImageOpaqueMemoryBindInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SparseImageOpaqueMemoryBindInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseImageOpaqueMemoryBindInfo" );
  p.bindCount = j[ "bindCount" ];
}
inline void from_json( const nlohmann::json &j, VkSparseImageOpaqueMemoryBindInfo &p ) {
  SparseImageOpaqueMemoryBindInfo temp;
  from_json( j, temp );
  p = VkSparseImageOpaqueMemoryBindInfo ( temp );
}

inline void to_json( nlohmann::json &j, const ImageSubresource &p ) {
  j = nlohmann::json::object();
  j[ "aspectMask" ] = p.aspectMask;
  j[ "mipLevel" ] = p.mipLevel;
  j[ "arrayLayer" ] = p.arrayLayer;
}
inline void to_json( nlohmann::json &j, const VkImageSubresource &p ) {
  to_json( j, ImageSubresource ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageSubresource &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageSubresource" );
  p.aspectMask = j[ "aspectMask" ];
  p.mipLevel = j[ "mipLevel" ];
  p.arrayLayer = j[ "arrayLayer" ];
}
inline void from_json( const nlohmann::json &j, VkImageSubresource &p ) {
  ImageSubresource temp;
  from_json( j, temp );
  p = VkImageSubresource ( temp );
}

inline void to_json( nlohmann::json &j, const Offset3D &p ) {
  j = nlohmann::json::object();
  j[ "x" ] = p.x;
  j[ "y" ] = p.y;
  j[ "z" ] = p.z;
}
inline void to_json( nlohmann::json &j, const VkOffset3D &p ) {
  to_json( j, Offset3D ( p ) );
}
inline void from_json( const nlohmann::json &j, Offset3D &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Offset3D" );
  p.x = j[ "x" ];
  p.y = j[ "y" ];
  p.z = j[ "z" ];
}
inline void from_json( const nlohmann::json &j, VkOffset3D &p ) {
  Offset3D temp;
  from_json( j, temp );
  p = VkOffset3D ( temp );
}

inline void to_json( nlohmann::json &j, const Extent3D &p ) {
  j = nlohmann::json::object();
  j[ "width" ] = p.width;
  j[ "height" ] = p.height;
  j[ "depth" ] = p.depth;
}
inline void to_json( nlohmann::json &j, const VkExtent3D &p ) {
  to_json( j, Extent3D ( p ) );
}
inline void from_json( const nlohmann::json &j, Extent3D &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Extent3D" );
  p.width = j[ "width" ];
  p.height = j[ "height" ];
  p.depth = j[ "depth" ];
}
inline void from_json( const nlohmann::json &j, VkExtent3D &p ) {
  Extent3D temp;
  from_json( j, temp );
  p = VkExtent3D ( temp );
}

inline void to_json( nlohmann::json &j, const SparseImageMemoryBind &p ) {
  j = nlohmann::json::object();
  j[ "subresource" ] = p.subresource;
  j[ "offset" ] = p.offset;
  j[ "extent" ] = p.extent;
  j[ "memoryOffset" ] = p.memoryOffset;
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkSparseImageMemoryBind &p ) {
  to_json( j, SparseImageMemoryBind ( p ) );
}
inline void from_json( const nlohmann::json &j, SparseImageMemoryBind &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseImageMemoryBind" );
  p.subresource = j[ "subresource" ];
  p.offset = j[ "offset" ];
  p.extent = j[ "extent" ];
  p.memoryOffset = j[ "memoryOffset" ];
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkSparseImageMemoryBind &p ) {
  SparseImageMemoryBind temp;
  from_json( j, temp );
  p = VkSparseImageMemoryBind ( temp );
}

inline void to_json( nlohmann::json &j, const SparseImageMemoryBindInfo &p ) {
  j = nlohmann::json::object();
  j[ "bindCount" ] = p.bindCount;
  j[ "pBinds" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBinds ) );
}
inline void to_json( nlohmann::json &j, const VkSparseImageMemoryBindInfo &p ) {
  to_json( j, SparseImageMemoryBindInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SparseImageMemoryBindInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseImageMemoryBindInfo" );
  p.bindCount = j[ "bindCount" ];
}
inline void from_json( const nlohmann::json &j, VkSparseImageMemoryBindInfo &p ) {
  SparseImageMemoryBindInfo temp;
  from_json( j, temp );
  p = VkSparseImageMemoryBindInfo ( temp );
}

inline void to_json( nlohmann::json &j, const BindSparseInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "waitSemaphoreCount" ] = p.waitSemaphoreCount;
  j[ "pWaitSemaphores" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitSemaphores ) );
  j[ "bufferBindCount" ] = p.bufferBindCount;
  j[ "pBufferBinds" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBufferBinds ) );
  j[ "imageOpaqueBindCount" ] = p.imageOpaqueBindCount;
  j[ "pImageOpaqueBinds" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pImageOpaqueBinds ) );
  j[ "imageBindCount" ] = p.imageBindCount;
  j[ "pImageBinds" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pImageBinds ) );
  j[ "signalSemaphoreCount" ] = p.signalSemaphoreCount;
  j[ "pSignalSemaphores" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSignalSemaphores ) );
}
inline void to_json( nlohmann::json &j, const VkBindSparseInfo &p ) {
  to_json( j, BindSparseInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, BindSparseInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindSparseInfo" );
  p.waitSemaphoreCount = j[ "waitSemaphoreCount" ];
  p.bufferBindCount = j[ "bufferBindCount" ];
  p.imageOpaqueBindCount = j[ "imageOpaqueBindCount" ];
  p.imageBindCount = j[ "imageBindCount" ];
  p.signalSemaphoreCount = j[ "signalSemaphoreCount" ];
}
inline void from_json( const nlohmann::json &j, VkBindSparseInfo &p ) {
  BindSparseInfo temp;
  from_json( j, temp );
  p = VkBindSparseInfo ( temp );
}

inline void to_json( nlohmann::json &j, const BindVertexBufferIndirectCommandNV &p ) {
  j = nlohmann::json::object();
  j[ "size" ] = p.size;
  j[ "stride" ] = p.stride;
}
inline void to_json( nlohmann::json &j, const VkBindVertexBufferIndirectCommandNV &p ) {
  to_json( j, BindVertexBufferIndirectCommandNV ( p ) );
}
inline void from_json( const nlohmann::json &j, BindVertexBufferIndirectCommandNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BindVertexBufferIndirectCommandNV" );
  p.size = j[ "size" ];
  p.stride = j[ "stride" ];
}
inline void from_json( const nlohmann::json &j, VkBindVertexBufferIndirectCommandNV &p ) {
  BindVertexBufferIndirectCommandNV temp;
  from_json( j, temp );
  p = VkBindVertexBufferIndirectCommandNV ( temp );
}

inline void to_json( nlohmann::json &j, const ImageSubresourceLayers &p ) {
  j = nlohmann::json::object();
  j[ "aspectMask" ] = p.aspectMask;
  j[ "mipLevel" ] = p.mipLevel;
  j[ "baseArrayLayer" ] = p.baseArrayLayer;
  j[ "layerCount" ] = p.layerCount;
}
inline void to_json( nlohmann::json &j, const VkImageSubresourceLayers &p ) {
  to_json( j, ImageSubresourceLayers ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageSubresourceLayers &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageSubresourceLayers" );
  p.aspectMask = j[ "aspectMask" ];
  p.mipLevel = j[ "mipLevel" ];
  p.baseArrayLayer = j[ "baseArrayLayer" ];
  p.layerCount = j[ "layerCount" ];
}
inline void from_json( const nlohmann::json &j, VkImageSubresourceLayers &p ) {
  ImageSubresourceLayers temp;
  from_json( j, temp );
  p = VkImageSubresourceLayers ( temp );
}

inline void to_json( nlohmann::json &j, const ImageBlit2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcSubresource" ] = p.srcSubresource;
  j[ "srcOffsets" ] = nlohmann::json::array();
  std::copy( p.srcOffsets.begin(), p.srcOffsets.end(), std::back_inserter( j[ "srcOffsets" ] ) );
  j[ "dstSubresource" ] = p.dstSubresource;
  j[ "dstOffsets" ] = nlohmann::json::array();
  std::copy( p.dstOffsets.begin(), p.dstOffsets.end(), std::back_inserter( j[ "dstOffsets" ] ) );
}
inline void to_json( nlohmann::json &j, const VkImageBlit2KHR &p ) {
  to_json( j, ImageBlit2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageBlit2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageBlit2KHR" );
  p.srcSubresource = j[ "srcSubresource" ];
  if( !j[ "srcOffsets" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for ImageBlit2KHR.srcOffsets" );
  if( !j[ "srcOffsets" ].size() > p.srcOffsets.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for ImageBlit2KHR.srcOffsets" );
  std::fill( p.srcOffsets.begin(), p.srcOffsets.end(), std::remove_cv_t< std::remove_reference_t< decltype( *p.srcOffsets.begin() ) > >() );
  std::copy( j[ "srcOffsets" ].begin(), j[ "srcOffsets" ].end(), p.srcOffsets.begin() );
  p.dstSubresource = j[ "dstSubresource" ];
  if( !j[ "dstOffsets" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for ImageBlit2KHR.dstOffsets" );
  if( !j[ "dstOffsets" ].size() > p.dstOffsets.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for ImageBlit2KHR.dstOffsets" );
  std::fill( p.dstOffsets.begin(), p.dstOffsets.end(), std::remove_cv_t< std::remove_reference_t< decltype( *p.dstOffsets.begin() ) > >() );
  std::copy( j[ "dstOffsets" ].begin(), j[ "dstOffsets" ].end(), p.dstOffsets.begin() );
}
inline void from_json( const nlohmann::json &j, VkImageBlit2KHR &p ) {
  ImageBlit2KHR temp;
  from_json( j, temp );
  p = VkImageBlit2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const BlitImageInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcImageLayout" ] = p.srcImageLayout;
  j[ "dstImageLayout" ] = p.dstImageLayout;
  j[ "regionCount" ] = p.regionCount;
  j[ "pRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRegions ) );
  j[ "filter" ] = p.filter;
}
inline void to_json( nlohmann::json &j, const VkBlitImageInfo2KHR &p ) {
  to_json( j, BlitImageInfo2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, BlitImageInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BlitImageInfo2KHR" );
  p.srcImageLayout = j[ "srcImageLayout" ];
  p.dstImageLayout = j[ "dstImageLayout" ];
  p.regionCount = j[ "regionCount" ];
  p.filter = j[ "filter" ];
}
inline void from_json( const nlohmann::json &j, VkBlitImageInfo2KHR &p ) {
  BlitImageInfo2KHR temp;
  from_json( j, temp );
  p = VkBlitImageInfo2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const BufferCopy &p ) {
  j = nlohmann::json::object();
  j[ "srcOffset" ] = p.srcOffset;
  j[ "dstOffset" ] = p.dstOffset;
  j[ "size" ] = p.size;
}
inline void to_json( nlohmann::json &j, const VkBufferCopy &p ) {
  to_json( j, BufferCopy ( p ) );
}
inline void from_json( const nlohmann::json &j, BufferCopy &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferCopy" );
  p.srcOffset = j[ "srcOffset" ];
  p.dstOffset = j[ "dstOffset" ];
  p.size = j[ "size" ];
}
inline void from_json( const nlohmann::json &j, VkBufferCopy &p ) {
  BufferCopy temp;
  from_json( j, temp );
  p = VkBufferCopy ( temp );
}

inline void to_json( nlohmann::json &j, const BufferCopy2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcOffset" ] = p.srcOffset;
  j[ "dstOffset" ] = p.dstOffset;
  j[ "size" ] = p.size;
}
inline void to_json( nlohmann::json &j, const VkBufferCopy2KHR &p ) {
  to_json( j, BufferCopy2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, BufferCopy2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferCopy2KHR" );
  p.srcOffset = j[ "srcOffset" ];
  p.dstOffset = j[ "dstOffset" ];
  p.size = j[ "size" ];
}
inline void from_json( const nlohmann::json &j, VkBufferCopy2KHR &p ) {
  BufferCopy2KHR temp;
  from_json( j, temp );
  p = VkBufferCopy2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const BufferCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "size" ] = p.size;
  j[ "usage" ] = p.usage;
  j[ "sharingMode" ] = p.sharingMode;
  j[ "queueFamilyIndexCount" ] = p.queueFamilyIndexCount;
  j[ "pQueueFamilyIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pQueueFamilyIndices ) );
}
inline void to_json( nlohmann::json &j, const VkBufferCreateInfo &p ) {
  to_json( j, BufferCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, BufferCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferCreateInfo" );
  p.flags = j[ "flags" ];
  p.size = j[ "size" ];
  p.usage = j[ "usage" ];
  p.sharingMode = j[ "sharingMode" ];
  p.queueFamilyIndexCount = j[ "queueFamilyIndexCount" ];
}
inline void from_json( const nlohmann::json &j, VkBufferCreateInfo &p ) {
  BufferCreateInfo temp;
  from_json( j, temp );
  p = VkBufferCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const BufferDeviceAddressCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkBufferDeviceAddressCreateInfoEXT &p ) {
  to_json( j, BufferDeviceAddressCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, BufferDeviceAddressCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferDeviceAddressCreateInfoEXT" );
}
inline void from_json( const nlohmann::json &j, VkBufferDeviceAddressCreateInfoEXT &p ) {
  BufferDeviceAddressCreateInfoEXT temp;
  from_json( j, temp );
  p = VkBufferDeviceAddressCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const BufferDeviceAddressInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkBufferDeviceAddressInfo &p ) {
  to_json( j, BufferDeviceAddressInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, BufferDeviceAddressInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferDeviceAddressInfo" );
}
inline void from_json( const nlohmann::json &j, VkBufferDeviceAddressInfo &p ) {
  BufferDeviceAddressInfo temp;
  from_json( j, temp );
  p = VkBufferDeviceAddressInfo ( temp );
}

inline void to_json( nlohmann::json &j, const BufferImageCopy &p ) {
  j = nlohmann::json::object();
  j[ "bufferOffset" ] = p.bufferOffset;
  j[ "bufferRowLength" ] = p.bufferRowLength;
  j[ "bufferImageHeight" ] = p.bufferImageHeight;
  j[ "imageSubresource" ] = p.imageSubresource;
  j[ "imageOffset" ] = p.imageOffset;
  j[ "imageExtent" ] = p.imageExtent;
}
inline void to_json( nlohmann::json &j, const VkBufferImageCopy &p ) {
  to_json( j, BufferImageCopy ( p ) );
}
inline void from_json( const nlohmann::json &j, BufferImageCopy &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferImageCopy" );
  p.bufferOffset = j[ "bufferOffset" ];
  p.bufferRowLength = j[ "bufferRowLength" ];
  p.bufferImageHeight = j[ "bufferImageHeight" ];
  p.imageSubresource = j[ "imageSubresource" ];
  p.imageOffset = j[ "imageOffset" ];
  p.imageExtent = j[ "imageExtent" ];
}
inline void from_json( const nlohmann::json &j, VkBufferImageCopy &p ) {
  BufferImageCopy temp;
  from_json( j, temp );
  p = VkBufferImageCopy ( temp );
}

inline void to_json( nlohmann::json &j, const BufferImageCopy2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "bufferOffset" ] = p.bufferOffset;
  j[ "bufferRowLength" ] = p.bufferRowLength;
  j[ "bufferImageHeight" ] = p.bufferImageHeight;
  j[ "imageSubresource" ] = p.imageSubresource;
  j[ "imageOffset" ] = p.imageOffset;
  j[ "imageExtent" ] = p.imageExtent;
}
inline void to_json( nlohmann::json &j, const VkBufferImageCopy2KHR &p ) {
  to_json( j, BufferImageCopy2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, BufferImageCopy2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferImageCopy2KHR" );
  p.bufferOffset = j[ "bufferOffset" ];
  p.bufferRowLength = j[ "bufferRowLength" ];
  p.bufferImageHeight = j[ "bufferImageHeight" ];
  p.imageSubresource = j[ "imageSubresource" ];
  p.imageOffset = j[ "imageOffset" ];
  p.imageExtent = j[ "imageExtent" ];
}
inline void from_json( const nlohmann::json &j, VkBufferImageCopy2KHR &p ) {
  BufferImageCopy2KHR temp;
  from_json( j, temp );
  p = VkBufferImageCopy2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const BufferMemoryBarrier &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
  j[ "srcQueueFamilyIndex" ] = p.srcQueueFamilyIndex;
  j[ "dstQueueFamilyIndex" ] = p.dstQueueFamilyIndex;
  j[ "offset" ] = p.offset;
  j[ "size" ] = p.size;
}
inline void to_json( nlohmann::json &j, const VkBufferMemoryBarrier &p ) {
  to_json( j, BufferMemoryBarrier ( p ) );
}
inline void from_json( const nlohmann::json &j, BufferMemoryBarrier &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferMemoryBarrier" );
  p.srcAccessMask = j[ "srcAccessMask" ];
  p.dstAccessMask = j[ "dstAccessMask" ];
  p.srcQueueFamilyIndex = j[ "srcQueueFamilyIndex" ];
  p.dstQueueFamilyIndex = j[ "dstQueueFamilyIndex" ];
  p.offset = j[ "offset" ];
  p.size = j[ "size" ];
}
inline void from_json( const nlohmann::json &j, VkBufferMemoryBarrier &p ) {
  BufferMemoryBarrier temp;
  from_json( j, temp );
  p = VkBufferMemoryBarrier ( temp );
}

inline void to_json( nlohmann::json &j, const BufferMemoryBarrier2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcStageMask" ] = p.srcStageMask;
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstStageMask" ] = p.dstStageMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
  j[ "srcQueueFamilyIndex" ] = p.srcQueueFamilyIndex;
  j[ "dstQueueFamilyIndex" ] = p.dstQueueFamilyIndex;
  j[ "offset" ] = p.offset;
  j[ "size" ] = p.size;
}
inline void to_json( nlohmann::json &j, const VkBufferMemoryBarrier2KHR &p ) {
  to_json( j, BufferMemoryBarrier2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, BufferMemoryBarrier2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferMemoryBarrier2KHR" );
  p.srcStageMask = j[ "srcStageMask" ];
  p.srcAccessMask = j[ "srcAccessMask" ];
  p.dstStageMask = j[ "dstStageMask" ];
  p.dstAccessMask = j[ "dstAccessMask" ];
  p.srcQueueFamilyIndex = j[ "srcQueueFamilyIndex" ];
  p.dstQueueFamilyIndex = j[ "dstQueueFamilyIndex" ];
  p.offset = j[ "offset" ];
  p.size = j[ "size" ];
}
inline void from_json( const nlohmann::json &j, VkBufferMemoryBarrier2KHR &p ) {
  BufferMemoryBarrier2KHR temp;
  from_json( j, temp );
  p = VkBufferMemoryBarrier2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const BufferMemoryRequirementsInfo2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkBufferMemoryRequirementsInfo2 &p ) {
  to_json( j, BufferMemoryRequirementsInfo2 ( p ) );
}
inline void from_json( const nlohmann::json &j, BufferMemoryRequirementsInfo2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferMemoryRequirementsInfo2" );
}
inline void from_json( const nlohmann::json &j, VkBufferMemoryRequirementsInfo2 &p ) {
  BufferMemoryRequirementsInfo2 temp;
  from_json( j, temp );
  p = VkBufferMemoryRequirementsInfo2 ( temp );
}

inline void to_json( nlohmann::json &j, const BufferOpaqueCaptureAddressCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "opaqueCaptureAddress" ] = p.opaqueCaptureAddress;
}
inline void to_json( nlohmann::json &j, const VkBufferOpaqueCaptureAddressCreateInfo &p ) {
  to_json( j, BufferOpaqueCaptureAddressCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, BufferOpaqueCaptureAddressCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferOpaqueCaptureAddressCreateInfo" );
  p.opaqueCaptureAddress = j[ "opaqueCaptureAddress" ];
}
inline void from_json( const nlohmann::json &j, VkBufferOpaqueCaptureAddressCreateInfo &p ) {
  BufferOpaqueCaptureAddressCreateInfo temp;
  from_json( j, temp );
  p = VkBufferOpaqueCaptureAddressCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const BufferViewCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "format" ] = p.format;
  j[ "offset" ] = p.offset;
  j[ "range" ] = p.range;
}
inline void to_json( nlohmann::json &j, const VkBufferViewCreateInfo &p ) {
  to_json( j, BufferViewCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, BufferViewCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for BufferViewCreateInfo" );
  p.flags = j[ "flags" ];
  p.format = j[ "format" ];
  p.offset = j[ "offset" ];
  p.range = j[ "range" ];
}
inline void from_json( const nlohmann::json &j, VkBufferViewCreateInfo &p ) {
  BufferViewCreateInfo temp;
  from_json( j, temp );
  p = VkBufferViewCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const CalibratedTimestampInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "timeDomain" ] = p.timeDomain;
}
inline void to_json( nlohmann::json &j, const VkCalibratedTimestampInfoEXT &p ) {
  to_json( j, CalibratedTimestampInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, CalibratedTimestampInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CalibratedTimestampInfoEXT" );
  p.timeDomain = j[ "timeDomain" ];
}
inline void from_json( const nlohmann::json &j, VkCalibratedTimestampInfoEXT &p ) {
  CalibratedTimestampInfoEXT temp;
  from_json( j, temp );
  p = VkCalibratedTimestampInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const CheckpointData2NV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stage" ] = p.stage;
  j[ "pCheckpointMarker" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCheckpointMarker ) );
}
inline void to_json( nlohmann::json &j, const VkCheckpointData2NV &p ) {
  to_json( j, CheckpointData2NV ( p ) );
}
inline void from_json( const nlohmann::json &j, CheckpointData2NV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CheckpointData2NV" );
  p.stage = j[ "stage" ];
}
inline void from_json( const nlohmann::json &j, VkCheckpointData2NV &p ) {
  CheckpointData2NV temp;
  from_json( j, temp );
  p = VkCheckpointData2NV ( temp );
}

inline void to_json( nlohmann::json &j, const CheckpointDataNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stage" ] = p.stage;
  j[ "pCheckpointMarker" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCheckpointMarker ) );
}
inline void to_json( nlohmann::json &j, const VkCheckpointDataNV &p ) {
  to_json( j, CheckpointDataNV ( p ) );
}
inline void from_json( const nlohmann::json &j, CheckpointDataNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CheckpointDataNV" );
  p.stage = j[ "stage" ];
}
inline void from_json( const nlohmann::json &j, VkCheckpointDataNV &p ) {
  CheckpointDataNV temp;
  from_json( j, temp );
  p = VkCheckpointDataNV ( temp );
}

inline void to_json( nlohmann::json &j, const ClearDepthStencilValue &p ) {
  j = nlohmann::json::object();
  j[ "depth" ] = p.depth;
  j[ "stencil" ] = p.stencil;
}
inline void to_json( nlohmann::json &j, const VkClearDepthStencilValue &p ) {
  to_json( j, ClearDepthStencilValue ( p ) );
}
inline void from_json( const nlohmann::json &j, ClearDepthStencilValue &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ClearDepthStencilValue" );
  p.depth = j[ "depth" ];
  p.stencil = j[ "stencil" ];
}
inline void from_json( const nlohmann::json &j, VkClearDepthStencilValue &p ) {
  ClearDepthStencilValue temp;
  from_json( j, temp );
  p = VkClearDepthStencilValue ( temp );
}

inline void to_json( nlohmann::json &j, const ClearAttachment &p ) {
  j = nlohmann::json::object();
  j[ "aspectMask" ] = p.aspectMask;
  j[ "colorAttachment" ] = p.colorAttachment;
}
inline void to_json( nlohmann::json &j, const VkClearAttachment &p ) {
  to_json( j, ClearAttachment ( p ) );
}
inline void from_json( const nlohmann::json &j, ClearAttachment &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ClearAttachment" );
  p.aspectMask = j[ "aspectMask" ];
  p.colorAttachment = j[ "colorAttachment" ];
}
inline void from_json( const nlohmann::json &j, VkClearAttachment &p ) {
  ClearAttachment temp;
  from_json( j, temp );
  p = VkClearAttachment ( temp );
}

inline void to_json( nlohmann::json &j, const ClearRect &p ) {
  j = nlohmann::json::object();
  j[ "rect" ] = p.rect;
  j[ "baseArrayLayer" ] = p.baseArrayLayer;
  j[ "layerCount" ] = p.layerCount;
}
inline void to_json( nlohmann::json &j, const VkClearRect &p ) {
  to_json( j, ClearRect ( p ) );
}
inline void from_json( const nlohmann::json &j, ClearRect &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ClearRect" );
  p.rect = j[ "rect" ];
  p.baseArrayLayer = j[ "baseArrayLayer" ];
  p.layerCount = j[ "layerCount" ];
}
inline void from_json( const nlohmann::json &j, VkClearRect &p ) {
  ClearRect temp;
  from_json( j, temp );
  p = VkClearRect ( temp );
}

inline void to_json( nlohmann::json &j, const CoarseSampleLocationNV &p ) {
  j = nlohmann::json::object();
  j[ "pixelX" ] = p.pixelX;
  j[ "pixelY" ] = p.pixelY;
  j[ "sample" ] = p.sample;
}
inline void to_json( nlohmann::json &j, const VkCoarseSampleLocationNV &p ) {
  to_json( j, CoarseSampleLocationNV ( p ) );
}
inline void from_json( const nlohmann::json &j, CoarseSampleLocationNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CoarseSampleLocationNV" );
  p.pixelX = j[ "pixelX" ];
  p.pixelY = j[ "pixelY" ];
  p.sample = j[ "sample" ];
}
inline void from_json( const nlohmann::json &j, VkCoarseSampleLocationNV &p ) {
  CoarseSampleLocationNV temp;
  from_json( j, temp );
  p = VkCoarseSampleLocationNV ( temp );
}

inline void to_json( nlohmann::json &j, const CoarseSampleOrderCustomNV &p ) {
  j = nlohmann::json::object();
  j[ "shadingRate" ] = p.shadingRate;
  j[ "sampleCount" ] = p.sampleCount;
  j[ "sampleLocationCount" ] = p.sampleLocationCount;
  j[ "pSampleLocations" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSampleLocations ) );
}
inline void to_json( nlohmann::json &j, const VkCoarseSampleOrderCustomNV &p ) {
  to_json( j, CoarseSampleOrderCustomNV ( p ) );
}
inline void from_json( const nlohmann::json &j, CoarseSampleOrderCustomNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CoarseSampleOrderCustomNV" );
  p.shadingRate = j[ "shadingRate" ];
  p.sampleCount = j[ "sampleCount" ];
  p.sampleLocationCount = j[ "sampleLocationCount" ];
}
inline void from_json( const nlohmann::json &j, VkCoarseSampleOrderCustomNV &p ) {
  CoarseSampleOrderCustomNV temp;
  from_json( j, temp );
  p = VkCoarseSampleOrderCustomNV ( temp );
}

inline void to_json( nlohmann::json &j, const CommandBufferAllocateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "level" ] = p.level;
  j[ "commandBufferCount" ] = p.commandBufferCount;
}
inline void to_json( nlohmann::json &j, const VkCommandBufferAllocateInfo &p ) {
  to_json( j, CommandBufferAllocateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, CommandBufferAllocateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandBufferAllocateInfo" );
  p.level = j[ "level" ];
  p.commandBufferCount = j[ "commandBufferCount" ];
}
inline void from_json( const nlohmann::json &j, VkCommandBufferAllocateInfo &p ) {
  CommandBufferAllocateInfo temp;
  from_json( j, temp );
  p = VkCommandBufferAllocateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const CommandBufferInheritanceInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "subpass" ] = p.subpass;
  j[ "occlusionQueryEnable" ] = bool( p.occlusionQueryEnable );
  j[ "queryFlags" ] = p.queryFlags;
  j[ "pipelineStatistics" ] = p.pipelineStatistics;
}
inline void to_json( nlohmann::json &j, const VkCommandBufferInheritanceInfo &p ) {
  to_json( j, CommandBufferInheritanceInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, CommandBufferInheritanceInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandBufferInheritanceInfo" );
  p.subpass = j[ "subpass" ];
  p.occlusionQueryEnable = j[ "occlusionQueryEnable" ];
  p.queryFlags = j[ "queryFlags" ];
  p.pipelineStatistics = j[ "pipelineStatistics" ];
}
inline void from_json( const nlohmann::json &j, VkCommandBufferInheritanceInfo &p ) {
  CommandBufferInheritanceInfo temp;
  from_json( j, temp );
  p = VkCommandBufferInheritanceInfo ( temp );
}

inline void to_json( nlohmann::json &j, const CommandBufferBeginInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pInheritanceInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pInheritanceInfo ) );
}
inline void to_json( nlohmann::json &j, const VkCommandBufferBeginInfo &p ) {
  to_json( j, CommandBufferBeginInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, CommandBufferBeginInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandBufferBeginInfo" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkCommandBufferBeginInfo &p ) {
  CommandBufferBeginInfo temp;
  from_json( j, temp );
  p = VkCommandBufferBeginInfo ( temp );
}

inline void to_json( nlohmann::json &j, const CommandBufferInheritanceConditionalRenderingInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "conditionalRenderingEnable" ] = bool( p.conditionalRenderingEnable );
}
inline void to_json( nlohmann::json &j, const VkCommandBufferInheritanceConditionalRenderingInfoEXT &p ) {
  to_json( j, CommandBufferInheritanceConditionalRenderingInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, CommandBufferInheritanceConditionalRenderingInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandBufferInheritanceConditionalRenderingInfoEXT" );
  p.conditionalRenderingEnable = j[ "conditionalRenderingEnable" ];
}
inline void from_json( const nlohmann::json &j, VkCommandBufferInheritanceConditionalRenderingInfoEXT &p ) {
  CommandBufferInheritanceConditionalRenderingInfoEXT temp;
  from_json( j, temp );
  p = VkCommandBufferInheritanceConditionalRenderingInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const CommandBufferInheritanceRenderPassTransformInfoQCOM &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "transform" ] = p.transform;
  j[ "renderArea" ] = p.renderArea;
}
inline void to_json( nlohmann::json &j, const VkCommandBufferInheritanceRenderPassTransformInfoQCOM &p ) {
  to_json( j, CommandBufferInheritanceRenderPassTransformInfoQCOM ( p ) );
}
inline void from_json( const nlohmann::json &j, CommandBufferInheritanceRenderPassTransformInfoQCOM &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandBufferInheritanceRenderPassTransformInfoQCOM" );
  p.transform = j[ "transform" ];
  p.renderArea = j[ "renderArea" ];
}
inline void from_json( const nlohmann::json &j, VkCommandBufferInheritanceRenderPassTransformInfoQCOM &p ) {
  CommandBufferInheritanceRenderPassTransformInfoQCOM temp;
  from_json( j, temp );
  p = VkCommandBufferInheritanceRenderPassTransformInfoQCOM ( temp );
}

inline void to_json( nlohmann::json &j, const Viewport &p ) {
  j = nlohmann::json::object();
  j[ "x" ] = p.x;
  j[ "y" ] = p.y;
  j[ "width" ] = p.width;
  j[ "height" ] = p.height;
  j[ "minDepth" ] = p.minDepth;
  j[ "maxDepth" ] = p.maxDepth;
}
inline void to_json( nlohmann::json &j, const VkViewport &p ) {
  to_json( j, Viewport ( p ) );
}
inline void from_json( const nlohmann::json &j, Viewport &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Viewport" );
  p.x = j[ "x" ];
  p.y = j[ "y" ];
  p.width = j[ "width" ];
  p.height = j[ "height" ];
  p.minDepth = j[ "minDepth" ];
  p.maxDepth = j[ "maxDepth" ];
}
inline void from_json( const nlohmann::json &j, VkViewport &p ) {
  Viewport temp;
  from_json( j, temp );
  p = VkViewport ( temp );
}

inline void to_json( nlohmann::json &j, const CommandBufferInheritanceViewportScissorInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "viewportScissor2D" ] = bool( p.viewportScissor2D );
  j[ "viewportDepthCount" ] = p.viewportDepthCount;
  j[ "pViewportDepths" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewportDepths ) );
}
inline void to_json( nlohmann::json &j, const VkCommandBufferInheritanceViewportScissorInfoNV &p ) {
  to_json( j, CommandBufferInheritanceViewportScissorInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, CommandBufferInheritanceViewportScissorInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandBufferInheritanceViewportScissorInfoNV" );
  p.viewportScissor2D = j[ "viewportScissor2D" ];
  p.viewportDepthCount = j[ "viewportDepthCount" ];
}
inline void from_json( const nlohmann::json &j, VkCommandBufferInheritanceViewportScissorInfoNV &p ) {
  CommandBufferInheritanceViewportScissorInfoNV temp;
  from_json( j, temp );
  p = VkCommandBufferInheritanceViewportScissorInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const CommandBufferSubmitInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceMask" ] = p.deviceMask;
}
inline void to_json( nlohmann::json &j, const VkCommandBufferSubmitInfoKHR &p ) {
  to_json( j, CommandBufferSubmitInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, CommandBufferSubmitInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandBufferSubmitInfoKHR" );
  p.deviceMask = j[ "deviceMask" ];
}
inline void from_json( const nlohmann::json &j, VkCommandBufferSubmitInfoKHR &p ) {
  CommandBufferSubmitInfoKHR temp;
  from_json( j, temp );
  p = VkCommandBufferSubmitInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const CommandPoolCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "queueFamilyIndex" ] = p.queueFamilyIndex;
}
inline void to_json( nlohmann::json &j, const VkCommandPoolCreateInfo &p ) {
  to_json( j, CommandPoolCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, CommandPoolCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CommandPoolCreateInfo" );
  p.flags = j[ "flags" ];
  p.queueFamilyIndex = j[ "queueFamilyIndex" ];
}
inline void from_json( const nlohmann::json &j, VkCommandPoolCreateInfo &p ) {
  CommandPoolCreateInfo temp;
  from_json( j, temp );
  p = VkCommandPoolCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SpecializationMapEntry &p ) {
  j = nlohmann::json::object();
  j[ "constantID" ] = p.constantID;
  j[ "offset" ] = p.offset;
  j[ "size" ] = p.size;
}
inline void to_json( nlohmann::json &j, const VkSpecializationMapEntry &p ) {
  to_json( j, SpecializationMapEntry ( p ) );
}
inline void from_json( const nlohmann::json &j, SpecializationMapEntry &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SpecializationMapEntry" );
  p.constantID = j[ "constantID" ];
  p.offset = j[ "offset" ];
  p.size = j[ "size" ];
}
inline void from_json( const nlohmann::json &j, VkSpecializationMapEntry &p ) {
  SpecializationMapEntry temp;
  from_json( j, temp );
  p = VkSpecializationMapEntry ( temp );
}

inline void to_json( nlohmann::json &j, const SpecializationInfo &p ) {
  j = nlohmann::json::object();
  j[ "mapEntryCount" ] = p.mapEntryCount;
  j[ "pMapEntries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pMapEntries ) );
  j[ "dataSize" ] = p.dataSize;
  j[ "pData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pData ) );
}
inline void to_json( nlohmann::json &j, const VkSpecializationInfo &p ) {
  to_json( j, SpecializationInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SpecializationInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SpecializationInfo" );
  p.mapEntryCount = j[ "mapEntryCount" ];
  p.dataSize = j[ "dataSize" ];
}
inline void from_json( const nlohmann::json &j, VkSpecializationInfo &p ) {
  SpecializationInfo temp;
  from_json( j, temp );
  p = VkSpecializationInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineShaderStageCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "stage" ] = p.stage;
  if( p.pName ) j[ "pName" ] = std::string( p.pName );
  j[ "pSpecializationInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSpecializationInfo ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineShaderStageCreateInfo &p ) {
  to_json( j, PipelineShaderStageCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineShaderStageCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineShaderStageCreateInfo" );
  p.flags = j[ "flags" ];
  p.stage = j[ "stage" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineShaderStageCreateInfo &p ) {
  PipelineShaderStageCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineShaderStageCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const ComputePipelineCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "stage" ] = p.stage;
  j[ "basePipelineIndex" ] = p.basePipelineIndex;
}
inline void to_json( nlohmann::json &j, const VkComputePipelineCreateInfo &p ) {
  to_json( j, ComputePipelineCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ComputePipelineCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ComputePipelineCreateInfo" );
  p.flags = j[ "flags" ];
  p.stage = j[ "stage" ];
  p.basePipelineIndex = j[ "basePipelineIndex" ];
}
inline void from_json( const nlohmann::json &j, VkComputePipelineCreateInfo &p ) {
  ComputePipelineCreateInfo temp;
  from_json( j, temp );
  p = VkComputePipelineCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const ConditionalRenderingBeginInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "offset" ] = p.offset;
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkConditionalRenderingBeginInfoEXT &p ) {
  to_json( j, ConditionalRenderingBeginInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ConditionalRenderingBeginInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ConditionalRenderingBeginInfoEXT" );
  p.offset = j[ "offset" ];
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkConditionalRenderingBeginInfoEXT &p ) {
  ConditionalRenderingBeginInfoEXT temp;
  from_json( j, temp );
  p = VkConditionalRenderingBeginInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const ConformanceVersion &p ) {
  j = nlohmann::json::object();
  j[ "major" ] = p.major;
  j[ "minor" ] = p.minor;
  j[ "subminor" ] = p.subminor;
  j[ "patch" ] = p.patch;
}
inline void to_json( nlohmann::json &j, const VkConformanceVersion &p ) {
  to_json( j, ConformanceVersion ( p ) );
}
inline void from_json( const nlohmann::json &j, ConformanceVersion &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ConformanceVersion" );
  p.major = j[ "major" ];
  p.minor = j[ "minor" ];
  p.subminor = j[ "subminor" ];
  p.patch = j[ "patch" ];
}
inline void from_json( const nlohmann::json &j, VkConformanceVersion &p ) {
  ConformanceVersion temp;
  from_json( j, temp );
  p = VkConformanceVersion ( temp );
}

inline void to_json( nlohmann::json &j, const CooperativeMatrixPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "MSize" ] = p.MSize;
  j[ "NSize" ] = p.NSize;
  j[ "KSize" ] = p.KSize;
  j[ "AType" ] = p.AType;
  j[ "BType" ] = p.BType;
  j[ "CType" ] = p.CType;
  j[ "DType" ] = p.DType;
  j[ "scope" ] = p.scope;
}
inline void to_json( nlohmann::json &j, const VkCooperativeMatrixPropertiesNV &p ) {
  to_json( j, CooperativeMatrixPropertiesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, CooperativeMatrixPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CooperativeMatrixPropertiesNV" );
  p.MSize = j[ "MSize" ];
  p.NSize = j[ "NSize" ];
  p.KSize = j[ "KSize" ];
  p.AType = j[ "AType" ];
  p.BType = j[ "BType" ];
  p.CType = j[ "CType" ];
  p.DType = j[ "DType" ];
  p.scope = j[ "scope" ];
}
inline void from_json( const nlohmann::json &j, VkCooperativeMatrixPropertiesNV &p ) {
  CooperativeMatrixPropertiesNV temp;
  from_json( j, temp );
  p = VkCooperativeMatrixPropertiesNV ( temp );
}

inline void to_json( nlohmann::json &j, const CopyAccelerationStructureInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "mode" ] = p.mode;
}
inline void to_json( nlohmann::json &j, const VkCopyAccelerationStructureInfoKHR &p ) {
  to_json( j, CopyAccelerationStructureInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, CopyAccelerationStructureInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyAccelerationStructureInfoKHR" );
  p.mode = j[ "mode" ];
}
inline void from_json( const nlohmann::json &j, VkCopyAccelerationStructureInfoKHR &p ) {
  CopyAccelerationStructureInfoKHR temp;
  from_json( j, temp );
  p = VkCopyAccelerationStructureInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const CopyAccelerationStructureToMemoryInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "mode" ] = p.mode;
}
inline void to_json( nlohmann::json &j, const VkCopyAccelerationStructureToMemoryInfoKHR &p ) {
  to_json( j, CopyAccelerationStructureToMemoryInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, CopyAccelerationStructureToMemoryInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyAccelerationStructureToMemoryInfoKHR" );
  p.mode = j[ "mode" ];
}
inline void from_json( const nlohmann::json &j, VkCopyAccelerationStructureToMemoryInfoKHR &p ) {
  CopyAccelerationStructureToMemoryInfoKHR temp;
  from_json( j, temp );
  p = VkCopyAccelerationStructureToMemoryInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const CopyBufferInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "regionCount" ] = p.regionCount;
  j[ "pRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRegions ) );
}
inline void to_json( nlohmann::json &j, const VkCopyBufferInfo2KHR &p ) {
  to_json( j, CopyBufferInfo2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, CopyBufferInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyBufferInfo2KHR" );
  p.regionCount = j[ "regionCount" ];
}
inline void from_json( const nlohmann::json &j, VkCopyBufferInfo2KHR &p ) {
  CopyBufferInfo2KHR temp;
  from_json( j, temp );
  p = VkCopyBufferInfo2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const CopyBufferToImageInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dstImageLayout" ] = p.dstImageLayout;
  j[ "regionCount" ] = p.regionCount;
  j[ "pRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRegions ) );
}
inline void to_json( nlohmann::json &j, const VkCopyBufferToImageInfo2KHR &p ) {
  to_json( j, CopyBufferToImageInfo2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, CopyBufferToImageInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyBufferToImageInfo2KHR" );
  p.dstImageLayout = j[ "dstImageLayout" ];
  p.regionCount = j[ "regionCount" ];
}
inline void from_json( const nlohmann::json &j, VkCopyBufferToImageInfo2KHR &p ) {
  CopyBufferToImageInfo2KHR temp;
  from_json( j, temp );
  p = VkCopyBufferToImageInfo2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const CopyCommandTransformInfoQCOM &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "transform" ] = p.transform;
}
inline void to_json( nlohmann::json &j, const VkCopyCommandTransformInfoQCOM &p ) {
  to_json( j, CopyCommandTransformInfoQCOM ( p ) );
}
inline void from_json( const nlohmann::json &j, CopyCommandTransformInfoQCOM &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyCommandTransformInfoQCOM" );
  p.transform = j[ "transform" ];
}
inline void from_json( const nlohmann::json &j, VkCopyCommandTransformInfoQCOM &p ) {
  CopyCommandTransformInfoQCOM temp;
  from_json( j, temp );
  p = VkCopyCommandTransformInfoQCOM ( temp );
}

inline void to_json( nlohmann::json &j, const CopyDescriptorSet &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcBinding" ] = p.srcBinding;
  j[ "srcArrayElement" ] = p.srcArrayElement;
  j[ "dstBinding" ] = p.dstBinding;
  j[ "dstArrayElement" ] = p.dstArrayElement;
  j[ "descriptorCount" ] = p.descriptorCount;
}
inline void to_json( nlohmann::json &j, const VkCopyDescriptorSet &p ) {
  to_json( j, CopyDescriptorSet ( p ) );
}
inline void from_json( const nlohmann::json &j, CopyDescriptorSet &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyDescriptorSet" );
  p.srcBinding = j[ "srcBinding" ];
  p.srcArrayElement = j[ "srcArrayElement" ];
  p.dstBinding = j[ "dstBinding" ];
  p.dstArrayElement = j[ "dstArrayElement" ];
  p.descriptorCount = j[ "descriptorCount" ];
}
inline void from_json( const nlohmann::json &j, VkCopyDescriptorSet &p ) {
  CopyDescriptorSet temp;
  from_json( j, temp );
  p = VkCopyDescriptorSet ( temp );
}

inline void to_json( nlohmann::json &j, const ImageCopy2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcSubresource" ] = p.srcSubresource;
  j[ "srcOffset" ] = p.srcOffset;
  j[ "dstSubresource" ] = p.dstSubresource;
  j[ "dstOffset" ] = p.dstOffset;
  j[ "extent" ] = p.extent;
}
inline void to_json( nlohmann::json &j, const VkImageCopy2KHR &p ) {
  to_json( j, ImageCopy2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageCopy2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageCopy2KHR" );
  p.srcSubresource = j[ "srcSubresource" ];
  p.srcOffset = j[ "srcOffset" ];
  p.dstSubresource = j[ "dstSubresource" ];
  p.dstOffset = j[ "dstOffset" ];
  p.extent = j[ "extent" ];
}
inline void from_json( const nlohmann::json &j, VkImageCopy2KHR &p ) {
  ImageCopy2KHR temp;
  from_json( j, temp );
  p = VkImageCopy2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const CopyImageInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcImageLayout" ] = p.srcImageLayout;
  j[ "dstImageLayout" ] = p.dstImageLayout;
  j[ "regionCount" ] = p.regionCount;
  j[ "pRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRegions ) );
}
inline void to_json( nlohmann::json &j, const VkCopyImageInfo2KHR &p ) {
  to_json( j, CopyImageInfo2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, CopyImageInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyImageInfo2KHR" );
  p.srcImageLayout = j[ "srcImageLayout" ];
  p.dstImageLayout = j[ "dstImageLayout" ];
  p.regionCount = j[ "regionCount" ];
}
inline void from_json( const nlohmann::json &j, VkCopyImageInfo2KHR &p ) {
  CopyImageInfo2KHR temp;
  from_json( j, temp );
  p = VkCopyImageInfo2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const CopyImageToBufferInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcImageLayout" ] = p.srcImageLayout;
  j[ "regionCount" ] = p.regionCount;
  j[ "pRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRegions ) );
}
inline void to_json( nlohmann::json &j, const VkCopyImageToBufferInfo2KHR &p ) {
  to_json( j, CopyImageToBufferInfo2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, CopyImageToBufferInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyImageToBufferInfo2KHR" );
  p.srcImageLayout = j[ "srcImageLayout" ];
  p.regionCount = j[ "regionCount" ];
}
inline void from_json( const nlohmann::json &j, VkCopyImageToBufferInfo2KHR &p ) {
  CopyImageToBufferInfo2KHR temp;
  from_json( j, temp );
  p = VkCopyImageToBufferInfo2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const CopyMemoryToAccelerationStructureInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "mode" ] = p.mode;
}
inline void to_json( nlohmann::json &j, const VkCopyMemoryToAccelerationStructureInfoKHR &p ) {
  to_json( j, CopyMemoryToAccelerationStructureInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, CopyMemoryToAccelerationStructureInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CopyMemoryToAccelerationStructureInfoKHR" );
  p.mode = j[ "mode" ];
}
inline void from_json( const nlohmann::json &j, VkCopyMemoryToAccelerationStructureInfoKHR &p ) {
  CopyMemoryToAccelerationStructureInfoKHR temp;
  from_json( j, temp );
  p = VkCopyMemoryToAccelerationStructureInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const CuFunctionCreateInfoNVX &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  if( p.pName ) j[ "pName" ] = std::string( p.pName );
}
inline void to_json( nlohmann::json &j, const VkCuFunctionCreateInfoNVX &p ) {
  to_json( j, CuFunctionCreateInfoNVX ( p ) );
}
inline void from_json( const nlohmann::json &j, CuFunctionCreateInfoNVX &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CuFunctionCreateInfoNVX" );
}
inline void from_json( const nlohmann::json &j, VkCuFunctionCreateInfoNVX &p ) {
  CuFunctionCreateInfoNVX temp;
  from_json( j, temp );
  p = VkCuFunctionCreateInfoNVX ( temp );
}

inline void to_json( nlohmann::json &j, const CuLaunchInfoNVX &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "gridDimX" ] = p.gridDimX;
  j[ "gridDimY" ] = p.gridDimY;
  j[ "gridDimZ" ] = p.gridDimZ;
  j[ "blockDimX" ] = p.blockDimX;
  j[ "blockDimY" ] = p.blockDimY;
  j[ "blockDimZ" ] = p.blockDimZ;
  j[ "sharedMemBytes" ] = p.sharedMemBytes;
  j[ "paramCount" ] = p.paramCount;
  j[ "pParams" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pParams ) );
  j[ "extraCount" ] = p.extraCount;
  j[ "pExtras" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pExtras ) );
}
inline void to_json( nlohmann::json &j, const VkCuLaunchInfoNVX &p ) {
  to_json( j, CuLaunchInfoNVX ( p ) );
}
inline void from_json( const nlohmann::json &j, CuLaunchInfoNVX &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CuLaunchInfoNVX" );
  p.gridDimX = j[ "gridDimX" ];
  p.gridDimY = j[ "gridDimY" ];
  p.gridDimZ = j[ "gridDimZ" ];
  p.blockDimX = j[ "blockDimX" ];
  p.blockDimY = j[ "blockDimY" ];
  p.blockDimZ = j[ "blockDimZ" ];
  p.sharedMemBytes = j[ "sharedMemBytes" ];
  p.paramCount = j[ "paramCount" ];
  p.extraCount = j[ "extraCount" ];
}
inline void from_json( const nlohmann::json &j, VkCuLaunchInfoNVX &p ) {
  CuLaunchInfoNVX temp;
  from_json( j, temp );
  p = VkCuLaunchInfoNVX ( temp );
}

inline void to_json( nlohmann::json &j, const CuModuleCreateInfoNVX &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dataSize" ] = p.dataSize;
  j[ "pData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pData ) );
}
inline void to_json( nlohmann::json &j, const VkCuModuleCreateInfoNVX &p ) {
  to_json( j, CuModuleCreateInfoNVX ( p ) );
}
inline void from_json( const nlohmann::json &j, CuModuleCreateInfoNVX &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for CuModuleCreateInfoNVX" );
  p.dataSize = j[ "dataSize" ];
}
inline void from_json( const nlohmann::json &j, VkCuModuleCreateInfoNVX &p ) {
  CuModuleCreateInfoNVX temp;
  from_json( j, temp );
  p = VkCuModuleCreateInfoNVX ( temp );
}

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const D3D12FenceSubmitInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "waitSemaphoreValuesCount" ] = p.waitSemaphoreValuesCount;
  j[ "pWaitSemaphoreValues" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitSemaphoreValues ) );
  j[ "signalSemaphoreValuesCount" ] = p.signalSemaphoreValuesCount;
  j[ "pSignalSemaphoreValues" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSignalSemaphoreValues ) );
}
inline void to_json( nlohmann::json &j, const VkD3D12FenceSubmitInfoKHR &p ) {
  to_json( j, D3D12FenceSubmitInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, D3D12FenceSubmitInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for D3D12FenceSubmitInfoKHR" );
  p.waitSemaphoreValuesCount = j[ "waitSemaphoreValuesCount" ];
  p.signalSemaphoreValuesCount = j[ "signalSemaphoreValuesCount" ];
}
inline void from_json( const nlohmann::json &j, VkD3D12FenceSubmitInfoKHR &p ) {
  D3D12FenceSubmitInfoKHR temp;
  from_json( j, temp );
  p = VkD3D12FenceSubmitInfoKHR ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const DebugMarkerMarkerInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  if( p.pMarkerName ) j[ "pMarkerName" ] = std::string( p.pMarkerName );
  j[ "color" ] = nlohmann::json::array();
  std::copy( p.color.begin(), p.color.end(), std::back_inserter( j[ "color" ] ) );
}
inline void to_json( nlohmann::json &j, const VkDebugMarkerMarkerInfoEXT &p ) {
  to_json( j, DebugMarkerMarkerInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DebugMarkerMarkerInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugMarkerMarkerInfoEXT" );
  if( !j[ "color" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for DebugMarkerMarkerInfoEXT.color" );
  if( !j[ "color" ].size() > p.color.size() ) throw vulkan2json::invalid_array_value( "too many values in array for DebugMarkerMarkerInfoEXT.color" );
  std::fill( p.color.begin(), p.color.end(), 0 );
  std::copy( j[ "color" ].begin(), j[ "color" ].end(), p.color.begin() );
}
inline void from_json( const nlohmann::json &j, VkDebugMarkerMarkerInfoEXT &p ) {
  DebugMarkerMarkerInfoEXT temp;
  from_json( j, temp );
  p = VkDebugMarkerMarkerInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DebugMarkerObjectNameInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "objectType" ] = p.objectType;
  j[ "object" ] = p.object;
  if( p.pObjectName ) j[ "pObjectName" ] = std::string( p.pObjectName );
}
inline void to_json( nlohmann::json &j, const VkDebugMarkerObjectNameInfoEXT &p ) {
  to_json( j, DebugMarkerObjectNameInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DebugMarkerObjectNameInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugMarkerObjectNameInfoEXT" );
  p.objectType = j[ "objectType" ];
  p.object = j[ "object" ];
}
inline void from_json( const nlohmann::json &j, VkDebugMarkerObjectNameInfoEXT &p ) {
  DebugMarkerObjectNameInfoEXT temp;
  from_json( j, temp );
  p = VkDebugMarkerObjectNameInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DebugMarkerObjectTagInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "objectType" ] = p.objectType;
  j[ "object" ] = p.object;
  j[ "tagName" ] = p.tagName;
  j[ "tagSize" ] = p.tagSize;
  j[ "pTag" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pTag ) );
}
inline void to_json( nlohmann::json &j, const VkDebugMarkerObjectTagInfoEXT &p ) {
  to_json( j, DebugMarkerObjectTagInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DebugMarkerObjectTagInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugMarkerObjectTagInfoEXT" );
  p.objectType = j[ "objectType" ];
  p.object = j[ "object" ];
  p.tagName = j[ "tagName" ];
  p.tagSize = j[ "tagSize" ];
}
inline void from_json( const nlohmann::json &j, VkDebugMarkerObjectTagInfoEXT &p ) {
  DebugMarkerObjectTagInfoEXT temp;
  from_json( j, temp );
  p = VkDebugMarkerObjectTagInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DebugReportCallbackCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pfnCallback" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnCallback ) );
  j[ "pUserData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pUserData ) );
}
inline void to_json( nlohmann::json &j, const VkDebugReportCallbackCreateInfoEXT &p ) {
  to_json( j, DebugReportCallbackCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DebugReportCallbackCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugReportCallbackCreateInfoEXT" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkDebugReportCallbackCreateInfoEXT &p ) {
  DebugReportCallbackCreateInfoEXT temp;
  from_json( j, temp );
  p = VkDebugReportCallbackCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DebugUtilsLabelEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  if( p.pLabelName ) j[ "pLabelName" ] = std::string( p.pLabelName );
  j[ "color" ] = nlohmann::json::array();
  std::copy( p.color.begin(), p.color.end(), std::back_inserter( j[ "color" ] ) );
}
inline void to_json( nlohmann::json &j, const VkDebugUtilsLabelEXT &p ) {
  to_json( j, DebugUtilsLabelEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DebugUtilsLabelEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugUtilsLabelEXT" );
  if( !j[ "color" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for DebugUtilsLabelEXT.color" );
  if( !j[ "color" ].size() > p.color.size() ) throw vulkan2json::invalid_array_value( "too many values in array for DebugUtilsLabelEXT.color" );
  std::fill( p.color.begin(), p.color.end(), 0 );
  std::copy( j[ "color" ].begin(), j[ "color" ].end(), p.color.begin() );
}
inline void from_json( const nlohmann::json &j, VkDebugUtilsLabelEXT &p ) {
  DebugUtilsLabelEXT temp;
  from_json( j, temp );
  p = VkDebugUtilsLabelEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DebugUtilsObjectNameInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "objectType" ] = p.objectType;
  j[ "objectHandle" ] = p.objectHandle;
  if( p.pObjectName ) j[ "pObjectName" ] = std::string( p.pObjectName );
}
inline void to_json( nlohmann::json &j, const VkDebugUtilsObjectNameInfoEXT &p ) {
  to_json( j, DebugUtilsObjectNameInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DebugUtilsObjectNameInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugUtilsObjectNameInfoEXT" );
  p.objectType = j[ "objectType" ];
  p.objectHandle = j[ "objectHandle" ];
}
inline void from_json( const nlohmann::json &j, VkDebugUtilsObjectNameInfoEXT &p ) {
  DebugUtilsObjectNameInfoEXT temp;
  from_json( j, temp );
  p = VkDebugUtilsObjectNameInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DebugUtilsMessengerCallbackDataEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  if( p.pMessageIdName ) j[ "pMessageIdName" ] = std::string( p.pMessageIdName );
  j[ "messageIdNumber" ] = p.messageIdNumber;
  if( p.pMessage ) j[ "pMessage" ] = std::string( p.pMessage );
  j[ "queueLabelCount" ] = p.queueLabelCount;
  j[ "pQueueLabels" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pQueueLabels ) );
  j[ "cmdBufLabelCount" ] = p.cmdBufLabelCount;
  j[ "pCmdBufLabels" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCmdBufLabels ) );
  j[ "objectCount" ] = p.objectCount;
  j[ "pObjects" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pObjects ) );
}
inline void to_json( nlohmann::json &j, const VkDebugUtilsMessengerCallbackDataEXT &p ) {
  to_json( j, DebugUtilsMessengerCallbackDataEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DebugUtilsMessengerCallbackDataEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugUtilsMessengerCallbackDataEXT" );
  p.flags = j[ "flags" ];
  p.messageIdNumber = j[ "messageIdNumber" ];
  p.queueLabelCount = j[ "queueLabelCount" ];
  p.cmdBufLabelCount = j[ "cmdBufLabelCount" ];
  p.objectCount = j[ "objectCount" ];
}
inline void from_json( const nlohmann::json &j, VkDebugUtilsMessengerCallbackDataEXT &p ) {
  DebugUtilsMessengerCallbackDataEXT temp;
  from_json( j, temp );
  p = VkDebugUtilsMessengerCallbackDataEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DebugUtilsMessengerCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "messageSeverity" ] = p.messageSeverity;
  j[ "messageType" ] = p.messageType;
  j[ "pfnUserCallback" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnUserCallback ) );
  j[ "pUserData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pUserData ) );
}
inline void to_json( nlohmann::json &j, const VkDebugUtilsMessengerCreateInfoEXT &p ) {
  to_json( j, DebugUtilsMessengerCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DebugUtilsMessengerCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugUtilsMessengerCreateInfoEXT" );
  p.flags = j[ "flags" ];
  p.messageSeverity = j[ "messageSeverity" ];
  p.messageType = j[ "messageType" ];
}
inline void from_json( const nlohmann::json &j, VkDebugUtilsMessengerCreateInfoEXT &p ) {
  DebugUtilsMessengerCreateInfoEXT temp;
  from_json( j, temp );
  p = VkDebugUtilsMessengerCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DebugUtilsObjectTagInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "objectType" ] = p.objectType;
  j[ "objectHandle" ] = p.objectHandle;
  j[ "tagName" ] = p.tagName;
  j[ "tagSize" ] = p.tagSize;
  j[ "pTag" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pTag ) );
}
inline void to_json( nlohmann::json &j, const VkDebugUtilsObjectTagInfoEXT &p ) {
  to_json( j, DebugUtilsObjectTagInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DebugUtilsObjectTagInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DebugUtilsObjectTagInfoEXT" );
  p.objectType = j[ "objectType" ];
  p.objectHandle = j[ "objectHandle" ];
  p.tagName = j[ "tagName" ];
  p.tagSize = j[ "tagSize" ];
}
inline void from_json( const nlohmann::json &j, VkDebugUtilsObjectTagInfoEXT &p ) {
  DebugUtilsObjectTagInfoEXT temp;
  from_json( j, temp );
  p = VkDebugUtilsObjectTagInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DedicatedAllocationBufferCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dedicatedAllocation" ] = bool( p.dedicatedAllocation );
}
inline void to_json( nlohmann::json &j, const VkDedicatedAllocationBufferCreateInfoNV &p ) {
  to_json( j, DedicatedAllocationBufferCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, DedicatedAllocationBufferCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DedicatedAllocationBufferCreateInfoNV" );
  p.dedicatedAllocation = j[ "dedicatedAllocation" ];
}
inline void from_json( const nlohmann::json &j, VkDedicatedAllocationBufferCreateInfoNV &p ) {
  DedicatedAllocationBufferCreateInfoNV temp;
  from_json( j, temp );
  p = VkDedicatedAllocationBufferCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const DedicatedAllocationImageCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dedicatedAllocation" ] = bool( p.dedicatedAllocation );
}
inline void to_json( nlohmann::json &j, const VkDedicatedAllocationImageCreateInfoNV &p ) {
  to_json( j, DedicatedAllocationImageCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, DedicatedAllocationImageCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DedicatedAllocationImageCreateInfoNV" );
  p.dedicatedAllocation = j[ "dedicatedAllocation" ];
}
inline void from_json( const nlohmann::json &j, VkDedicatedAllocationImageCreateInfoNV &p ) {
  DedicatedAllocationImageCreateInfoNV temp;
  from_json( j, temp );
  p = VkDedicatedAllocationImageCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const DedicatedAllocationMemoryAllocateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkDedicatedAllocationMemoryAllocateInfoNV &p ) {
  to_json( j, DedicatedAllocationMemoryAllocateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, DedicatedAllocationMemoryAllocateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DedicatedAllocationMemoryAllocateInfoNV" );
}
inline void from_json( const nlohmann::json &j, VkDedicatedAllocationMemoryAllocateInfoNV &p ) {
  DedicatedAllocationMemoryAllocateInfoNV temp;
  from_json( j, temp );
  p = VkDedicatedAllocationMemoryAllocateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const MemoryBarrier2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcStageMask" ] = p.srcStageMask;
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstStageMask" ] = p.dstStageMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
}
inline void to_json( nlohmann::json &j, const VkMemoryBarrier2KHR &p ) {
  to_json( j, MemoryBarrier2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryBarrier2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryBarrier2KHR" );
  p.srcStageMask = j[ "srcStageMask" ];
  p.srcAccessMask = j[ "srcAccessMask" ];
  p.dstStageMask = j[ "dstStageMask" ];
  p.dstAccessMask = j[ "dstAccessMask" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryBarrier2KHR &p ) {
  MemoryBarrier2KHR temp;
  from_json( j, temp );
  p = VkMemoryBarrier2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const ImageSubresourceRange &p ) {
  j = nlohmann::json::object();
  j[ "aspectMask" ] = p.aspectMask;
  j[ "baseMipLevel" ] = p.baseMipLevel;
  j[ "levelCount" ] = p.levelCount;
  j[ "baseArrayLayer" ] = p.baseArrayLayer;
  j[ "layerCount" ] = p.layerCount;
}
inline void to_json( nlohmann::json &j, const VkImageSubresourceRange &p ) {
  to_json( j, ImageSubresourceRange ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageSubresourceRange &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageSubresourceRange" );
  p.aspectMask = j[ "aspectMask" ];
  p.baseMipLevel = j[ "baseMipLevel" ];
  p.levelCount = j[ "levelCount" ];
  p.baseArrayLayer = j[ "baseArrayLayer" ];
  p.layerCount = j[ "layerCount" ];
}
inline void from_json( const nlohmann::json &j, VkImageSubresourceRange &p ) {
  ImageSubresourceRange temp;
  from_json( j, temp );
  p = VkImageSubresourceRange ( temp );
}

inline void to_json( nlohmann::json &j, const ImageMemoryBarrier2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcStageMask" ] = p.srcStageMask;
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstStageMask" ] = p.dstStageMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
  j[ "oldLayout" ] = p.oldLayout;
  j[ "newLayout" ] = p.newLayout;
  j[ "srcQueueFamilyIndex" ] = p.srcQueueFamilyIndex;
  j[ "dstQueueFamilyIndex" ] = p.dstQueueFamilyIndex;
  j[ "subresourceRange" ] = p.subresourceRange;
}
inline void to_json( nlohmann::json &j, const VkImageMemoryBarrier2KHR &p ) {
  to_json( j, ImageMemoryBarrier2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageMemoryBarrier2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageMemoryBarrier2KHR" );
  p.srcStageMask = j[ "srcStageMask" ];
  p.srcAccessMask = j[ "srcAccessMask" ];
  p.dstStageMask = j[ "dstStageMask" ];
  p.dstAccessMask = j[ "dstAccessMask" ];
  p.oldLayout = j[ "oldLayout" ];
  p.newLayout = j[ "newLayout" ];
  p.srcQueueFamilyIndex = j[ "srcQueueFamilyIndex" ];
  p.dstQueueFamilyIndex = j[ "dstQueueFamilyIndex" ];
  p.subresourceRange = j[ "subresourceRange" ];
}
inline void from_json( const nlohmann::json &j, VkImageMemoryBarrier2KHR &p ) {
  ImageMemoryBarrier2KHR temp;
  from_json( j, temp );
  p = VkImageMemoryBarrier2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const DependencyInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dependencyFlags" ] = p.dependencyFlags;
  j[ "memoryBarrierCount" ] = p.memoryBarrierCount;
  j[ "pMemoryBarriers" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pMemoryBarriers ) );
  j[ "bufferMemoryBarrierCount" ] = p.bufferMemoryBarrierCount;
  j[ "pBufferMemoryBarriers" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBufferMemoryBarriers ) );
  j[ "imageMemoryBarrierCount" ] = p.imageMemoryBarrierCount;
  j[ "pImageMemoryBarriers" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pImageMemoryBarriers ) );
}
inline void to_json( nlohmann::json &j, const VkDependencyInfoKHR &p ) {
  to_json( j, DependencyInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DependencyInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DependencyInfoKHR" );
  p.dependencyFlags = j[ "dependencyFlags" ];
  p.memoryBarrierCount = j[ "memoryBarrierCount" ];
  p.bufferMemoryBarrierCount = j[ "bufferMemoryBarrierCount" ];
  p.imageMemoryBarrierCount = j[ "imageMemoryBarrierCount" ];
}
inline void from_json( const nlohmann::json &j, VkDependencyInfoKHR &p ) {
  DependencyInfoKHR temp;
  from_json( j, temp );
  p = VkDependencyInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const DescriptorBufferInfo &p ) {
  j = nlohmann::json::object();
  j[ "offset" ] = p.offset;
  j[ "range" ] = p.range;
}
inline void to_json( nlohmann::json &j, const VkDescriptorBufferInfo &p ) {
  to_json( j, DescriptorBufferInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorBufferInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorBufferInfo" );
  p.offset = j[ "offset" ];
  p.range = j[ "range" ];
}
inline void from_json( const nlohmann::json &j, VkDescriptorBufferInfo &p ) {
  DescriptorBufferInfo temp;
  from_json( j, temp );
  p = VkDescriptorBufferInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DescriptorImageInfo &p ) {
  j = nlohmann::json::object();
  j[ "imageLayout" ] = p.imageLayout;
}
inline void to_json( nlohmann::json &j, const VkDescriptorImageInfo &p ) {
  to_json( j, DescriptorImageInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorImageInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorImageInfo" );
  p.imageLayout = j[ "imageLayout" ];
}
inline void from_json( const nlohmann::json &j, VkDescriptorImageInfo &p ) {
  DescriptorImageInfo temp;
  from_json( j, temp );
  p = VkDescriptorImageInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DescriptorPoolSize &p ) {
  j = nlohmann::json::object();
  j[ "type" ] = p.type;
  j[ "descriptorCount" ] = p.descriptorCount;
}
inline void to_json( nlohmann::json &j, const VkDescriptorPoolSize &p ) {
  to_json( j, DescriptorPoolSize ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorPoolSize &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorPoolSize" );
  p.type = j[ "type" ];
  p.descriptorCount = j[ "descriptorCount" ];
}
inline void from_json( const nlohmann::json &j, VkDescriptorPoolSize &p ) {
  DescriptorPoolSize temp;
  from_json( j, temp );
  p = VkDescriptorPoolSize ( temp );
}

inline void to_json( nlohmann::json &j, const DescriptorPoolCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "maxSets" ] = p.maxSets;
  j[ "poolSizeCount" ] = p.poolSizeCount;
  j[ "pPoolSizes" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPoolSizes ) );
}
inline void to_json( nlohmann::json &j, const VkDescriptorPoolCreateInfo &p ) {
  to_json( j, DescriptorPoolCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorPoolCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorPoolCreateInfo" );
  p.flags = j[ "flags" ];
  p.maxSets = j[ "maxSets" ];
  p.poolSizeCount = j[ "poolSizeCount" ];
}
inline void from_json( const nlohmann::json &j, VkDescriptorPoolCreateInfo &p ) {
  DescriptorPoolCreateInfo temp;
  from_json( j, temp );
  p = VkDescriptorPoolCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DescriptorPoolInlineUniformBlockCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxInlineUniformBlockBindings" ] = p.maxInlineUniformBlockBindings;
}
inline void to_json( nlohmann::json &j, const VkDescriptorPoolInlineUniformBlockCreateInfoEXT &p ) {
  to_json( j, DescriptorPoolInlineUniformBlockCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorPoolInlineUniformBlockCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorPoolInlineUniformBlockCreateInfoEXT" );
  p.maxInlineUniformBlockBindings = j[ "maxInlineUniformBlockBindings" ];
}
inline void from_json( const nlohmann::json &j, VkDescriptorPoolInlineUniformBlockCreateInfoEXT &p ) {
  DescriptorPoolInlineUniformBlockCreateInfoEXT temp;
  from_json( j, temp );
  p = VkDescriptorPoolInlineUniformBlockCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DescriptorSetAllocateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "descriptorSetCount" ] = p.descriptorSetCount;
  j[ "pSetLayouts" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSetLayouts ) );
}
inline void to_json( nlohmann::json &j, const VkDescriptorSetAllocateInfo &p ) {
  to_json( j, DescriptorSetAllocateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorSetAllocateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorSetAllocateInfo" );
  p.descriptorSetCount = j[ "descriptorSetCount" ];
}
inline void from_json( const nlohmann::json &j, VkDescriptorSetAllocateInfo &p ) {
  DescriptorSetAllocateInfo temp;
  from_json( j, temp );
  p = VkDescriptorSetAllocateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DescriptorSetLayoutBinding &p ) {
  j = nlohmann::json::object();
  j[ "binding" ] = p.binding;
  j[ "descriptorType" ] = p.descriptorType;
  j[ "descriptorCount" ] = p.descriptorCount;
  j[ "stageFlags" ] = p.stageFlags;
  j[ "pImmutableSamplers" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pImmutableSamplers ) );
}
inline void to_json( nlohmann::json &j, const VkDescriptorSetLayoutBinding &p ) {
  to_json( j, DescriptorSetLayoutBinding ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorSetLayoutBinding &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorSetLayoutBinding" );
  p.binding = j[ "binding" ];
  p.descriptorType = j[ "descriptorType" ];
  p.descriptorCount = j[ "descriptorCount" ];
  p.stageFlags = j[ "stageFlags" ];
}
inline void from_json( const nlohmann::json &j, VkDescriptorSetLayoutBinding &p ) {
  DescriptorSetLayoutBinding temp;
  from_json( j, temp );
  p = VkDescriptorSetLayoutBinding ( temp );
}

inline void to_json( nlohmann::json &j, const DescriptorSetLayoutBindingFlagsCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "bindingCount" ] = p.bindingCount;
  j[ "pBindingFlags" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBindingFlags ) );
}
inline void to_json( nlohmann::json &j, const VkDescriptorSetLayoutBindingFlagsCreateInfo &p ) {
  to_json( j, DescriptorSetLayoutBindingFlagsCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorSetLayoutBindingFlagsCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorSetLayoutBindingFlagsCreateInfo" );
  p.bindingCount = j[ "bindingCount" ];
}
inline void from_json( const nlohmann::json &j, VkDescriptorSetLayoutBindingFlagsCreateInfo &p ) {
  DescriptorSetLayoutBindingFlagsCreateInfo temp;
  from_json( j, temp );
  p = VkDescriptorSetLayoutBindingFlagsCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DescriptorSetLayoutCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "bindingCount" ] = p.bindingCount;
  j[ "pBindings" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBindings ) );
}
inline void to_json( nlohmann::json &j, const VkDescriptorSetLayoutCreateInfo &p ) {
  to_json( j, DescriptorSetLayoutCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorSetLayoutCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorSetLayoutCreateInfo" );
  p.flags = j[ "flags" ];
  p.bindingCount = j[ "bindingCount" ];
}
inline void from_json( const nlohmann::json &j, VkDescriptorSetLayoutCreateInfo &p ) {
  DescriptorSetLayoutCreateInfo temp;
  from_json( j, temp );
  p = VkDescriptorSetLayoutCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DescriptorSetLayoutSupport &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "supported" ] = bool( p.supported );
}
inline void to_json( nlohmann::json &j, const VkDescriptorSetLayoutSupport &p ) {
  to_json( j, DescriptorSetLayoutSupport ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorSetLayoutSupport &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorSetLayoutSupport" );
  p.supported = j[ "supported" ];
}
inline void from_json( const nlohmann::json &j, VkDescriptorSetLayoutSupport &p ) {
  DescriptorSetLayoutSupport temp;
  from_json( j, temp );
  p = VkDescriptorSetLayoutSupport ( temp );
}

inline void to_json( nlohmann::json &j, const DescriptorSetVariableDescriptorCountAllocateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "descriptorSetCount" ] = p.descriptorSetCount;
  j[ "pDescriptorCounts" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDescriptorCounts ) );
}
inline void to_json( nlohmann::json &j, const VkDescriptorSetVariableDescriptorCountAllocateInfo &p ) {
  to_json( j, DescriptorSetVariableDescriptorCountAllocateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorSetVariableDescriptorCountAllocateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorSetVariableDescriptorCountAllocateInfo" );
  p.descriptorSetCount = j[ "descriptorSetCount" ];
}
inline void from_json( const nlohmann::json &j, VkDescriptorSetVariableDescriptorCountAllocateInfo &p ) {
  DescriptorSetVariableDescriptorCountAllocateInfo temp;
  from_json( j, temp );
  p = VkDescriptorSetVariableDescriptorCountAllocateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DescriptorSetVariableDescriptorCountLayoutSupport &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxVariableDescriptorCount" ] = p.maxVariableDescriptorCount;
}
inline void to_json( nlohmann::json &j, const VkDescriptorSetVariableDescriptorCountLayoutSupport &p ) {
  to_json( j, DescriptorSetVariableDescriptorCountLayoutSupport ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorSetVariableDescriptorCountLayoutSupport &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorSetVariableDescriptorCountLayoutSupport" );
  p.maxVariableDescriptorCount = j[ "maxVariableDescriptorCount" ];
}
inline void from_json( const nlohmann::json &j, VkDescriptorSetVariableDescriptorCountLayoutSupport &p ) {
  DescriptorSetVariableDescriptorCountLayoutSupport temp;
  from_json( j, temp );
  p = VkDescriptorSetVariableDescriptorCountLayoutSupport ( temp );
}

inline void to_json( nlohmann::json &j, const DescriptorUpdateTemplateEntry &p ) {
  j = nlohmann::json::object();
  j[ "dstBinding" ] = p.dstBinding;
  j[ "dstArrayElement" ] = p.dstArrayElement;
  j[ "descriptorCount" ] = p.descriptorCount;
  j[ "descriptorType" ] = p.descriptorType;
  j[ "offset" ] = p.offset;
  j[ "stride" ] = p.stride;
}
inline void to_json( nlohmann::json &j, const VkDescriptorUpdateTemplateEntry &p ) {
  to_json( j, DescriptorUpdateTemplateEntry ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorUpdateTemplateEntry &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorUpdateTemplateEntry" );
  p.dstBinding = j[ "dstBinding" ];
  p.dstArrayElement = j[ "dstArrayElement" ];
  p.descriptorCount = j[ "descriptorCount" ];
  p.descriptorType = j[ "descriptorType" ];
  p.offset = j[ "offset" ];
  p.stride = j[ "stride" ];
}
inline void from_json( const nlohmann::json &j, VkDescriptorUpdateTemplateEntry &p ) {
  DescriptorUpdateTemplateEntry temp;
  from_json( j, temp );
  p = VkDescriptorUpdateTemplateEntry ( temp );
}

inline void to_json( nlohmann::json &j, const DescriptorUpdateTemplateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "descriptorUpdateEntryCount" ] = p.descriptorUpdateEntryCount;
  j[ "pDescriptorUpdateEntries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDescriptorUpdateEntries ) );
  j[ "templateType" ] = p.templateType;
  j[ "pipelineBindPoint" ] = p.pipelineBindPoint;
  j[ "set" ] = p.set;
}
inline void to_json( nlohmann::json &j, const VkDescriptorUpdateTemplateCreateInfo &p ) {
  to_json( j, DescriptorUpdateTemplateCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DescriptorUpdateTemplateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DescriptorUpdateTemplateCreateInfo" );
  p.flags = j[ "flags" ];
  p.descriptorUpdateEntryCount = j[ "descriptorUpdateEntryCount" ];
  p.templateType = j[ "templateType" ];
  p.pipelineBindPoint = j[ "pipelineBindPoint" ];
  p.set = j[ "set" ];
}
inline void from_json( const nlohmann::json &j, VkDescriptorUpdateTemplateCreateInfo &p ) {
  DescriptorUpdateTemplateCreateInfo temp;
  from_json( j, temp );
  p = VkDescriptorUpdateTemplateCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceQueueCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "queueFamilyIndex" ] = p.queueFamilyIndex;
  j[ "queueCount" ] = p.queueCount;
  j[ "pQueuePriorities" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pQueuePriorities ) );
}
inline void to_json( nlohmann::json &j, const VkDeviceQueueCreateInfo &p ) {
  to_json( j, DeviceQueueCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceQueueCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceQueueCreateInfo" );
  p.flags = j[ "flags" ];
  p.queueFamilyIndex = j[ "queueFamilyIndex" ];
  p.queueCount = j[ "queueCount" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceQueueCreateInfo &p ) {
  DeviceQueueCreateInfo temp;
  from_json( j, temp );
  p = VkDeviceQueueCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceFeatures &p ) {
  j = nlohmann::json::object();
  j[ "robustBufferAccess" ] = bool( p.robustBufferAccess );
  j[ "fullDrawIndexUint32" ] = bool( p.fullDrawIndexUint32 );
  j[ "imageCubeArray" ] = bool( p.imageCubeArray );
  j[ "independentBlend" ] = bool( p.independentBlend );
  j[ "geometryShader" ] = bool( p.geometryShader );
  j[ "tessellationShader" ] = bool( p.tessellationShader );
  j[ "sampleRateShading" ] = bool( p.sampleRateShading );
  j[ "dualSrcBlend" ] = bool( p.dualSrcBlend );
  j[ "logicOp" ] = bool( p.logicOp );
  j[ "multiDrawIndirect" ] = bool( p.multiDrawIndirect );
  j[ "drawIndirectFirstInstance" ] = bool( p.drawIndirectFirstInstance );
  j[ "depthClamp" ] = bool( p.depthClamp );
  j[ "depthBiasClamp" ] = bool( p.depthBiasClamp );
  j[ "fillModeNonSolid" ] = bool( p.fillModeNonSolid );
  j[ "depthBounds" ] = bool( p.depthBounds );
  j[ "wideLines" ] = bool( p.wideLines );
  j[ "largePoints" ] = bool( p.largePoints );
  j[ "alphaToOne" ] = bool( p.alphaToOne );
  j[ "multiViewport" ] = bool( p.multiViewport );
  j[ "samplerAnisotropy" ] = bool( p.samplerAnisotropy );
  j[ "textureCompressionETC2" ] = bool( p.textureCompressionETC2 );
  j[ "textureCompressionASTC_LDR" ] = bool( p.textureCompressionASTC_LDR );
  j[ "textureCompressionBC" ] = bool( p.textureCompressionBC );
  j[ "occlusionQueryPrecise" ] = bool( p.occlusionQueryPrecise );
  j[ "pipelineStatisticsQuery" ] = bool( p.pipelineStatisticsQuery );
  j[ "vertexPipelineStoresAndAtomics" ] = bool( p.vertexPipelineStoresAndAtomics );
  j[ "fragmentStoresAndAtomics" ] = bool( p.fragmentStoresAndAtomics );
  j[ "shaderTessellationAndGeometryPointSize" ] = bool( p.shaderTessellationAndGeometryPointSize );
  j[ "shaderImageGatherExtended" ] = bool( p.shaderImageGatherExtended );
  j[ "shaderStorageImageExtendedFormats" ] = bool( p.shaderStorageImageExtendedFormats );
  j[ "shaderStorageImageMultisample" ] = bool( p.shaderStorageImageMultisample );
  j[ "shaderStorageImageReadWithoutFormat" ] = bool( p.shaderStorageImageReadWithoutFormat );
  j[ "shaderStorageImageWriteWithoutFormat" ] = bool( p.shaderStorageImageWriteWithoutFormat );
  j[ "shaderUniformBufferArrayDynamicIndexing" ] = bool( p.shaderUniformBufferArrayDynamicIndexing );
  j[ "shaderSampledImageArrayDynamicIndexing" ] = bool( p.shaderSampledImageArrayDynamicIndexing );
  j[ "shaderStorageBufferArrayDynamicIndexing" ] = bool( p.shaderStorageBufferArrayDynamicIndexing );
  j[ "shaderStorageImageArrayDynamicIndexing" ] = bool( p.shaderStorageImageArrayDynamicIndexing );
  j[ "shaderClipDistance" ] = bool( p.shaderClipDistance );
  j[ "shaderCullDistance" ] = bool( p.shaderCullDistance );
  j[ "shaderFloat64" ] = bool( p.shaderFloat64 );
  j[ "shaderInt64" ] = bool( p.shaderInt64 );
  j[ "shaderInt16" ] = bool( p.shaderInt16 );
  j[ "shaderResourceResidency" ] = bool( p.shaderResourceResidency );
  j[ "shaderResourceMinLod" ] = bool( p.shaderResourceMinLod );
  j[ "sparseBinding" ] = bool( p.sparseBinding );
  j[ "sparseResidencyBuffer" ] = bool( p.sparseResidencyBuffer );
  j[ "sparseResidencyImage2D" ] = bool( p.sparseResidencyImage2D );
  j[ "sparseResidencyImage3D" ] = bool( p.sparseResidencyImage3D );
  j[ "sparseResidency2Samples" ] = bool( p.sparseResidency2Samples );
  j[ "sparseResidency4Samples" ] = bool( p.sparseResidency4Samples );
  j[ "sparseResidency8Samples" ] = bool( p.sparseResidency8Samples );
  j[ "sparseResidency16Samples" ] = bool( p.sparseResidency16Samples );
  j[ "sparseResidencyAliased" ] = bool( p.sparseResidencyAliased );
  j[ "variableMultisampleRate" ] = bool( p.variableMultisampleRate );
  j[ "inheritedQueries" ] = bool( p.inheritedQueries );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceFeatures &p ) {
  to_json( j, PhysicalDeviceFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFeatures" );
  p.robustBufferAccess = j[ "robustBufferAccess" ];
  p.fullDrawIndexUint32 = j[ "fullDrawIndexUint32" ];
  p.imageCubeArray = j[ "imageCubeArray" ];
  p.independentBlend = j[ "independentBlend" ];
  p.geometryShader = j[ "geometryShader" ];
  p.tessellationShader = j[ "tessellationShader" ];
  p.sampleRateShading = j[ "sampleRateShading" ];
  p.dualSrcBlend = j[ "dualSrcBlend" ];
  p.logicOp = j[ "logicOp" ];
  p.multiDrawIndirect = j[ "multiDrawIndirect" ];
  p.drawIndirectFirstInstance = j[ "drawIndirectFirstInstance" ];
  p.depthClamp = j[ "depthClamp" ];
  p.depthBiasClamp = j[ "depthBiasClamp" ];
  p.fillModeNonSolid = j[ "fillModeNonSolid" ];
  p.depthBounds = j[ "depthBounds" ];
  p.wideLines = j[ "wideLines" ];
  p.largePoints = j[ "largePoints" ];
  p.alphaToOne = j[ "alphaToOne" ];
  p.multiViewport = j[ "multiViewport" ];
  p.samplerAnisotropy = j[ "samplerAnisotropy" ];
  p.textureCompressionETC2 = j[ "textureCompressionETC2" ];
  p.textureCompressionASTC_LDR = j[ "textureCompressionASTC_LDR" ];
  p.textureCompressionBC = j[ "textureCompressionBC" ];
  p.occlusionQueryPrecise = j[ "occlusionQueryPrecise" ];
  p.pipelineStatisticsQuery = j[ "pipelineStatisticsQuery" ];
  p.vertexPipelineStoresAndAtomics = j[ "vertexPipelineStoresAndAtomics" ];
  p.fragmentStoresAndAtomics = j[ "fragmentStoresAndAtomics" ];
  p.shaderTessellationAndGeometryPointSize = j[ "shaderTessellationAndGeometryPointSize" ];
  p.shaderImageGatherExtended = j[ "shaderImageGatherExtended" ];
  p.shaderStorageImageExtendedFormats = j[ "shaderStorageImageExtendedFormats" ];
  p.shaderStorageImageMultisample = j[ "shaderStorageImageMultisample" ];
  p.shaderStorageImageReadWithoutFormat = j[ "shaderStorageImageReadWithoutFormat" ];
  p.shaderStorageImageWriteWithoutFormat = j[ "shaderStorageImageWriteWithoutFormat" ];
  p.shaderUniformBufferArrayDynamicIndexing = j[ "shaderUniformBufferArrayDynamicIndexing" ];
  p.shaderSampledImageArrayDynamicIndexing = j[ "shaderSampledImageArrayDynamicIndexing" ];
  p.shaderStorageBufferArrayDynamicIndexing = j[ "shaderStorageBufferArrayDynamicIndexing" ];
  p.shaderStorageImageArrayDynamicIndexing = j[ "shaderStorageImageArrayDynamicIndexing" ];
  p.shaderClipDistance = j[ "shaderClipDistance" ];
  p.shaderCullDistance = j[ "shaderCullDistance" ];
  p.shaderFloat64 = j[ "shaderFloat64" ];
  p.shaderInt64 = j[ "shaderInt64" ];
  p.shaderInt16 = j[ "shaderInt16" ];
  p.shaderResourceResidency = j[ "shaderResourceResidency" ];
  p.shaderResourceMinLod = j[ "shaderResourceMinLod" ];
  p.sparseBinding = j[ "sparseBinding" ];
  p.sparseResidencyBuffer = j[ "sparseResidencyBuffer" ];
  p.sparseResidencyImage2D = j[ "sparseResidencyImage2D" ];
  p.sparseResidencyImage3D = j[ "sparseResidencyImage3D" ];
  p.sparseResidency2Samples = j[ "sparseResidency2Samples" ];
  p.sparseResidency4Samples = j[ "sparseResidency4Samples" ];
  p.sparseResidency8Samples = j[ "sparseResidency8Samples" ];
  p.sparseResidency16Samples = j[ "sparseResidency16Samples" ];
  p.sparseResidencyAliased = j[ "sparseResidencyAliased" ];
  p.variableMultisampleRate = j[ "variableMultisampleRate" ];
  p.inheritedQueries = j[ "inheritedQueries" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceFeatures &p ) {
  PhysicalDeviceFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "queueCreateInfoCount" ] = p.queueCreateInfoCount;
  j[ "pQueueCreateInfos" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pQueueCreateInfos ) );
  j[ "enabledLayerCount" ] = p.enabledLayerCount;
  j[ "ppEnabledLayerNames" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.ppEnabledLayerNames ) );
  j[ "enabledExtensionCount" ] = p.enabledExtensionCount;
  j[ "ppEnabledExtensionNames" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.ppEnabledExtensionNames ) );
  j[ "pEnabledFeatures" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pEnabledFeatures ) );
}
inline void to_json( nlohmann::json &j, const VkDeviceCreateInfo &p ) {
  to_json( j, DeviceCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceCreateInfo" );
  p.flags = j[ "flags" ];
  p.queueCreateInfoCount = j[ "queueCreateInfoCount" ];
  p.enabledLayerCount = j[ "enabledLayerCount" ];
  p.enabledExtensionCount = j[ "enabledExtensionCount" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceCreateInfo &p ) {
  DeviceCreateInfo temp;
  from_json( j, temp );
  p = VkDeviceCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceDeviceMemoryReportCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pfnUserCallback" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pfnUserCallback ) );
  j[ "pUserData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pUserData ) );
}
inline void to_json( nlohmann::json &j, const VkDeviceDeviceMemoryReportCreateInfoEXT &p ) {
  to_json( j, DeviceDeviceMemoryReportCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceDeviceMemoryReportCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceDeviceMemoryReportCreateInfoEXT" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceDeviceMemoryReportCreateInfoEXT &p ) {
  DeviceDeviceMemoryReportCreateInfoEXT temp;
  from_json( j, temp );
  p = VkDeviceDeviceMemoryReportCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceDiagnosticsConfigCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkDeviceDiagnosticsConfigCreateInfoNV &p ) {
  to_json( j, DeviceDiagnosticsConfigCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceDiagnosticsConfigCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceDiagnosticsConfigCreateInfoNV" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceDiagnosticsConfigCreateInfoNV &p ) {
  DeviceDiagnosticsConfigCreateInfoNV temp;
  from_json( j, temp );
  p = VkDeviceDiagnosticsConfigCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceEventInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceEvent" ] = p.deviceEvent;
}
inline void to_json( nlohmann::json &j, const VkDeviceEventInfoEXT &p ) {
  to_json( j, DeviceEventInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceEventInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceEventInfoEXT" );
  p.deviceEvent = j[ "deviceEvent" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceEventInfoEXT &p ) {
  DeviceEventInfoEXT temp;
  from_json( j, temp );
  p = VkDeviceEventInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceGroupBindSparseInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "resourceDeviceIndex" ] = p.resourceDeviceIndex;
  j[ "memoryDeviceIndex" ] = p.memoryDeviceIndex;
}
inline void to_json( nlohmann::json &j, const VkDeviceGroupBindSparseInfo &p ) {
  to_json( j, DeviceGroupBindSparseInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceGroupBindSparseInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupBindSparseInfo" );
  p.resourceDeviceIndex = j[ "resourceDeviceIndex" ];
  p.memoryDeviceIndex = j[ "memoryDeviceIndex" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceGroupBindSparseInfo &p ) {
  DeviceGroupBindSparseInfo temp;
  from_json( j, temp );
  p = VkDeviceGroupBindSparseInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceGroupCommandBufferBeginInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceMask" ] = p.deviceMask;
}
inline void to_json( nlohmann::json &j, const VkDeviceGroupCommandBufferBeginInfo &p ) {
  to_json( j, DeviceGroupCommandBufferBeginInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceGroupCommandBufferBeginInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupCommandBufferBeginInfo" );
  p.deviceMask = j[ "deviceMask" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceGroupCommandBufferBeginInfo &p ) {
  DeviceGroupCommandBufferBeginInfo temp;
  from_json( j, temp );
  p = VkDeviceGroupCommandBufferBeginInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceGroupDeviceCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "physicalDeviceCount" ] = p.physicalDeviceCount;
  j[ "pPhysicalDevices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPhysicalDevices ) );
}
inline void to_json( nlohmann::json &j, const VkDeviceGroupDeviceCreateInfo &p ) {
  to_json( j, DeviceGroupDeviceCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceGroupDeviceCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupDeviceCreateInfo" );
  p.physicalDeviceCount = j[ "physicalDeviceCount" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceGroupDeviceCreateInfo &p ) {
  DeviceGroupDeviceCreateInfo temp;
  from_json( j, temp );
  p = VkDeviceGroupDeviceCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceGroupPresentCapabilitiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "presentMask" ] = nlohmann::json::array();
  std::copy( p.presentMask.begin(), p.presentMask.end(), std::back_inserter( j[ "presentMask" ] ) );
  j[ "modes" ] = p.modes;
}
inline void to_json( nlohmann::json &j, const VkDeviceGroupPresentCapabilitiesKHR &p ) {
  to_json( j, DeviceGroupPresentCapabilitiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceGroupPresentCapabilitiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupPresentCapabilitiesKHR" );
  if( !j[ "presentMask" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for DeviceGroupPresentCapabilitiesKHR.presentMask" );
  if( !j[ "presentMask" ].size() > p.presentMask.size() ) throw vulkan2json::invalid_array_value( "too many values in array for DeviceGroupPresentCapabilitiesKHR.presentMask" );
  std::fill( p.presentMask.begin(), p.presentMask.end(), 0 );
  std::copy( j[ "presentMask" ].begin(), j[ "presentMask" ].end(), p.presentMask.begin() );
  p.modes = j[ "modes" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceGroupPresentCapabilitiesKHR &p ) {
  DeviceGroupPresentCapabilitiesKHR temp;
  from_json( j, temp );
  p = VkDeviceGroupPresentCapabilitiesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceGroupPresentInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "swapchainCount" ] = p.swapchainCount;
  j[ "pDeviceMasks" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDeviceMasks ) );
  j[ "mode" ] = p.mode;
}
inline void to_json( nlohmann::json &j, const VkDeviceGroupPresentInfoKHR &p ) {
  to_json( j, DeviceGroupPresentInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceGroupPresentInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupPresentInfoKHR" );
  p.swapchainCount = j[ "swapchainCount" ];
  p.mode = j[ "mode" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceGroupPresentInfoKHR &p ) {
  DeviceGroupPresentInfoKHR temp;
  from_json( j, temp );
  p = VkDeviceGroupPresentInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceGroupRenderPassBeginInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceMask" ] = p.deviceMask;
  j[ "deviceRenderAreaCount" ] = p.deviceRenderAreaCount;
  j[ "pDeviceRenderAreas" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDeviceRenderAreas ) );
}
inline void to_json( nlohmann::json &j, const VkDeviceGroupRenderPassBeginInfo &p ) {
  to_json( j, DeviceGroupRenderPassBeginInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceGroupRenderPassBeginInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupRenderPassBeginInfo" );
  p.deviceMask = j[ "deviceMask" ];
  p.deviceRenderAreaCount = j[ "deviceRenderAreaCount" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceGroupRenderPassBeginInfo &p ) {
  DeviceGroupRenderPassBeginInfo temp;
  from_json( j, temp );
  p = VkDeviceGroupRenderPassBeginInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceGroupSubmitInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "waitSemaphoreCount" ] = p.waitSemaphoreCount;
  j[ "pWaitSemaphoreDeviceIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitSemaphoreDeviceIndices ) );
  j[ "commandBufferCount" ] = p.commandBufferCount;
  j[ "pCommandBufferDeviceMasks" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCommandBufferDeviceMasks ) );
  j[ "signalSemaphoreCount" ] = p.signalSemaphoreCount;
  j[ "pSignalSemaphoreDeviceIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSignalSemaphoreDeviceIndices ) );
}
inline void to_json( nlohmann::json &j, const VkDeviceGroupSubmitInfo &p ) {
  to_json( j, DeviceGroupSubmitInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceGroupSubmitInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupSubmitInfo" );
  p.waitSemaphoreCount = j[ "waitSemaphoreCount" ];
  p.commandBufferCount = j[ "commandBufferCount" ];
  p.signalSemaphoreCount = j[ "signalSemaphoreCount" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceGroupSubmitInfo &p ) {
  DeviceGroupSubmitInfo temp;
  from_json( j, temp );
  p = VkDeviceGroupSubmitInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceGroupSwapchainCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "modes" ] = p.modes;
}
inline void to_json( nlohmann::json &j, const VkDeviceGroupSwapchainCreateInfoKHR &p ) {
  to_json( j, DeviceGroupSwapchainCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceGroupSwapchainCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceGroupSwapchainCreateInfoKHR" );
  p.modes = j[ "modes" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceGroupSwapchainCreateInfoKHR &p ) {
  DeviceGroupSwapchainCreateInfoKHR temp;
  from_json( j, temp );
  p = VkDeviceGroupSwapchainCreateInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceMemoryOpaqueCaptureAddressInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkDeviceMemoryOpaqueCaptureAddressInfo &p ) {
  to_json( j, DeviceMemoryOpaqueCaptureAddressInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceMemoryOpaqueCaptureAddressInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceMemoryOpaqueCaptureAddressInfo" );
}
inline void from_json( const nlohmann::json &j, VkDeviceMemoryOpaqueCaptureAddressInfo &p ) {
  DeviceMemoryOpaqueCaptureAddressInfo temp;
  from_json( j, temp );
  p = VkDeviceMemoryOpaqueCaptureAddressInfo ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceMemoryOverallocationCreateInfoAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "overallocationBehavior" ] = p.overallocationBehavior;
}
inline void to_json( nlohmann::json &j, const VkDeviceMemoryOverallocationCreateInfoAMD &p ) {
  to_json( j, DeviceMemoryOverallocationCreateInfoAMD ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceMemoryOverallocationCreateInfoAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceMemoryOverallocationCreateInfoAMD" );
  p.overallocationBehavior = j[ "overallocationBehavior" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceMemoryOverallocationCreateInfoAMD &p ) {
  DeviceMemoryOverallocationCreateInfoAMD temp;
  from_json( j, temp );
  p = VkDeviceMemoryOverallocationCreateInfoAMD ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceMemoryReportCallbackDataEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "type" ] = p.type;
  j[ "memoryObjectId" ] = p.memoryObjectId;
  j[ "size" ] = p.size;
  j[ "objectType" ] = p.objectType;
  j[ "objectHandle" ] = p.objectHandle;
  j[ "heapIndex" ] = p.heapIndex;
}
inline void to_json( nlohmann::json &j, const VkDeviceMemoryReportCallbackDataEXT &p ) {
  to_json( j, DeviceMemoryReportCallbackDataEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceMemoryReportCallbackDataEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceMemoryReportCallbackDataEXT" );
  p.flags = j[ "flags" ];
  p.type = j[ "type" ];
  p.memoryObjectId = j[ "memoryObjectId" ];
  p.size = j[ "size" ];
  p.objectType = j[ "objectType" ];
  p.objectHandle = j[ "objectHandle" ];
  p.heapIndex = j[ "heapIndex" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceMemoryReportCallbackDataEXT &p ) {
  DeviceMemoryReportCallbackDataEXT temp;
  from_json( j, temp );
  p = VkDeviceMemoryReportCallbackDataEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DevicePrivateDataCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "privateDataSlotRequestCount" ] = p.privateDataSlotRequestCount;
}
inline void to_json( nlohmann::json &j, const VkDevicePrivateDataCreateInfoEXT &p ) {
  to_json( j, DevicePrivateDataCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DevicePrivateDataCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DevicePrivateDataCreateInfoEXT" );
  p.privateDataSlotRequestCount = j[ "privateDataSlotRequestCount" ];
}
inline void from_json( const nlohmann::json &j, VkDevicePrivateDataCreateInfoEXT &p ) {
  DevicePrivateDataCreateInfoEXT temp;
  from_json( j, temp );
  p = VkDevicePrivateDataCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceQueueGlobalPriorityCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "globalPriority" ] = p.globalPriority;
}
inline void to_json( nlohmann::json &j, const VkDeviceQueueGlobalPriorityCreateInfoEXT &p ) {
  to_json( j, DeviceQueueGlobalPriorityCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceQueueGlobalPriorityCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceQueueGlobalPriorityCreateInfoEXT" );
  p.globalPriority = j[ "globalPriority" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceQueueGlobalPriorityCreateInfoEXT &p ) {
  DeviceQueueGlobalPriorityCreateInfoEXT temp;
  from_json( j, temp );
  p = VkDeviceQueueGlobalPriorityCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DeviceQueueInfo2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "queueFamilyIndex" ] = p.queueFamilyIndex;
  j[ "queueIndex" ] = p.queueIndex;
}
inline void to_json( nlohmann::json &j, const VkDeviceQueueInfo2 &p ) {
  to_json( j, DeviceQueueInfo2 ( p ) );
}
inline void from_json( const nlohmann::json &j, DeviceQueueInfo2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DeviceQueueInfo2" );
  p.flags = j[ "flags" ];
  p.queueFamilyIndex = j[ "queueFamilyIndex" ];
  p.queueIndex = j[ "queueIndex" ];
}
inline void from_json( const nlohmann::json &j, VkDeviceQueueInfo2 &p ) {
  DeviceQueueInfo2 temp;
  from_json( j, temp );
  p = VkDeviceQueueInfo2 ( temp );
}

#if defined( VK_USE_PLATFORM_DIRECTFB_EXT )
inline void to_json( nlohmann::json &j, const DirectFBSurfaceCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "dfb" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.dfb ) );
  j[ "surface" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.surface ) );
}
inline void to_json( nlohmann::json &j, const VkDirectFBSurfaceCreateInfoEXT &p ) {
  to_json( j, DirectFBSurfaceCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DirectFBSurfaceCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DirectFBSurfaceCreateInfoEXT" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkDirectFBSurfaceCreateInfoEXT &p ) {
  DirectFBSurfaceCreateInfoEXT temp;
  from_json( j, temp );
  p = VkDirectFBSurfaceCreateInfoEXT ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const DispatchIndirectCommand &p ) {
  j = nlohmann::json::object();
  j[ "x" ] = p.x;
  j[ "y" ] = p.y;
  j[ "z" ] = p.z;
}
inline void to_json( nlohmann::json &j, const VkDispatchIndirectCommand &p ) {
  to_json( j, DispatchIndirectCommand ( p ) );
}
inline void from_json( const nlohmann::json &j, DispatchIndirectCommand &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DispatchIndirectCommand" );
  p.x = j[ "x" ];
  p.y = j[ "y" ];
  p.z = j[ "z" ];
}
inline void from_json( const nlohmann::json &j, VkDispatchIndirectCommand &p ) {
  DispatchIndirectCommand temp;
  from_json( j, temp );
  p = VkDispatchIndirectCommand ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayEventInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "displayEvent" ] = p.displayEvent;
}
inline void to_json( nlohmann::json &j, const VkDisplayEventInfoEXT &p ) {
  to_json( j, DisplayEventInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayEventInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayEventInfoEXT" );
  p.displayEvent = j[ "displayEvent" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayEventInfoEXT &p ) {
  DisplayEventInfoEXT temp;
  from_json( j, temp );
  p = VkDisplayEventInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayModeParametersKHR &p ) {
  j = nlohmann::json::object();
  j[ "visibleRegion" ] = p.visibleRegion;
  j[ "refreshRate" ] = p.refreshRate;
}
inline void to_json( nlohmann::json &j, const VkDisplayModeParametersKHR &p ) {
  to_json( j, DisplayModeParametersKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayModeParametersKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayModeParametersKHR" );
  p.visibleRegion = j[ "visibleRegion" ];
  p.refreshRate = j[ "refreshRate" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayModeParametersKHR &p ) {
  DisplayModeParametersKHR temp;
  from_json( j, temp );
  p = VkDisplayModeParametersKHR ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayModeCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "parameters" ] = p.parameters;
}
inline void to_json( nlohmann::json &j, const VkDisplayModeCreateInfoKHR &p ) {
  to_json( j, DisplayModeCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayModeCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayModeCreateInfoKHR" );
  p.flags = j[ "flags" ];
  p.parameters = j[ "parameters" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayModeCreateInfoKHR &p ) {
  DisplayModeCreateInfoKHR temp;
  from_json( j, temp );
  p = VkDisplayModeCreateInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayModePropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "parameters" ] = p.parameters;
}
inline void to_json( nlohmann::json &j, const VkDisplayModePropertiesKHR &p ) {
  to_json( j, DisplayModePropertiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayModePropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayModePropertiesKHR" );
  p.parameters = j[ "parameters" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayModePropertiesKHR &p ) {
  DisplayModePropertiesKHR temp;
  from_json( j, temp );
  p = VkDisplayModePropertiesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayModeProperties2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "displayModeProperties" ] = p.displayModeProperties;
}
inline void to_json( nlohmann::json &j, const VkDisplayModeProperties2KHR &p ) {
  to_json( j, DisplayModeProperties2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayModeProperties2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayModeProperties2KHR" );
  p.displayModeProperties = j[ "displayModeProperties" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayModeProperties2KHR &p ) {
  DisplayModeProperties2KHR temp;
  from_json( j, temp );
  p = VkDisplayModeProperties2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayNativeHdrSurfaceCapabilitiesAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "localDimmingSupport" ] = bool( p.localDimmingSupport );
}
inline void to_json( nlohmann::json &j, const VkDisplayNativeHdrSurfaceCapabilitiesAMD &p ) {
  to_json( j, DisplayNativeHdrSurfaceCapabilitiesAMD ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayNativeHdrSurfaceCapabilitiesAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayNativeHdrSurfaceCapabilitiesAMD" );
  p.localDimmingSupport = j[ "localDimmingSupport" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayNativeHdrSurfaceCapabilitiesAMD &p ) {
  DisplayNativeHdrSurfaceCapabilitiesAMD temp;
  from_json( j, temp );
  p = VkDisplayNativeHdrSurfaceCapabilitiesAMD ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayPlaneCapabilitiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "supportedAlpha" ] = p.supportedAlpha;
  j[ "minSrcPosition" ] = p.minSrcPosition;
  j[ "maxSrcPosition" ] = p.maxSrcPosition;
  j[ "minSrcExtent" ] = p.minSrcExtent;
  j[ "maxSrcExtent" ] = p.maxSrcExtent;
  j[ "minDstPosition" ] = p.minDstPosition;
  j[ "maxDstPosition" ] = p.maxDstPosition;
  j[ "minDstExtent" ] = p.minDstExtent;
  j[ "maxDstExtent" ] = p.maxDstExtent;
}
inline void to_json( nlohmann::json &j, const VkDisplayPlaneCapabilitiesKHR &p ) {
  to_json( j, DisplayPlaneCapabilitiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayPlaneCapabilitiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPlaneCapabilitiesKHR" );
  p.supportedAlpha = j[ "supportedAlpha" ];
  p.minSrcPosition = j[ "minSrcPosition" ];
  p.maxSrcPosition = j[ "maxSrcPosition" ];
  p.minSrcExtent = j[ "minSrcExtent" ];
  p.maxSrcExtent = j[ "maxSrcExtent" ];
  p.minDstPosition = j[ "minDstPosition" ];
  p.maxDstPosition = j[ "maxDstPosition" ];
  p.minDstExtent = j[ "minDstExtent" ];
  p.maxDstExtent = j[ "maxDstExtent" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayPlaneCapabilitiesKHR &p ) {
  DisplayPlaneCapabilitiesKHR temp;
  from_json( j, temp );
  p = VkDisplayPlaneCapabilitiesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayPlaneCapabilities2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "capabilities" ] = p.capabilities;
}
inline void to_json( nlohmann::json &j, const VkDisplayPlaneCapabilities2KHR &p ) {
  to_json( j, DisplayPlaneCapabilities2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayPlaneCapabilities2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPlaneCapabilities2KHR" );
  p.capabilities = j[ "capabilities" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayPlaneCapabilities2KHR &p ) {
  DisplayPlaneCapabilities2KHR temp;
  from_json( j, temp );
  p = VkDisplayPlaneCapabilities2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayPlaneInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "planeIndex" ] = p.planeIndex;
}
inline void to_json( nlohmann::json &j, const VkDisplayPlaneInfo2KHR &p ) {
  to_json( j, DisplayPlaneInfo2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayPlaneInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPlaneInfo2KHR" );
  p.planeIndex = j[ "planeIndex" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayPlaneInfo2KHR &p ) {
  DisplayPlaneInfo2KHR temp;
  from_json( j, temp );
  p = VkDisplayPlaneInfo2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayPlanePropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "currentStackIndex" ] = p.currentStackIndex;
}
inline void to_json( nlohmann::json &j, const VkDisplayPlanePropertiesKHR &p ) {
  to_json( j, DisplayPlanePropertiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayPlanePropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPlanePropertiesKHR" );
  p.currentStackIndex = j[ "currentStackIndex" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayPlanePropertiesKHR &p ) {
  DisplayPlanePropertiesKHR temp;
  from_json( j, temp );
  p = VkDisplayPlanePropertiesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayPlaneProperties2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "displayPlaneProperties" ] = p.displayPlaneProperties;
}
inline void to_json( nlohmann::json &j, const VkDisplayPlaneProperties2KHR &p ) {
  to_json( j, DisplayPlaneProperties2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayPlaneProperties2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPlaneProperties2KHR" );
  p.displayPlaneProperties = j[ "displayPlaneProperties" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayPlaneProperties2KHR &p ) {
  DisplayPlaneProperties2KHR temp;
  from_json( j, temp );
  p = VkDisplayPlaneProperties2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayPowerInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "powerState" ] = p.powerState;
}
inline void to_json( nlohmann::json &j, const VkDisplayPowerInfoEXT &p ) {
  to_json( j, DisplayPowerInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayPowerInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPowerInfoEXT" );
  p.powerState = j[ "powerState" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayPowerInfoEXT &p ) {
  DisplayPowerInfoEXT temp;
  from_json( j, temp );
  p = VkDisplayPowerInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayPresentInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcRect" ] = p.srcRect;
  j[ "dstRect" ] = p.dstRect;
  j[ "persistent" ] = bool( p.persistent );
}
inline void to_json( nlohmann::json &j, const VkDisplayPresentInfoKHR &p ) {
  to_json( j, DisplayPresentInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayPresentInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPresentInfoKHR" );
  p.srcRect = j[ "srcRect" ];
  p.dstRect = j[ "dstRect" ];
  p.persistent = j[ "persistent" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayPresentInfoKHR &p ) {
  DisplayPresentInfoKHR temp;
  from_json( j, temp );
  p = VkDisplayPresentInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayPropertiesKHR &p ) {
  j = nlohmann::json::object();
  if( p.displayName ) j[ "displayName" ] = std::string( p.displayName );
  j[ "physicalDimensions" ] = p.physicalDimensions;
  j[ "physicalResolution" ] = p.physicalResolution;
  j[ "supportedTransforms" ] = p.supportedTransforms;
  j[ "planeReorderPossible" ] = bool( p.planeReorderPossible );
  j[ "persistentContent" ] = bool( p.persistentContent );
}
inline void to_json( nlohmann::json &j, const VkDisplayPropertiesKHR &p ) {
  to_json( j, DisplayPropertiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayPropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayPropertiesKHR" );
  p.physicalDimensions = j[ "physicalDimensions" ];
  p.physicalResolution = j[ "physicalResolution" ];
  p.supportedTransforms = j[ "supportedTransforms" ];
  p.planeReorderPossible = j[ "planeReorderPossible" ];
  p.persistentContent = j[ "persistentContent" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayPropertiesKHR &p ) {
  DisplayPropertiesKHR temp;
  from_json( j, temp );
  p = VkDisplayPropertiesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const DisplayProperties2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "displayProperties" ] = p.displayProperties;
}
inline void to_json( nlohmann::json &j, const VkDisplayProperties2KHR &p ) {
  to_json( j, DisplayProperties2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplayProperties2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplayProperties2KHR" );
  p.displayProperties = j[ "displayProperties" ];
}
inline void from_json( const nlohmann::json &j, VkDisplayProperties2KHR &p ) {
  DisplayProperties2KHR temp;
  from_json( j, temp );
  p = VkDisplayProperties2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const DisplaySurfaceCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "planeIndex" ] = p.planeIndex;
  j[ "planeStackIndex" ] = p.planeStackIndex;
  j[ "transform" ] = p.transform;
  j[ "globalAlpha" ] = p.globalAlpha;
  j[ "alphaMode" ] = p.alphaMode;
  j[ "imageExtent" ] = p.imageExtent;
}
inline void to_json( nlohmann::json &j, const VkDisplaySurfaceCreateInfoKHR &p ) {
  to_json( j, DisplaySurfaceCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, DisplaySurfaceCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DisplaySurfaceCreateInfoKHR" );
  p.flags = j[ "flags" ];
  p.planeIndex = j[ "planeIndex" ];
  p.planeStackIndex = j[ "planeStackIndex" ];
  p.transform = j[ "transform" ];
  p.globalAlpha = j[ "globalAlpha" ];
  p.alphaMode = j[ "alphaMode" ];
  p.imageExtent = j[ "imageExtent" ];
}
inline void from_json( const nlohmann::json &j, VkDisplaySurfaceCreateInfoKHR &p ) {
  DisplaySurfaceCreateInfoKHR temp;
  from_json( j, temp );
  p = VkDisplaySurfaceCreateInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const DrawIndexedIndirectCommand &p ) {
  j = nlohmann::json::object();
  j[ "indexCount" ] = p.indexCount;
  j[ "instanceCount" ] = p.instanceCount;
  j[ "firstIndex" ] = p.firstIndex;
  j[ "vertexOffset" ] = p.vertexOffset;
  j[ "firstInstance" ] = p.firstInstance;
}
inline void to_json( nlohmann::json &j, const VkDrawIndexedIndirectCommand &p ) {
  to_json( j, DrawIndexedIndirectCommand ( p ) );
}
inline void from_json( const nlohmann::json &j, DrawIndexedIndirectCommand &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DrawIndexedIndirectCommand" );
  p.indexCount = j[ "indexCount" ];
  p.instanceCount = j[ "instanceCount" ];
  p.firstIndex = j[ "firstIndex" ];
  p.vertexOffset = j[ "vertexOffset" ];
  p.firstInstance = j[ "firstInstance" ];
}
inline void from_json( const nlohmann::json &j, VkDrawIndexedIndirectCommand &p ) {
  DrawIndexedIndirectCommand temp;
  from_json( j, temp );
  p = VkDrawIndexedIndirectCommand ( temp );
}

inline void to_json( nlohmann::json &j, const DrawIndirectCommand &p ) {
  j = nlohmann::json::object();
  j[ "vertexCount" ] = p.vertexCount;
  j[ "instanceCount" ] = p.instanceCount;
  j[ "firstVertex" ] = p.firstVertex;
  j[ "firstInstance" ] = p.firstInstance;
}
inline void to_json( nlohmann::json &j, const VkDrawIndirectCommand &p ) {
  to_json( j, DrawIndirectCommand ( p ) );
}
inline void from_json( const nlohmann::json &j, DrawIndirectCommand &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DrawIndirectCommand" );
  p.vertexCount = j[ "vertexCount" ];
  p.instanceCount = j[ "instanceCount" ];
  p.firstVertex = j[ "firstVertex" ];
  p.firstInstance = j[ "firstInstance" ];
}
inline void from_json( const nlohmann::json &j, VkDrawIndirectCommand &p ) {
  DrawIndirectCommand temp;
  from_json( j, temp );
  p = VkDrawIndirectCommand ( temp );
}

inline void to_json( nlohmann::json &j, const DrawMeshTasksIndirectCommandNV &p ) {
  j = nlohmann::json::object();
  j[ "taskCount" ] = p.taskCount;
  j[ "firstTask" ] = p.firstTask;
}
inline void to_json( nlohmann::json &j, const VkDrawMeshTasksIndirectCommandNV &p ) {
  to_json( j, DrawMeshTasksIndirectCommandNV ( p ) );
}
inline void from_json( const nlohmann::json &j, DrawMeshTasksIndirectCommandNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DrawMeshTasksIndirectCommandNV" );
  p.taskCount = j[ "taskCount" ];
  p.firstTask = j[ "firstTask" ];
}
inline void from_json( const nlohmann::json &j, VkDrawMeshTasksIndirectCommandNV &p ) {
  DrawMeshTasksIndirectCommandNV temp;
  from_json( j, temp );
  p = VkDrawMeshTasksIndirectCommandNV ( temp );
}

inline void to_json( nlohmann::json &j, const DrmFormatModifierPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "drmFormatModifier" ] = p.drmFormatModifier;
  j[ "drmFormatModifierPlaneCount" ] = p.drmFormatModifierPlaneCount;
  j[ "drmFormatModifierTilingFeatures" ] = p.drmFormatModifierTilingFeatures;
}
inline void to_json( nlohmann::json &j, const VkDrmFormatModifierPropertiesEXT &p ) {
  to_json( j, DrmFormatModifierPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DrmFormatModifierPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DrmFormatModifierPropertiesEXT" );
  p.drmFormatModifier = j[ "drmFormatModifier" ];
  p.drmFormatModifierPlaneCount = j[ "drmFormatModifierPlaneCount" ];
  p.drmFormatModifierTilingFeatures = j[ "drmFormatModifierTilingFeatures" ];
}
inline void from_json( const nlohmann::json &j, VkDrmFormatModifierPropertiesEXT &p ) {
  DrmFormatModifierPropertiesEXT temp;
  from_json( j, temp );
  p = VkDrmFormatModifierPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const DrmFormatModifierPropertiesListEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "drmFormatModifierCount" ] = p.drmFormatModifierCount;
  j[ "pDrmFormatModifierProperties" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDrmFormatModifierProperties ) );
}
inline void to_json( nlohmann::json &j, const VkDrmFormatModifierPropertiesListEXT &p ) {
  to_json( j, DrmFormatModifierPropertiesListEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, DrmFormatModifierPropertiesListEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for DrmFormatModifierPropertiesListEXT" );
  p.drmFormatModifierCount = j[ "drmFormatModifierCount" ];
}
inline void from_json( const nlohmann::json &j, VkDrmFormatModifierPropertiesListEXT &p ) {
  DrmFormatModifierPropertiesListEXT temp;
  from_json( j, temp );
  p = VkDrmFormatModifierPropertiesListEXT ( temp );
}

inline void to_json( nlohmann::json &j, const EventCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkEventCreateInfo &p ) {
  to_json( j, EventCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, EventCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for EventCreateInfo" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkEventCreateInfo &p ) {
  EventCreateInfo temp;
  from_json( j, temp );
  p = VkEventCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const ExportFenceCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleTypes" ] = p.handleTypes;
}
inline void to_json( nlohmann::json &j, const VkExportFenceCreateInfo &p ) {
  to_json( j, ExportFenceCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ExportFenceCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExportFenceCreateInfo" );
  p.handleTypes = j[ "handleTypes" ];
}
inline void from_json( const nlohmann::json &j, VkExportFenceCreateInfo &p ) {
  ExportFenceCreateInfo temp;
  from_json( j, temp );
  p = VkExportFenceCreateInfo ( temp );
}

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const ExportFenceWin32HandleInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pAttributes" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttributes ) );
  j[ "dwAccess" ] = p.dwAccess;
}
inline void to_json( nlohmann::json &j, const VkExportFenceWin32HandleInfoKHR &p ) {
  to_json( j, ExportFenceWin32HandleInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ExportFenceWin32HandleInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExportFenceWin32HandleInfoKHR" );
  p.dwAccess = j[ "dwAccess" ];
}
inline void from_json( const nlohmann::json &j, VkExportFenceWin32HandleInfoKHR &p ) {
  ExportFenceWin32HandleInfoKHR temp;
  from_json( j, temp );
  p = VkExportFenceWin32HandleInfoKHR ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const ExportMemoryAllocateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleTypes" ] = p.handleTypes;
}
inline void to_json( nlohmann::json &j, const VkExportMemoryAllocateInfo &p ) {
  to_json( j, ExportMemoryAllocateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ExportMemoryAllocateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExportMemoryAllocateInfo" );
  p.handleTypes = j[ "handleTypes" ];
}
inline void from_json( const nlohmann::json &j, VkExportMemoryAllocateInfo &p ) {
  ExportMemoryAllocateInfo temp;
  from_json( j, temp );
  p = VkExportMemoryAllocateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const ExportMemoryAllocateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleTypes" ] = p.handleTypes;
}
inline void to_json( nlohmann::json &j, const VkExportMemoryAllocateInfoNV &p ) {
  to_json( j, ExportMemoryAllocateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, ExportMemoryAllocateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExportMemoryAllocateInfoNV" );
  p.handleTypes = j[ "handleTypes" ];
}
inline void from_json( const nlohmann::json &j, VkExportMemoryAllocateInfoNV &p ) {
  ExportMemoryAllocateInfoNV temp;
  from_json( j, temp );
  p = VkExportMemoryAllocateInfoNV ( temp );
}

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const ExportMemoryWin32HandleInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pAttributes" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttributes ) );
  j[ "dwAccess" ] = p.dwAccess;
}
inline void to_json( nlohmann::json &j, const VkExportMemoryWin32HandleInfoKHR &p ) {
  to_json( j, ExportMemoryWin32HandleInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ExportMemoryWin32HandleInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExportMemoryWin32HandleInfoKHR" );
  p.dwAccess = j[ "dwAccess" ];
}
inline void from_json( const nlohmann::json &j, VkExportMemoryWin32HandleInfoKHR &p ) {
  ExportMemoryWin32HandleInfoKHR temp;
  from_json( j, temp );
  p = VkExportMemoryWin32HandleInfoKHR ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const ExportMemoryWin32HandleInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pAttributes" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttributes ) );
  j[ "dwAccess" ] = p.dwAccess;
}
inline void to_json( nlohmann::json &j, const VkExportMemoryWin32HandleInfoNV &p ) {
  to_json( j, ExportMemoryWin32HandleInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, ExportMemoryWin32HandleInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExportMemoryWin32HandleInfoNV" );
  p.dwAccess = j[ "dwAccess" ];
}
inline void from_json( const nlohmann::json &j, VkExportMemoryWin32HandleInfoNV &p ) {
  ExportMemoryWin32HandleInfoNV temp;
  from_json( j, temp );
  p = VkExportMemoryWin32HandleInfoNV ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const ExportSemaphoreCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleTypes" ] = p.handleTypes;
}
inline void to_json( nlohmann::json &j, const VkExportSemaphoreCreateInfo &p ) {
  to_json( j, ExportSemaphoreCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ExportSemaphoreCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExportSemaphoreCreateInfo" );
  p.handleTypes = j[ "handleTypes" ];
}
inline void from_json( const nlohmann::json &j, VkExportSemaphoreCreateInfo &p ) {
  ExportSemaphoreCreateInfo temp;
  from_json( j, temp );
  p = VkExportSemaphoreCreateInfo ( temp );
}

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const ExportSemaphoreWin32HandleInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pAttributes" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttributes ) );
  j[ "dwAccess" ] = p.dwAccess;
}
inline void to_json( nlohmann::json &j, const VkExportSemaphoreWin32HandleInfoKHR &p ) {
  to_json( j, ExportSemaphoreWin32HandleInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ExportSemaphoreWin32HandleInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExportSemaphoreWin32HandleInfoKHR" );
  p.dwAccess = j[ "dwAccess" ];
}
inline void from_json( const nlohmann::json &j, VkExportSemaphoreWin32HandleInfoKHR &p ) {
  ExportSemaphoreWin32HandleInfoKHR temp;
  from_json( j, temp );
  p = VkExportSemaphoreWin32HandleInfoKHR ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const ExtensionProperties &p ) {
  j = nlohmann::json::object();
  j[ "extensionName" ] = std::string( p.extensionName.begin(), std::find( p.extensionName.begin(), p.extensionName.end(), '\0' ) );
  j[ "specVersion" ] = p.specVersion;
}
inline void to_json( nlohmann::json &j, const VkExtensionProperties &p ) {
  to_json( j, ExtensionProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, ExtensionProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExtensionProperties" );
  {
    std::string s = j[ "extensionName" ];
    if( !p.extensionName.empty() ) {
      p.extensionName[ p.extensionName.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.extensionName.size() - 1u ) ), p.extensionName.begin() );
    }
  }
  p.specVersion = j[ "specVersion" ];
}
inline void from_json( const nlohmann::json &j, VkExtensionProperties &p ) {
  ExtensionProperties temp;
  from_json( j, temp );
  p = VkExtensionProperties ( temp );
}

inline void to_json( nlohmann::json &j, const ExternalMemoryProperties &p ) {
  j = nlohmann::json::object();
  j[ "externalMemoryFeatures" ] = p.externalMemoryFeatures;
  j[ "exportFromImportedHandleTypes" ] = p.exportFromImportedHandleTypes;
  j[ "compatibleHandleTypes" ] = p.compatibleHandleTypes;
}
inline void to_json( nlohmann::json &j, const VkExternalMemoryProperties &p ) {
  to_json( j, ExternalMemoryProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, ExternalMemoryProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalMemoryProperties" );
  p.externalMemoryFeatures = j[ "externalMemoryFeatures" ];
  p.exportFromImportedHandleTypes = j[ "exportFromImportedHandleTypes" ];
  p.compatibleHandleTypes = j[ "compatibleHandleTypes" ];
}
inline void from_json( const nlohmann::json &j, VkExternalMemoryProperties &p ) {
  ExternalMemoryProperties temp;
  from_json( j, temp );
  p = VkExternalMemoryProperties ( temp );
}

inline void to_json( nlohmann::json &j, const ExternalBufferProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "externalMemoryProperties" ] = p.externalMemoryProperties;
}
inline void to_json( nlohmann::json &j, const VkExternalBufferProperties &p ) {
  to_json( j, ExternalBufferProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, ExternalBufferProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalBufferProperties" );
  p.externalMemoryProperties = j[ "externalMemoryProperties" ];
}
inline void from_json( const nlohmann::json &j, VkExternalBufferProperties &p ) {
  ExternalBufferProperties temp;
  from_json( j, temp );
  p = VkExternalBufferProperties ( temp );
}

inline void to_json( nlohmann::json &j, const ExternalFenceProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "exportFromImportedHandleTypes" ] = p.exportFromImportedHandleTypes;
  j[ "compatibleHandleTypes" ] = p.compatibleHandleTypes;
  j[ "externalFenceFeatures" ] = p.externalFenceFeatures;
}
inline void to_json( nlohmann::json &j, const VkExternalFenceProperties &p ) {
  to_json( j, ExternalFenceProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, ExternalFenceProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalFenceProperties" );
  p.exportFromImportedHandleTypes = j[ "exportFromImportedHandleTypes" ];
  p.compatibleHandleTypes = j[ "compatibleHandleTypes" ];
  p.externalFenceFeatures = j[ "externalFenceFeatures" ];
}
inline void from_json( const nlohmann::json &j, VkExternalFenceProperties &p ) {
  ExternalFenceProperties temp;
  from_json( j, temp );
  p = VkExternalFenceProperties ( temp );
}

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
inline void to_json( nlohmann::json &j, const ExternalFormatANDROID &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "externalFormat" ] = p.externalFormat;
}
inline void to_json( nlohmann::json &j, const VkExternalFormatANDROID &p ) {
  to_json( j, ExternalFormatANDROID ( p ) );
}
inline void from_json( const nlohmann::json &j, ExternalFormatANDROID &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalFormatANDROID" );
  p.externalFormat = j[ "externalFormat" ];
}
inline void from_json( const nlohmann::json &j, VkExternalFormatANDROID &p ) {
  ExternalFormatANDROID temp;
  from_json( j, temp );
  p = VkExternalFormatANDROID ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const ExternalImageFormatProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "externalMemoryProperties" ] = p.externalMemoryProperties;
}
inline void to_json( nlohmann::json &j, const VkExternalImageFormatProperties &p ) {
  to_json( j, ExternalImageFormatProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, ExternalImageFormatProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalImageFormatProperties" );
  p.externalMemoryProperties = j[ "externalMemoryProperties" ];
}
inline void from_json( const nlohmann::json &j, VkExternalImageFormatProperties &p ) {
  ExternalImageFormatProperties temp;
  from_json( j, temp );
  p = VkExternalImageFormatProperties ( temp );
}

inline void to_json( nlohmann::json &j, const ImageFormatProperties &p ) {
  j = nlohmann::json::object();
  j[ "maxExtent" ] = p.maxExtent;
  j[ "maxMipLevels" ] = p.maxMipLevels;
  j[ "maxArrayLayers" ] = p.maxArrayLayers;
  j[ "sampleCounts" ] = p.sampleCounts;
  j[ "maxResourceSize" ] = p.maxResourceSize;
}
inline void to_json( nlohmann::json &j, const VkImageFormatProperties &p ) {
  to_json( j, ImageFormatProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageFormatProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageFormatProperties" );
  p.maxExtent = j[ "maxExtent" ];
  p.maxMipLevels = j[ "maxMipLevels" ];
  p.maxArrayLayers = j[ "maxArrayLayers" ];
  p.sampleCounts = j[ "sampleCounts" ];
  p.maxResourceSize = j[ "maxResourceSize" ];
}
inline void from_json( const nlohmann::json &j, VkImageFormatProperties &p ) {
  ImageFormatProperties temp;
  from_json( j, temp );
  p = VkImageFormatProperties ( temp );
}

inline void to_json( nlohmann::json &j, const ExternalImageFormatPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "imageFormatProperties" ] = p.imageFormatProperties;
  j[ "externalMemoryFeatures" ] = p.externalMemoryFeatures;
  j[ "exportFromImportedHandleTypes" ] = p.exportFromImportedHandleTypes;
  j[ "compatibleHandleTypes" ] = p.compatibleHandleTypes;
}
inline void to_json( nlohmann::json &j, const VkExternalImageFormatPropertiesNV &p ) {
  to_json( j, ExternalImageFormatPropertiesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, ExternalImageFormatPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalImageFormatPropertiesNV" );
  p.imageFormatProperties = j[ "imageFormatProperties" ];
  p.externalMemoryFeatures = j[ "externalMemoryFeatures" ];
  p.exportFromImportedHandleTypes = j[ "exportFromImportedHandleTypes" ];
  p.compatibleHandleTypes = j[ "compatibleHandleTypes" ];
}
inline void from_json( const nlohmann::json &j, VkExternalImageFormatPropertiesNV &p ) {
  ExternalImageFormatPropertiesNV temp;
  from_json( j, temp );
  p = VkExternalImageFormatPropertiesNV ( temp );
}

inline void to_json( nlohmann::json &j, const ExternalMemoryBufferCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleTypes" ] = p.handleTypes;
}
inline void to_json( nlohmann::json &j, const VkExternalMemoryBufferCreateInfo &p ) {
  to_json( j, ExternalMemoryBufferCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ExternalMemoryBufferCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalMemoryBufferCreateInfo" );
  p.handleTypes = j[ "handleTypes" ];
}
inline void from_json( const nlohmann::json &j, VkExternalMemoryBufferCreateInfo &p ) {
  ExternalMemoryBufferCreateInfo temp;
  from_json( j, temp );
  p = VkExternalMemoryBufferCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const ExternalMemoryImageCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleTypes" ] = p.handleTypes;
}
inline void to_json( nlohmann::json &j, const VkExternalMemoryImageCreateInfo &p ) {
  to_json( j, ExternalMemoryImageCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ExternalMemoryImageCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalMemoryImageCreateInfo" );
  p.handleTypes = j[ "handleTypes" ];
}
inline void from_json( const nlohmann::json &j, VkExternalMemoryImageCreateInfo &p ) {
  ExternalMemoryImageCreateInfo temp;
  from_json( j, temp );
  p = VkExternalMemoryImageCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const ExternalMemoryImageCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleTypes" ] = p.handleTypes;
}
inline void to_json( nlohmann::json &j, const VkExternalMemoryImageCreateInfoNV &p ) {
  to_json( j, ExternalMemoryImageCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, ExternalMemoryImageCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalMemoryImageCreateInfoNV" );
  p.handleTypes = j[ "handleTypes" ];
}
inline void from_json( const nlohmann::json &j, VkExternalMemoryImageCreateInfoNV &p ) {
  ExternalMemoryImageCreateInfoNV temp;
  from_json( j, temp );
  p = VkExternalMemoryImageCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const ExternalSemaphoreProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "exportFromImportedHandleTypes" ] = p.exportFromImportedHandleTypes;
  j[ "compatibleHandleTypes" ] = p.compatibleHandleTypes;
  j[ "externalSemaphoreFeatures" ] = p.externalSemaphoreFeatures;
}
inline void to_json( nlohmann::json &j, const VkExternalSemaphoreProperties &p ) {
  to_json( j, ExternalSemaphoreProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, ExternalSemaphoreProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ExternalSemaphoreProperties" );
  p.exportFromImportedHandleTypes = j[ "exportFromImportedHandleTypes" ];
  p.compatibleHandleTypes = j[ "compatibleHandleTypes" ];
  p.externalSemaphoreFeatures = j[ "externalSemaphoreFeatures" ];
}
inline void from_json( const nlohmann::json &j, VkExternalSemaphoreProperties &p ) {
  ExternalSemaphoreProperties temp;
  from_json( j, temp );
  p = VkExternalSemaphoreProperties ( temp );
}

inline void to_json( nlohmann::json &j, const FenceCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkFenceCreateInfo &p ) {
  to_json( j, FenceCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, FenceCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FenceCreateInfo" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkFenceCreateInfo &p ) {
  FenceCreateInfo temp;
  from_json( j, temp );
  p = VkFenceCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const FenceGetFdInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkFenceGetFdInfoKHR &p ) {
  to_json( j, FenceGetFdInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, FenceGetFdInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FenceGetFdInfoKHR" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkFenceGetFdInfoKHR &p ) {
  FenceGetFdInfoKHR temp;
  from_json( j, temp );
  p = VkFenceGetFdInfoKHR ( temp );
}

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const FenceGetWin32HandleInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkFenceGetWin32HandleInfoKHR &p ) {
  to_json( j, FenceGetWin32HandleInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, FenceGetWin32HandleInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FenceGetWin32HandleInfoKHR" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkFenceGetWin32HandleInfoKHR &p ) {
  FenceGetWin32HandleInfoKHR temp;
  from_json( j, temp );
  p = VkFenceGetWin32HandleInfoKHR ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const FilterCubicImageViewImageFormatPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "filterCubic" ] = bool( p.filterCubic );
  j[ "filterCubicMinmax" ] = bool( p.filterCubicMinmax );
}
inline void to_json( nlohmann::json &j, const VkFilterCubicImageViewImageFormatPropertiesEXT &p ) {
  to_json( j, FilterCubicImageViewImageFormatPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, FilterCubicImageViewImageFormatPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FilterCubicImageViewImageFormatPropertiesEXT" );
  p.filterCubic = j[ "filterCubic" ];
  p.filterCubicMinmax = j[ "filterCubicMinmax" ];
}
inline void from_json( const nlohmann::json &j, VkFilterCubicImageViewImageFormatPropertiesEXT &p ) {
  FilterCubicImageViewImageFormatPropertiesEXT temp;
  from_json( j, temp );
  p = VkFilterCubicImageViewImageFormatPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const FormatProperties &p ) {
  j = nlohmann::json::object();
  j[ "linearTilingFeatures" ] = p.linearTilingFeatures;
  j[ "optimalTilingFeatures" ] = p.optimalTilingFeatures;
  j[ "bufferFeatures" ] = p.bufferFeatures;
}
inline void to_json( nlohmann::json &j, const VkFormatProperties &p ) {
  to_json( j, FormatProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, FormatProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FormatProperties" );
  p.linearTilingFeatures = j[ "linearTilingFeatures" ];
  p.optimalTilingFeatures = j[ "optimalTilingFeatures" ];
  p.bufferFeatures = j[ "bufferFeatures" ];
}
inline void from_json( const nlohmann::json &j, VkFormatProperties &p ) {
  FormatProperties temp;
  from_json( j, temp );
  p = VkFormatProperties ( temp );
}

inline void to_json( nlohmann::json &j, const FormatProperties2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "formatProperties" ] = p.formatProperties;
}
inline void to_json( nlohmann::json &j, const VkFormatProperties2 &p ) {
  to_json( j, FormatProperties2 ( p ) );
}
inline void from_json( const nlohmann::json &j, FormatProperties2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FormatProperties2" );
  p.formatProperties = j[ "formatProperties" ];
}
inline void from_json( const nlohmann::json &j, VkFormatProperties2 &p ) {
  FormatProperties2 temp;
  from_json( j, temp );
  p = VkFormatProperties2 ( temp );
}

inline void to_json( nlohmann::json &j, const FragmentShadingRateAttachmentInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pFragmentShadingRateAttachment" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pFragmentShadingRateAttachment ) );
  j[ "shadingRateAttachmentTexelSize" ] = p.shadingRateAttachmentTexelSize;
}
inline void to_json( nlohmann::json &j, const VkFragmentShadingRateAttachmentInfoKHR &p ) {
  to_json( j, FragmentShadingRateAttachmentInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, FragmentShadingRateAttachmentInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FragmentShadingRateAttachmentInfoKHR" );
  p.shadingRateAttachmentTexelSize = j[ "shadingRateAttachmentTexelSize" ];
}
inline void from_json( const nlohmann::json &j, VkFragmentShadingRateAttachmentInfoKHR &p ) {
  FragmentShadingRateAttachmentInfoKHR temp;
  from_json( j, temp );
  p = VkFragmentShadingRateAttachmentInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const FramebufferAttachmentImageInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "usage" ] = p.usage;
  j[ "width" ] = p.width;
  j[ "height" ] = p.height;
  j[ "layerCount" ] = p.layerCount;
  j[ "viewFormatCount" ] = p.viewFormatCount;
  j[ "pViewFormats" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewFormats ) );
}
inline void to_json( nlohmann::json &j, const VkFramebufferAttachmentImageInfo &p ) {
  to_json( j, FramebufferAttachmentImageInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, FramebufferAttachmentImageInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FramebufferAttachmentImageInfo" );
  p.flags = j[ "flags" ];
  p.usage = j[ "usage" ];
  p.width = j[ "width" ];
  p.height = j[ "height" ];
  p.layerCount = j[ "layerCount" ];
  p.viewFormatCount = j[ "viewFormatCount" ];
}
inline void from_json( const nlohmann::json &j, VkFramebufferAttachmentImageInfo &p ) {
  FramebufferAttachmentImageInfo temp;
  from_json( j, temp );
  p = VkFramebufferAttachmentImageInfo ( temp );
}

inline void to_json( nlohmann::json &j, const FramebufferAttachmentsCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "attachmentImageInfoCount" ] = p.attachmentImageInfoCount;
  j[ "pAttachmentImageInfos" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttachmentImageInfos ) );
}
inline void to_json( nlohmann::json &j, const VkFramebufferAttachmentsCreateInfo &p ) {
  to_json( j, FramebufferAttachmentsCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, FramebufferAttachmentsCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FramebufferAttachmentsCreateInfo" );
  p.attachmentImageInfoCount = j[ "attachmentImageInfoCount" ];
}
inline void from_json( const nlohmann::json &j, VkFramebufferAttachmentsCreateInfo &p ) {
  FramebufferAttachmentsCreateInfo temp;
  from_json( j, temp );
  p = VkFramebufferAttachmentsCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const FramebufferCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "attachmentCount" ] = p.attachmentCount;
  j[ "pAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttachments ) );
  j[ "width" ] = p.width;
  j[ "height" ] = p.height;
  j[ "layers" ] = p.layers;
}
inline void to_json( nlohmann::json &j, const VkFramebufferCreateInfo &p ) {
  to_json( j, FramebufferCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, FramebufferCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FramebufferCreateInfo" );
  p.flags = j[ "flags" ];
  p.attachmentCount = j[ "attachmentCount" ];
  p.width = j[ "width" ];
  p.height = j[ "height" ];
  p.layers = j[ "layers" ];
}
inline void from_json( const nlohmann::json &j, VkFramebufferCreateInfo &p ) {
  FramebufferCreateInfo temp;
  from_json( j, temp );
  p = VkFramebufferCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const FramebufferMixedSamplesCombinationNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "coverageReductionMode" ] = p.coverageReductionMode;
  j[ "rasterizationSamples" ] = p.rasterizationSamples;
  j[ "depthStencilSamples" ] = p.depthStencilSamples;
  j[ "colorSamples" ] = p.colorSamples;
}
inline void to_json( nlohmann::json &j, const VkFramebufferMixedSamplesCombinationNV &p ) {
  to_json( j, FramebufferMixedSamplesCombinationNV ( p ) );
}
inline void from_json( const nlohmann::json &j, FramebufferMixedSamplesCombinationNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for FramebufferMixedSamplesCombinationNV" );
  p.coverageReductionMode = j[ "coverageReductionMode" ];
  p.rasterizationSamples = j[ "rasterizationSamples" ];
  p.depthStencilSamples = j[ "depthStencilSamples" ];
  p.colorSamples = j[ "colorSamples" ];
}
inline void from_json( const nlohmann::json &j, VkFramebufferMixedSamplesCombinationNV &p ) {
  FramebufferMixedSamplesCombinationNV temp;
  from_json( j, temp );
  p = VkFramebufferMixedSamplesCombinationNV ( temp );
}

inline void to_json( nlohmann::json &j, const IndirectCommandsStreamNV &p ) {
  j = nlohmann::json::object();
  j[ "offset" ] = p.offset;
}
inline void to_json( nlohmann::json &j, const VkIndirectCommandsStreamNV &p ) {
  to_json( j, IndirectCommandsStreamNV ( p ) );
}
inline void from_json( const nlohmann::json &j, IndirectCommandsStreamNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for IndirectCommandsStreamNV" );
  p.offset = j[ "offset" ];
}
inline void from_json( const nlohmann::json &j, VkIndirectCommandsStreamNV &p ) {
  IndirectCommandsStreamNV temp;
  from_json( j, temp );
  p = VkIndirectCommandsStreamNV ( temp );
}

inline void to_json( nlohmann::json &j, const GeneratedCommandsInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pipelineBindPoint" ] = p.pipelineBindPoint;
  j[ "streamCount" ] = p.streamCount;
  j[ "pStreams" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStreams ) );
  j[ "sequencesCount" ] = p.sequencesCount;
  j[ "preprocessOffset" ] = p.preprocessOffset;
  j[ "preprocessSize" ] = p.preprocessSize;
  j[ "sequencesCountOffset" ] = p.sequencesCountOffset;
  j[ "sequencesIndexOffset" ] = p.sequencesIndexOffset;
}
inline void to_json( nlohmann::json &j, const VkGeneratedCommandsInfoNV &p ) {
  to_json( j, GeneratedCommandsInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, GeneratedCommandsInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GeneratedCommandsInfoNV" );
  p.pipelineBindPoint = j[ "pipelineBindPoint" ];
  p.streamCount = j[ "streamCount" ];
  p.sequencesCount = j[ "sequencesCount" ];
  p.preprocessOffset = j[ "preprocessOffset" ];
  p.preprocessSize = j[ "preprocessSize" ];
  p.sequencesCountOffset = j[ "sequencesCountOffset" ];
  p.sequencesIndexOffset = j[ "sequencesIndexOffset" ];
}
inline void from_json( const nlohmann::json &j, VkGeneratedCommandsInfoNV &p ) {
  GeneratedCommandsInfoNV temp;
  from_json( j, temp );
  p = VkGeneratedCommandsInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const GeneratedCommandsMemoryRequirementsInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pipelineBindPoint" ] = p.pipelineBindPoint;
  j[ "maxSequencesCount" ] = p.maxSequencesCount;
}
inline void to_json( nlohmann::json &j, const VkGeneratedCommandsMemoryRequirementsInfoNV &p ) {
  to_json( j, GeneratedCommandsMemoryRequirementsInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, GeneratedCommandsMemoryRequirementsInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GeneratedCommandsMemoryRequirementsInfoNV" );
  p.pipelineBindPoint = j[ "pipelineBindPoint" ];
  p.maxSequencesCount = j[ "maxSequencesCount" ];
}
inline void from_json( const nlohmann::json &j, VkGeneratedCommandsMemoryRequirementsInfoNV &p ) {
  GeneratedCommandsMemoryRequirementsInfoNV temp;
  from_json( j, temp );
  p = VkGeneratedCommandsMemoryRequirementsInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const VertexInputBindingDescription &p ) {
  j = nlohmann::json::object();
  j[ "binding" ] = p.binding;
  j[ "stride" ] = p.stride;
  j[ "inputRate" ] = p.inputRate;
}
inline void to_json( nlohmann::json &j, const VkVertexInputBindingDescription &p ) {
  to_json( j, VertexInputBindingDescription ( p ) );
}
inline void from_json( const nlohmann::json &j, VertexInputBindingDescription &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VertexInputBindingDescription" );
  p.binding = j[ "binding" ];
  p.stride = j[ "stride" ];
  p.inputRate = j[ "inputRate" ];
}
inline void from_json( const nlohmann::json &j, VkVertexInputBindingDescription &p ) {
  VertexInputBindingDescription temp;
  from_json( j, temp );
  p = VkVertexInputBindingDescription ( temp );
}

inline void to_json( nlohmann::json &j, const VertexInputAttributeDescription &p ) {
  j = nlohmann::json::object();
  j[ "location" ] = p.location;
  j[ "binding" ] = p.binding;
  j[ "format" ] = p.format;
  j[ "offset" ] = p.offset;
}
inline void to_json( nlohmann::json &j, const VkVertexInputAttributeDescription &p ) {
  to_json( j, VertexInputAttributeDescription ( p ) );
}
inline void from_json( const nlohmann::json &j, VertexInputAttributeDescription &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VertexInputAttributeDescription" );
  p.location = j[ "location" ];
  p.binding = j[ "binding" ];
  p.format = j[ "format" ];
  p.offset = j[ "offset" ];
}
inline void from_json( const nlohmann::json &j, VkVertexInputAttributeDescription &p ) {
  VertexInputAttributeDescription temp;
  from_json( j, temp );
  p = VkVertexInputAttributeDescription ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineVertexInputStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "vertexBindingDescriptionCount" ] = p.vertexBindingDescriptionCount;
  j[ "pVertexBindingDescriptions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pVertexBindingDescriptions ) );
  j[ "vertexAttributeDescriptionCount" ] = p.vertexAttributeDescriptionCount;
  j[ "pVertexAttributeDescriptions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pVertexAttributeDescriptions ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineVertexInputStateCreateInfo &p ) {
  to_json( j, PipelineVertexInputStateCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineVertexInputStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineVertexInputStateCreateInfo" );
  p.flags = j[ "flags" ];
  p.vertexBindingDescriptionCount = j[ "vertexBindingDescriptionCount" ];
  p.vertexAttributeDescriptionCount = j[ "vertexAttributeDescriptionCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineVertexInputStateCreateInfo &p ) {
  PipelineVertexInputStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineVertexInputStateCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineInputAssemblyStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "topology" ] = p.topology;
  j[ "primitiveRestartEnable" ] = bool( p.primitiveRestartEnable );
}
inline void to_json( nlohmann::json &j, const VkPipelineInputAssemblyStateCreateInfo &p ) {
  to_json( j, PipelineInputAssemblyStateCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineInputAssemblyStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineInputAssemblyStateCreateInfo" );
  p.flags = j[ "flags" ];
  p.topology = j[ "topology" ];
  p.primitiveRestartEnable = j[ "primitiveRestartEnable" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineInputAssemblyStateCreateInfo &p ) {
  PipelineInputAssemblyStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineInputAssemblyStateCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineTessellationStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "patchControlPoints" ] = p.patchControlPoints;
}
inline void to_json( nlohmann::json &j, const VkPipelineTessellationStateCreateInfo &p ) {
  to_json( j, PipelineTessellationStateCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineTessellationStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineTessellationStateCreateInfo" );
  p.flags = j[ "flags" ];
  p.patchControlPoints = j[ "patchControlPoints" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineTessellationStateCreateInfo &p ) {
  PipelineTessellationStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineTessellationStateCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineViewportStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "viewportCount" ] = p.viewportCount;
  j[ "pViewports" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewports ) );
  j[ "scissorCount" ] = p.scissorCount;
  j[ "pScissors" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pScissors ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineViewportStateCreateInfo &p ) {
  to_json( j, PipelineViewportStateCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineViewportStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineViewportStateCreateInfo" );
  p.flags = j[ "flags" ];
  p.viewportCount = j[ "viewportCount" ];
  p.scissorCount = j[ "scissorCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineViewportStateCreateInfo &p ) {
  PipelineViewportStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineViewportStateCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineRasterizationStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "depthClampEnable" ] = bool( p.depthClampEnable );
  j[ "rasterizerDiscardEnable" ] = bool( p.rasterizerDiscardEnable );
  j[ "polygonMode" ] = p.polygonMode;
  j[ "cullMode" ] = p.cullMode;
  j[ "frontFace" ] = p.frontFace;
  j[ "depthBiasEnable" ] = bool( p.depthBiasEnable );
  j[ "depthBiasConstantFactor" ] = p.depthBiasConstantFactor;
  j[ "depthBiasClamp" ] = p.depthBiasClamp;
  j[ "depthBiasSlopeFactor" ] = p.depthBiasSlopeFactor;
  j[ "lineWidth" ] = p.lineWidth;
}
inline void to_json( nlohmann::json &j, const VkPipelineRasterizationStateCreateInfo &p ) {
  to_json( j, PipelineRasterizationStateCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRasterizationStateCreateInfo" );
  p.flags = j[ "flags" ];
  p.depthClampEnable = j[ "depthClampEnable" ];
  p.rasterizerDiscardEnable = j[ "rasterizerDiscardEnable" ];
  p.polygonMode = j[ "polygonMode" ];
  p.cullMode = j[ "cullMode" ];
  p.frontFace = j[ "frontFace" ];
  p.depthBiasEnable = j[ "depthBiasEnable" ];
  p.depthBiasConstantFactor = j[ "depthBiasConstantFactor" ];
  p.depthBiasClamp = j[ "depthBiasClamp" ];
  p.depthBiasSlopeFactor = j[ "depthBiasSlopeFactor" ];
  p.lineWidth = j[ "lineWidth" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineRasterizationStateCreateInfo &p ) {
  PipelineRasterizationStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineRasterizationStateCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineMultisampleStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "rasterizationSamples" ] = p.rasterizationSamples;
  j[ "sampleShadingEnable" ] = bool( p.sampleShadingEnable );
  j[ "minSampleShading" ] = p.minSampleShading;
  j[ "pSampleMask" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSampleMask ) );
  j[ "alphaToCoverageEnable" ] = bool( p.alphaToCoverageEnable );
  j[ "alphaToOneEnable" ] = bool( p.alphaToOneEnable );
}
inline void to_json( nlohmann::json &j, const VkPipelineMultisampleStateCreateInfo &p ) {
  to_json( j, PipelineMultisampleStateCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineMultisampleStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineMultisampleStateCreateInfo" );
  p.flags = j[ "flags" ];
  p.rasterizationSamples = j[ "rasterizationSamples" ];
  p.sampleShadingEnable = j[ "sampleShadingEnable" ];
  p.minSampleShading = j[ "minSampleShading" ];
  p.alphaToCoverageEnable = j[ "alphaToCoverageEnable" ];
  p.alphaToOneEnable = j[ "alphaToOneEnable" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineMultisampleStateCreateInfo &p ) {
  PipelineMultisampleStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineMultisampleStateCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const StencilOpState &p ) {
  j = nlohmann::json::object();
  j[ "failOp" ] = p.failOp;
  j[ "passOp" ] = p.passOp;
  j[ "depthFailOp" ] = p.depthFailOp;
  j[ "compareOp" ] = p.compareOp;
  j[ "compareMask" ] = p.compareMask;
  j[ "writeMask" ] = p.writeMask;
  j[ "reference" ] = p.reference;
}
inline void to_json( nlohmann::json &j, const VkStencilOpState &p ) {
  to_json( j, StencilOpState ( p ) );
}
inline void from_json( const nlohmann::json &j, StencilOpState &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for StencilOpState" );
  p.failOp = j[ "failOp" ];
  p.passOp = j[ "passOp" ];
  p.depthFailOp = j[ "depthFailOp" ];
  p.compareOp = j[ "compareOp" ];
  p.compareMask = j[ "compareMask" ];
  p.writeMask = j[ "writeMask" ];
  p.reference = j[ "reference" ];
}
inline void from_json( const nlohmann::json &j, VkStencilOpState &p ) {
  StencilOpState temp;
  from_json( j, temp );
  p = VkStencilOpState ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineDepthStencilStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "depthTestEnable" ] = bool( p.depthTestEnable );
  j[ "depthWriteEnable" ] = bool( p.depthWriteEnable );
  j[ "depthCompareOp" ] = p.depthCompareOp;
  j[ "depthBoundsTestEnable" ] = bool( p.depthBoundsTestEnable );
  j[ "stencilTestEnable" ] = bool( p.stencilTestEnable );
  j[ "front" ] = p.front;
  j[ "back" ] = p.back;
  j[ "minDepthBounds" ] = p.minDepthBounds;
  j[ "maxDepthBounds" ] = p.maxDepthBounds;
}
inline void to_json( nlohmann::json &j, const VkPipelineDepthStencilStateCreateInfo &p ) {
  to_json( j, PipelineDepthStencilStateCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineDepthStencilStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineDepthStencilStateCreateInfo" );
  p.flags = j[ "flags" ];
  p.depthTestEnable = j[ "depthTestEnable" ];
  p.depthWriteEnable = j[ "depthWriteEnable" ];
  p.depthCompareOp = j[ "depthCompareOp" ];
  p.depthBoundsTestEnable = j[ "depthBoundsTestEnable" ];
  p.stencilTestEnable = j[ "stencilTestEnable" ];
  p.front = j[ "front" ];
  p.back = j[ "back" ];
  p.minDepthBounds = j[ "minDepthBounds" ];
  p.maxDepthBounds = j[ "maxDepthBounds" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineDepthStencilStateCreateInfo &p ) {
  PipelineDepthStencilStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineDepthStencilStateCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineColorBlendAttachmentState &p ) {
  j = nlohmann::json::object();
  j[ "blendEnable" ] = bool( p.blendEnable );
  j[ "srcColorBlendFactor" ] = p.srcColorBlendFactor;
  j[ "dstColorBlendFactor" ] = p.dstColorBlendFactor;
  j[ "colorBlendOp" ] = p.colorBlendOp;
  j[ "srcAlphaBlendFactor" ] = p.srcAlphaBlendFactor;
  j[ "dstAlphaBlendFactor" ] = p.dstAlphaBlendFactor;
  j[ "alphaBlendOp" ] = p.alphaBlendOp;
  j[ "colorWriteMask" ] = p.colorWriteMask;
}
inline void to_json( nlohmann::json &j, const VkPipelineColorBlendAttachmentState &p ) {
  to_json( j, PipelineColorBlendAttachmentState ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineColorBlendAttachmentState &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineColorBlendAttachmentState" );
  p.blendEnable = j[ "blendEnable" ];
  p.srcColorBlendFactor = j[ "srcColorBlendFactor" ];
  p.dstColorBlendFactor = j[ "dstColorBlendFactor" ];
  p.colorBlendOp = j[ "colorBlendOp" ];
  p.srcAlphaBlendFactor = j[ "srcAlphaBlendFactor" ];
  p.dstAlphaBlendFactor = j[ "dstAlphaBlendFactor" ];
  p.alphaBlendOp = j[ "alphaBlendOp" ];
  p.colorWriteMask = j[ "colorWriteMask" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineColorBlendAttachmentState &p ) {
  PipelineColorBlendAttachmentState temp;
  from_json( j, temp );
  p = VkPipelineColorBlendAttachmentState ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineColorBlendStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "logicOpEnable" ] = bool( p.logicOpEnable );
  j[ "logicOp" ] = p.logicOp;
  j[ "attachmentCount" ] = p.attachmentCount;
  j[ "pAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttachments ) );
  j[ "blendConstants" ] = nlohmann::json::array();
  std::copy( p.blendConstants.begin(), p.blendConstants.end(), std::back_inserter( j[ "blendConstants" ] ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineColorBlendStateCreateInfo &p ) {
  to_json( j, PipelineColorBlendStateCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineColorBlendStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineColorBlendStateCreateInfo" );
  p.flags = j[ "flags" ];
  p.logicOpEnable = j[ "logicOpEnable" ];
  p.logicOp = j[ "logicOp" ];
  p.attachmentCount = j[ "attachmentCount" ];
  if( !j[ "blendConstants" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PipelineColorBlendStateCreateInfo.blendConstants" );
  if( !j[ "blendConstants" ].size() > p.blendConstants.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PipelineColorBlendStateCreateInfo.blendConstants" );
  std::fill( p.blendConstants.begin(), p.blendConstants.end(), 0 );
  std::copy( j[ "blendConstants" ].begin(), j[ "blendConstants" ].end(), p.blendConstants.begin() );
}
inline void from_json( const nlohmann::json &j, VkPipelineColorBlendStateCreateInfo &p ) {
  PipelineColorBlendStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineColorBlendStateCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineDynamicStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "dynamicStateCount" ] = p.dynamicStateCount;
  j[ "pDynamicStates" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDynamicStates ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineDynamicStateCreateInfo &p ) {
  to_json( j, PipelineDynamicStateCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineDynamicStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineDynamicStateCreateInfo" );
  p.flags = j[ "flags" ];
  p.dynamicStateCount = j[ "dynamicStateCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineDynamicStateCreateInfo &p ) {
  PipelineDynamicStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineDynamicStateCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const GraphicsPipelineCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "stageCount" ] = p.stageCount;
  j[ "pStages" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStages ) );
  j[ "pVertexInputState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pVertexInputState ) );
  j[ "pInputAssemblyState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pInputAssemblyState ) );
  j[ "pTessellationState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pTessellationState ) );
  j[ "pViewportState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewportState ) );
  j[ "pRasterizationState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRasterizationState ) );
  j[ "pMultisampleState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pMultisampleState ) );
  j[ "pDepthStencilState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDepthStencilState ) );
  j[ "pColorBlendState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pColorBlendState ) );
  j[ "pDynamicState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDynamicState ) );
  j[ "subpass" ] = p.subpass;
  j[ "basePipelineIndex" ] = p.basePipelineIndex;
}
inline void to_json( nlohmann::json &j, const VkGraphicsPipelineCreateInfo &p ) {
  to_json( j, GraphicsPipelineCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, GraphicsPipelineCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GraphicsPipelineCreateInfo" );
  p.flags = j[ "flags" ];
  p.stageCount = j[ "stageCount" ];
  p.subpass = j[ "subpass" ];
  p.basePipelineIndex = j[ "basePipelineIndex" ];
}
inline void from_json( const nlohmann::json &j, VkGraphicsPipelineCreateInfo &p ) {
  GraphicsPipelineCreateInfo temp;
  from_json( j, temp );
  p = VkGraphicsPipelineCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const GraphicsShaderGroupCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stageCount" ] = p.stageCount;
  j[ "pStages" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStages ) );
  j[ "pVertexInputState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pVertexInputState ) );
  j[ "pTessellationState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pTessellationState ) );
}
inline void to_json( nlohmann::json &j, const VkGraphicsShaderGroupCreateInfoNV &p ) {
  to_json( j, GraphicsShaderGroupCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, GraphicsShaderGroupCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GraphicsShaderGroupCreateInfoNV" );
  p.stageCount = j[ "stageCount" ];
}
inline void from_json( const nlohmann::json &j, VkGraphicsShaderGroupCreateInfoNV &p ) {
  GraphicsShaderGroupCreateInfoNV temp;
  from_json( j, temp );
  p = VkGraphicsShaderGroupCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const GraphicsPipelineShaderGroupsCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "groupCount" ] = p.groupCount;
  j[ "pGroups" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pGroups ) );
  j[ "pipelineCount" ] = p.pipelineCount;
  j[ "pPipelines" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPipelines ) );
}
inline void to_json( nlohmann::json &j, const VkGraphicsPipelineShaderGroupsCreateInfoNV &p ) {
  to_json( j, GraphicsPipelineShaderGroupsCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, GraphicsPipelineShaderGroupsCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for GraphicsPipelineShaderGroupsCreateInfoNV" );
  p.groupCount = j[ "groupCount" ];
  p.pipelineCount = j[ "pipelineCount" ];
}
inline void from_json( const nlohmann::json &j, VkGraphicsPipelineShaderGroupsCreateInfoNV &p ) {
  GraphicsPipelineShaderGroupsCreateInfoNV temp;
  from_json( j, temp );
  p = VkGraphicsPipelineShaderGroupsCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const XYColorEXT &p ) {
  j = nlohmann::json::object();
  j[ "x" ] = p.x;
  j[ "y" ] = p.y;
}
inline void to_json( nlohmann::json &j, const VkXYColorEXT &p ) {
  to_json( j, XYColorEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, XYColorEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for XYColorEXT" );
  p.x = j[ "x" ];
  p.y = j[ "y" ];
}
inline void from_json( const nlohmann::json &j, VkXYColorEXT &p ) {
  XYColorEXT temp;
  from_json( j, temp );
  p = VkXYColorEXT ( temp );
}

inline void to_json( nlohmann::json &j, const HdrMetadataEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "displayPrimaryRed" ] = p.displayPrimaryRed;
  j[ "displayPrimaryGreen" ] = p.displayPrimaryGreen;
  j[ "displayPrimaryBlue" ] = p.displayPrimaryBlue;
  j[ "whitePoint" ] = p.whitePoint;
  j[ "maxLuminance" ] = p.maxLuminance;
  j[ "minLuminance" ] = p.minLuminance;
  j[ "maxContentLightLevel" ] = p.maxContentLightLevel;
  j[ "maxFrameAverageLightLevel" ] = p.maxFrameAverageLightLevel;
}
inline void to_json( nlohmann::json &j, const VkHdrMetadataEXT &p ) {
  to_json( j, HdrMetadataEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, HdrMetadataEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for HdrMetadataEXT" );
  p.displayPrimaryRed = j[ "displayPrimaryRed" ];
  p.displayPrimaryGreen = j[ "displayPrimaryGreen" ];
  p.displayPrimaryBlue = j[ "displayPrimaryBlue" ];
  p.whitePoint = j[ "whitePoint" ];
  p.maxLuminance = j[ "maxLuminance" ];
  p.minLuminance = j[ "minLuminance" ];
  p.maxContentLightLevel = j[ "maxContentLightLevel" ];
  p.maxFrameAverageLightLevel = j[ "maxFrameAverageLightLevel" ];
}
inline void from_json( const nlohmann::json &j, VkHdrMetadataEXT &p ) {
  HdrMetadataEXT temp;
  from_json( j, temp );
  p = VkHdrMetadataEXT ( temp );
}

inline void to_json( nlohmann::json &j, const HeadlessSurfaceCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkHeadlessSurfaceCreateInfoEXT &p ) {
  to_json( j, HeadlessSurfaceCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, HeadlessSurfaceCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for HeadlessSurfaceCreateInfoEXT" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkHeadlessSurfaceCreateInfoEXT &p ) {
  HeadlessSurfaceCreateInfoEXT temp;
  from_json( j, temp );
  p = VkHeadlessSurfaceCreateInfoEXT ( temp );
}

#if defined( VK_USE_PLATFORM_IOS_MVK )
inline void to_json( nlohmann::json &j, const IOSSurfaceCreateInfoMVK &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pView" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pView ) );
}
inline void to_json( nlohmann::json &j, const VkIOSSurfaceCreateInfoMVK &p ) {
  to_json( j, IOSSurfaceCreateInfoMVK ( p ) );
}
inline void from_json( const nlohmann::json &j, IOSSurfaceCreateInfoMVK &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for IOSSurfaceCreateInfoMVK" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkIOSSurfaceCreateInfoMVK &p ) {
  IOSSurfaceCreateInfoMVK temp;
  from_json( j, temp );
  p = VkIOSSurfaceCreateInfoMVK ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const ImageBlit &p ) {
  j = nlohmann::json::object();
  j[ "srcSubresource" ] = p.srcSubresource;
  j[ "srcOffsets" ] = nlohmann::json::array();
  std::copy( p.srcOffsets.begin(), p.srcOffsets.end(), std::back_inserter( j[ "srcOffsets" ] ) );
  j[ "dstSubresource" ] = p.dstSubresource;
  j[ "dstOffsets" ] = nlohmann::json::array();
  std::copy( p.dstOffsets.begin(), p.dstOffsets.end(), std::back_inserter( j[ "dstOffsets" ] ) );
}
inline void to_json( nlohmann::json &j, const VkImageBlit &p ) {
  to_json( j, ImageBlit ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageBlit &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageBlit" );
  p.srcSubresource = j[ "srcSubresource" ];
  if( !j[ "srcOffsets" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for ImageBlit.srcOffsets" );
  if( !j[ "srcOffsets" ].size() > p.srcOffsets.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for ImageBlit.srcOffsets" );
  std::fill( p.srcOffsets.begin(), p.srcOffsets.end(), std::remove_cv_t< std::remove_reference_t< decltype( *p.srcOffsets.begin() ) > >() );
  std::copy( j[ "srcOffsets" ].begin(), j[ "srcOffsets" ].end(), p.srcOffsets.begin() );
  p.dstSubresource = j[ "dstSubresource" ];
  if( !j[ "dstOffsets" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for ImageBlit.dstOffsets" );
  if( !j[ "dstOffsets" ].size() > p.dstOffsets.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for ImageBlit.dstOffsets" );
  std::fill( p.dstOffsets.begin(), p.dstOffsets.end(), std::remove_cv_t< std::remove_reference_t< decltype( *p.dstOffsets.begin() ) > >() );
  std::copy( j[ "dstOffsets" ].begin(), j[ "dstOffsets" ].end(), p.dstOffsets.begin() );
}
inline void from_json( const nlohmann::json &j, VkImageBlit &p ) {
  ImageBlit temp;
  from_json( j, temp );
  p = VkImageBlit ( temp );
}

inline void to_json( nlohmann::json &j, const ImageCopy &p ) {
  j = nlohmann::json::object();
  j[ "srcSubresource" ] = p.srcSubresource;
  j[ "srcOffset" ] = p.srcOffset;
  j[ "dstSubresource" ] = p.dstSubresource;
  j[ "dstOffset" ] = p.dstOffset;
  j[ "extent" ] = p.extent;
}
inline void to_json( nlohmann::json &j, const VkImageCopy &p ) {
  to_json( j, ImageCopy ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageCopy &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageCopy" );
  p.srcSubresource = j[ "srcSubresource" ];
  p.srcOffset = j[ "srcOffset" ];
  p.dstSubresource = j[ "dstSubresource" ];
  p.dstOffset = j[ "dstOffset" ];
  p.extent = j[ "extent" ];
}
inline void from_json( const nlohmann::json &j, VkImageCopy &p ) {
  ImageCopy temp;
  from_json( j, temp );
  p = VkImageCopy ( temp );
}

inline void to_json( nlohmann::json &j, const ImageCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "imageType" ] = p.imageType;
  j[ "format" ] = p.format;
  j[ "extent" ] = p.extent;
  j[ "mipLevels" ] = p.mipLevels;
  j[ "arrayLayers" ] = p.arrayLayers;
  j[ "samples" ] = p.samples;
  j[ "tiling" ] = p.tiling;
  j[ "usage" ] = p.usage;
  j[ "sharingMode" ] = p.sharingMode;
  j[ "queueFamilyIndexCount" ] = p.queueFamilyIndexCount;
  j[ "pQueueFamilyIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pQueueFamilyIndices ) );
  j[ "initialLayout" ] = p.initialLayout;
}
inline void to_json( nlohmann::json &j, const VkImageCreateInfo &p ) {
  to_json( j, ImageCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageCreateInfo" );
  p.flags = j[ "flags" ];
  p.imageType = j[ "imageType" ];
  p.format = j[ "format" ];
  p.extent = j[ "extent" ];
  p.mipLevels = j[ "mipLevels" ];
  p.arrayLayers = j[ "arrayLayers" ];
  p.samples = j[ "samples" ];
  p.tiling = j[ "tiling" ];
  p.usage = j[ "usage" ];
  p.sharingMode = j[ "sharingMode" ];
  p.queueFamilyIndexCount = j[ "queueFamilyIndexCount" ];
  p.initialLayout = j[ "initialLayout" ];
}
inline void from_json( const nlohmann::json &j, VkImageCreateInfo &p ) {
  ImageCreateInfo temp;
  from_json( j, temp );
  p = VkImageCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SubresourceLayout &p ) {
  j = nlohmann::json::object();
  j[ "offset" ] = p.offset;
  j[ "size" ] = p.size;
  j[ "rowPitch" ] = p.rowPitch;
  j[ "arrayPitch" ] = p.arrayPitch;
  j[ "depthPitch" ] = p.depthPitch;
}
inline void to_json( nlohmann::json &j, const VkSubresourceLayout &p ) {
  to_json( j, SubresourceLayout ( p ) );
}
inline void from_json( const nlohmann::json &j, SubresourceLayout &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubresourceLayout" );
  p.offset = j[ "offset" ];
  p.size = j[ "size" ];
  p.rowPitch = j[ "rowPitch" ];
  p.arrayPitch = j[ "arrayPitch" ];
  p.depthPitch = j[ "depthPitch" ];
}
inline void from_json( const nlohmann::json &j, VkSubresourceLayout &p ) {
  SubresourceLayout temp;
  from_json( j, temp );
  p = VkSubresourceLayout ( temp );
}

inline void to_json( nlohmann::json &j, const ImageDrmFormatModifierExplicitCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "drmFormatModifier" ] = p.drmFormatModifier;
  j[ "drmFormatModifierPlaneCount" ] = p.drmFormatModifierPlaneCount;
  j[ "pPlaneLayouts" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPlaneLayouts ) );
}
inline void to_json( nlohmann::json &j, const VkImageDrmFormatModifierExplicitCreateInfoEXT &p ) {
  to_json( j, ImageDrmFormatModifierExplicitCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageDrmFormatModifierExplicitCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageDrmFormatModifierExplicitCreateInfoEXT" );
  p.drmFormatModifier = j[ "drmFormatModifier" ];
  p.drmFormatModifierPlaneCount = j[ "drmFormatModifierPlaneCount" ];
}
inline void from_json( const nlohmann::json &j, VkImageDrmFormatModifierExplicitCreateInfoEXT &p ) {
  ImageDrmFormatModifierExplicitCreateInfoEXT temp;
  from_json( j, temp );
  p = VkImageDrmFormatModifierExplicitCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const ImageDrmFormatModifierListCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "drmFormatModifierCount" ] = p.drmFormatModifierCount;
  j[ "pDrmFormatModifiers" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDrmFormatModifiers ) );
}
inline void to_json( nlohmann::json &j, const VkImageDrmFormatModifierListCreateInfoEXT &p ) {
  to_json( j, ImageDrmFormatModifierListCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageDrmFormatModifierListCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageDrmFormatModifierListCreateInfoEXT" );
  p.drmFormatModifierCount = j[ "drmFormatModifierCount" ];
}
inline void from_json( const nlohmann::json &j, VkImageDrmFormatModifierListCreateInfoEXT &p ) {
  ImageDrmFormatModifierListCreateInfoEXT temp;
  from_json( j, temp );
  p = VkImageDrmFormatModifierListCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const ImageDrmFormatModifierPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "drmFormatModifier" ] = p.drmFormatModifier;
}
inline void to_json( nlohmann::json &j, const VkImageDrmFormatModifierPropertiesEXT &p ) {
  to_json( j, ImageDrmFormatModifierPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageDrmFormatModifierPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageDrmFormatModifierPropertiesEXT" );
  p.drmFormatModifier = j[ "drmFormatModifier" ];
}
inline void from_json( const nlohmann::json &j, VkImageDrmFormatModifierPropertiesEXT &p ) {
  ImageDrmFormatModifierPropertiesEXT temp;
  from_json( j, temp );
  p = VkImageDrmFormatModifierPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const ImageFormatListCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "viewFormatCount" ] = p.viewFormatCount;
  j[ "pViewFormats" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewFormats ) );
}
inline void to_json( nlohmann::json &j, const VkImageFormatListCreateInfo &p ) {
  to_json( j, ImageFormatListCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageFormatListCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageFormatListCreateInfo" );
  p.viewFormatCount = j[ "viewFormatCount" ];
}
inline void from_json( const nlohmann::json &j, VkImageFormatListCreateInfo &p ) {
  ImageFormatListCreateInfo temp;
  from_json( j, temp );
  p = VkImageFormatListCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const ImageFormatProperties2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "imageFormatProperties" ] = p.imageFormatProperties;
}
inline void to_json( nlohmann::json &j, const VkImageFormatProperties2 &p ) {
  to_json( j, ImageFormatProperties2 ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageFormatProperties2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageFormatProperties2" );
  p.imageFormatProperties = j[ "imageFormatProperties" ];
}
inline void from_json( const nlohmann::json &j, VkImageFormatProperties2 &p ) {
  ImageFormatProperties2 temp;
  from_json( j, temp );
  p = VkImageFormatProperties2 ( temp );
}

inline void to_json( nlohmann::json &j, const ImageMemoryBarrier &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
  j[ "oldLayout" ] = p.oldLayout;
  j[ "newLayout" ] = p.newLayout;
  j[ "srcQueueFamilyIndex" ] = p.srcQueueFamilyIndex;
  j[ "dstQueueFamilyIndex" ] = p.dstQueueFamilyIndex;
  j[ "subresourceRange" ] = p.subresourceRange;
}
inline void to_json( nlohmann::json &j, const VkImageMemoryBarrier &p ) {
  to_json( j, ImageMemoryBarrier ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageMemoryBarrier &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageMemoryBarrier" );
  p.srcAccessMask = j[ "srcAccessMask" ];
  p.dstAccessMask = j[ "dstAccessMask" ];
  p.oldLayout = j[ "oldLayout" ];
  p.newLayout = j[ "newLayout" ];
  p.srcQueueFamilyIndex = j[ "srcQueueFamilyIndex" ];
  p.dstQueueFamilyIndex = j[ "dstQueueFamilyIndex" ];
  p.subresourceRange = j[ "subresourceRange" ];
}
inline void from_json( const nlohmann::json &j, VkImageMemoryBarrier &p ) {
  ImageMemoryBarrier temp;
  from_json( j, temp );
  p = VkImageMemoryBarrier ( temp );
}

inline void to_json( nlohmann::json &j, const ImageMemoryRequirementsInfo2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkImageMemoryRequirementsInfo2 &p ) {
  to_json( j, ImageMemoryRequirementsInfo2 ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageMemoryRequirementsInfo2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageMemoryRequirementsInfo2" );
}
inline void from_json( const nlohmann::json &j, VkImageMemoryRequirementsInfo2 &p ) {
  ImageMemoryRequirementsInfo2 temp;
  from_json( j, temp );
  p = VkImageMemoryRequirementsInfo2 ( temp );
}

#if defined( VK_USE_PLATFORM_FUCHSIA )
inline void to_json( nlohmann::json &j, const ImagePipeSurfaceCreateInfoFUCHSIA &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkImagePipeSurfaceCreateInfoFUCHSIA &p ) {
  to_json( j, ImagePipeSurfaceCreateInfoFUCHSIA ( p ) );
}
inline void from_json( const nlohmann::json &j, ImagePipeSurfaceCreateInfoFUCHSIA &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImagePipeSurfaceCreateInfoFUCHSIA" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkImagePipeSurfaceCreateInfoFUCHSIA &p ) {
  ImagePipeSurfaceCreateInfoFUCHSIA temp;
  from_json( j, temp );
  p = VkImagePipeSurfaceCreateInfoFUCHSIA ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const ImagePlaneMemoryRequirementsInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "planeAspect" ] = p.planeAspect;
}
inline void to_json( nlohmann::json &j, const VkImagePlaneMemoryRequirementsInfo &p ) {
  to_json( j, ImagePlaneMemoryRequirementsInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ImagePlaneMemoryRequirementsInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImagePlaneMemoryRequirementsInfo" );
  p.planeAspect = j[ "planeAspect" ];
}
inline void from_json( const nlohmann::json &j, VkImagePlaneMemoryRequirementsInfo &p ) {
  ImagePlaneMemoryRequirementsInfo temp;
  from_json( j, temp );
  p = VkImagePlaneMemoryRequirementsInfo ( temp );
}

inline void to_json( nlohmann::json &j, const ImageResolve &p ) {
  j = nlohmann::json::object();
  j[ "srcSubresource" ] = p.srcSubresource;
  j[ "srcOffset" ] = p.srcOffset;
  j[ "dstSubresource" ] = p.dstSubresource;
  j[ "dstOffset" ] = p.dstOffset;
  j[ "extent" ] = p.extent;
}
inline void to_json( nlohmann::json &j, const VkImageResolve &p ) {
  to_json( j, ImageResolve ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageResolve &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageResolve" );
  p.srcSubresource = j[ "srcSubresource" ];
  p.srcOffset = j[ "srcOffset" ];
  p.dstSubresource = j[ "dstSubresource" ];
  p.dstOffset = j[ "dstOffset" ];
  p.extent = j[ "extent" ];
}
inline void from_json( const nlohmann::json &j, VkImageResolve &p ) {
  ImageResolve temp;
  from_json( j, temp );
  p = VkImageResolve ( temp );
}

inline void to_json( nlohmann::json &j, const ImageResolve2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcSubresource" ] = p.srcSubresource;
  j[ "srcOffset" ] = p.srcOffset;
  j[ "dstSubresource" ] = p.dstSubresource;
  j[ "dstOffset" ] = p.dstOffset;
  j[ "extent" ] = p.extent;
}
inline void to_json( nlohmann::json &j, const VkImageResolve2KHR &p ) {
  to_json( j, ImageResolve2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageResolve2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageResolve2KHR" );
  p.srcSubresource = j[ "srcSubresource" ];
  p.srcOffset = j[ "srcOffset" ];
  p.dstSubresource = j[ "dstSubresource" ];
  p.dstOffset = j[ "dstOffset" ];
  p.extent = j[ "extent" ];
}
inline void from_json( const nlohmann::json &j, VkImageResolve2KHR &p ) {
  ImageResolve2KHR temp;
  from_json( j, temp );
  p = VkImageResolve2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const ImageSparseMemoryRequirementsInfo2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkImageSparseMemoryRequirementsInfo2 &p ) {
  to_json( j, ImageSparseMemoryRequirementsInfo2 ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageSparseMemoryRequirementsInfo2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageSparseMemoryRequirementsInfo2" );
}
inline void from_json( const nlohmann::json &j, VkImageSparseMemoryRequirementsInfo2 &p ) {
  ImageSparseMemoryRequirementsInfo2 temp;
  from_json( j, temp );
  p = VkImageSparseMemoryRequirementsInfo2 ( temp );
}

inline void to_json( nlohmann::json &j, const ImageStencilUsageCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stencilUsage" ] = p.stencilUsage;
}
inline void to_json( nlohmann::json &j, const VkImageStencilUsageCreateInfo &p ) {
  to_json( j, ImageStencilUsageCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageStencilUsageCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageStencilUsageCreateInfo" );
  p.stencilUsage = j[ "stencilUsage" ];
}
inline void from_json( const nlohmann::json &j, VkImageStencilUsageCreateInfo &p ) {
  ImageStencilUsageCreateInfo temp;
  from_json( j, temp );
  p = VkImageStencilUsageCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const ImageSwapchainCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkImageSwapchainCreateInfoKHR &p ) {
  to_json( j, ImageSwapchainCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageSwapchainCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageSwapchainCreateInfoKHR" );
}
inline void from_json( const nlohmann::json &j, VkImageSwapchainCreateInfoKHR &p ) {
  ImageSwapchainCreateInfoKHR temp;
  from_json( j, temp );
  p = VkImageSwapchainCreateInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const ImageViewASTCDecodeModeEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "decodeMode" ] = p.decodeMode;
}
inline void to_json( nlohmann::json &j, const VkImageViewASTCDecodeModeEXT &p ) {
  to_json( j, ImageViewASTCDecodeModeEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageViewASTCDecodeModeEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageViewASTCDecodeModeEXT" );
  p.decodeMode = j[ "decodeMode" ];
}
inline void from_json( const nlohmann::json &j, VkImageViewASTCDecodeModeEXT &p ) {
  ImageViewASTCDecodeModeEXT temp;
  from_json( j, temp );
  p = VkImageViewASTCDecodeModeEXT ( temp );
}

inline void to_json( nlohmann::json &j, const ImageViewAddressPropertiesNVX &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "size" ] = p.size;
}
inline void to_json( nlohmann::json &j, const VkImageViewAddressPropertiesNVX &p ) {
  to_json( j, ImageViewAddressPropertiesNVX ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageViewAddressPropertiesNVX &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageViewAddressPropertiesNVX" );
  p.size = j[ "size" ];
}
inline void from_json( const nlohmann::json &j, VkImageViewAddressPropertiesNVX &p ) {
  ImageViewAddressPropertiesNVX temp;
  from_json( j, temp );
  p = VkImageViewAddressPropertiesNVX ( temp );
}

inline void to_json( nlohmann::json &j, const ImageViewCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "viewType" ] = p.viewType;
  j[ "format" ] = p.format;
  j[ "components" ] = p.components;
  j[ "subresourceRange" ] = p.subresourceRange;
}
inline void to_json( nlohmann::json &j, const VkImageViewCreateInfo &p ) {
  to_json( j, ImageViewCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageViewCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageViewCreateInfo" );
  p.flags = j[ "flags" ];
  p.viewType = j[ "viewType" ];
  p.format = j[ "format" ];
  p.components = j[ "components" ];
  p.subresourceRange = j[ "subresourceRange" ];
}
inline void from_json( const nlohmann::json &j, VkImageViewCreateInfo &p ) {
  ImageViewCreateInfo temp;
  from_json( j, temp );
  p = VkImageViewCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const ImageViewHandleInfoNVX &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "descriptorType" ] = p.descriptorType;
}
inline void to_json( nlohmann::json &j, const VkImageViewHandleInfoNVX &p ) {
  to_json( j, ImageViewHandleInfoNVX ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageViewHandleInfoNVX &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageViewHandleInfoNVX" );
  p.descriptorType = j[ "descriptorType" ];
}
inline void from_json( const nlohmann::json &j, VkImageViewHandleInfoNVX &p ) {
  ImageViewHandleInfoNVX temp;
  from_json( j, temp );
  p = VkImageViewHandleInfoNVX ( temp );
}

inline void to_json( nlohmann::json &j, const ImageViewUsageCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "usage" ] = p.usage;
}
inline void to_json( nlohmann::json &j, const VkImageViewUsageCreateInfo &p ) {
  to_json( j, ImageViewUsageCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ImageViewUsageCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImageViewUsageCreateInfo" );
  p.usage = j[ "usage" ];
}
inline void from_json( const nlohmann::json &j, VkImageViewUsageCreateInfo &p ) {
  ImageViewUsageCreateInfo temp;
  from_json( j, temp );
  p = VkImageViewUsageCreateInfo ( temp );
}

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
inline void to_json( nlohmann::json &j, const ImportAndroidHardwareBufferInfoANDROID &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "buffer" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.buffer ) );
}
inline void to_json( nlohmann::json &j, const VkImportAndroidHardwareBufferInfoANDROID &p ) {
  to_json( j, ImportAndroidHardwareBufferInfoANDROID ( p ) );
}
inline void from_json( const nlohmann::json &j, ImportAndroidHardwareBufferInfoANDROID &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportAndroidHardwareBufferInfoANDROID" );
}
inline void from_json( const nlohmann::json &j, VkImportAndroidHardwareBufferInfoANDROID &p ) {
  ImportAndroidHardwareBufferInfoANDROID temp;
  from_json( j, temp );
  p = VkImportAndroidHardwareBufferInfoANDROID ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const ImportFenceFdInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "handleType" ] = p.handleType;
  j[ "fd" ] = p.fd;
}
inline void to_json( nlohmann::json &j, const VkImportFenceFdInfoKHR &p ) {
  to_json( j, ImportFenceFdInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ImportFenceFdInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportFenceFdInfoKHR" );
  p.flags = j[ "flags" ];
  p.handleType = j[ "handleType" ];
  p.fd = j[ "fd" ];
}
inline void from_json( const nlohmann::json &j, VkImportFenceFdInfoKHR &p ) {
  ImportFenceFdInfoKHR temp;
  from_json( j, temp );
  p = VkImportFenceFdInfoKHR ( temp );
}

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const ImportFenceWin32HandleInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkImportFenceWin32HandleInfoKHR &p ) {
  to_json( j, ImportFenceWin32HandleInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ImportFenceWin32HandleInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportFenceWin32HandleInfoKHR" );
  p.flags = j[ "flags" ];
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkImportFenceWin32HandleInfoKHR &p ) {
  ImportFenceWin32HandleInfoKHR temp;
  from_json( j, temp );
  p = VkImportFenceWin32HandleInfoKHR ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const ImportMemoryFdInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
  j[ "fd" ] = p.fd;
}
inline void to_json( nlohmann::json &j, const VkImportMemoryFdInfoKHR &p ) {
  to_json( j, ImportMemoryFdInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ImportMemoryFdInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportMemoryFdInfoKHR" );
  p.handleType = j[ "handleType" ];
  p.fd = j[ "fd" ];
}
inline void from_json( const nlohmann::json &j, VkImportMemoryFdInfoKHR &p ) {
  ImportMemoryFdInfoKHR temp;
  from_json( j, temp );
  p = VkImportMemoryFdInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const ImportMemoryHostPointerInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
  j[ "pHostPointer" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pHostPointer ) );
}
inline void to_json( nlohmann::json &j, const VkImportMemoryHostPointerInfoEXT &p ) {
  to_json( j, ImportMemoryHostPointerInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ImportMemoryHostPointerInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportMemoryHostPointerInfoEXT" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkImportMemoryHostPointerInfoEXT &p ) {
  ImportMemoryHostPointerInfoEXT temp;
  from_json( j, temp );
  p = VkImportMemoryHostPointerInfoEXT ( temp );
}

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const ImportMemoryWin32HandleInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkImportMemoryWin32HandleInfoKHR &p ) {
  to_json( j, ImportMemoryWin32HandleInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ImportMemoryWin32HandleInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportMemoryWin32HandleInfoKHR" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkImportMemoryWin32HandleInfoKHR &p ) {
  ImportMemoryWin32HandleInfoKHR temp;
  from_json( j, temp );
  p = VkImportMemoryWin32HandleInfoKHR ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const ImportMemoryWin32HandleInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkImportMemoryWin32HandleInfoNV &p ) {
  to_json( j, ImportMemoryWin32HandleInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, ImportMemoryWin32HandleInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportMemoryWin32HandleInfoNV" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkImportMemoryWin32HandleInfoNV &p ) {
  ImportMemoryWin32HandleInfoNV temp;
  from_json( j, temp );
  p = VkImportMemoryWin32HandleInfoNV ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_FUCHSIA )
inline void to_json( nlohmann::json &j, const ImportMemoryZirconHandleInfoFUCHSIA &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkImportMemoryZirconHandleInfoFUCHSIA &p ) {
  to_json( j, ImportMemoryZirconHandleInfoFUCHSIA ( p ) );
}
inline void from_json( const nlohmann::json &j, ImportMemoryZirconHandleInfoFUCHSIA &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportMemoryZirconHandleInfoFUCHSIA" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkImportMemoryZirconHandleInfoFUCHSIA &p ) {
  ImportMemoryZirconHandleInfoFUCHSIA temp;
  from_json( j, temp );
  p = VkImportMemoryZirconHandleInfoFUCHSIA ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const ImportSemaphoreFdInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "handleType" ] = p.handleType;
  j[ "fd" ] = p.fd;
}
inline void to_json( nlohmann::json &j, const VkImportSemaphoreFdInfoKHR &p ) {
  to_json( j, ImportSemaphoreFdInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ImportSemaphoreFdInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportSemaphoreFdInfoKHR" );
  p.flags = j[ "flags" ];
  p.handleType = j[ "handleType" ];
  p.fd = j[ "fd" ];
}
inline void from_json( const nlohmann::json &j, VkImportSemaphoreFdInfoKHR &p ) {
  ImportSemaphoreFdInfoKHR temp;
  from_json( j, temp );
  p = VkImportSemaphoreFdInfoKHR ( temp );
}

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const ImportSemaphoreWin32HandleInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkImportSemaphoreWin32HandleInfoKHR &p ) {
  to_json( j, ImportSemaphoreWin32HandleInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ImportSemaphoreWin32HandleInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportSemaphoreWin32HandleInfoKHR" );
  p.flags = j[ "flags" ];
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkImportSemaphoreWin32HandleInfoKHR &p ) {
  ImportSemaphoreWin32HandleInfoKHR temp;
  from_json( j, temp );
  p = VkImportSemaphoreWin32HandleInfoKHR ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_FUCHSIA )
inline void to_json( nlohmann::json &j, const ImportSemaphoreZirconHandleInfoFUCHSIA &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkImportSemaphoreZirconHandleInfoFUCHSIA &p ) {
  to_json( j, ImportSemaphoreZirconHandleInfoFUCHSIA ( p ) );
}
inline void from_json( const nlohmann::json &j, ImportSemaphoreZirconHandleInfoFUCHSIA &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ImportSemaphoreZirconHandleInfoFUCHSIA" );
  p.flags = j[ "flags" ];
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkImportSemaphoreZirconHandleInfoFUCHSIA &p ) {
  ImportSemaphoreZirconHandleInfoFUCHSIA temp;
  from_json( j, temp );
  p = VkImportSemaphoreZirconHandleInfoFUCHSIA ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const IndirectCommandsLayoutTokenNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "tokenType" ] = p.tokenType;
  j[ "stream" ] = p.stream;
  j[ "offset" ] = p.offset;
  j[ "vertexBindingUnit" ] = p.vertexBindingUnit;
  j[ "vertexDynamicStride" ] = bool( p.vertexDynamicStride );
  j[ "pushconstantShaderStageFlags" ] = p.pushconstantShaderStageFlags;
  j[ "pushconstantOffset" ] = p.pushconstantOffset;
  j[ "pushconstantSize" ] = p.pushconstantSize;
  j[ "indirectStateFlags" ] = p.indirectStateFlags;
  j[ "indexTypeCount" ] = p.indexTypeCount;
  j[ "pIndexTypes" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pIndexTypes ) );
  j[ "pIndexTypeValues" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pIndexTypeValues ) );
}
inline void to_json( nlohmann::json &j, const VkIndirectCommandsLayoutTokenNV &p ) {
  to_json( j, IndirectCommandsLayoutTokenNV ( p ) );
}
inline void from_json( const nlohmann::json &j, IndirectCommandsLayoutTokenNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for IndirectCommandsLayoutTokenNV" );
  p.tokenType = j[ "tokenType" ];
  p.stream = j[ "stream" ];
  p.offset = j[ "offset" ];
  p.vertexBindingUnit = j[ "vertexBindingUnit" ];
  p.vertexDynamicStride = j[ "vertexDynamicStride" ];
  p.pushconstantShaderStageFlags = j[ "pushconstantShaderStageFlags" ];
  p.pushconstantOffset = j[ "pushconstantOffset" ];
  p.pushconstantSize = j[ "pushconstantSize" ];
  p.indirectStateFlags = j[ "indirectStateFlags" ];
  p.indexTypeCount = j[ "indexTypeCount" ];
}
inline void from_json( const nlohmann::json &j, VkIndirectCommandsLayoutTokenNV &p ) {
  IndirectCommandsLayoutTokenNV temp;
  from_json( j, temp );
  p = VkIndirectCommandsLayoutTokenNV ( temp );
}

inline void to_json( nlohmann::json &j, const IndirectCommandsLayoutCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pipelineBindPoint" ] = p.pipelineBindPoint;
  j[ "tokenCount" ] = p.tokenCount;
  j[ "pTokens" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pTokens ) );
  j[ "streamCount" ] = p.streamCount;
  j[ "pStreamStrides" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStreamStrides ) );
}
inline void to_json( nlohmann::json &j, const VkIndirectCommandsLayoutCreateInfoNV &p ) {
  to_json( j, IndirectCommandsLayoutCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, IndirectCommandsLayoutCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for IndirectCommandsLayoutCreateInfoNV" );
  p.flags = j[ "flags" ];
  p.pipelineBindPoint = j[ "pipelineBindPoint" ];
  p.tokenCount = j[ "tokenCount" ];
  p.streamCount = j[ "streamCount" ];
}
inline void from_json( const nlohmann::json &j, VkIndirectCommandsLayoutCreateInfoNV &p ) {
  IndirectCommandsLayoutCreateInfoNV temp;
  from_json( j, temp );
  p = VkIndirectCommandsLayoutCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const InitializePerformanceApiInfoINTEL &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pUserData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pUserData ) );
}
inline void to_json( nlohmann::json &j, const VkInitializePerformanceApiInfoINTEL &p ) {
  to_json( j, InitializePerformanceApiInfoINTEL ( p ) );
}
inline void from_json( const nlohmann::json &j, InitializePerformanceApiInfoINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for InitializePerformanceApiInfoINTEL" );
}
inline void from_json( const nlohmann::json &j, VkInitializePerformanceApiInfoINTEL &p ) {
  InitializePerformanceApiInfoINTEL temp;
  from_json( j, temp );
  p = VkInitializePerformanceApiInfoINTEL ( temp );
}

inline void to_json( nlohmann::json &j, const InputAttachmentAspectReference &p ) {
  j = nlohmann::json::object();
  j[ "subpass" ] = p.subpass;
  j[ "inputAttachmentIndex" ] = p.inputAttachmentIndex;
  j[ "aspectMask" ] = p.aspectMask;
}
inline void to_json( nlohmann::json &j, const VkInputAttachmentAspectReference &p ) {
  to_json( j, InputAttachmentAspectReference ( p ) );
}
inline void from_json( const nlohmann::json &j, InputAttachmentAspectReference &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for InputAttachmentAspectReference" );
  p.subpass = j[ "subpass" ];
  p.inputAttachmentIndex = j[ "inputAttachmentIndex" ];
  p.aspectMask = j[ "aspectMask" ];
}
inline void from_json( const nlohmann::json &j, VkInputAttachmentAspectReference &p ) {
  InputAttachmentAspectReference temp;
  from_json( j, temp );
  p = VkInputAttachmentAspectReference ( temp );
}

inline void to_json( nlohmann::json &j, const InstanceCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pApplicationInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pApplicationInfo ) );
  j[ "enabledLayerCount" ] = p.enabledLayerCount;
  j[ "ppEnabledLayerNames" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.ppEnabledLayerNames ) );
  j[ "enabledExtensionCount" ] = p.enabledExtensionCount;
  j[ "ppEnabledExtensionNames" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.ppEnabledExtensionNames ) );
}
inline void to_json( nlohmann::json &j, const VkInstanceCreateInfo &p ) {
  to_json( j, InstanceCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, InstanceCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for InstanceCreateInfo" );
  p.flags = j[ "flags" ];
  p.enabledLayerCount = j[ "enabledLayerCount" ];
  p.enabledExtensionCount = j[ "enabledExtensionCount" ];
}
inline void from_json( const nlohmann::json &j, VkInstanceCreateInfo &p ) {
  InstanceCreateInfo temp;
  from_json( j, temp );
  p = VkInstanceCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const LayerProperties &p ) {
  j = nlohmann::json::object();
  j[ "layerName" ] = std::string( p.layerName.begin(), std::find( p.layerName.begin(), p.layerName.end(), '\0' ) );
  j[ "specVersion" ] = p.specVersion;
  j[ "implementationVersion" ] = p.implementationVersion;
  j[ "description" ] = std::string( p.description.begin(), std::find( p.description.begin(), p.description.end(), '\0' ) );
}
inline void to_json( nlohmann::json &j, const VkLayerProperties &p ) {
  to_json( j, LayerProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, LayerProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for LayerProperties" );
  {
    std::string s = j[ "layerName" ];
    if( !p.layerName.empty() ) {
      p.layerName[ p.layerName.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.layerName.size() - 1u ) ), p.layerName.begin() );
    }
  }
  p.specVersion = j[ "specVersion" ];
  p.implementationVersion = j[ "implementationVersion" ];
  {
    std::string s = j[ "description" ];
    if( !p.description.empty() ) {
      p.description[ p.description.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.description.size() - 1u ) ), p.description.begin() );
    }
  }
}
inline void from_json( const nlohmann::json &j, VkLayerProperties &p ) {
  LayerProperties temp;
  from_json( j, temp );
  p = VkLayerProperties ( temp );
}

#if defined( VK_USE_PLATFORM_MACOS_MVK )
inline void to_json( nlohmann::json &j, const MacOSSurfaceCreateInfoMVK &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pView" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pView ) );
}
inline void to_json( nlohmann::json &j, const VkMacOSSurfaceCreateInfoMVK &p ) {
  to_json( j, MacOSSurfaceCreateInfoMVK ( p ) );
}
inline void from_json( const nlohmann::json &j, MacOSSurfaceCreateInfoMVK &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MacOSSurfaceCreateInfoMVK" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkMacOSSurfaceCreateInfoMVK &p ) {
  MacOSSurfaceCreateInfoMVK temp;
  from_json( j, temp );
  p = VkMacOSSurfaceCreateInfoMVK ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const MappedMemoryRange &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "offset" ] = p.offset;
  j[ "size" ] = p.size;
}
inline void to_json( nlohmann::json &j, const VkMappedMemoryRange &p ) {
  to_json( j, MappedMemoryRange ( p ) );
}
inline void from_json( const nlohmann::json &j, MappedMemoryRange &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MappedMemoryRange" );
  p.offset = j[ "offset" ];
  p.size = j[ "size" ];
}
inline void from_json( const nlohmann::json &j, VkMappedMemoryRange &p ) {
  MappedMemoryRange temp;
  from_json( j, temp );
  p = VkMappedMemoryRange ( temp );
}

inline void to_json( nlohmann::json &j, const MemoryAllocateFlagsInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "deviceMask" ] = p.deviceMask;
}
inline void to_json( nlohmann::json &j, const VkMemoryAllocateFlagsInfo &p ) {
  to_json( j, MemoryAllocateFlagsInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryAllocateFlagsInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryAllocateFlagsInfo" );
  p.flags = j[ "flags" ];
  p.deviceMask = j[ "deviceMask" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryAllocateFlagsInfo &p ) {
  MemoryAllocateFlagsInfo temp;
  from_json( j, temp );
  p = VkMemoryAllocateFlagsInfo ( temp );
}

inline void to_json( nlohmann::json &j, const MemoryAllocateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "allocationSize" ] = p.allocationSize;
  j[ "memoryTypeIndex" ] = p.memoryTypeIndex;
}
inline void to_json( nlohmann::json &j, const VkMemoryAllocateInfo &p ) {
  to_json( j, MemoryAllocateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryAllocateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryAllocateInfo" );
  p.allocationSize = j[ "allocationSize" ];
  p.memoryTypeIndex = j[ "memoryTypeIndex" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryAllocateInfo &p ) {
  MemoryAllocateInfo temp;
  from_json( j, temp );
  p = VkMemoryAllocateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const MemoryBarrier &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
}
inline void to_json( nlohmann::json &j, const VkMemoryBarrier &p ) {
  to_json( j, MemoryBarrier ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryBarrier &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryBarrier" );
  p.srcAccessMask = j[ "srcAccessMask" ];
  p.dstAccessMask = j[ "dstAccessMask" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryBarrier &p ) {
  MemoryBarrier temp;
  from_json( j, temp );
  p = VkMemoryBarrier ( temp );
}

inline void to_json( nlohmann::json &j, const MemoryDedicatedAllocateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkMemoryDedicatedAllocateInfo &p ) {
  to_json( j, MemoryDedicatedAllocateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryDedicatedAllocateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryDedicatedAllocateInfo" );
}
inline void from_json( const nlohmann::json &j, VkMemoryDedicatedAllocateInfo &p ) {
  MemoryDedicatedAllocateInfo temp;
  from_json( j, temp );
  p = VkMemoryDedicatedAllocateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const MemoryDedicatedRequirements &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "prefersDedicatedAllocation" ] = bool( p.prefersDedicatedAllocation );
  j[ "requiresDedicatedAllocation" ] = bool( p.requiresDedicatedAllocation );
}
inline void to_json( nlohmann::json &j, const VkMemoryDedicatedRequirements &p ) {
  to_json( j, MemoryDedicatedRequirements ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryDedicatedRequirements &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryDedicatedRequirements" );
  p.prefersDedicatedAllocation = j[ "prefersDedicatedAllocation" ];
  p.requiresDedicatedAllocation = j[ "requiresDedicatedAllocation" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryDedicatedRequirements &p ) {
  MemoryDedicatedRequirements temp;
  from_json( j, temp );
  p = VkMemoryDedicatedRequirements ( temp );
}

inline void to_json( nlohmann::json &j, const MemoryFdPropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryTypeBits" ] = p.memoryTypeBits;
}
inline void to_json( nlohmann::json &j, const VkMemoryFdPropertiesKHR &p ) {
  to_json( j, MemoryFdPropertiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryFdPropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryFdPropertiesKHR" );
  p.memoryTypeBits = j[ "memoryTypeBits" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryFdPropertiesKHR &p ) {
  MemoryFdPropertiesKHR temp;
  from_json( j, temp );
  p = VkMemoryFdPropertiesKHR ( temp );
}

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
inline void to_json( nlohmann::json &j, const MemoryGetAndroidHardwareBufferInfoANDROID &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkMemoryGetAndroidHardwareBufferInfoANDROID &p ) {
  to_json( j, MemoryGetAndroidHardwareBufferInfoANDROID ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryGetAndroidHardwareBufferInfoANDROID &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryGetAndroidHardwareBufferInfoANDROID" );
}
inline void from_json( const nlohmann::json &j, VkMemoryGetAndroidHardwareBufferInfoANDROID &p ) {
  MemoryGetAndroidHardwareBufferInfoANDROID temp;
  from_json( j, temp );
  p = VkMemoryGetAndroidHardwareBufferInfoANDROID ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const MemoryGetFdInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkMemoryGetFdInfoKHR &p ) {
  to_json( j, MemoryGetFdInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryGetFdInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryGetFdInfoKHR" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryGetFdInfoKHR &p ) {
  MemoryGetFdInfoKHR temp;
  from_json( j, temp );
  p = VkMemoryGetFdInfoKHR ( temp );
}

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const MemoryGetWin32HandleInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkMemoryGetWin32HandleInfoKHR &p ) {
  to_json( j, MemoryGetWin32HandleInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryGetWin32HandleInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryGetWin32HandleInfoKHR" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryGetWin32HandleInfoKHR &p ) {
  MemoryGetWin32HandleInfoKHR temp;
  from_json( j, temp );
  p = VkMemoryGetWin32HandleInfoKHR ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_FUCHSIA )
inline void to_json( nlohmann::json &j, const MemoryGetZirconHandleInfoFUCHSIA &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkMemoryGetZirconHandleInfoFUCHSIA &p ) {
  to_json( j, MemoryGetZirconHandleInfoFUCHSIA ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryGetZirconHandleInfoFUCHSIA &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryGetZirconHandleInfoFUCHSIA" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryGetZirconHandleInfoFUCHSIA &p ) {
  MemoryGetZirconHandleInfoFUCHSIA temp;
  from_json( j, temp );
  p = VkMemoryGetZirconHandleInfoFUCHSIA ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const MemoryHeap &p ) {
  j = nlohmann::json::object();
  j[ "size" ] = p.size;
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkMemoryHeap &p ) {
  to_json( j, MemoryHeap ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryHeap &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryHeap" );
  p.size = j[ "size" ];
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryHeap &p ) {
  MemoryHeap temp;
  from_json( j, temp );
  p = VkMemoryHeap ( temp );
}

inline void to_json( nlohmann::json &j, const MemoryHostPointerPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryTypeBits" ] = p.memoryTypeBits;
}
inline void to_json( nlohmann::json &j, const VkMemoryHostPointerPropertiesEXT &p ) {
  to_json( j, MemoryHostPointerPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryHostPointerPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryHostPointerPropertiesEXT" );
  p.memoryTypeBits = j[ "memoryTypeBits" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryHostPointerPropertiesEXT &p ) {
  MemoryHostPointerPropertiesEXT temp;
  from_json( j, temp );
  p = VkMemoryHostPointerPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const MemoryOpaqueCaptureAddressAllocateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "opaqueCaptureAddress" ] = p.opaqueCaptureAddress;
}
inline void to_json( nlohmann::json &j, const VkMemoryOpaqueCaptureAddressAllocateInfo &p ) {
  to_json( j, MemoryOpaqueCaptureAddressAllocateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryOpaqueCaptureAddressAllocateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryOpaqueCaptureAddressAllocateInfo" );
  p.opaqueCaptureAddress = j[ "opaqueCaptureAddress" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryOpaqueCaptureAddressAllocateInfo &p ) {
  MemoryOpaqueCaptureAddressAllocateInfo temp;
  from_json( j, temp );
  p = VkMemoryOpaqueCaptureAddressAllocateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const MemoryPriorityAllocateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "priority" ] = p.priority;
}
inline void to_json( nlohmann::json &j, const VkMemoryPriorityAllocateInfoEXT &p ) {
  to_json( j, MemoryPriorityAllocateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryPriorityAllocateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryPriorityAllocateInfoEXT" );
  p.priority = j[ "priority" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryPriorityAllocateInfoEXT &p ) {
  MemoryPriorityAllocateInfoEXT temp;
  from_json( j, temp );
  p = VkMemoryPriorityAllocateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const MemoryRequirements &p ) {
  j = nlohmann::json::object();
  j[ "size" ] = p.size;
  j[ "alignment" ] = p.alignment;
  j[ "memoryTypeBits" ] = p.memoryTypeBits;
}
inline void to_json( nlohmann::json &j, const VkMemoryRequirements &p ) {
  to_json( j, MemoryRequirements ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryRequirements &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryRequirements" );
  p.size = j[ "size" ];
  p.alignment = j[ "alignment" ];
  p.memoryTypeBits = j[ "memoryTypeBits" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryRequirements &p ) {
  MemoryRequirements temp;
  from_json( j, temp );
  p = VkMemoryRequirements ( temp );
}

inline void to_json( nlohmann::json &j, const MemoryRequirements2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryRequirements" ] = p.memoryRequirements;
}
inline void to_json( nlohmann::json &j, const VkMemoryRequirements2 &p ) {
  to_json( j, MemoryRequirements2 ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryRequirements2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryRequirements2" );
  p.memoryRequirements = j[ "memoryRequirements" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryRequirements2 &p ) {
  MemoryRequirements2 temp;
  from_json( j, temp );
  p = VkMemoryRequirements2 ( temp );
}

inline void to_json( nlohmann::json &j, const MemoryType &p ) {
  j = nlohmann::json::object();
  j[ "propertyFlags" ] = p.propertyFlags;
  j[ "heapIndex" ] = p.heapIndex;
}
inline void to_json( nlohmann::json &j, const VkMemoryType &p ) {
  to_json( j, MemoryType ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryType &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryType" );
  p.propertyFlags = j[ "propertyFlags" ];
  p.heapIndex = j[ "heapIndex" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryType &p ) {
  MemoryType temp;
  from_json( j, temp );
  p = VkMemoryType ( temp );
}

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const MemoryWin32HandlePropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryTypeBits" ] = p.memoryTypeBits;
}
inline void to_json( nlohmann::json &j, const VkMemoryWin32HandlePropertiesKHR &p ) {
  to_json( j, MemoryWin32HandlePropertiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryWin32HandlePropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryWin32HandlePropertiesKHR" );
  p.memoryTypeBits = j[ "memoryTypeBits" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryWin32HandlePropertiesKHR &p ) {
  MemoryWin32HandlePropertiesKHR temp;
  from_json( j, temp );
  p = VkMemoryWin32HandlePropertiesKHR ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_FUCHSIA )
inline void to_json( nlohmann::json &j, const MemoryZirconHandlePropertiesFUCHSIA &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryTypeBits" ] = p.memoryTypeBits;
}
inline void to_json( nlohmann::json &j, const VkMemoryZirconHandlePropertiesFUCHSIA &p ) {
  to_json( j, MemoryZirconHandlePropertiesFUCHSIA ( p ) );
}
inline void from_json( const nlohmann::json &j, MemoryZirconHandlePropertiesFUCHSIA &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MemoryZirconHandlePropertiesFUCHSIA" );
  p.memoryTypeBits = j[ "memoryTypeBits" ];
}
inline void from_json( const nlohmann::json &j, VkMemoryZirconHandlePropertiesFUCHSIA &p ) {
  MemoryZirconHandlePropertiesFUCHSIA temp;
  from_json( j, temp );
  p = VkMemoryZirconHandlePropertiesFUCHSIA ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_METAL_EXT )
inline void to_json( nlohmann::json &j, const MetalSurfaceCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pLayer" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pLayer ) );
}
inline void to_json( nlohmann::json &j, const VkMetalSurfaceCreateInfoEXT &p ) {
  to_json( j, MetalSurfaceCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, MetalSurfaceCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MetalSurfaceCreateInfoEXT" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkMetalSurfaceCreateInfoEXT &p ) {
  MetalSurfaceCreateInfoEXT temp;
  from_json( j, temp );
  p = VkMetalSurfaceCreateInfoEXT ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const MultiDrawIndexedInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "firstIndex" ] = p.firstIndex;
  j[ "indexCount" ] = p.indexCount;
  j[ "vertexOffset" ] = p.vertexOffset;
}
inline void to_json( nlohmann::json &j, const VkMultiDrawIndexedInfoEXT &p ) {
  to_json( j, MultiDrawIndexedInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, MultiDrawIndexedInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MultiDrawIndexedInfoEXT" );
  p.firstIndex = j[ "firstIndex" ];
  p.indexCount = j[ "indexCount" ];
  p.vertexOffset = j[ "vertexOffset" ];
}
inline void from_json( const nlohmann::json &j, VkMultiDrawIndexedInfoEXT &p ) {
  MultiDrawIndexedInfoEXT temp;
  from_json( j, temp );
  p = VkMultiDrawIndexedInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const MultiDrawInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "firstVertex" ] = p.firstVertex;
  j[ "vertexCount" ] = p.vertexCount;
}
inline void to_json( nlohmann::json &j, const VkMultiDrawInfoEXT &p ) {
  to_json( j, MultiDrawInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, MultiDrawInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MultiDrawInfoEXT" );
  p.firstVertex = j[ "firstVertex" ];
  p.vertexCount = j[ "vertexCount" ];
}
inline void from_json( const nlohmann::json &j, VkMultiDrawInfoEXT &p ) {
  MultiDrawInfoEXT temp;
  from_json( j, temp );
  p = VkMultiDrawInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const MultisamplePropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxSampleLocationGridSize" ] = p.maxSampleLocationGridSize;
}
inline void to_json( nlohmann::json &j, const VkMultisamplePropertiesEXT &p ) {
  to_json( j, MultisamplePropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, MultisamplePropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MultisamplePropertiesEXT" );
  p.maxSampleLocationGridSize = j[ "maxSampleLocationGridSize" ];
}
inline void from_json( const nlohmann::json &j, VkMultisamplePropertiesEXT &p ) {
  MultisamplePropertiesEXT temp;
  from_json( j, temp );
  p = VkMultisamplePropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const MutableDescriptorTypeListVALVE &p ) {
  j = nlohmann::json::object();
  j[ "descriptorTypeCount" ] = p.descriptorTypeCount;
  j[ "pDescriptorTypes" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDescriptorTypes ) );
}
inline void to_json( nlohmann::json &j, const VkMutableDescriptorTypeListVALVE &p ) {
  to_json( j, MutableDescriptorTypeListVALVE ( p ) );
}
inline void from_json( const nlohmann::json &j, MutableDescriptorTypeListVALVE &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MutableDescriptorTypeListVALVE" );
  p.descriptorTypeCount = j[ "descriptorTypeCount" ];
}
inline void from_json( const nlohmann::json &j, VkMutableDescriptorTypeListVALVE &p ) {
  MutableDescriptorTypeListVALVE temp;
  from_json( j, temp );
  p = VkMutableDescriptorTypeListVALVE ( temp );
}

inline void to_json( nlohmann::json &j, const MutableDescriptorTypeCreateInfoVALVE &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "mutableDescriptorTypeListCount" ] = p.mutableDescriptorTypeListCount;
  j[ "pMutableDescriptorTypeLists" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pMutableDescriptorTypeLists ) );
}
inline void to_json( nlohmann::json &j, const VkMutableDescriptorTypeCreateInfoVALVE &p ) {
  to_json( j, MutableDescriptorTypeCreateInfoVALVE ( p ) );
}
inline void from_json( const nlohmann::json &j, MutableDescriptorTypeCreateInfoVALVE &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for MutableDescriptorTypeCreateInfoVALVE" );
  p.mutableDescriptorTypeListCount = j[ "mutableDescriptorTypeListCount" ];
}
inline void from_json( const nlohmann::json &j, VkMutableDescriptorTypeCreateInfoVALVE &p ) {
  MutableDescriptorTypeCreateInfoVALVE temp;
  from_json( j, temp );
  p = VkMutableDescriptorTypeCreateInfoVALVE ( temp );
}

inline void to_json( nlohmann::json &j, const PastPresentationTimingGOOGLE &p ) {
  j = nlohmann::json::object();
  j[ "presentID" ] = p.presentID;
  j[ "desiredPresentTime" ] = p.desiredPresentTime;
  j[ "actualPresentTime" ] = p.actualPresentTime;
  j[ "earliestPresentTime" ] = p.earliestPresentTime;
  j[ "presentMargin" ] = p.presentMargin;
}
inline void to_json( nlohmann::json &j, const VkPastPresentationTimingGOOGLE &p ) {
  to_json( j, PastPresentationTimingGOOGLE ( p ) );
}
inline void from_json( const nlohmann::json &j, PastPresentationTimingGOOGLE &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PastPresentationTimingGOOGLE" );
  p.presentID = j[ "presentID" ];
  p.desiredPresentTime = j[ "desiredPresentTime" ];
  p.actualPresentTime = j[ "actualPresentTime" ];
  p.earliestPresentTime = j[ "earliestPresentTime" ];
  p.presentMargin = j[ "presentMargin" ];
}
inline void from_json( const nlohmann::json &j, VkPastPresentationTimingGOOGLE &p ) {
  PastPresentationTimingGOOGLE temp;
  from_json( j, temp );
  p = VkPastPresentationTimingGOOGLE ( temp );
}

inline void to_json( nlohmann::json &j, const PerformanceConfigurationAcquireInfoINTEL &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "type" ] = p.type;
}
inline void to_json( nlohmann::json &j, const VkPerformanceConfigurationAcquireInfoINTEL &p ) {
  to_json( j, PerformanceConfigurationAcquireInfoINTEL ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceConfigurationAcquireInfoINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceConfigurationAcquireInfoINTEL" );
  p.type = j[ "type" ];
}
inline void from_json( const nlohmann::json &j, VkPerformanceConfigurationAcquireInfoINTEL &p ) {
  PerformanceConfigurationAcquireInfoINTEL temp;
  from_json( j, temp );
  p = VkPerformanceConfigurationAcquireInfoINTEL ( temp );
}

inline void to_json( nlohmann::json &j, const PerformanceCounterDescriptionKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "name" ] = std::string( p.name.begin(), std::find( p.name.begin(), p.name.end(), '\0' ) );
  j[ "category" ] = std::string( p.category.begin(), std::find( p.category.begin(), p.category.end(), '\0' ) );
  j[ "description" ] = std::string( p.description.begin(), std::find( p.description.begin(), p.description.end(), '\0' ) );
}
inline void to_json( nlohmann::json &j, const VkPerformanceCounterDescriptionKHR &p ) {
  to_json( j, PerformanceCounterDescriptionKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceCounterDescriptionKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceCounterDescriptionKHR" );
  p.flags = j[ "flags" ];
  {
    std::string s = j[ "name" ];
    if( !p.name.empty() ) {
      p.name[ p.name.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.name.size() - 1u ) ), p.name.begin() );
    }
  }
  {
    std::string s = j[ "category" ];
    if( !p.category.empty() ) {
      p.category[ p.category.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.category.size() - 1u ) ), p.category.begin() );
    }
  }
  {
    std::string s = j[ "description" ];
    if( !p.description.empty() ) {
      p.description[ p.description.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.description.size() - 1u ) ), p.description.begin() );
    }
  }
}
inline void from_json( const nlohmann::json &j, VkPerformanceCounterDescriptionKHR &p ) {
  PerformanceCounterDescriptionKHR temp;
  from_json( j, temp );
  p = VkPerformanceCounterDescriptionKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PerformanceCounterKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "unit" ] = p.unit;
  j[ "scope" ] = p.scope;
  j[ "storage" ] = p.storage;
  j[ "uuid" ] = nlohmann::json::array();
  std::copy( p.uuid.begin(), p.uuid.end(), std::back_inserter( j[ "uuid" ] ) );
}
inline void to_json( nlohmann::json &j, const VkPerformanceCounterKHR &p ) {
  to_json( j, PerformanceCounterKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceCounterKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceCounterKHR" );
  p.unit = j[ "unit" ];
  p.scope = j[ "scope" ];
  p.storage = j[ "storage" ];
  if( !j[ "uuid" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PerformanceCounterKHR.uuid" );
  if( !j[ "uuid" ].size() > p.uuid.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PerformanceCounterKHR.uuid" );
  std::fill( p.uuid.begin(), p.uuid.end(), 0 );
  std::copy( j[ "uuid" ].begin(), j[ "uuid" ].end(), p.uuid.begin() );
}
inline void from_json( const nlohmann::json &j, VkPerformanceCounterKHR &p ) {
  PerformanceCounterKHR temp;
  from_json( j, temp );
  p = VkPerformanceCounterKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PerformanceMarkerInfoINTEL &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "marker" ] = p.marker;
}
inline void to_json( nlohmann::json &j, const VkPerformanceMarkerInfoINTEL &p ) {
  to_json( j, PerformanceMarkerInfoINTEL ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceMarkerInfoINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceMarkerInfoINTEL" );
  p.marker = j[ "marker" ];
}
inline void from_json( const nlohmann::json &j, VkPerformanceMarkerInfoINTEL &p ) {
  PerformanceMarkerInfoINTEL temp;
  from_json( j, temp );
  p = VkPerformanceMarkerInfoINTEL ( temp );
}

inline void to_json( nlohmann::json &j, const PerformanceOverrideInfoINTEL &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "type" ] = p.type;
  j[ "enable" ] = bool( p.enable );
  j[ "parameter" ] = p.parameter;
}
inline void to_json( nlohmann::json &j, const VkPerformanceOverrideInfoINTEL &p ) {
  to_json( j, PerformanceOverrideInfoINTEL ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceOverrideInfoINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceOverrideInfoINTEL" );
  p.type = j[ "type" ];
  p.enable = j[ "enable" ];
  p.parameter = j[ "parameter" ];
}
inline void from_json( const nlohmann::json &j, VkPerformanceOverrideInfoINTEL &p ) {
  PerformanceOverrideInfoINTEL temp;
  from_json( j, temp );
  p = VkPerformanceOverrideInfoINTEL ( temp );
}

inline void to_json( nlohmann::json &j, const PerformanceQuerySubmitInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "counterPassIndex" ] = p.counterPassIndex;
}
inline void to_json( nlohmann::json &j, const VkPerformanceQuerySubmitInfoKHR &p ) {
  to_json( j, PerformanceQuerySubmitInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceQuerySubmitInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceQuerySubmitInfoKHR" );
  p.counterPassIndex = j[ "counterPassIndex" ];
}
inline void from_json( const nlohmann::json &j, VkPerformanceQuerySubmitInfoKHR &p ) {
  PerformanceQuerySubmitInfoKHR temp;
  from_json( j, temp );
  p = VkPerformanceQuerySubmitInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PerformanceStreamMarkerInfoINTEL &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "marker" ] = p.marker;
}
inline void to_json( nlohmann::json &j, const VkPerformanceStreamMarkerInfoINTEL &p ) {
  to_json( j, PerformanceStreamMarkerInfoINTEL ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceStreamMarkerInfoINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceStreamMarkerInfoINTEL" );
  p.marker = j[ "marker" ];
}
inline void from_json( const nlohmann::json &j, VkPerformanceStreamMarkerInfoINTEL &p ) {
  PerformanceStreamMarkerInfoINTEL temp;
  from_json( j, temp );
  p = VkPerformanceStreamMarkerInfoINTEL ( temp );
}

inline void to_json( nlohmann::json &j, const PerformanceValueINTEL &p ) {
  j = nlohmann::json::object();
  j[ "type" ] = p.type;
}
inline void to_json( nlohmann::json &j, const VkPerformanceValueINTEL &p ) {
  to_json( j, PerformanceValueINTEL ( p ) );
}
inline void from_json( const nlohmann::json &j, PerformanceValueINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PerformanceValueINTEL" );
  p.type = j[ "type" ];
}
inline void from_json( const nlohmann::json &j, VkPerformanceValueINTEL &p ) {
  PerformanceValueINTEL temp;
  from_json( j, temp );
  p = VkPerformanceValueINTEL ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDevice16BitStorageFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "storageBuffer16BitAccess" ] = bool( p.storageBuffer16BitAccess );
  j[ "uniformAndStorageBuffer16BitAccess" ] = bool( p.uniformAndStorageBuffer16BitAccess );
  j[ "storagePushConstant16" ] = bool( p.storagePushConstant16 );
  j[ "storageInputOutput16" ] = bool( p.storageInputOutput16 );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDevice16BitStorageFeatures &p ) {
  to_json( j, PhysicalDevice16BitStorageFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDevice16BitStorageFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevice16BitStorageFeatures" );
  p.storageBuffer16BitAccess = j[ "storageBuffer16BitAccess" ];
  p.uniformAndStorageBuffer16BitAccess = j[ "uniformAndStorageBuffer16BitAccess" ];
  p.storagePushConstant16 = j[ "storagePushConstant16" ];
  p.storageInputOutput16 = j[ "storageInputOutput16" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDevice16BitStorageFeatures &p ) {
  PhysicalDevice16BitStorageFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDevice16BitStorageFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDevice4444FormatsFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "formatA4R4G4B4" ] = bool( p.formatA4R4G4B4 );
  j[ "formatA4B4G4R4" ] = bool( p.formatA4B4G4R4 );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDevice4444FormatsFeaturesEXT &p ) {
  to_json( j, PhysicalDevice4444FormatsFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDevice4444FormatsFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevice4444FormatsFeaturesEXT" );
  p.formatA4R4G4B4 = j[ "formatA4R4G4B4" ];
  p.formatA4B4G4R4 = j[ "formatA4B4G4R4" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDevice4444FormatsFeaturesEXT &p ) {
  PhysicalDevice4444FormatsFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDevice4444FormatsFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDevice8BitStorageFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "storageBuffer8BitAccess" ] = bool( p.storageBuffer8BitAccess );
  j[ "uniformAndStorageBuffer8BitAccess" ] = bool( p.uniformAndStorageBuffer8BitAccess );
  j[ "storagePushConstant8" ] = bool( p.storagePushConstant8 );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDevice8BitStorageFeatures &p ) {
  to_json( j, PhysicalDevice8BitStorageFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDevice8BitStorageFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevice8BitStorageFeatures" );
  p.storageBuffer8BitAccess = j[ "storageBuffer8BitAccess" ];
  p.uniformAndStorageBuffer8BitAccess = j[ "uniformAndStorageBuffer8BitAccess" ];
  p.storagePushConstant8 = j[ "storagePushConstant8" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDevice8BitStorageFeatures &p ) {
  PhysicalDevice8BitStorageFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDevice8BitStorageFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceASTCDecodeFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "decodeModeSharedExponent" ] = bool( p.decodeModeSharedExponent );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceASTCDecodeFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceASTCDecodeFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceASTCDecodeFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceASTCDecodeFeaturesEXT" );
  p.decodeModeSharedExponent = j[ "decodeModeSharedExponent" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceASTCDecodeFeaturesEXT &p ) {
  PhysicalDeviceASTCDecodeFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceASTCDecodeFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceAccelerationStructureFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "accelerationStructure" ] = bool( p.accelerationStructure );
  j[ "accelerationStructureCaptureReplay" ] = bool( p.accelerationStructureCaptureReplay );
  j[ "accelerationStructureIndirectBuild" ] = bool( p.accelerationStructureIndirectBuild );
  j[ "accelerationStructureHostCommands" ] = bool( p.accelerationStructureHostCommands );
  j[ "descriptorBindingAccelerationStructureUpdateAfterBind" ] = bool( p.descriptorBindingAccelerationStructureUpdateAfterBind );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceAccelerationStructureFeaturesKHR &p ) {
  to_json( j, PhysicalDeviceAccelerationStructureFeaturesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceAccelerationStructureFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceAccelerationStructureFeaturesKHR" );
  p.accelerationStructure = j[ "accelerationStructure" ];
  p.accelerationStructureCaptureReplay = j[ "accelerationStructureCaptureReplay" ];
  p.accelerationStructureIndirectBuild = j[ "accelerationStructureIndirectBuild" ];
  p.accelerationStructureHostCommands = j[ "accelerationStructureHostCommands" ];
  p.descriptorBindingAccelerationStructureUpdateAfterBind = j[ "descriptorBindingAccelerationStructureUpdateAfterBind" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceAccelerationStructureFeaturesKHR &p ) {
  PhysicalDeviceAccelerationStructureFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceAccelerationStructureFeaturesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceAccelerationStructurePropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxGeometryCount" ] = p.maxGeometryCount;
  j[ "maxInstanceCount" ] = p.maxInstanceCount;
  j[ "maxPrimitiveCount" ] = p.maxPrimitiveCount;
  j[ "maxPerStageDescriptorAccelerationStructures" ] = p.maxPerStageDescriptorAccelerationStructures;
  j[ "maxPerStageDescriptorUpdateAfterBindAccelerationStructures" ] = p.maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
  j[ "maxDescriptorSetAccelerationStructures" ] = p.maxDescriptorSetAccelerationStructures;
  j[ "maxDescriptorSetUpdateAfterBindAccelerationStructures" ] = p.maxDescriptorSetUpdateAfterBindAccelerationStructures;
  j[ "minAccelerationStructureScratchOffsetAlignment" ] = p.minAccelerationStructureScratchOffsetAlignment;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceAccelerationStructurePropertiesKHR &p ) {
  to_json( j, PhysicalDeviceAccelerationStructurePropertiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceAccelerationStructurePropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceAccelerationStructurePropertiesKHR" );
  p.maxGeometryCount = j[ "maxGeometryCount" ];
  p.maxInstanceCount = j[ "maxInstanceCount" ];
  p.maxPrimitiveCount = j[ "maxPrimitiveCount" ];
  p.maxPerStageDescriptorAccelerationStructures = j[ "maxPerStageDescriptorAccelerationStructures" ];
  p.maxPerStageDescriptorUpdateAfterBindAccelerationStructures = j[ "maxPerStageDescriptorUpdateAfterBindAccelerationStructures" ];
  p.maxDescriptorSetAccelerationStructures = j[ "maxDescriptorSetAccelerationStructures" ];
  p.maxDescriptorSetUpdateAfterBindAccelerationStructures = j[ "maxDescriptorSetUpdateAfterBindAccelerationStructures" ];
  p.minAccelerationStructureScratchOffsetAlignment = j[ "minAccelerationStructureScratchOffsetAlignment" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceAccelerationStructurePropertiesKHR &p ) {
  PhysicalDeviceAccelerationStructurePropertiesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceAccelerationStructurePropertiesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceBlendOperationAdvancedFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "advancedBlendCoherentOperations" ] = bool( p.advancedBlendCoherentOperations );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceBlendOperationAdvancedFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceBlendOperationAdvancedFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceBlendOperationAdvancedFeaturesEXT" );
  p.advancedBlendCoherentOperations = j[ "advancedBlendCoherentOperations" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT &p ) {
  PhysicalDeviceBlendOperationAdvancedFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceBlendOperationAdvancedPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "advancedBlendMaxColorAttachments" ] = p.advancedBlendMaxColorAttachments;
  j[ "advancedBlendIndependentBlend" ] = bool( p.advancedBlendIndependentBlend );
  j[ "advancedBlendNonPremultipliedSrcColor" ] = bool( p.advancedBlendNonPremultipliedSrcColor );
  j[ "advancedBlendNonPremultipliedDstColor" ] = bool( p.advancedBlendNonPremultipliedDstColor );
  j[ "advancedBlendCorrelatedOverlap" ] = bool( p.advancedBlendCorrelatedOverlap );
  j[ "advancedBlendAllOperations" ] = bool( p.advancedBlendAllOperations );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceBlendOperationAdvancedPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceBlendOperationAdvancedPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceBlendOperationAdvancedPropertiesEXT" );
  p.advancedBlendMaxColorAttachments = j[ "advancedBlendMaxColorAttachments" ];
  p.advancedBlendIndependentBlend = j[ "advancedBlendIndependentBlend" ];
  p.advancedBlendNonPremultipliedSrcColor = j[ "advancedBlendNonPremultipliedSrcColor" ];
  p.advancedBlendNonPremultipliedDstColor = j[ "advancedBlendNonPremultipliedDstColor" ];
  p.advancedBlendCorrelatedOverlap = j[ "advancedBlendCorrelatedOverlap" ];
  p.advancedBlendAllOperations = j[ "advancedBlendAllOperations" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT &p ) {
  PhysicalDeviceBlendOperationAdvancedPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceBufferDeviceAddressFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "bufferDeviceAddress" ] = bool( p.bufferDeviceAddress );
  j[ "bufferDeviceAddressCaptureReplay" ] = bool( p.bufferDeviceAddressCaptureReplay );
  j[ "bufferDeviceAddressMultiDevice" ] = bool( p.bufferDeviceAddressMultiDevice );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceBufferDeviceAddressFeatures &p ) {
  to_json( j, PhysicalDeviceBufferDeviceAddressFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceBufferDeviceAddressFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceBufferDeviceAddressFeatures" );
  p.bufferDeviceAddress = j[ "bufferDeviceAddress" ];
  p.bufferDeviceAddressCaptureReplay = j[ "bufferDeviceAddressCaptureReplay" ];
  p.bufferDeviceAddressMultiDevice = j[ "bufferDeviceAddressMultiDevice" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceBufferDeviceAddressFeatures &p ) {
  PhysicalDeviceBufferDeviceAddressFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceBufferDeviceAddressFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceBufferDeviceAddressFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "bufferDeviceAddress" ] = bool( p.bufferDeviceAddress );
  j[ "bufferDeviceAddressCaptureReplay" ] = bool( p.bufferDeviceAddressCaptureReplay );
  j[ "bufferDeviceAddressMultiDevice" ] = bool( p.bufferDeviceAddressMultiDevice );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceBufferDeviceAddressFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceBufferDeviceAddressFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceBufferDeviceAddressFeaturesEXT" );
  p.bufferDeviceAddress = j[ "bufferDeviceAddress" ];
  p.bufferDeviceAddressCaptureReplay = j[ "bufferDeviceAddressCaptureReplay" ];
  p.bufferDeviceAddressMultiDevice = j[ "bufferDeviceAddressMultiDevice" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &p ) {
  PhysicalDeviceBufferDeviceAddressFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceCoherentMemoryFeaturesAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceCoherentMemory" ] = bool( p.deviceCoherentMemory );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceCoherentMemoryFeaturesAMD &p ) {
  to_json( j, PhysicalDeviceCoherentMemoryFeaturesAMD ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceCoherentMemoryFeaturesAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceCoherentMemoryFeaturesAMD" );
  p.deviceCoherentMemory = j[ "deviceCoherentMemory" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceCoherentMemoryFeaturesAMD &p ) {
  PhysicalDeviceCoherentMemoryFeaturesAMD temp;
  from_json( j, temp );
  p = VkPhysicalDeviceCoherentMemoryFeaturesAMD ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceColorWriteEnableFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "colorWriteEnable" ] = bool( p.colorWriteEnable );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceColorWriteEnableFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceColorWriteEnableFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceColorWriteEnableFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceColorWriteEnableFeaturesEXT" );
  p.colorWriteEnable = j[ "colorWriteEnable" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceColorWriteEnableFeaturesEXT &p ) {
  PhysicalDeviceColorWriteEnableFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceColorWriteEnableFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceComputeShaderDerivativesFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "computeDerivativeGroupQuads" ] = bool( p.computeDerivativeGroupQuads );
  j[ "computeDerivativeGroupLinear" ] = bool( p.computeDerivativeGroupLinear );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV &p ) {
  to_json( j, PhysicalDeviceComputeShaderDerivativesFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceComputeShaderDerivativesFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceComputeShaderDerivativesFeaturesNV" );
  p.computeDerivativeGroupQuads = j[ "computeDerivativeGroupQuads" ];
  p.computeDerivativeGroupLinear = j[ "computeDerivativeGroupLinear" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV &p ) {
  PhysicalDeviceComputeShaderDerivativesFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceComputeShaderDerivativesFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceConditionalRenderingFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "conditionalRendering" ] = bool( p.conditionalRendering );
  j[ "inheritedConditionalRendering" ] = bool( p.inheritedConditionalRendering );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceConditionalRenderingFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceConditionalRenderingFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceConditionalRenderingFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceConditionalRenderingFeaturesEXT" );
  p.conditionalRendering = j[ "conditionalRendering" ];
  p.inheritedConditionalRendering = j[ "inheritedConditionalRendering" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceConditionalRenderingFeaturesEXT &p ) {
  PhysicalDeviceConditionalRenderingFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceConditionalRenderingFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceConservativeRasterizationPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "primitiveOverestimationSize" ] = p.primitiveOverestimationSize;
  j[ "maxExtraPrimitiveOverestimationSize" ] = p.maxExtraPrimitiveOverestimationSize;
  j[ "extraPrimitiveOverestimationSizeGranularity" ] = p.extraPrimitiveOverestimationSizeGranularity;
  j[ "primitiveUnderestimation" ] = bool( p.primitiveUnderestimation );
  j[ "conservativePointAndLineRasterization" ] = bool( p.conservativePointAndLineRasterization );
  j[ "degenerateTrianglesRasterized" ] = bool( p.degenerateTrianglesRasterized );
  j[ "degenerateLinesRasterized" ] = bool( p.degenerateLinesRasterized );
  j[ "fullyCoveredFragmentShaderInputVariable" ] = bool( p.fullyCoveredFragmentShaderInputVariable );
  j[ "conservativeRasterizationPostDepthCoverage" ] = bool( p.conservativeRasterizationPostDepthCoverage );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceConservativeRasterizationPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceConservativeRasterizationPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceConservativeRasterizationPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceConservativeRasterizationPropertiesEXT" );
  p.primitiveOverestimationSize = j[ "primitiveOverestimationSize" ];
  p.maxExtraPrimitiveOverestimationSize = j[ "maxExtraPrimitiveOverestimationSize" ];
  p.extraPrimitiveOverestimationSizeGranularity = j[ "extraPrimitiveOverestimationSizeGranularity" ];
  p.primitiveUnderestimation = j[ "primitiveUnderestimation" ];
  p.conservativePointAndLineRasterization = j[ "conservativePointAndLineRasterization" ];
  p.degenerateTrianglesRasterized = j[ "degenerateTrianglesRasterized" ];
  p.degenerateLinesRasterized = j[ "degenerateLinesRasterized" ];
  p.fullyCoveredFragmentShaderInputVariable = j[ "fullyCoveredFragmentShaderInputVariable" ];
  p.conservativeRasterizationPostDepthCoverage = j[ "conservativeRasterizationPostDepthCoverage" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceConservativeRasterizationPropertiesEXT &p ) {
  PhysicalDeviceConservativeRasterizationPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceConservativeRasterizationPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceCooperativeMatrixFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "cooperativeMatrix" ] = bool( p.cooperativeMatrix );
  j[ "cooperativeMatrixRobustBufferAccess" ] = bool( p.cooperativeMatrixRobustBufferAccess );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceCooperativeMatrixFeaturesNV &p ) {
  to_json( j, PhysicalDeviceCooperativeMatrixFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceCooperativeMatrixFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceCooperativeMatrixFeaturesNV" );
  p.cooperativeMatrix = j[ "cooperativeMatrix" ];
  p.cooperativeMatrixRobustBufferAccess = j[ "cooperativeMatrixRobustBufferAccess" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceCooperativeMatrixFeaturesNV &p ) {
  PhysicalDeviceCooperativeMatrixFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceCooperativeMatrixFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceCooperativeMatrixPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "cooperativeMatrixSupportedStages" ] = p.cooperativeMatrixSupportedStages;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceCooperativeMatrixPropertiesNV &p ) {
  to_json( j, PhysicalDeviceCooperativeMatrixPropertiesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceCooperativeMatrixPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceCooperativeMatrixPropertiesNV" );
  p.cooperativeMatrixSupportedStages = j[ "cooperativeMatrixSupportedStages" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceCooperativeMatrixPropertiesNV &p ) {
  PhysicalDeviceCooperativeMatrixPropertiesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceCooperativeMatrixPropertiesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceCornerSampledImageFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "cornerSampledImage" ] = bool( p.cornerSampledImage );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceCornerSampledImageFeaturesNV &p ) {
  to_json( j, PhysicalDeviceCornerSampledImageFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceCornerSampledImageFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceCornerSampledImageFeaturesNV" );
  p.cornerSampledImage = j[ "cornerSampledImage" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceCornerSampledImageFeaturesNV &p ) {
  PhysicalDeviceCornerSampledImageFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceCornerSampledImageFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceCoverageReductionModeFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "coverageReductionMode" ] = bool( p.coverageReductionMode );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceCoverageReductionModeFeaturesNV &p ) {
  to_json( j, PhysicalDeviceCoverageReductionModeFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceCoverageReductionModeFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceCoverageReductionModeFeaturesNV" );
  p.coverageReductionMode = j[ "coverageReductionMode" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceCoverageReductionModeFeaturesNV &p ) {
  PhysicalDeviceCoverageReductionModeFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceCoverageReductionModeFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceCustomBorderColorFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "customBorderColors" ] = bool( p.customBorderColors );
  j[ "customBorderColorWithoutFormat" ] = bool( p.customBorderColorWithoutFormat );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceCustomBorderColorFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceCustomBorderColorFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceCustomBorderColorFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceCustomBorderColorFeaturesEXT" );
  p.customBorderColors = j[ "customBorderColors" ];
  p.customBorderColorWithoutFormat = j[ "customBorderColorWithoutFormat" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceCustomBorderColorFeaturesEXT &p ) {
  PhysicalDeviceCustomBorderColorFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceCustomBorderColorFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceCustomBorderColorPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxCustomBorderColorSamplers" ] = p.maxCustomBorderColorSamplers;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceCustomBorderColorPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceCustomBorderColorPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceCustomBorderColorPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceCustomBorderColorPropertiesEXT" );
  p.maxCustomBorderColorSamplers = j[ "maxCustomBorderColorSamplers" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceCustomBorderColorPropertiesEXT &p ) {
  PhysicalDeviceCustomBorderColorPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceCustomBorderColorPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dedicatedAllocationImageAliasing" ] = bool( p.dedicatedAllocationImageAliasing );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &p ) {
  to_json( j, PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV" );
  p.dedicatedAllocationImageAliasing = j[ "dedicatedAllocationImageAliasing" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &p ) {
  PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceDepthClipEnableFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "depthClipEnable" ] = bool( p.depthClipEnable );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceDepthClipEnableFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceDepthClipEnableFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceDepthClipEnableFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDepthClipEnableFeaturesEXT" );
  p.depthClipEnable = j[ "depthClipEnable" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceDepthClipEnableFeaturesEXT &p ) {
  PhysicalDeviceDepthClipEnableFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDepthClipEnableFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceDepthStencilResolveProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "supportedDepthResolveModes" ] = p.supportedDepthResolveModes;
  j[ "supportedStencilResolveModes" ] = p.supportedStencilResolveModes;
  j[ "independentResolveNone" ] = bool( p.independentResolveNone );
  j[ "independentResolve" ] = bool( p.independentResolve );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceDepthStencilResolveProperties &p ) {
  to_json( j, PhysicalDeviceDepthStencilResolveProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceDepthStencilResolveProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDepthStencilResolveProperties" );
  p.supportedDepthResolveModes = j[ "supportedDepthResolveModes" ];
  p.supportedStencilResolveModes = j[ "supportedStencilResolveModes" ];
  p.independentResolveNone = j[ "independentResolveNone" ];
  p.independentResolve = j[ "independentResolve" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceDepthStencilResolveProperties &p ) {
  PhysicalDeviceDepthStencilResolveProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDepthStencilResolveProperties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceDescriptorIndexingFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderInputAttachmentArrayDynamicIndexing" ] = bool( p.shaderInputAttachmentArrayDynamicIndexing );
  j[ "shaderUniformTexelBufferArrayDynamicIndexing" ] = bool( p.shaderUniformTexelBufferArrayDynamicIndexing );
  j[ "shaderStorageTexelBufferArrayDynamicIndexing" ] = bool( p.shaderStorageTexelBufferArrayDynamicIndexing );
  j[ "shaderUniformBufferArrayNonUniformIndexing" ] = bool( p.shaderUniformBufferArrayNonUniformIndexing );
  j[ "shaderSampledImageArrayNonUniformIndexing" ] = bool( p.shaderSampledImageArrayNonUniformIndexing );
  j[ "shaderStorageBufferArrayNonUniformIndexing" ] = bool( p.shaderStorageBufferArrayNonUniformIndexing );
  j[ "shaderStorageImageArrayNonUniformIndexing" ] = bool( p.shaderStorageImageArrayNonUniformIndexing );
  j[ "shaderInputAttachmentArrayNonUniformIndexing" ] = bool( p.shaderInputAttachmentArrayNonUniformIndexing );
  j[ "shaderUniformTexelBufferArrayNonUniformIndexing" ] = bool( p.shaderUniformTexelBufferArrayNonUniformIndexing );
  j[ "shaderStorageTexelBufferArrayNonUniformIndexing" ] = bool( p.shaderStorageTexelBufferArrayNonUniformIndexing );
  j[ "descriptorBindingUniformBufferUpdateAfterBind" ] = bool( p.descriptorBindingUniformBufferUpdateAfterBind );
  j[ "descriptorBindingSampledImageUpdateAfterBind" ] = bool( p.descriptorBindingSampledImageUpdateAfterBind );
  j[ "descriptorBindingStorageImageUpdateAfterBind" ] = bool( p.descriptorBindingStorageImageUpdateAfterBind );
  j[ "descriptorBindingStorageBufferUpdateAfterBind" ] = bool( p.descriptorBindingStorageBufferUpdateAfterBind );
  j[ "descriptorBindingUniformTexelBufferUpdateAfterBind" ] = bool( p.descriptorBindingUniformTexelBufferUpdateAfterBind );
  j[ "descriptorBindingStorageTexelBufferUpdateAfterBind" ] = bool( p.descriptorBindingStorageTexelBufferUpdateAfterBind );
  j[ "descriptorBindingUpdateUnusedWhilePending" ] = bool( p.descriptorBindingUpdateUnusedWhilePending );
  j[ "descriptorBindingPartiallyBound" ] = bool( p.descriptorBindingPartiallyBound );
  j[ "descriptorBindingVariableDescriptorCount" ] = bool( p.descriptorBindingVariableDescriptorCount );
  j[ "runtimeDescriptorArray" ] = bool( p.runtimeDescriptorArray );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceDescriptorIndexingFeatures &p ) {
  to_json( j, PhysicalDeviceDescriptorIndexingFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceDescriptorIndexingFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDescriptorIndexingFeatures" );
  p.shaderInputAttachmentArrayDynamicIndexing = j[ "shaderInputAttachmentArrayDynamicIndexing" ];
  p.shaderUniformTexelBufferArrayDynamicIndexing = j[ "shaderUniformTexelBufferArrayDynamicIndexing" ];
  p.shaderStorageTexelBufferArrayDynamicIndexing = j[ "shaderStorageTexelBufferArrayDynamicIndexing" ];
  p.shaderUniformBufferArrayNonUniformIndexing = j[ "shaderUniformBufferArrayNonUniformIndexing" ];
  p.shaderSampledImageArrayNonUniformIndexing = j[ "shaderSampledImageArrayNonUniformIndexing" ];
  p.shaderStorageBufferArrayNonUniformIndexing = j[ "shaderStorageBufferArrayNonUniformIndexing" ];
  p.shaderStorageImageArrayNonUniformIndexing = j[ "shaderStorageImageArrayNonUniformIndexing" ];
  p.shaderInputAttachmentArrayNonUniformIndexing = j[ "shaderInputAttachmentArrayNonUniformIndexing" ];
  p.shaderUniformTexelBufferArrayNonUniformIndexing = j[ "shaderUniformTexelBufferArrayNonUniformIndexing" ];
  p.shaderStorageTexelBufferArrayNonUniformIndexing = j[ "shaderStorageTexelBufferArrayNonUniformIndexing" ];
  p.descriptorBindingUniformBufferUpdateAfterBind = j[ "descriptorBindingUniformBufferUpdateAfterBind" ];
  p.descriptorBindingSampledImageUpdateAfterBind = j[ "descriptorBindingSampledImageUpdateAfterBind" ];
  p.descriptorBindingStorageImageUpdateAfterBind = j[ "descriptorBindingStorageImageUpdateAfterBind" ];
  p.descriptorBindingStorageBufferUpdateAfterBind = j[ "descriptorBindingStorageBufferUpdateAfterBind" ];
  p.descriptorBindingUniformTexelBufferUpdateAfterBind = j[ "descriptorBindingUniformTexelBufferUpdateAfterBind" ];
  p.descriptorBindingStorageTexelBufferUpdateAfterBind = j[ "descriptorBindingStorageTexelBufferUpdateAfterBind" ];
  p.descriptorBindingUpdateUnusedWhilePending = j[ "descriptorBindingUpdateUnusedWhilePending" ];
  p.descriptorBindingPartiallyBound = j[ "descriptorBindingPartiallyBound" ];
  p.descriptorBindingVariableDescriptorCount = j[ "descriptorBindingVariableDescriptorCount" ];
  p.runtimeDescriptorArray = j[ "runtimeDescriptorArray" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceDescriptorIndexingFeatures &p ) {
  PhysicalDeviceDescriptorIndexingFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDescriptorIndexingFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceDescriptorIndexingProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxUpdateAfterBindDescriptorsInAllPools" ] = p.maxUpdateAfterBindDescriptorsInAllPools;
  j[ "shaderUniformBufferArrayNonUniformIndexingNative" ] = bool( p.shaderUniformBufferArrayNonUniformIndexingNative );
  j[ "shaderSampledImageArrayNonUniformIndexingNative" ] = bool( p.shaderSampledImageArrayNonUniformIndexingNative );
  j[ "shaderStorageBufferArrayNonUniformIndexingNative" ] = bool( p.shaderStorageBufferArrayNonUniformIndexingNative );
  j[ "shaderStorageImageArrayNonUniformIndexingNative" ] = bool( p.shaderStorageImageArrayNonUniformIndexingNative );
  j[ "shaderInputAttachmentArrayNonUniformIndexingNative" ] = bool( p.shaderInputAttachmentArrayNonUniformIndexingNative );
  j[ "robustBufferAccessUpdateAfterBind" ] = bool( p.robustBufferAccessUpdateAfterBind );
  j[ "quadDivergentImplicitLod" ] = bool( p.quadDivergentImplicitLod );
  j[ "maxPerStageDescriptorUpdateAfterBindSamplers" ] = p.maxPerStageDescriptorUpdateAfterBindSamplers;
  j[ "maxPerStageDescriptorUpdateAfterBindUniformBuffers" ] = p.maxPerStageDescriptorUpdateAfterBindUniformBuffers;
  j[ "maxPerStageDescriptorUpdateAfterBindStorageBuffers" ] = p.maxPerStageDescriptorUpdateAfterBindStorageBuffers;
  j[ "maxPerStageDescriptorUpdateAfterBindSampledImages" ] = p.maxPerStageDescriptorUpdateAfterBindSampledImages;
  j[ "maxPerStageDescriptorUpdateAfterBindStorageImages" ] = p.maxPerStageDescriptorUpdateAfterBindStorageImages;
  j[ "maxPerStageDescriptorUpdateAfterBindInputAttachments" ] = p.maxPerStageDescriptorUpdateAfterBindInputAttachments;
  j[ "maxPerStageUpdateAfterBindResources" ] = p.maxPerStageUpdateAfterBindResources;
  j[ "maxDescriptorSetUpdateAfterBindSamplers" ] = p.maxDescriptorSetUpdateAfterBindSamplers;
  j[ "maxDescriptorSetUpdateAfterBindUniformBuffers" ] = p.maxDescriptorSetUpdateAfterBindUniformBuffers;
  j[ "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic" ] = p.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
  j[ "maxDescriptorSetUpdateAfterBindStorageBuffers" ] = p.maxDescriptorSetUpdateAfterBindStorageBuffers;
  j[ "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic" ] = p.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
  j[ "maxDescriptorSetUpdateAfterBindSampledImages" ] = p.maxDescriptorSetUpdateAfterBindSampledImages;
  j[ "maxDescriptorSetUpdateAfterBindStorageImages" ] = p.maxDescriptorSetUpdateAfterBindStorageImages;
  j[ "maxDescriptorSetUpdateAfterBindInputAttachments" ] = p.maxDescriptorSetUpdateAfterBindInputAttachments;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceDescriptorIndexingProperties &p ) {
  to_json( j, PhysicalDeviceDescriptorIndexingProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceDescriptorIndexingProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDescriptorIndexingProperties" );
  p.maxUpdateAfterBindDescriptorsInAllPools = j[ "maxUpdateAfterBindDescriptorsInAllPools" ];
  p.shaderUniformBufferArrayNonUniformIndexingNative = j[ "shaderUniformBufferArrayNonUniformIndexingNative" ];
  p.shaderSampledImageArrayNonUniformIndexingNative = j[ "shaderSampledImageArrayNonUniformIndexingNative" ];
  p.shaderStorageBufferArrayNonUniformIndexingNative = j[ "shaderStorageBufferArrayNonUniformIndexingNative" ];
  p.shaderStorageImageArrayNonUniformIndexingNative = j[ "shaderStorageImageArrayNonUniformIndexingNative" ];
  p.shaderInputAttachmentArrayNonUniformIndexingNative = j[ "shaderInputAttachmentArrayNonUniformIndexingNative" ];
  p.robustBufferAccessUpdateAfterBind = j[ "robustBufferAccessUpdateAfterBind" ];
  p.quadDivergentImplicitLod = j[ "quadDivergentImplicitLod" ];
  p.maxPerStageDescriptorUpdateAfterBindSamplers = j[ "maxPerStageDescriptorUpdateAfterBindSamplers" ];
  p.maxPerStageDescriptorUpdateAfterBindUniformBuffers = j[ "maxPerStageDescriptorUpdateAfterBindUniformBuffers" ];
  p.maxPerStageDescriptorUpdateAfterBindStorageBuffers = j[ "maxPerStageDescriptorUpdateAfterBindStorageBuffers" ];
  p.maxPerStageDescriptorUpdateAfterBindSampledImages = j[ "maxPerStageDescriptorUpdateAfterBindSampledImages" ];
  p.maxPerStageDescriptorUpdateAfterBindStorageImages = j[ "maxPerStageDescriptorUpdateAfterBindStorageImages" ];
  p.maxPerStageDescriptorUpdateAfterBindInputAttachments = j[ "maxPerStageDescriptorUpdateAfterBindInputAttachments" ];
  p.maxPerStageUpdateAfterBindResources = j[ "maxPerStageUpdateAfterBindResources" ];
  p.maxDescriptorSetUpdateAfterBindSamplers = j[ "maxDescriptorSetUpdateAfterBindSamplers" ];
  p.maxDescriptorSetUpdateAfterBindUniformBuffers = j[ "maxDescriptorSetUpdateAfterBindUniformBuffers" ];
  p.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = j[ "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic" ];
  p.maxDescriptorSetUpdateAfterBindStorageBuffers = j[ "maxDescriptorSetUpdateAfterBindStorageBuffers" ];
  p.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = j[ "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic" ];
  p.maxDescriptorSetUpdateAfterBindSampledImages = j[ "maxDescriptorSetUpdateAfterBindSampledImages" ];
  p.maxDescriptorSetUpdateAfterBindStorageImages = j[ "maxDescriptorSetUpdateAfterBindStorageImages" ];
  p.maxDescriptorSetUpdateAfterBindInputAttachments = j[ "maxDescriptorSetUpdateAfterBindInputAttachments" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceDescriptorIndexingProperties &p ) {
  PhysicalDeviceDescriptorIndexingProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDescriptorIndexingProperties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceDeviceGeneratedCommandsFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceGeneratedCommands" ] = bool( p.deviceGeneratedCommands );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV &p ) {
  to_json( j, PhysicalDeviceDeviceGeneratedCommandsFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceDeviceGeneratedCommandsFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV" );
  p.deviceGeneratedCommands = j[ "deviceGeneratedCommands" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV &p ) {
  PhysicalDeviceDeviceGeneratedCommandsFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceDeviceGeneratedCommandsPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxGraphicsShaderGroupCount" ] = p.maxGraphicsShaderGroupCount;
  j[ "maxIndirectSequenceCount" ] = p.maxIndirectSequenceCount;
  j[ "maxIndirectCommandsTokenCount" ] = p.maxIndirectCommandsTokenCount;
  j[ "maxIndirectCommandsStreamCount" ] = p.maxIndirectCommandsStreamCount;
  j[ "maxIndirectCommandsTokenOffset" ] = p.maxIndirectCommandsTokenOffset;
  j[ "maxIndirectCommandsStreamStride" ] = p.maxIndirectCommandsStreamStride;
  j[ "minSequencesCountBufferOffsetAlignment" ] = p.minSequencesCountBufferOffsetAlignment;
  j[ "minSequencesIndexBufferOffsetAlignment" ] = p.minSequencesIndexBufferOffsetAlignment;
  j[ "minIndirectCommandsBufferOffsetAlignment" ] = p.minIndirectCommandsBufferOffsetAlignment;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV &p ) {
  to_json( j, PhysicalDeviceDeviceGeneratedCommandsPropertiesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceDeviceGeneratedCommandsPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV" );
  p.maxGraphicsShaderGroupCount = j[ "maxGraphicsShaderGroupCount" ];
  p.maxIndirectSequenceCount = j[ "maxIndirectSequenceCount" ];
  p.maxIndirectCommandsTokenCount = j[ "maxIndirectCommandsTokenCount" ];
  p.maxIndirectCommandsStreamCount = j[ "maxIndirectCommandsStreamCount" ];
  p.maxIndirectCommandsTokenOffset = j[ "maxIndirectCommandsTokenOffset" ];
  p.maxIndirectCommandsStreamStride = j[ "maxIndirectCommandsStreamStride" ];
  p.minSequencesCountBufferOffsetAlignment = j[ "minSequencesCountBufferOffsetAlignment" ];
  p.minSequencesIndexBufferOffsetAlignment = j[ "minSequencesIndexBufferOffsetAlignment" ];
  p.minIndirectCommandsBufferOffsetAlignment = j[ "minIndirectCommandsBufferOffsetAlignment" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV &p ) {
  PhysicalDeviceDeviceGeneratedCommandsPropertiesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceDeviceMemoryReportFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceMemoryReport" ] = bool( p.deviceMemoryReport );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceDeviceMemoryReportFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceDeviceMemoryReportFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDeviceMemoryReportFeaturesEXT" );
  p.deviceMemoryReport = j[ "deviceMemoryReport" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT &p ) {
  PhysicalDeviceDeviceMemoryReportFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDeviceMemoryReportFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceDiagnosticsConfigFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "diagnosticsConfig" ] = bool( p.diagnosticsConfig );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceDiagnosticsConfigFeaturesNV &p ) {
  to_json( j, PhysicalDeviceDiagnosticsConfigFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceDiagnosticsConfigFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDiagnosticsConfigFeaturesNV" );
  p.diagnosticsConfig = j[ "diagnosticsConfig" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceDiagnosticsConfigFeaturesNV &p ) {
  PhysicalDeviceDiagnosticsConfigFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDiagnosticsConfigFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceDiscardRectanglePropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxDiscardRectangles" ] = p.maxDiscardRectangles;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceDiscardRectanglePropertiesEXT &p ) {
  to_json( j, PhysicalDeviceDiscardRectanglePropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceDiscardRectanglePropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDiscardRectanglePropertiesEXT" );
  p.maxDiscardRectangles = j[ "maxDiscardRectangles" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceDiscardRectanglePropertiesEXT &p ) {
  PhysicalDeviceDiscardRectanglePropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDiscardRectanglePropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceDriverProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "driverID" ] = p.driverID;
  j[ "driverName" ] = std::string( p.driverName.begin(), std::find( p.driverName.begin(), p.driverName.end(), '\0' ) );
  j[ "driverInfo" ] = std::string( p.driverInfo.begin(), std::find( p.driverInfo.begin(), p.driverInfo.end(), '\0' ) );
  j[ "conformanceVersion" ] = p.conformanceVersion;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceDriverProperties &p ) {
  to_json( j, PhysicalDeviceDriverProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceDriverProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDriverProperties" );
  p.driverID = j[ "driverID" ];
  {
    std::string s = j[ "driverName" ];
    if( !p.driverName.empty() ) {
      p.driverName[ p.driverName.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.driverName.size() - 1u ) ), p.driverName.begin() );
    }
  }
  {
    std::string s = j[ "driverInfo" ];
    if( !p.driverInfo.empty() ) {
      p.driverInfo[ p.driverInfo.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.driverInfo.size() - 1u ) ), p.driverInfo.begin() );
    }
  }
  p.conformanceVersion = j[ "conformanceVersion" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceDriverProperties &p ) {
  PhysicalDeviceDriverProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDriverProperties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceDrmPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "hasPrimary" ] = bool( p.hasPrimary );
  j[ "hasRender" ] = bool( p.hasRender );
  j[ "primaryMajor" ] = p.primaryMajor;
  j[ "primaryMinor" ] = p.primaryMinor;
  j[ "renderMajor" ] = p.renderMajor;
  j[ "renderMinor" ] = p.renderMinor;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceDrmPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceDrmPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceDrmPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceDrmPropertiesEXT" );
  p.hasPrimary = j[ "hasPrimary" ];
  p.hasRender = j[ "hasRender" ];
  p.primaryMajor = j[ "primaryMajor" ];
  p.primaryMinor = j[ "primaryMinor" ];
  p.renderMajor = j[ "renderMajor" ];
  p.renderMinor = j[ "renderMinor" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceDrmPropertiesEXT &p ) {
  PhysicalDeviceDrmPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceDrmPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceExclusiveScissorFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "exclusiveScissor" ] = bool( p.exclusiveScissor );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceExclusiveScissorFeaturesNV &p ) {
  to_json( j, PhysicalDeviceExclusiveScissorFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceExclusiveScissorFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExclusiveScissorFeaturesNV" );
  p.exclusiveScissor = j[ "exclusiveScissor" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceExclusiveScissorFeaturesNV &p ) {
  PhysicalDeviceExclusiveScissorFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExclusiveScissorFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceExtendedDynamicState2FeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "extendedDynamicState2" ] = bool( p.extendedDynamicState2 );
  j[ "extendedDynamicState2LogicOp" ] = bool( p.extendedDynamicState2LogicOp );
  j[ "extendedDynamicState2PatchControlPoints" ] = bool( p.extendedDynamicState2PatchControlPoints );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT &p ) {
  to_json( j, PhysicalDeviceExtendedDynamicState2FeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceExtendedDynamicState2FeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExtendedDynamicState2FeaturesEXT" );
  p.extendedDynamicState2 = j[ "extendedDynamicState2" ];
  p.extendedDynamicState2LogicOp = j[ "extendedDynamicState2LogicOp" ];
  p.extendedDynamicState2PatchControlPoints = j[ "extendedDynamicState2PatchControlPoints" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT &p ) {
  PhysicalDeviceExtendedDynamicState2FeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExtendedDynamicState2FeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceExtendedDynamicStateFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "extendedDynamicState" ] = bool( p.extendedDynamicState );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceExtendedDynamicStateFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceExtendedDynamicStateFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExtendedDynamicStateFeaturesEXT" );
  p.extendedDynamicState = j[ "extendedDynamicState" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT &p ) {
  PhysicalDeviceExtendedDynamicStateFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExtendedDynamicStateFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceExternalBufferInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "usage" ] = p.usage;
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceExternalBufferInfo &p ) {
  to_json( j, PhysicalDeviceExternalBufferInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceExternalBufferInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExternalBufferInfo" );
  p.flags = j[ "flags" ];
  p.usage = j[ "usage" ];
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceExternalBufferInfo &p ) {
  PhysicalDeviceExternalBufferInfo temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExternalBufferInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceExternalFenceInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceExternalFenceInfo &p ) {
  to_json( j, PhysicalDeviceExternalFenceInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceExternalFenceInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExternalFenceInfo" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceExternalFenceInfo &p ) {
  PhysicalDeviceExternalFenceInfo temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExternalFenceInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceExternalImageFormatInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceExternalImageFormatInfo &p ) {
  to_json( j, PhysicalDeviceExternalImageFormatInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceExternalImageFormatInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExternalImageFormatInfo" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceExternalImageFormatInfo &p ) {
  PhysicalDeviceExternalImageFormatInfo temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExternalImageFormatInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceExternalMemoryHostPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "minImportedHostPointerAlignment" ] = p.minImportedHostPointerAlignment;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceExternalMemoryHostPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceExternalMemoryHostPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceExternalMemoryHostPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExternalMemoryHostPropertiesEXT" );
  p.minImportedHostPointerAlignment = j[ "minImportedHostPointerAlignment" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceExternalMemoryHostPropertiesEXT &p ) {
  PhysicalDeviceExternalMemoryHostPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExternalMemoryHostPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceExternalSemaphoreInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceExternalSemaphoreInfo &p ) {
  to_json( j, PhysicalDeviceExternalSemaphoreInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceExternalSemaphoreInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceExternalSemaphoreInfo" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceExternalSemaphoreInfo &p ) {
  PhysicalDeviceExternalSemaphoreInfo temp;
  from_json( j, temp );
  p = VkPhysicalDeviceExternalSemaphoreInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceFeatures2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "features" ] = p.features;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceFeatures2 &p ) {
  to_json( j, PhysicalDeviceFeatures2 ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceFeatures2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFeatures2" );
  p.features = j[ "features" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceFeatures2 &p ) {
  PhysicalDeviceFeatures2 temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFeatures2 ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceFloatControlsProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "denormBehaviorIndependence" ] = p.denormBehaviorIndependence;
  j[ "roundingModeIndependence" ] = p.roundingModeIndependence;
  j[ "shaderSignedZeroInfNanPreserveFloat16" ] = bool( p.shaderSignedZeroInfNanPreserveFloat16 );
  j[ "shaderSignedZeroInfNanPreserveFloat32" ] = bool( p.shaderSignedZeroInfNanPreserveFloat32 );
  j[ "shaderSignedZeroInfNanPreserveFloat64" ] = bool( p.shaderSignedZeroInfNanPreserveFloat64 );
  j[ "shaderDenormPreserveFloat16" ] = bool( p.shaderDenormPreserveFloat16 );
  j[ "shaderDenormPreserveFloat32" ] = bool( p.shaderDenormPreserveFloat32 );
  j[ "shaderDenormPreserveFloat64" ] = bool( p.shaderDenormPreserveFloat64 );
  j[ "shaderDenormFlushToZeroFloat16" ] = bool( p.shaderDenormFlushToZeroFloat16 );
  j[ "shaderDenormFlushToZeroFloat32" ] = bool( p.shaderDenormFlushToZeroFloat32 );
  j[ "shaderDenormFlushToZeroFloat64" ] = bool( p.shaderDenormFlushToZeroFloat64 );
  j[ "shaderRoundingModeRTEFloat16" ] = bool( p.shaderRoundingModeRTEFloat16 );
  j[ "shaderRoundingModeRTEFloat32" ] = bool( p.shaderRoundingModeRTEFloat32 );
  j[ "shaderRoundingModeRTEFloat64" ] = bool( p.shaderRoundingModeRTEFloat64 );
  j[ "shaderRoundingModeRTZFloat16" ] = bool( p.shaderRoundingModeRTZFloat16 );
  j[ "shaderRoundingModeRTZFloat32" ] = bool( p.shaderRoundingModeRTZFloat32 );
  j[ "shaderRoundingModeRTZFloat64" ] = bool( p.shaderRoundingModeRTZFloat64 );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceFloatControlsProperties &p ) {
  to_json( j, PhysicalDeviceFloatControlsProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceFloatControlsProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFloatControlsProperties" );
  p.denormBehaviorIndependence = j[ "denormBehaviorIndependence" ];
  p.roundingModeIndependence = j[ "roundingModeIndependence" ];
  p.shaderSignedZeroInfNanPreserveFloat16 = j[ "shaderSignedZeroInfNanPreserveFloat16" ];
  p.shaderSignedZeroInfNanPreserveFloat32 = j[ "shaderSignedZeroInfNanPreserveFloat32" ];
  p.shaderSignedZeroInfNanPreserveFloat64 = j[ "shaderSignedZeroInfNanPreserveFloat64" ];
  p.shaderDenormPreserveFloat16 = j[ "shaderDenormPreserveFloat16" ];
  p.shaderDenormPreserveFloat32 = j[ "shaderDenormPreserveFloat32" ];
  p.shaderDenormPreserveFloat64 = j[ "shaderDenormPreserveFloat64" ];
  p.shaderDenormFlushToZeroFloat16 = j[ "shaderDenormFlushToZeroFloat16" ];
  p.shaderDenormFlushToZeroFloat32 = j[ "shaderDenormFlushToZeroFloat32" ];
  p.shaderDenormFlushToZeroFloat64 = j[ "shaderDenormFlushToZeroFloat64" ];
  p.shaderRoundingModeRTEFloat16 = j[ "shaderRoundingModeRTEFloat16" ];
  p.shaderRoundingModeRTEFloat32 = j[ "shaderRoundingModeRTEFloat32" ];
  p.shaderRoundingModeRTEFloat64 = j[ "shaderRoundingModeRTEFloat64" ];
  p.shaderRoundingModeRTZFloat16 = j[ "shaderRoundingModeRTZFloat16" ];
  p.shaderRoundingModeRTZFloat32 = j[ "shaderRoundingModeRTZFloat32" ];
  p.shaderRoundingModeRTZFloat64 = j[ "shaderRoundingModeRTZFloat64" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceFloatControlsProperties &p ) {
  PhysicalDeviceFloatControlsProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFloatControlsProperties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceFragmentDensityMap2FeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fragmentDensityMapDeferred" ] = bool( p.fragmentDensityMapDeferred );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT &p ) {
  to_json( j, PhysicalDeviceFragmentDensityMap2FeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceFragmentDensityMap2FeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentDensityMap2FeaturesEXT" );
  p.fragmentDensityMapDeferred = j[ "fragmentDensityMapDeferred" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT &p ) {
  PhysicalDeviceFragmentDensityMap2FeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentDensityMap2FeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceFragmentDensityMap2PropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "subsampledLoads" ] = bool( p.subsampledLoads );
  j[ "subsampledCoarseReconstructionEarlyAccess" ] = bool( p.subsampledCoarseReconstructionEarlyAccess );
  j[ "maxSubsampledArrayLayers" ] = p.maxSubsampledArrayLayers;
  j[ "maxDescriptorSetSubsampledSamplers" ] = p.maxDescriptorSetSubsampledSamplers;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT &p ) {
  to_json( j, PhysicalDeviceFragmentDensityMap2PropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceFragmentDensityMap2PropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentDensityMap2PropertiesEXT" );
  p.subsampledLoads = j[ "subsampledLoads" ];
  p.subsampledCoarseReconstructionEarlyAccess = j[ "subsampledCoarseReconstructionEarlyAccess" ];
  p.maxSubsampledArrayLayers = j[ "maxSubsampledArrayLayers" ];
  p.maxDescriptorSetSubsampledSamplers = j[ "maxDescriptorSetSubsampledSamplers" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT &p ) {
  PhysicalDeviceFragmentDensityMap2PropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentDensityMap2PropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceFragmentDensityMapFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fragmentDensityMap" ] = bool( p.fragmentDensityMap );
  j[ "fragmentDensityMapDynamic" ] = bool( p.fragmentDensityMapDynamic );
  j[ "fragmentDensityMapNonSubsampledImages" ] = bool( p.fragmentDensityMapNonSubsampledImages );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentDensityMapFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceFragmentDensityMapFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceFragmentDensityMapFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentDensityMapFeaturesEXT" );
  p.fragmentDensityMap = j[ "fragmentDensityMap" ];
  p.fragmentDensityMapDynamic = j[ "fragmentDensityMapDynamic" ];
  p.fragmentDensityMapNonSubsampledImages = j[ "fragmentDensityMapNonSubsampledImages" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentDensityMapFeaturesEXT &p ) {
  PhysicalDeviceFragmentDensityMapFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentDensityMapFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceFragmentDensityMapPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "minFragmentDensityTexelSize" ] = p.minFragmentDensityTexelSize;
  j[ "maxFragmentDensityTexelSize" ] = p.maxFragmentDensityTexelSize;
  j[ "fragmentDensityInvocations" ] = bool( p.fragmentDensityInvocations );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentDensityMapPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceFragmentDensityMapPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceFragmentDensityMapPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentDensityMapPropertiesEXT" );
  p.minFragmentDensityTexelSize = j[ "minFragmentDensityTexelSize" ];
  p.maxFragmentDensityTexelSize = j[ "maxFragmentDensityTexelSize" ];
  p.fragmentDensityInvocations = j[ "fragmentDensityInvocations" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentDensityMapPropertiesEXT &p ) {
  PhysicalDeviceFragmentDensityMapPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentDensityMapPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceFragmentShaderBarycentricFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fragmentShaderBarycentric" ] = bool( p.fragmentShaderBarycentric );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV &p ) {
  to_json( j, PhysicalDeviceFragmentShaderBarycentricFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceFragmentShaderBarycentricFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentShaderBarycentricFeaturesNV" );
  p.fragmentShaderBarycentric = j[ "fragmentShaderBarycentric" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV &p ) {
  PhysicalDeviceFragmentShaderBarycentricFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceFragmentShaderInterlockFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fragmentShaderSampleInterlock" ] = bool( p.fragmentShaderSampleInterlock );
  j[ "fragmentShaderPixelInterlock" ] = bool( p.fragmentShaderPixelInterlock );
  j[ "fragmentShaderShadingRateInterlock" ] = bool( p.fragmentShaderShadingRateInterlock );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceFragmentShaderInterlockFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceFragmentShaderInterlockFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentShaderInterlockFeaturesEXT" );
  p.fragmentShaderSampleInterlock = j[ "fragmentShaderSampleInterlock" ];
  p.fragmentShaderPixelInterlock = j[ "fragmentShaderPixelInterlock" ];
  p.fragmentShaderShadingRateInterlock = j[ "fragmentShaderShadingRateInterlock" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT &p ) {
  PhysicalDeviceFragmentShaderInterlockFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceFragmentShadingRateEnumsFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fragmentShadingRateEnums" ] = bool( p.fragmentShadingRateEnums );
  j[ "supersampleFragmentShadingRates" ] = bool( p.supersampleFragmentShadingRates );
  j[ "noInvocationFragmentShadingRates" ] = bool( p.noInvocationFragmentShadingRates );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV &p ) {
  to_json( j, PhysicalDeviceFragmentShadingRateEnumsFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceFragmentShadingRateEnumsFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV" );
  p.fragmentShadingRateEnums = j[ "fragmentShadingRateEnums" ];
  p.supersampleFragmentShadingRates = j[ "supersampleFragmentShadingRates" ];
  p.noInvocationFragmentShadingRates = j[ "noInvocationFragmentShadingRates" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV &p ) {
  PhysicalDeviceFragmentShadingRateEnumsFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceFragmentShadingRateEnumsPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxFragmentShadingRateInvocationCount" ] = p.maxFragmentShadingRateInvocationCount;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV &p ) {
  to_json( j, PhysicalDeviceFragmentShadingRateEnumsPropertiesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceFragmentShadingRateEnumsPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV" );
  p.maxFragmentShadingRateInvocationCount = j[ "maxFragmentShadingRateInvocationCount" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV &p ) {
  PhysicalDeviceFragmentShadingRateEnumsPropertiesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceFragmentShadingRateFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pipelineFragmentShadingRate" ] = bool( p.pipelineFragmentShadingRate );
  j[ "primitiveFragmentShadingRate" ] = bool( p.primitiveFragmentShadingRate );
  j[ "attachmentFragmentShadingRate" ] = bool( p.attachmentFragmentShadingRate );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentShadingRateFeaturesKHR &p ) {
  to_json( j, PhysicalDeviceFragmentShadingRateFeaturesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceFragmentShadingRateFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentShadingRateFeaturesKHR" );
  p.pipelineFragmentShadingRate = j[ "pipelineFragmentShadingRate" ];
  p.primitiveFragmentShadingRate = j[ "primitiveFragmentShadingRate" ];
  p.attachmentFragmentShadingRate = j[ "attachmentFragmentShadingRate" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentShadingRateFeaturesKHR &p ) {
  PhysicalDeviceFragmentShadingRateFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentShadingRateFeaturesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceFragmentShadingRateKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "sampleCounts" ] = p.sampleCounts;
  j[ "fragmentSize" ] = p.fragmentSize;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentShadingRateKHR &p ) {
  to_json( j, PhysicalDeviceFragmentShadingRateKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceFragmentShadingRateKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentShadingRateKHR" );
  p.sampleCounts = j[ "sampleCounts" ];
  p.fragmentSize = j[ "fragmentSize" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentShadingRateKHR &p ) {
  PhysicalDeviceFragmentShadingRateKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentShadingRateKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceFragmentShadingRatePropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "minFragmentShadingRateAttachmentTexelSize" ] = p.minFragmentShadingRateAttachmentTexelSize;
  j[ "maxFragmentShadingRateAttachmentTexelSize" ] = p.maxFragmentShadingRateAttachmentTexelSize;
  j[ "maxFragmentShadingRateAttachmentTexelSizeAspectRatio" ] = p.maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
  j[ "primitiveFragmentShadingRateWithMultipleViewports" ] = bool( p.primitiveFragmentShadingRateWithMultipleViewports );
  j[ "layeredShadingRateAttachments" ] = bool( p.layeredShadingRateAttachments );
  j[ "fragmentShadingRateNonTrivialCombinerOps" ] = bool( p.fragmentShadingRateNonTrivialCombinerOps );
  j[ "maxFragmentSize" ] = p.maxFragmentSize;
  j[ "maxFragmentSizeAspectRatio" ] = p.maxFragmentSizeAspectRatio;
  j[ "maxFragmentShadingRateCoverageSamples" ] = p.maxFragmentShadingRateCoverageSamples;
  j[ "maxFragmentShadingRateRasterizationSamples" ] = p.maxFragmentShadingRateRasterizationSamples;
  j[ "fragmentShadingRateWithShaderDepthStencilWrites" ] = bool( p.fragmentShadingRateWithShaderDepthStencilWrites );
  j[ "fragmentShadingRateWithSampleMask" ] = bool( p.fragmentShadingRateWithSampleMask );
  j[ "fragmentShadingRateWithShaderSampleMask" ] = bool( p.fragmentShadingRateWithShaderSampleMask );
  j[ "fragmentShadingRateWithConservativeRasterization" ] = bool( p.fragmentShadingRateWithConservativeRasterization );
  j[ "fragmentShadingRateWithFragmentShaderInterlock" ] = bool( p.fragmentShadingRateWithFragmentShaderInterlock );
  j[ "fragmentShadingRateWithCustomSampleLocations" ] = bool( p.fragmentShadingRateWithCustomSampleLocations );
  j[ "fragmentShadingRateStrictMultiplyCombiner" ] = bool( p.fragmentShadingRateStrictMultiplyCombiner );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceFragmentShadingRatePropertiesKHR &p ) {
  to_json( j, PhysicalDeviceFragmentShadingRatePropertiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceFragmentShadingRatePropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceFragmentShadingRatePropertiesKHR" );
  p.minFragmentShadingRateAttachmentTexelSize = j[ "minFragmentShadingRateAttachmentTexelSize" ];
  p.maxFragmentShadingRateAttachmentTexelSize = j[ "maxFragmentShadingRateAttachmentTexelSize" ];
  p.maxFragmentShadingRateAttachmentTexelSizeAspectRatio = j[ "maxFragmentShadingRateAttachmentTexelSizeAspectRatio" ];
  p.primitiveFragmentShadingRateWithMultipleViewports = j[ "primitiveFragmentShadingRateWithMultipleViewports" ];
  p.layeredShadingRateAttachments = j[ "layeredShadingRateAttachments" ];
  p.fragmentShadingRateNonTrivialCombinerOps = j[ "fragmentShadingRateNonTrivialCombinerOps" ];
  p.maxFragmentSize = j[ "maxFragmentSize" ];
  p.maxFragmentSizeAspectRatio = j[ "maxFragmentSizeAspectRatio" ];
  p.maxFragmentShadingRateCoverageSamples = j[ "maxFragmentShadingRateCoverageSamples" ];
  p.maxFragmentShadingRateRasterizationSamples = j[ "maxFragmentShadingRateRasterizationSamples" ];
  p.fragmentShadingRateWithShaderDepthStencilWrites = j[ "fragmentShadingRateWithShaderDepthStencilWrites" ];
  p.fragmentShadingRateWithSampleMask = j[ "fragmentShadingRateWithSampleMask" ];
  p.fragmentShadingRateWithShaderSampleMask = j[ "fragmentShadingRateWithShaderSampleMask" ];
  p.fragmentShadingRateWithConservativeRasterization = j[ "fragmentShadingRateWithConservativeRasterization" ];
  p.fragmentShadingRateWithFragmentShaderInterlock = j[ "fragmentShadingRateWithFragmentShaderInterlock" ];
  p.fragmentShadingRateWithCustomSampleLocations = j[ "fragmentShadingRateWithCustomSampleLocations" ];
  p.fragmentShadingRateStrictMultiplyCombiner = j[ "fragmentShadingRateStrictMultiplyCombiner" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceFragmentShadingRatePropertiesKHR &p ) {
  PhysicalDeviceFragmentShadingRatePropertiesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceFragmentShadingRatePropertiesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceGlobalPriorityQueryFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "globalPriorityQuery" ] = bool( p.globalPriorityQuery );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceGlobalPriorityQueryFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceGlobalPriorityQueryFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceGlobalPriorityQueryFeaturesEXT" );
  p.globalPriorityQuery = j[ "globalPriorityQuery" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT &p ) {
  PhysicalDeviceGlobalPriorityQueryFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceGroupProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "physicalDeviceCount" ] = p.physicalDeviceCount;
  j[ "subsetAllocation" ] = bool( p.subsetAllocation );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceGroupProperties &p ) {
  to_json( j, PhysicalDeviceGroupProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceGroupProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceGroupProperties" );
  p.physicalDeviceCount = j[ "physicalDeviceCount" ];
  p.subsetAllocation = j[ "subsetAllocation" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceGroupProperties &p ) {
  PhysicalDeviceGroupProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceGroupProperties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceHostQueryResetFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "hostQueryReset" ] = bool( p.hostQueryReset );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceHostQueryResetFeatures &p ) {
  to_json( j, PhysicalDeviceHostQueryResetFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceHostQueryResetFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceHostQueryResetFeatures" );
  p.hostQueryReset = j[ "hostQueryReset" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceHostQueryResetFeatures &p ) {
  PhysicalDeviceHostQueryResetFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceHostQueryResetFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceIDProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceUUID" ] = nlohmann::json::array();
  std::copy( p.deviceUUID.begin(), p.deviceUUID.end(), std::back_inserter( j[ "deviceUUID" ] ) );
  j[ "driverUUID" ] = nlohmann::json::array();
  std::copy( p.driverUUID.begin(), p.driverUUID.end(), std::back_inserter( j[ "driverUUID" ] ) );
  j[ "deviceLUID" ] = nlohmann::json::array();
  std::copy( p.deviceLUID.begin(), p.deviceLUID.end(), std::back_inserter( j[ "deviceLUID" ] ) );
  j[ "deviceNodeMask" ] = p.deviceNodeMask;
  j[ "deviceLUIDValid" ] = bool( p.deviceLUIDValid );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceIDProperties &p ) {
  to_json( j, PhysicalDeviceIDProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceIDProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceIDProperties" );
  if( !j[ "deviceUUID" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceIDProperties.deviceUUID" );
  if( !j[ "deviceUUID" ].size() > p.deviceUUID.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceIDProperties.deviceUUID" );
  std::fill( p.deviceUUID.begin(), p.deviceUUID.end(), 0 );
  std::copy( j[ "deviceUUID" ].begin(), j[ "deviceUUID" ].end(), p.deviceUUID.begin() );
  if( !j[ "driverUUID" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceIDProperties.driverUUID" );
  if( !j[ "driverUUID" ].size() > p.driverUUID.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceIDProperties.driverUUID" );
  std::fill( p.driverUUID.begin(), p.driverUUID.end(), 0 );
  std::copy( j[ "driverUUID" ].begin(), j[ "driverUUID" ].end(), p.driverUUID.begin() );
  if( !j[ "deviceLUID" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceIDProperties.deviceLUID" );
  if( !j[ "deviceLUID" ].size() > p.deviceLUID.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceIDProperties.deviceLUID" );
  std::fill( p.deviceLUID.begin(), p.deviceLUID.end(), 0 );
  std::copy( j[ "deviceLUID" ].begin(), j[ "deviceLUID" ].end(), p.deviceLUID.begin() );
  p.deviceNodeMask = j[ "deviceNodeMask" ];
  p.deviceLUIDValid = j[ "deviceLUIDValid" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceIDProperties &p ) {
  PhysicalDeviceIDProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceIDProperties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceImageDrmFormatModifierInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "drmFormatModifier" ] = p.drmFormatModifier;
  j[ "sharingMode" ] = p.sharingMode;
  j[ "queueFamilyIndexCount" ] = p.queueFamilyIndexCount;
  j[ "pQueueFamilyIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pQueueFamilyIndices ) );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceImageDrmFormatModifierInfoEXT &p ) {
  to_json( j, PhysicalDeviceImageDrmFormatModifierInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceImageDrmFormatModifierInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceImageDrmFormatModifierInfoEXT" );
  p.drmFormatModifier = j[ "drmFormatModifier" ];
  p.sharingMode = j[ "sharingMode" ];
  p.queueFamilyIndexCount = j[ "queueFamilyIndexCount" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceImageDrmFormatModifierInfoEXT &p ) {
  PhysicalDeviceImageDrmFormatModifierInfoEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceImageDrmFormatModifierInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceImageFormatInfo2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "format" ] = p.format;
  j[ "type" ] = p.type;
  j[ "tiling" ] = p.tiling;
  j[ "usage" ] = p.usage;
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceImageFormatInfo2 &p ) {
  to_json( j, PhysicalDeviceImageFormatInfo2 ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceImageFormatInfo2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceImageFormatInfo2" );
  p.format = j[ "format" ];
  p.type = j[ "type" ];
  p.tiling = j[ "tiling" ];
  p.usage = j[ "usage" ];
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceImageFormatInfo2 &p ) {
  PhysicalDeviceImageFormatInfo2 temp;
  from_json( j, temp );
  p = VkPhysicalDeviceImageFormatInfo2 ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceImageRobustnessFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "robustImageAccess" ] = bool( p.robustImageAccess );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceImageRobustnessFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceImageRobustnessFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceImageRobustnessFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceImageRobustnessFeaturesEXT" );
  p.robustImageAccess = j[ "robustImageAccess" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceImageRobustnessFeaturesEXT &p ) {
  PhysicalDeviceImageRobustnessFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceImageRobustnessFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceImageViewImageFormatInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "imageViewType" ] = p.imageViewType;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceImageViewImageFormatInfoEXT &p ) {
  to_json( j, PhysicalDeviceImageViewImageFormatInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceImageViewImageFormatInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceImageViewImageFormatInfoEXT" );
  p.imageViewType = j[ "imageViewType" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceImageViewImageFormatInfoEXT &p ) {
  PhysicalDeviceImageViewImageFormatInfoEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceImageViewImageFormatInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceImagelessFramebufferFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "imagelessFramebuffer" ] = bool( p.imagelessFramebuffer );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceImagelessFramebufferFeatures &p ) {
  to_json( j, PhysicalDeviceImagelessFramebufferFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceImagelessFramebufferFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceImagelessFramebufferFeatures" );
  p.imagelessFramebuffer = j[ "imagelessFramebuffer" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceImagelessFramebufferFeatures &p ) {
  PhysicalDeviceImagelessFramebufferFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceImagelessFramebufferFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceIndexTypeUint8FeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "indexTypeUint8" ] = bool( p.indexTypeUint8 );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceIndexTypeUint8FeaturesEXT &p ) {
  to_json( j, PhysicalDeviceIndexTypeUint8FeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceIndexTypeUint8FeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceIndexTypeUint8FeaturesEXT" );
  p.indexTypeUint8 = j[ "indexTypeUint8" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceIndexTypeUint8FeaturesEXT &p ) {
  PhysicalDeviceIndexTypeUint8FeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceIndexTypeUint8FeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceInheritedViewportScissorFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "inheritedViewportScissor2D" ] = bool( p.inheritedViewportScissor2D );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceInheritedViewportScissorFeaturesNV &p ) {
  to_json( j, PhysicalDeviceInheritedViewportScissorFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceInheritedViewportScissorFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceInheritedViewportScissorFeaturesNV" );
  p.inheritedViewportScissor2D = j[ "inheritedViewportScissor2D" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceInheritedViewportScissorFeaturesNV &p ) {
  PhysicalDeviceInheritedViewportScissorFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceInheritedViewportScissorFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceInlineUniformBlockFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "inlineUniformBlock" ] = bool( p.inlineUniformBlock );
  j[ "descriptorBindingInlineUniformBlockUpdateAfterBind" ] = bool( p.descriptorBindingInlineUniformBlockUpdateAfterBind );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceInlineUniformBlockFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceInlineUniformBlockFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceInlineUniformBlockFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceInlineUniformBlockFeaturesEXT" );
  p.inlineUniformBlock = j[ "inlineUniformBlock" ];
  p.descriptorBindingInlineUniformBlockUpdateAfterBind = j[ "descriptorBindingInlineUniformBlockUpdateAfterBind" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceInlineUniformBlockFeaturesEXT &p ) {
  PhysicalDeviceInlineUniformBlockFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceInlineUniformBlockFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceInlineUniformBlockPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxInlineUniformBlockSize" ] = p.maxInlineUniformBlockSize;
  j[ "maxPerStageDescriptorInlineUniformBlocks" ] = p.maxPerStageDescriptorInlineUniformBlocks;
  j[ "maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks" ] = p.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
  j[ "maxDescriptorSetInlineUniformBlocks" ] = p.maxDescriptorSetInlineUniformBlocks;
  j[ "maxDescriptorSetUpdateAfterBindInlineUniformBlocks" ] = p.maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceInlineUniformBlockPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceInlineUniformBlockPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceInlineUniformBlockPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceInlineUniformBlockPropertiesEXT" );
  p.maxInlineUniformBlockSize = j[ "maxInlineUniformBlockSize" ];
  p.maxPerStageDescriptorInlineUniformBlocks = j[ "maxPerStageDescriptorInlineUniformBlocks" ];
  p.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = j[ "maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks" ];
  p.maxDescriptorSetInlineUniformBlocks = j[ "maxDescriptorSetInlineUniformBlocks" ];
  p.maxDescriptorSetUpdateAfterBindInlineUniformBlocks = j[ "maxDescriptorSetUpdateAfterBindInlineUniformBlocks" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceInlineUniformBlockPropertiesEXT &p ) {
  PhysicalDeviceInlineUniformBlockPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceInlineUniformBlockPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceLimits &p ) {
  j = nlohmann::json::object();
  j[ "maxImageDimension1D" ] = p.maxImageDimension1D;
  j[ "maxImageDimension2D" ] = p.maxImageDimension2D;
  j[ "maxImageDimension3D" ] = p.maxImageDimension3D;
  j[ "maxImageDimensionCube" ] = p.maxImageDimensionCube;
  j[ "maxImageArrayLayers" ] = p.maxImageArrayLayers;
  j[ "maxTexelBufferElements" ] = p.maxTexelBufferElements;
  j[ "maxUniformBufferRange" ] = p.maxUniformBufferRange;
  j[ "maxStorageBufferRange" ] = p.maxStorageBufferRange;
  j[ "maxPushConstantsSize" ] = p.maxPushConstantsSize;
  j[ "maxMemoryAllocationCount" ] = p.maxMemoryAllocationCount;
  j[ "maxSamplerAllocationCount" ] = p.maxSamplerAllocationCount;
  j[ "bufferImageGranularity" ] = p.bufferImageGranularity;
  j[ "sparseAddressSpaceSize" ] = p.sparseAddressSpaceSize;
  j[ "maxBoundDescriptorSets" ] = p.maxBoundDescriptorSets;
  j[ "maxPerStageDescriptorSamplers" ] = p.maxPerStageDescriptorSamplers;
  j[ "maxPerStageDescriptorUniformBuffers" ] = p.maxPerStageDescriptorUniformBuffers;
  j[ "maxPerStageDescriptorStorageBuffers" ] = p.maxPerStageDescriptorStorageBuffers;
  j[ "maxPerStageDescriptorSampledImages" ] = p.maxPerStageDescriptorSampledImages;
  j[ "maxPerStageDescriptorStorageImages" ] = p.maxPerStageDescriptorStorageImages;
  j[ "maxPerStageDescriptorInputAttachments" ] = p.maxPerStageDescriptorInputAttachments;
  j[ "maxPerStageResources" ] = p.maxPerStageResources;
  j[ "maxDescriptorSetSamplers" ] = p.maxDescriptorSetSamplers;
  j[ "maxDescriptorSetUniformBuffers" ] = p.maxDescriptorSetUniformBuffers;
  j[ "maxDescriptorSetUniformBuffersDynamic" ] = p.maxDescriptorSetUniformBuffersDynamic;
  j[ "maxDescriptorSetStorageBuffers" ] = p.maxDescriptorSetStorageBuffers;
  j[ "maxDescriptorSetStorageBuffersDynamic" ] = p.maxDescriptorSetStorageBuffersDynamic;
  j[ "maxDescriptorSetSampledImages" ] = p.maxDescriptorSetSampledImages;
  j[ "maxDescriptorSetStorageImages" ] = p.maxDescriptorSetStorageImages;
  j[ "maxDescriptorSetInputAttachments" ] = p.maxDescriptorSetInputAttachments;
  j[ "maxVertexInputAttributes" ] = p.maxVertexInputAttributes;
  j[ "maxVertexInputBindings" ] = p.maxVertexInputBindings;
  j[ "maxVertexInputAttributeOffset" ] = p.maxVertexInputAttributeOffset;
  j[ "maxVertexInputBindingStride" ] = p.maxVertexInputBindingStride;
  j[ "maxVertexOutputComponents" ] = p.maxVertexOutputComponents;
  j[ "maxTessellationGenerationLevel" ] = p.maxTessellationGenerationLevel;
  j[ "maxTessellationPatchSize" ] = p.maxTessellationPatchSize;
  j[ "maxTessellationControlPerVertexInputComponents" ] = p.maxTessellationControlPerVertexInputComponents;
  j[ "maxTessellationControlPerVertexOutputComponents" ] = p.maxTessellationControlPerVertexOutputComponents;
  j[ "maxTessellationControlPerPatchOutputComponents" ] = p.maxTessellationControlPerPatchOutputComponents;
  j[ "maxTessellationControlTotalOutputComponents" ] = p.maxTessellationControlTotalOutputComponents;
  j[ "maxTessellationEvaluationInputComponents" ] = p.maxTessellationEvaluationInputComponents;
  j[ "maxTessellationEvaluationOutputComponents" ] = p.maxTessellationEvaluationOutputComponents;
  j[ "maxGeometryShaderInvocations" ] = p.maxGeometryShaderInvocations;
  j[ "maxGeometryInputComponents" ] = p.maxGeometryInputComponents;
  j[ "maxGeometryOutputComponents" ] = p.maxGeometryOutputComponents;
  j[ "maxGeometryOutputVertices" ] = p.maxGeometryOutputVertices;
  j[ "maxGeometryTotalOutputComponents" ] = p.maxGeometryTotalOutputComponents;
  j[ "maxFragmentInputComponents" ] = p.maxFragmentInputComponents;
  j[ "maxFragmentOutputAttachments" ] = p.maxFragmentOutputAttachments;
  j[ "maxFragmentDualSrcAttachments" ] = p.maxFragmentDualSrcAttachments;
  j[ "maxFragmentCombinedOutputResources" ] = p.maxFragmentCombinedOutputResources;
  j[ "maxComputeSharedMemorySize" ] = p.maxComputeSharedMemorySize;
  j[ "maxComputeWorkGroupCount" ] = nlohmann::json::array();
  std::copy( p.maxComputeWorkGroupCount.begin(), p.maxComputeWorkGroupCount.end(), std::back_inserter( j[ "maxComputeWorkGroupCount" ] ) );
  j[ "maxComputeWorkGroupInvocations" ] = p.maxComputeWorkGroupInvocations;
  j[ "maxComputeWorkGroupSize" ] = nlohmann::json::array();
  std::copy( p.maxComputeWorkGroupSize.begin(), p.maxComputeWorkGroupSize.end(), std::back_inserter( j[ "maxComputeWorkGroupSize" ] ) );
  j[ "subPixelPrecisionBits" ] = p.subPixelPrecisionBits;
  j[ "subTexelPrecisionBits" ] = p.subTexelPrecisionBits;
  j[ "mipmapPrecisionBits" ] = p.mipmapPrecisionBits;
  j[ "maxDrawIndexedIndexValue" ] = p.maxDrawIndexedIndexValue;
  j[ "maxDrawIndirectCount" ] = p.maxDrawIndirectCount;
  j[ "maxSamplerLodBias" ] = p.maxSamplerLodBias;
  j[ "maxSamplerAnisotropy" ] = p.maxSamplerAnisotropy;
  j[ "maxViewports" ] = p.maxViewports;
  j[ "maxViewportDimensions" ] = nlohmann::json::array();
  std::copy( p.maxViewportDimensions.begin(), p.maxViewportDimensions.end(), std::back_inserter( j[ "maxViewportDimensions" ] ) );
  j[ "viewportBoundsRange" ] = nlohmann::json::array();
  std::copy( p.viewportBoundsRange.begin(), p.viewportBoundsRange.end(), std::back_inserter( j[ "viewportBoundsRange" ] ) );
  j[ "viewportSubPixelBits" ] = p.viewportSubPixelBits;
  j[ "minMemoryMapAlignment" ] = p.minMemoryMapAlignment;
  j[ "minTexelBufferOffsetAlignment" ] = p.minTexelBufferOffsetAlignment;
  j[ "minUniformBufferOffsetAlignment" ] = p.minUniformBufferOffsetAlignment;
  j[ "minStorageBufferOffsetAlignment" ] = p.minStorageBufferOffsetAlignment;
  j[ "minTexelOffset" ] = p.minTexelOffset;
  j[ "maxTexelOffset" ] = p.maxTexelOffset;
  j[ "minTexelGatherOffset" ] = p.minTexelGatherOffset;
  j[ "maxTexelGatherOffset" ] = p.maxTexelGatherOffset;
  j[ "minInterpolationOffset" ] = p.minInterpolationOffset;
  j[ "maxInterpolationOffset" ] = p.maxInterpolationOffset;
  j[ "subPixelInterpolationOffsetBits" ] = p.subPixelInterpolationOffsetBits;
  j[ "maxFramebufferWidth" ] = p.maxFramebufferWidth;
  j[ "maxFramebufferHeight" ] = p.maxFramebufferHeight;
  j[ "maxFramebufferLayers" ] = p.maxFramebufferLayers;
  j[ "framebufferColorSampleCounts" ] = p.framebufferColorSampleCounts;
  j[ "framebufferDepthSampleCounts" ] = p.framebufferDepthSampleCounts;
  j[ "framebufferStencilSampleCounts" ] = p.framebufferStencilSampleCounts;
  j[ "framebufferNoAttachmentsSampleCounts" ] = p.framebufferNoAttachmentsSampleCounts;
  j[ "maxColorAttachments" ] = p.maxColorAttachments;
  j[ "sampledImageColorSampleCounts" ] = p.sampledImageColorSampleCounts;
  j[ "sampledImageIntegerSampleCounts" ] = p.sampledImageIntegerSampleCounts;
  j[ "sampledImageDepthSampleCounts" ] = p.sampledImageDepthSampleCounts;
  j[ "sampledImageStencilSampleCounts" ] = p.sampledImageStencilSampleCounts;
  j[ "storageImageSampleCounts" ] = p.storageImageSampleCounts;
  j[ "maxSampleMaskWords" ] = p.maxSampleMaskWords;
  j[ "timestampComputeAndGraphics" ] = bool( p.timestampComputeAndGraphics );
  j[ "timestampPeriod" ] = p.timestampPeriod;
  j[ "maxClipDistances" ] = p.maxClipDistances;
  j[ "maxCullDistances" ] = p.maxCullDistances;
  j[ "maxCombinedClipAndCullDistances" ] = p.maxCombinedClipAndCullDistances;
  j[ "discreteQueuePriorities" ] = p.discreteQueuePriorities;
  j[ "pointSizeRange" ] = nlohmann::json::array();
  std::copy( p.pointSizeRange.begin(), p.pointSizeRange.end(), std::back_inserter( j[ "pointSizeRange" ] ) );
  j[ "lineWidthRange" ] = nlohmann::json::array();
  std::copy( p.lineWidthRange.begin(), p.lineWidthRange.end(), std::back_inserter( j[ "lineWidthRange" ] ) );
  j[ "pointSizeGranularity" ] = p.pointSizeGranularity;
  j[ "lineWidthGranularity" ] = p.lineWidthGranularity;
  j[ "strictLines" ] = bool( p.strictLines );
  j[ "standardSampleLocations" ] = bool( p.standardSampleLocations );
  j[ "optimalBufferCopyOffsetAlignment" ] = p.optimalBufferCopyOffsetAlignment;
  j[ "optimalBufferCopyRowPitchAlignment" ] = p.optimalBufferCopyRowPitchAlignment;
  j[ "nonCoherentAtomSize" ] = p.nonCoherentAtomSize;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceLimits &p ) {
  to_json( j, PhysicalDeviceLimits ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceLimits &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceLimits" );
  p.maxImageDimension1D = j[ "maxImageDimension1D" ];
  p.maxImageDimension2D = j[ "maxImageDimension2D" ];
  p.maxImageDimension3D = j[ "maxImageDimension3D" ];
  p.maxImageDimensionCube = j[ "maxImageDimensionCube" ];
  p.maxImageArrayLayers = j[ "maxImageArrayLayers" ];
  p.maxTexelBufferElements = j[ "maxTexelBufferElements" ];
  p.maxUniformBufferRange = j[ "maxUniformBufferRange" ];
  p.maxStorageBufferRange = j[ "maxStorageBufferRange" ];
  p.maxPushConstantsSize = j[ "maxPushConstantsSize" ];
  p.maxMemoryAllocationCount = j[ "maxMemoryAllocationCount" ];
  p.maxSamplerAllocationCount = j[ "maxSamplerAllocationCount" ];
  p.bufferImageGranularity = j[ "bufferImageGranularity" ];
  p.sparseAddressSpaceSize = j[ "sparseAddressSpaceSize" ];
  p.maxBoundDescriptorSets = j[ "maxBoundDescriptorSets" ];
  p.maxPerStageDescriptorSamplers = j[ "maxPerStageDescriptorSamplers" ];
  p.maxPerStageDescriptorUniformBuffers = j[ "maxPerStageDescriptorUniformBuffers" ];
  p.maxPerStageDescriptorStorageBuffers = j[ "maxPerStageDescriptorStorageBuffers" ];
  p.maxPerStageDescriptorSampledImages = j[ "maxPerStageDescriptorSampledImages" ];
  p.maxPerStageDescriptorStorageImages = j[ "maxPerStageDescriptorStorageImages" ];
  p.maxPerStageDescriptorInputAttachments = j[ "maxPerStageDescriptorInputAttachments" ];
  p.maxPerStageResources = j[ "maxPerStageResources" ];
  p.maxDescriptorSetSamplers = j[ "maxDescriptorSetSamplers" ];
  p.maxDescriptorSetUniformBuffers = j[ "maxDescriptorSetUniformBuffers" ];
  p.maxDescriptorSetUniformBuffersDynamic = j[ "maxDescriptorSetUniformBuffersDynamic" ];
  p.maxDescriptorSetStorageBuffers = j[ "maxDescriptorSetStorageBuffers" ];
  p.maxDescriptorSetStorageBuffersDynamic = j[ "maxDescriptorSetStorageBuffersDynamic" ];
  p.maxDescriptorSetSampledImages = j[ "maxDescriptorSetSampledImages" ];
  p.maxDescriptorSetStorageImages = j[ "maxDescriptorSetStorageImages" ];
  p.maxDescriptorSetInputAttachments = j[ "maxDescriptorSetInputAttachments" ];
  p.maxVertexInputAttributes = j[ "maxVertexInputAttributes" ];
  p.maxVertexInputBindings = j[ "maxVertexInputBindings" ];
  p.maxVertexInputAttributeOffset = j[ "maxVertexInputAttributeOffset" ];
  p.maxVertexInputBindingStride = j[ "maxVertexInputBindingStride" ];
  p.maxVertexOutputComponents = j[ "maxVertexOutputComponents" ];
  p.maxTessellationGenerationLevel = j[ "maxTessellationGenerationLevel" ];
  p.maxTessellationPatchSize = j[ "maxTessellationPatchSize" ];
  p.maxTessellationControlPerVertexInputComponents = j[ "maxTessellationControlPerVertexInputComponents" ];
  p.maxTessellationControlPerVertexOutputComponents = j[ "maxTessellationControlPerVertexOutputComponents" ];
  p.maxTessellationControlPerPatchOutputComponents = j[ "maxTessellationControlPerPatchOutputComponents" ];
  p.maxTessellationControlTotalOutputComponents = j[ "maxTessellationControlTotalOutputComponents" ];
  p.maxTessellationEvaluationInputComponents = j[ "maxTessellationEvaluationInputComponents" ];
  p.maxTessellationEvaluationOutputComponents = j[ "maxTessellationEvaluationOutputComponents" ];
  p.maxGeometryShaderInvocations = j[ "maxGeometryShaderInvocations" ];
  p.maxGeometryInputComponents = j[ "maxGeometryInputComponents" ];
  p.maxGeometryOutputComponents = j[ "maxGeometryOutputComponents" ];
  p.maxGeometryOutputVertices = j[ "maxGeometryOutputVertices" ];
  p.maxGeometryTotalOutputComponents = j[ "maxGeometryTotalOutputComponents" ];
  p.maxFragmentInputComponents = j[ "maxFragmentInputComponents" ];
  p.maxFragmentOutputAttachments = j[ "maxFragmentOutputAttachments" ];
  p.maxFragmentDualSrcAttachments = j[ "maxFragmentDualSrcAttachments" ];
  p.maxFragmentCombinedOutputResources = j[ "maxFragmentCombinedOutputResources" ];
  p.maxComputeSharedMemorySize = j[ "maxComputeSharedMemorySize" ];
  if( !j[ "maxComputeWorkGroupCount" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceLimits.maxComputeWorkGroupCount" );
  if( !j[ "maxComputeWorkGroupCount" ].size() > p.maxComputeWorkGroupCount.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceLimits.maxComputeWorkGroupCount" );
  std::fill( p.maxComputeWorkGroupCount.begin(), p.maxComputeWorkGroupCount.end(), 0 );
  std::copy( j[ "maxComputeWorkGroupCount" ].begin(), j[ "maxComputeWorkGroupCount" ].end(), p.maxComputeWorkGroupCount.begin() );
  p.maxComputeWorkGroupInvocations = j[ "maxComputeWorkGroupInvocations" ];
  if( !j[ "maxComputeWorkGroupSize" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceLimits.maxComputeWorkGroupSize" );
  if( !j[ "maxComputeWorkGroupSize" ].size() > p.maxComputeWorkGroupSize.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceLimits.maxComputeWorkGroupSize" );
  std::fill( p.maxComputeWorkGroupSize.begin(), p.maxComputeWorkGroupSize.end(), 0 );
  std::copy( j[ "maxComputeWorkGroupSize" ].begin(), j[ "maxComputeWorkGroupSize" ].end(), p.maxComputeWorkGroupSize.begin() );
  p.subPixelPrecisionBits = j[ "subPixelPrecisionBits" ];
  p.subTexelPrecisionBits = j[ "subTexelPrecisionBits" ];
  p.mipmapPrecisionBits = j[ "mipmapPrecisionBits" ];
  p.maxDrawIndexedIndexValue = j[ "maxDrawIndexedIndexValue" ];
  p.maxDrawIndirectCount = j[ "maxDrawIndirectCount" ];
  p.maxSamplerLodBias = j[ "maxSamplerLodBias" ];
  p.maxSamplerAnisotropy = j[ "maxSamplerAnisotropy" ];
  p.maxViewports = j[ "maxViewports" ];
  if( !j[ "maxViewportDimensions" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceLimits.maxViewportDimensions" );
  if( !j[ "maxViewportDimensions" ].size() > p.maxViewportDimensions.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceLimits.maxViewportDimensions" );
  std::fill( p.maxViewportDimensions.begin(), p.maxViewportDimensions.end(), 0 );
  std::copy( j[ "maxViewportDimensions" ].begin(), j[ "maxViewportDimensions" ].end(), p.maxViewportDimensions.begin() );
  if( !j[ "viewportBoundsRange" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceLimits.viewportBoundsRange" );
  if( !j[ "viewportBoundsRange" ].size() > p.viewportBoundsRange.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceLimits.viewportBoundsRange" );
  std::fill( p.viewportBoundsRange.begin(), p.viewportBoundsRange.end(), 0 );
  std::copy( j[ "viewportBoundsRange" ].begin(), j[ "viewportBoundsRange" ].end(), p.viewportBoundsRange.begin() );
  p.viewportSubPixelBits = j[ "viewportSubPixelBits" ];
  p.minMemoryMapAlignment = j[ "minMemoryMapAlignment" ];
  p.minTexelBufferOffsetAlignment = j[ "minTexelBufferOffsetAlignment" ];
  p.minUniformBufferOffsetAlignment = j[ "minUniformBufferOffsetAlignment" ];
  p.minStorageBufferOffsetAlignment = j[ "minStorageBufferOffsetAlignment" ];
  p.minTexelOffset = j[ "minTexelOffset" ];
  p.maxTexelOffset = j[ "maxTexelOffset" ];
  p.minTexelGatherOffset = j[ "minTexelGatherOffset" ];
  p.maxTexelGatherOffset = j[ "maxTexelGatherOffset" ];
  p.minInterpolationOffset = j[ "minInterpolationOffset" ];
  p.maxInterpolationOffset = j[ "maxInterpolationOffset" ];
  p.subPixelInterpolationOffsetBits = j[ "subPixelInterpolationOffsetBits" ];
  p.maxFramebufferWidth = j[ "maxFramebufferWidth" ];
  p.maxFramebufferHeight = j[ "maxFramebufferHeight" ];
  p.maxFramebufferLayers = j[ "maxFramebufferLayers" ];
  p.framebufferColorSampleCounts = j[ "framebufferColorSampleCounts" ];
  p.framebufferDepthSampleCounts = j[ "framebufferDepthSampleCounts" ];
  p.framebufferStencilSampleCounts = j[ "framebufferStencilSampleCounts" ];
  p.framebufferNoAttachmentsSampleCounts = j[ "framebufferNoAttachmentsSampleCounts" ];
  p.maxColorAttachments = j[ "maxColorAttachments" ];
  p.sampledImageColorSampleCounts = j[ "sampledImageColorSampleCounts" ];
  p.sampledImageIntegerSampleCounts = j[ "sampledImageIntegerSampleCounts" ];
  p.sampledImageDepthSampleCounts = j[ "sampledImageDepthSampleCounts" ];
  p.sampledImageStencilSampleCounts = j[ "sampledImageStencilSampleCounts" ];
  p.storageImageSampleCounts = j[ "storageImageSampleCounts" ];
  p.maxSampleMaskWords = j[ "maxSampleMaskWords" ];
  p.timestampComputeAndGraphics = j[ "timestampComputeAndGraphics" ];
  p.timestampPeriod = j[ "timestampPeriod" ];
  p.maxClipDistances = j[ "maxClipDistances" ];
  p.maxCullDistances = j[ "maxCullDistances" ];
  p.maxCombinedClipAndCullDistances = j[ "maxCombinedClipAndCullDistances" ];
  p.discreteQueuePriorities = j[ "discreteQueuePriorities" ];
  if( !j[ "pointSizeRange" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceLimits.pointSizeRange" );
  if( !j[ "pointSizeRange" ].size() > p.pointSizeRange.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceLimits.pointSizeRange" );
  std::fill( p.pointSizeRange.begin(), p.pointSizeRange.end(), 0 );
  std::copy( j[ "pointSizeRange" ].begin(), j[ "pointSizeRange" ].end(), p.pointSizeRange.begin() );
  if( !j[ "lineWidthRange" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceLimits.lineWidthRange" );
  if( !j[ "lineWidthRange" ].size() > p.lineWidthRange.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceLimits.lineWidthRange" );
  std::fill( p.lineWidthRange.begin(), p.lineWidthRange.end(), 0 );
  std::copy( j[ "lineWidthRange" ].begin(), j[ "lineWidthRange" ].end(), p.lineWidthRange.begin() );
  p.pointSizeGranularity = j[ "pointSizeGranularity" ];
  p.lineWidthGranularity = j[ "lineWidthGranularity" ];
  p.strictLines = j[ "strictLines" ];
  p.standardSampleLocations = j[ "standardSampleLocations" ];
  p.optimalBufferCopyOffsetAlignment = j[ "optimalBufferCopyOffsetAlignment" ];
  p.optimalBufferCopyRowPitchAlignment = j[ "optimalBufferCopyRowPitchAlignment" ];
  p.nonCoherentAtomSize = j[ "nonCoherentAtomSize" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceLimits &p ) {
  PhysicalDeviceLimits temp;
  from_json( j, temp );
  p = VkPhysicalDeviceLimits ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceLineRasterizationFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "rectangularLines" ] = bool( p.rectangularLines );
  j[ "bresenhamLines" ] = bool( p.bresenhamLines );
  j[ "smoothLines" ] = bool( p.smoothLines );
  j[ "stippledRectangularLines" ] = bool( p.stippledRectangularLines );
  j[ "stippledBresenhamLines" ] = bool( p.stippledBresenhamLines );
  j[ "stippledSmoothLines" ] = bool( p.stippledSmoothLines );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceLineRasterizationFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceLineRasterizationFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceLineRasterizationFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceLineRasterizationFeaturesEXT" );
  p.rectangularLines = j[ "rectangularLines" ];
  p.bresenhamLines = j[ "bresenhamLines" ];
  p.smoothLines = j[ "smoothLines" ];
  p.stippledRectangularLines = j[ "stippledRectangularLines" ];
  p.stippledBresenhamLines = j[ "stippledBresenhamLines" ];
  p.stippledSmoothLines = j[ "stippledSmoothLines" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceLineRasterizationFeaturesEXT &p ) {
  PhysicalDeviceLineRasterizationFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceLineRasterizationFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceLineRasterizationPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "lineSubPixelPrecisionBits" ] = p.lineSubPixelPrecisionBits;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceLineRasterizationPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceLineRasterizationPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceLineRasterizationPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceLineRasterizationPropertiesEXT" );
  p.lineSubPixelPrecisionBits = j[ "lineSubPixelPrecisionBits" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceLineRasterizationPropertiesEXT &p ) {
  PhysicalDeviceLineRasterizationPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceLineRasterizationPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceMaintenance3Properties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxPerSetDescriptors" ] = p.maxPerSetDescriptors;
  j[ "maxMemoryAllocationSize" ] = p.maxMemoryAllocationSize;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceMaintenance3Properties &p ) {
  to_json( j, PhysicalDeviceMaintenance3Properties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceMaintenance3Properties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMaintenance3Properties" );
  p.maxPerSetDescriptors = j[ "maxPerSetDescriptors" ];
  p.maxMemoryAllocationSize = j[ "maxMemoryAllocationSize" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceMaintenance3Properties &p ) {
  PhysicalDeviceMaintenance3Properties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMaintenance3Properties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceMemoryBudgetPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "heapBudget" ] = nlohmann::json::array();
  std::copy( p.heapBudget.begin(), p.heapBudget.end(), std::back_inserter( j[ "heapBudget" ] ) );
  j[ "heapUsage" ] = nlohmann::json::array();
  std::copy( p.heapUsage.begin(), p.heapUsage.end(), std::back_inserter( j[ "heapUsage" ] ) );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceMemoryBudgetPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceMemoryBudgetPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceMemoryBudgetPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMemoryBudgetPropertiesEXT" );
  if( !j[ "heapBudget" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceMemoryBudgetPropertiesEXT.heapBudget" );
  if( !j[ "heapBudget" ].size() > p.heapBudget.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceMemoryBudgetPropertiesEXT.heapBudget" );
  std::fill( p.heapBudget.begin(), p.heapBudget.end(), 0 );
  std::copy( j[ "heapBudget" ].begin(), j[ "heapBudget" ].end(), p.heapBudget.begin() );
  if( !j[ "heapUsage" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceMemoryBudgetPropertiesEXT.heapUsage" );
  if( !j[ "heapUsage" ].size() > p.heapUsage.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceMemoryBudgetPropertiesEXT.heapUsage" );
  std::fill( p.heapUsage.begin(), p.heapUsage.end(), 0 );
  std::copy( j[ "heapUsage" ].begin(), j[ "heapUsage" ].end(), p.heapUsage.begin() );
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceMemoryBudgetPropertiesEXT &p ) {
  PhysicalDeviceMemoryBudgetPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMemoryBudgetPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceMemoryPriorityFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryPriority" ] = bool( p.memoryPriority );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceMemoryPriorityFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceMemoryPriorityFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceMemoryPriorityFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMemoryPriorityFeaturesEXT" );
  p.memoryPriority = j[ "memoryPriority" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceMemoryPriorityFeaturesEXT &p ) {
  PhysicalDeviceMemoryPriorityFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMemoryPriorityFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceMemoryProperties &p ) {
  j = nlohmann::json::object();
  j[ "memoryTypeCount" ] = p.memoryTypeCount;
  j[ "memoryTypes" ] = nlohmann::json::array();
  std::copy( p.memoryTypes.begin(), p.memoryTypes.end(), std::back_inserter( j[ "memoryTypes" ] ) );
  j[ "memoryHeapCount" ] = p.memoryHeapCount;
  j[ "memoryHeaps" ] = nlohmann::json::array();
  std::copy( p.memoryHeaps.begin(), p.memoryHeaps.end(), std::back_inserter( j[ "memoryHeaps" ] ) );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceMemoryProperties &p ) {
  to_json( j, PhysicalDeviceMemoryProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceMemoryProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMemoryProperties" );
  p.memoryTypeCount = j[ "memoryTypeCount" ];
  if( !j[ "memoryTypes" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceMemoryProperties.memoryTypes" );
  if( !j[ "memoryTypes" ].size() > p.memoryTypes.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for PhysicalDeviceMemoryProperties.memoryTypes" );
  std::fill( p.memoryTypes.begin(), p.memoryTypes.end(), std::remove_cv_t< std::remove_reference_t< decltype( *p.memoryTypes.begin() ) > >() );
  std::copy( j[ "memoryTypes" ].begin(), j[ "memoryTypes" ].end(), p.memoryTypes.begin() );
  p.memoryHeapCount = j[ "memoryHeapCount" ];
  if( !j[ "memoryHeaps" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceMemoryProperties.memoryHeaps" );
  if( !j[ "memoryHeaps" ].size() > p.memoryHeaps.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for PhysicalDeviceMemoryProperties.memoryHeaps" );
  std::fill( p.memoryHeaps.begin(), p.memoryHeaps.end(), std::remove_cv_t< std::remove_reference_t< decltype( *p.memoryHeaps.begin() ) > >() );
  std::copy( j[ "memoryHeaps" ].begin(), j[ "memoryHeaps" ].end(), p.memoryHeaps.begin() );
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceMemoryProperties &p ) {
  PhysicalDeviceMemoryProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMemoryProperties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceMemoryProperties2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryProperties" ] = p.memoryProperties;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceMemoryProperties2 &p ) {
  to_json( j, PhysicalDeviceMemoryProperties2 ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceMemoryProperties2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMemoryProperties2" );
  p.memoryProperties = j[ "memoryProperties" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceMemoryProperties2 &p ) {
  PhysicalDeviceMemoryProperties2 temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMemoryProperties2 ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceMeshShaderFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "taskShader" ] = bool( p.taskShader );
  j[ "meshShader" ] = bool( p.meshShader );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceMeshShaderFeaturesNV &p ) {
  to_json( j, PhysicalDeviceMeshShaderFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceMeshShaderFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMeshShaderFeaturesNV" );
  p.taskShader = j[ "taskShader" ];
  p.meshShader = j[ "meshShader" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceMeshShaderFeaturesNV &p ) {
  PhysicalDeviceMeshShaderFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMeshShaderFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceMeshShaderPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxDrawMeshTasksCount" ] = p.maxDrawMeshTasksCount;
  j[ "maxTaskWorkGroupInvocations" ] = p.maxTaskWorkGroupInvocations;
  j[ "maxTaskWorkGroupSize" ] = nlohmann::json::array();
  std::copy( p.maxTaskWorkGroupSize.begin(), p.maxTaskWorkGroupSize.end(), std::back_inserter( j[ "maxTaskWorkGroupSize" ] ) );
  j[ "maxTaskTotalMemorySize" ] = p.maxTaskTotalMemorySize;
  j[ "maxTaskOutputCount" ] = p.maxTaskOutputCount;
  j[ "maxMeshWorkGroupInvocations" ] = p.maxMeshWorkGroupInvocations;
  j[ "maxMeshWorkGroupSize" ] = nlohmann::json::array();
  std::copy( p.maxMeshWorkGroupSize.begin(), p.maxMeshWorkGroupSize.end(), std::back_inserter( j[ "maxMeshWorkGroupSize" ] ) );
  j[ "maxMeshTotalMemorySize" ] = p.maxMeshTotalMemorySize;
  j[ "maxMeshOutputVertices" ] = p.maxMeshOutputVertices;
  j[ "maxMeshOutputPrimitives" ] = p.maxMeshOutputPrimitives;
  j[ "maxMeshMultiviewViewCount" ] = p.maxMeshMultiviewViewCount;
  j[ "meshOutputPerVertexGranularity" ] = p.meshOutputPerVertexGranularity;
  j[ "meshOutputPerPrimitiveGranularity" ] = p.meshOutputPerPrimitiveGranularity;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceMeshShaderPropertiesNV &p ) {
  to_json( j, PhysicalDeviceMeshShaderPropertiesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceMeshShaderPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMeshShaderPropertiesNV" );
  p.maxDrawMeshTasksCount = j[ "maxDrawMeshTasksCount" ];
  p.maxTaskWorkGroupInvocations = j[ "maxTaskWorkGroupInvocations" ];
  if( !j[ "maxTaskWorkGroupSize" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceMeshShaderPropertiesNV.maxTaskWorkGroupSize" );
  if( !j[ "maxTaskWorkGroupSize" ].size() > p.maxTaskWorkGroupSize.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceMeshShaderPropertiesNV.maxTaskWorkGroupSize" );
  std::fill( p.maxTaskWorkGroupSize.begin(), p.maxTaskWorkGroupSize.end(), 0 );
  std::copy( j[ "maxTaskWorkGroupSize" ].begin(), j[ "maxTaskWorkGroupSize" ].end(), p.maxTaskWorkGroupSize.begin() );
  p.maxTaskTotalMemorySize = j[ "maxTaskTotalMemorySize" ];
  p.maxTaskOutputCount = j[ "maxTaskOutputCount" ];
  p.maxMeshWorkGroupInvocations = j[ "maxMeshWorkGroupInvocations" ];
  if( !j[ "maxMeshWorkGroupSize" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceMeshShaderPropertiesNV.maxMeshWorkGroupSize" );
  if( !j[ "maxMeshWorkGroupSize" ].size() > p.maxMeshWorkGroupSize.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceMeshShaderPropertiesNV.maxMeshWorkGroupSize" );
  std::fill( p.maxMeshWorkGroupSize.begin(), p.maxMeshWorkGroupSize.end(), 0 );
  std::copy( j[ "maxMeshWorkGroupSize" ].begin(), j[ "maxMeshWorkGroupSize" ].end(), p.maxMeshWorkGroupSize.begin() );
  p.maxMeshTotalMemorySize = j[ "maxMeshTotalMemorySize" ];
  p.maxMeshOutputVertices = j[ "maxMeshOutputVertices" ];
  p.maxMeshOutputPrimitives = j[ "maxMeshOutputPrimitives" ];
  p.maxMeshMultiviewViewCount = j[ "maxMeshMultiviewViewCount" ];
  p.meshOutputPerVertexGranularity = j[ "meshOutputPerVertexGranularity" ];
  p.meshOutputPerPrimitiveGranularity = j[ "meshOutputPerPrimitiveGranularity" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceMeshShaderPropertiesNV &p ) {
  PhysicalDeviceMeshShaderPropertiesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMeshShaderPropertiesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceMultiDrawFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "multiDraw" ] = bool( p.multiDraw );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceMultiDrawFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceMultiDrawFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceMultiDrawFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMultiDrawFeaturesEXT" );
  p.multiDraw = j[ "multiDraw" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceMultiDrawFeaturesEXT &p ) {
  PhysicalDeviceMultiDrawFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMultiDrawFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceMultiDrawPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxMultiDrawCount" ] = p.maxMultiDrawCount;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceMultiDrawPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceMultiDrawPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceMultiDrawPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMultiDrawPropertiesEXT" );
  p.maxMultiDrawCount = j[ "maxMultiDrawCount" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceMultiDrawPropertiesEXT &p ) {
  PhysicalDeviceMultiDrawPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMultiDrawPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceMultiviewFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "multiview" ] = bool( p.multiview );
  j[ "multiviewGeometryShader" ] = bool( p.multiviewGeometryShader );
  j[ "multiviewTessellationShader" ] = bool( p.multiviewTessellationShader );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceMultiviewFeatures &p ) {
  to_json( j, PhysicalDeviceMultiviewFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceMultiviewFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMultiviewFeatures" );
  p.multiview = j[ "multiview" ];
  p.multiviewGeometryShader = j[ "multiviewGeometryShader" ];
  p.multiviewTessellationShader = j[ "multiviewTessellationShader" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceMultiviewFeatures &p ) {
  PhysicalDeviceMultiviewFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMultiviewFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "perViewPositionAllComponents" ] = bool( p.perViewPositionAllComponents );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &p ) {
  to_json( j, PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX" );
  p.perViewPositionAllComponents = j[ "perViewPositionAllComponents" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &p ) {
  PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceMultiviewProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxMultiviewViewCount" ] = p.maxMultiviewViewCount;
  j[ "maxMultiviewInstanceIndex" ] = p.maxMultiviewInstanceIndex;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceMultiviewProperties &p ) {
  to_json( j, PhysicalDeviceMultiviewProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceMultiviewProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMultiviewProperties" );
  p.maxMultiviewViewCount = j[ "maxMultiviewViewCount" ];
  p.maxMultiviewInstanceIndex = j[ "maxMultiviewInstanceIndex" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceMultiviewProperties &p ) {
  PhysicalDeviceMultiviewProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMultiviewProperties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceMutableDescriptorTypeFeaturesVALVE &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "mutableDescriptorType" ] = bool( p.mutableDescriptorType );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE &p ) {
  to_json( j, PhysicalDeviceMutableDescriptorTypeFeaturesVALVE ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceMutableDescriptorTypeFeaturesVALVE &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE" );
  p.mutableDescriptorType = j[ "mutableDescriptorType" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE &p ) {
  PhysicalDeviceMutableDescriptorTypeFeaturesVALVE temp;
  from_json( j, temp );
  p = VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDevicePCIBusInfoPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pciDomain" ] = p.pciDomain;
  j[ "pciBus" ] = p.pciBus;
  j[ "pciDevice" ] = p.pciDevice;
  j[ "pciFunction" ] = p.pciFunction;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDevicePCIBusInfoPropertiesEXT &p ) {
  to_json( j, PhysicalDevicePCIBusInfoPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDevicePCIBusInfoPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePCIBusInfoPropertiesEXT" );
  p.pciDomain = j[ "pciDomain" ];
  p.pciBus = j[ "pciBus" ];
  p.pciDevice = j[ "pciDevice" ];
  p.pciFunction = j[ "pciFunction" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDevicePCIBusInfoPropertiesEXT &p ) {
  PhysicalDevicePCIBusInfoPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDevicePCIBusInfoPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDevicePerformanceQueryFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "performanceCounterQueryPools" ] = bool( p.performanceCounterQueryPools );
  j[ "performanceCounterMultipleQueryPools" ] = bool( p.performanceCounterMultipleQueryPools );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDevicePerformanceQueryFeaturesKHR &p ) {
  to_json( j, PhysicalDevicePerformanceQueryFeaturesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDevicePerformanceQueryFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePerformanceQueryFeaturesKHR" );
  p.performanceCounterQueryPools = j[ "performanceCounterQueryPools" ];
  p.performanceCounterMultipleQueryPools = j[ "performanceCounterMultipleQueryPools" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDevicePerformanceQueryFeaturesKHR &p ) {
  PhysicalDevicePerformanceQueryFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDevicePerformanceQueryFeaturesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDevicePerformanceQueryPropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "allowCommandBufferQueryCopies" ] = bool( p.allowCommandBufferQueryCopies );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDevicePerformanceQueryPropertiesKHR &p ) {
  to_json( j, PhysicalDevicePerformanceQueryPropertiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDevicePerformanceQueryPropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePerformanceQueryPropertiesKHR" );
  p.allowCommandBufferQueryCopies = j[ "allowCommandBufferQueryCopies" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDevicePerformanceQueryPropertiesKHR &p ) {
  PhysicalDevicePerformanceQueryPropertiesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDevicePerformanceQueryPropertiesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDevicePipelineCreationCacheControlFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pipelineCreationCacheControl" ] = bool( p.pipelineCreationCacheControl );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT &p ) {
  to_json( j, PhysicalDevicePipelineCreationCacheControlFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDevicePipelineCreationCacheControlFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePipelineCreationCacheControlFeaturesEXT" );
  p.pipelineCreationCacheControl = j[ "pipelineCreationCacheControl" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT &p ) {
  PhysicalDevicePipelineCreationCacheControlFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDevicePipelineExecutablePropertiesFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pipelineExecutableInfo" ] = bool( p.pipelineExecutableInfo );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &p ) {
  to_json( j, PhysicalDevicePipelineExecutablePropertiesFeaturesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDevicePipelineExecutablePropertiesFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR" );
  p.pipelineExecutableInfo = j[ "pipelineExecutableInfo" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &p ) {
  PhysicalDevicePipelineExecutablePropertiesFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDevicePointClippingProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pointClippingBehavior" ] = p.pointClippingBehavior;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDevicePointClippingProperties &p ) {
  to_json( j, PhysicalDevicePointClippingProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDevicePointClippingProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePointClippingProperties" );
  p.pointClippingBehavior = j[ "pointClippingBehavior" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDevicePointClippingProperties &p ) {
  PhysicalDevicePointClippingProperties temp;
  from_json( j, temp );
  p = VkPhysicalDevicePointClippingProperties ( temp );
}

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const PhysicalDevicePortabilitySubsetFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "constantAlphaColorBlendFactors" ] = bool( p.constantAlphaColorBlendFactors );
  j[ "events" ] = bool( p.events );
  j[ "imageViewFormatReinterpretation" ] = bool( p.imageViewFormatReinterpretation );
  j[ "imageViewFormatSwizzle" ] = bool( p.imageViewFormatSwizzle );
  j[ "imageView2DOn3DImage" ] = bool( p.imageView2DOn3DImage );
  j[ "multisampleArrayImage" ] = bool( p.multisampleArrayImage );
  j[ "mutableComparisonSamplers" ] = bool( p.mutableComparisonSamplers );
  j[ "pointPolygons" ] = bool( p.pointPolygons );
  j[ "samplerMipLodBias" ] = bool( p.samplerMipLodBias );
  j[ "separateStencilMaskRef" ] = bool( p.separateStencilMaskRef );
  j[ "shaderSampleRateInterpolationFunctions" ] = bool( p.shaderSampleRateInterpolationFunctions );
  j[ "tessellationIsolines" ] = bool( p.tessellationIsolines );
  j[ "tessellationPointMode" ] = bool( p.tessellationPointMode );
  j[ "triangleFans" ] = bool( p.triangleFans );
  j[ "vertexAttributeAccessBeyondStride" ] = bool( p.vertexAttributeAccessBeyondStride );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDevicePortabilitySubsetFeaturesKHR &p ) {
  to_json( j, PhysicalDevicePortabilitySubsetFeaturesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDevicePortabilitySubsetFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePortabilitySubsetFeaturesKHR" );
  p.constantAlphaColorBlendFactors = j[ "constantAlphaColorBlendFactors" ];
  p.events = j[ "events" ];
  p.imageViewFormatReinterpretation = j[ "imageViewFormatReinterpretation" ];
  p.imageViewFormatSwizzle = j[ "imageViewFormatSwizzle" ];
  p.imageView2DOn3DImage = j[ "imageView2DOn3DImage" ];
  p.multisampleArrayImage = j[ "multisampleArrayImage" ];
  p.mutableComparisonSamplers = j[ "mutableComparisonSamplers" ];
  p.pointPolygons = j[ "pointPolygons" ];
  p.samplerMipLodBias = j[ "samplerMipLodBias" ];
  p.separateStencilMaskRef = j[ "separateStencilMaskRef" ];
  p.shaderSampleRateInterpolationFunctions = j[ "shaderSampleRateInterpolationFunctions" ];
  p.tessellationIsolines = j[ "tessellationIsolines" ];
  p.tessellationPointMode = j[ "tessellationPointMode" ];
  p.triangleFans = j[ "triangleFans" ];
  p.vertexAttributeAccessBeyondStride = j[ "vertexAttributeAccessBeyondStride" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDevicePortabilitySubsetFeaturesKHR &p ) {
  PhysicalDevicePortabilitySubsetFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDevicePortabilitySubsetFeaturesKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const PhysicalDevicePortabilitySubsetPropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "minVertexInputBindingStrideAlignment" ] = p.minVertexInputBindingStrideAlignment;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDevicePortabilitySubsetPropertiesKHR &p ) {
  to_json( j, PhysicalDevicePortabilitySubsetPropertiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDevicePortabilitySubsetPropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePortabilitySubsetPropertiesKHR" );
  p.minVertexInputBindingStrideAlignment = j[ "minVertexInputBindingStrideAlignment" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDevicePortabilitySubsetPropertiesKHR &p ) {
  PhysicalDevicePortabilitySubsetPropertiesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDevicePortabilitySubsetPropertiesKHR ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const PhysicalDevicePrivateDataFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "privateData" ] = bool( p.privateData );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDevicePrivateDataFeaturesEXT &p ) {
  to_json( j, PhysicalDevicePrivateDataFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDevicePrivateDataFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePrivateDataFeaturesEXT" );
  p.privateData = j[ "privateData" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDevicePrivateDataFeaturesEXT &p ) {
  PhysicalDevicePrivateDataFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDevicePrivateDataFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceSparseProperties &p ) {
  j = nlohmann::json::object();
  j[ "residencyStandard2DBlockShape" ] = bool( p.residencyStandard2DBlockShape );
  j[ "residencyStandard2DMultisampleBlockShape" ] = bool( p.residencyStandard2DMultisampleBlockShape );
  j[ "residencyStandard3DBlockShape" ] = bool( p.residencyStandard3DBlockShape );
  j[ "residencyAlignedMipSize" ] = bool( p.residencyAlignedMipSize );
  j[ "residencyNonResidentStrict" ] = bool( p.residencyNonResidentStrict );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceSparseProperties &p ) {
  to_json( j, PhysicalDeviceSparseProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceSparseProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSparseProperties" );
  p.residencyStandard2DBlockShape = j[ "residencyStandard2DBlockShape" ];
  p.residencyStandard2DMultisampleBlockShape = j[ "residencyStandard2DMultisampleBlockShape" ];
  p.residencyStandard3DBlockShape = j[ "residencyStandard3DBlockShape" ];
  p.residencyAlignedMipSize = j[ "residencyAlignedMipSize" ];
  p.residencyNonResidentStrict = j[ "residencyNonResidentStrict" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceSparseProperties &p ) {
  PhysicalDeviceSparseProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSparseProperties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceProperties &p ) {
  j = nlohmann::json::object();
  j[ "apiVersion" ] = p.apiVersion;
  j[ "driverVersion" ] = p.driverVersion;
  j[ "vendorID" ] = p.vendorID;
  j[ "deviceID" ] = p.deviceID;
  j[ "deviceType" ] = p.deviceType;
  j[ "deviceName" ] = std::string( p.deviceName.begin(), std::find( p.deviceName.begin(), p.deviceName.end(), '\0' ) );
  j[ "pipelineCacheUUID" ] = nlohmann::json::array();
  std::copy( p.pipelineCacheUUID.begin(), p.pipelineCacheUUID.end(), std::back_inserter( j[ "pipelineCacheUUID" ] ) );
  j[ "limits" ] = p.limits;
  j[ "sparseProperties" ] = p.sparseProperties;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceProperties &p ) {
  to_json( j, PhysicalDeviceProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceProperties" );
  p.apiVersion = j[ "apiVersion" ];
  p.driverVersion = j[ "driverVersion" ];
  p.vendorID = j[ "vendorID" ];
  p.deviceID = j[ "deviceID" ];
  p.deviceType = j[ "deviceType" ];
  {
    std::string s = j[ "deviceName" ];
    if( !p.deviceName.empty() ) {
      p.deviceName[ p.deviceName.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.deviceName.size() - 1u ) ), p.deviceName.begin() );
    }
  }
  if( !j[ "pipelineCacheUUID" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceProperties.pipelineCacheUUID" );
  if( !j[ "pipelineCacheUUID" ].size() > p.pipelineCacheUUID.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceProperties.pipelineCacheUUID" );
  std::fill( p.pipelineCacheUUID.begin(), p.pipelineCacheUUID.end(), 0 );
  std::copy( j[ "pipelineCacheUUID" ].begin(), j[ "pipelineCacheUUID" ].end(), p.pipelineCacheUUID.begin() );
  p.limits = j[ "limits" ];
  p.sparseProperties = j[ "sparseProperties" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceProperties &p ) {
  PhysicalDeviceProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceProperties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceProperties2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "properties" ] = p.properties;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceProperties2 &p ) {
  to_json( j, PhysicalDeviceProperties2 ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceProperties2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceProperties2" );
  p.properties = j[ "properties" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceProperties2 &p ) {
  PhysicalDeviceProperties2 temp;
  from_json( j, temp );
  p = VkPhysicalDeviceProperties2 ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceProtectedMemoryFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "protectedMemory" ] = bool( p.protectedMemory );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceProtectedMemoryFeatures &p ) {
  to_json( j, PhysicalDeviceProtectedMemoryFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceProtectedMemoryFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceProtectedMemoryFeatures" );
  p.protectedMemory = j[ "protectedMemory" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceProtectedMemoryFeatures &p ) {
  PhysicalDeviceProtectedMemoryFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceProtectedMemoryFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceProtectedMemoryProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "protectedNoFault" ] = bool( p.protectedNoFault );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceProtectedMemoryProperties &p ) {
  to_json( j, PhysicalDeviceProtectedMemoryProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceProtectedMemoryProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceProtectedMemoryProperties" );
  p.protectedNoFault = j[ "protectedNoFault" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceProtectedMemoryProperties &p ) {
  PhysicalDeviceProtectedMemoryProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceProtectedMemoryProperties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceProvokingVertexFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "provokingVertexLast" ] = bool( p.provokingVertexLast );
  j[ "transformFeedbackPreservesProvokingVertex" ] = bool( p.transformFeedbackPreservesProvokingVertex );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceProvokingVertexFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceProvokingVertexFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceProvokingVertexFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceProvokingVertexFeaturesEXT" );
  p.provokingVertexLast = j[ "provokingVertexLast" ];
  p.transformFeedbackPreservesProvokingVertex = j[ "transformFeedbackPreservesProvokingVertex" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceProvokingVertexFeaturesEXT &p ) {
  PhysicalDeviceProvokingVertexFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceProvokingVertexFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceProvokingVertexPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "provokingVertexModePerPipeline" ] = bool( p.provokingVertexModePerPipeline );
  j[ "transformFeedbackPreservesTriangleFanProvokingVertex" ] = bool( p.transformFeedbackPreservesTriangleFanProvokingVertex );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceProvokingVertexPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceProvokingVertexPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceProvokingVertexPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceProvokingVertexPropertiesEXT" );
  p.provokingVertexModePerPipeline = j[ "provokingVertexModePerPipeline" ];
  p.transformFeedbackPreservesTriangleFanProvokingVertex = j[ "transformFeedbackPreservesTriangleFanProvokingVertex" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceProvokingVertexPropertiesEXT &p ) {
  PhysicalDeviceProvokingVertexPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceProvokingVertexPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDevicePushDescriptorPropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxPushDescriptors" ] = p.maxPushDescriptors;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDevicePushDescriptorPropertiesKHR &p ) {
  to_json( j, PhysicalDevicePushDescriptorPropertiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDevicePushDescriptorPropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDevicePushDescriptorPropertiesKHR" );
  p.maxPushDescriptors = j[ "maxPushDescriptors" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDevicePushDescriptorPropertiesKHR &p ) {
  PhysicalDevicePushDescriptorPropertiesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDevicePushDescriptorPropertiesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceRayQueryFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "rayQuery" ] = bool( p.rayQuery );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceRayQueryFeaturesKHR &p ) {
  to_json( j, PhysicalDeviceRayQueryFeaturesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceRayQueryFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRayQueryFeaturesKHR" );
  p.rayQuery = j[ "rayQuery" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceRayQueryFeaturesKHR &p ) {
  PhysicalDeviceRayQueryFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRayQueryFeaturesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceRayTracingMotionBlurFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "rayTracingMotionBlur" ] = bool( p.rayTracingMotionBlur );
  j[ "rayTracingMotionBlurPipelineTraceRaysIndirect" ] = bool( p.rayTracingMotionBlurPipelineTraceRaysIndirect );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV &p ) {
  to_json( j, PhysicalDeviceRayTracingMotionBlurFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceRayTracingMotionBlurFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRayTracingMotionBlurFeaturesNV" );
  p.rayTracingMotionBlur = j[ "rayTracingMotionBlur" ];
  p.rayTracingMotionBlurPipelineTraceRaysIndirect = j[ "rayTracingMotionBlurPipelineTraceRaysIndirect" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceRayTracingMotionBlurFeaturesNV &p ) {
  PhysicalDeviceRayTracingMotionBlurFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRayTracingMotionBlurFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceRayTracingPipelineFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "rayTracingPipeline" ] = bool( p.rayTracingPipeline );
  j[ "rayTracingPipelineShaderGroupHandleCaptureReplay" ] = bool( p.rayTracingPipelineShaderGroupHandleCaptureReplay );
  j[ "rayTracingPipelineShaderGroupHandleCaptureReplayMixed" ] = bool( p.rayTracingPipelineShaderGroupHandleCaptureReplayMixed );
  j[ "rayTracingPipelineTraceRaysIndirect" ] = bool( p.rayTracingPipelineTraceRaysIndirect );
  j[ "rayTraversalPrimitiveCulling" ] = bool( p.rayTraversalPrimitiveCulling );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceRayTracingPipelineFeaturesKHR &p ) {
  to_json( j, PhysicalDeviceRayTracingPipelineFeaturesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceRayTracingPipelineFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRayTracingPipelineFeaturesKHR" );
  p.rayTracingPipeline = j[ "rayTracingPipeline" ];
  p.rayTracingPipelineShaderGroupHandleCaptureReplay = j[ "rayTracingPipelineShaderGroupHandleCaptureReplay" ];
  p.rayTracingPipelineShaderGroupHandleCaptureReplayMixed = j[ "rayTracingPipelineShaderGroupHandleCaptureReplayMixed" ];
  p.rayTracingPipelineTraceRaysIndirect = j[ "rayTracingPipelineTraceRaysIndirect" ];
  p.rayTraversalPrimitiveCulling = j[ "rayTraversalPrimitiveCulling" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceRayTracingPipelineFeaturesKHR &p ) {
  PhysicalDeviceRayTracingPipelineFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRayTracingPipelineFeaturesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceRayTracingPipelinePropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderGroupHandleSize" ] = p.shaderGroupHandleSize;
  j[ "maxRayRecursionDepth" ] = p.maxRayRecursionDepth;
  j[ "maxShaderGroupStride" ] = p.maxShaderGroupStride;
  j[ "shaderGroupBaseAlignment" ] = p.shaderGroupBaseAlignment;
  j[ "shaderGroupHandleCaptureReplaySize" ] = p.shaderGroupHandleCaptureReplaySize;
  j[ "maxRayDispatchInvocationCount" ] = p.maxRayDispatchInvocationCount;
  j[ "shaderGroupHandleAlignment" ] = p.shaderGroupHandleAlignment;
  j[ "maxRayHitAttributeSize" ] = p.maxRayHitAttributeSize;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceRayTracingPipelinePropertiesKHR &p ) {
  to_json( j, PhysicalDeviceRayTracingPipelinePropertiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceRayTracingPipelinePropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRayTracingPipelinePropertiesKHR" );
  p.shaderGroupHandleSize = j[ "shaderGroupHandleSize" ];
  p.maxRayRecursionDepth = j[ "maxRayRecursionDepth" ];
  p.maxShaderGroupStride = j[ "maxShaderGroupStride" ];
  p.shaderGroupBaseAlignment = j[ "shaderGroupBaseAlignment" ];
  p.shaderGroupHandleCaptureReplaySize = j[ "shaderGroupHandleCaptureReplaySize" ];
  p.maxRayDispatchInvocationCount = j[ "maxRayDispatchInvocationCount" ];
  p.shaderGroupHandleAlignment = j[ "shaderGroupHandleAlignment" ];
  p.maxRayHitAttributeSize = j[ "maxRayHitAttributeSize" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceRayTracingPipelinePropertiesKHR &p ) {
  PhysicalDeviceRayTracingPipelinePropertiesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRayTracingPipelinePropertiesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceRayTracingPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderGroupHandleSize" ] = p.shaderGroupHandleSize;
  j[ "maxRecursionDepth" ] = p.maxRecursionDepth;
  j[ "maxShaderGroupStride" ] = p.maxShaderGroupStride;
  j[ "shaderGroupBaseAlignment" ] = p.shaderGroupBaseAlignment;
  j[ "maxGeometryCount" ] = p.maxGeometryCount;
  j[ "maxInstanceCount" ] = p.maxInstanceCount;
  j[ "maxTriangleCount" ] = p.maxTriangleCount;
  j[ "maxDescriptorSetAccelerationStructures" ] = p.maxDescriptorSetAccelerationStructures;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceRayTracingPropertiesNV &p ) {
  to_json( j, PhysicalDeviceRayTracingPropertiesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceRayTracingPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRayTracingPropertiesNV" );
  p.shaderGroupHandleSize = j[ "shaderGroupHandleSize" ];
  p.maxRecursionDepth = j[ "maxRecursionDepth" ];
  p.maxShaderGroupStride = j[ "maxShaderGroupStride" ];
  p.shaderGroupBaseAlignment = j[ "shaderGroupBaseAlignment" ];
  p.maxGeometryCount = j[ "maxGeometryCount" ];
  p.maxInstanceCount = j[ "maxInstanceCount" ];
  p.maxTriangleCount = j[ "maxTriangleCount" ];
  p.maxDescriptorSetAccelerationStructures = j[ "maxDescriptorSetAccelerationStructures" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceRayTracingPropertiesNV &p ) {
  PhysicalDeviceRayTracingPropertiesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRayTracingPropertiesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceRepresentativeFragmentTestFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "representativeFragmentTest" ] = bool( p.representativeFragmentTest );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV &p ) {
  to_json( j, PhysicalDeviceRepresentativeFragmentTestFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceRepresentativeFragmentTestFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRepresentativeFragmentTestFeaturesNV" );
  p.representativeFragmentTest = j[ "representativeFragmentTest" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV &p ) {
  PhysicalDeviceRepresentativeFragmentTestFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceRobustness2FeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "robustBufferAccess2" ] = bool( p.robustBufferAccess2 );
  j[ "robustImageAccess2" ] = bool( p.robustImageAccess2 );
  j[ "nullDescriptor" ] = bool( p.nullDescriptor );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceRobustness2FeaturesEXT &p ) {
  to_json( j, PhysicalDeviceRobustness2FeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceRobustness2FeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRobustness2FeaturesEXT" );
  p.robustBufferAccess2 = j[ "robustBufferAccess2" ];
  p.robustImageAccess2 = j[ "robustImageAccess2" ];
  p.nullDescriptor = j[ "nullDescriptor" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceRobustness2FeaturesEXT &p ) {
  PhysicalDeviceRobustness2FeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRobustness2FeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceRobustness2PropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "robustStorageBufferAccessSizeAlignment" ] = p.robustStorageBufferAccessSizeAlignment;
  j[ "robustUniformBufferAccessSizeAlignment" ] = p.robustUniformBufferAccessSizeAlignment;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceRobustness2PropertiesEXT &p ) {
  to_json( j, PhysicalDeviceRobustness2PropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceRobustness2PropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceRobustness2PropertiesEXT" );
  p.robustStorageBufferAccessSizeAlignment = j[ "robustStorageBufferAccessSizeAlignment" ];
  p.robustUniformBufferAccessSizeAlignment = j[ "robustUniformBufferAccessSizeAlignment" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceRobustness2PropertiesEXT &p ) {
  PhysicalDeviceRobustness2PropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceRobustness2PropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceSampleLocationsPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "sampleLocationSampleCounts" ] = p.sampleLocationSampleCounts;
  j[ "maxSampleLocationGridSize" ] = p.maxSampleLocationGridSize;
  j[ "sampleLocationCoordinateRange" ] = nlohmann::json::array();
  std::copy( p.sampleLocationCoordinateRange.begin(), p.sampleLocationCoordinateRange.end(), std::back_inserter( j[ "sampleLocationCoordinateRange" ] ) );
  j[ "sampleLocationSubPixelBits" ] = p.sampleLocationSubPixelBits;
  j[ "variableSampleLocations" ] = bool( p.variableSampleLocations );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceSampleLocationsPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceSampleLocationsPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceSampleLocationsPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSampleLocationsPropertiesEXT" );
  p.sampleLocationSampleCounts = j[ "sampleLocationSampleCounts" ];
  p.maxSampleLocationGridSize = j[ "maxSampleLocationGridSize" ];
  if( !j[ "sampleLocationCoordinateRange" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceSampleLocationsPropertiesEXT.sampleLocationCoordinateRange" );
  if( !j[ "sampleLocationCoordinateRange" ].size() > p.sampleLocationCoordinateRange.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceSampleLocationsPropertiesEXT.sampleLocationCoordinateRange" );
  std::fill( p.sampleLocationCoordinateRange.begin(), p.sampleLocationCoordinateRange.end(), 0 );
  std::copy( j[ "sampleLocationCoordinateRange" ].begin(), j[ "sampleLocationCoordinateRange" ].end(), p.sampleLocationCoordinateRange.begin() );
  p.sampleLocationSubPixelBits = j[ "sampleLocationSubPixelBits" ];
  p.variableSampleLocations = j[ "variableSampleLocations" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceSampleLocationsPropertiesEXT &p ) {
  PhysicalDeviceSampleLocationsPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSampleLocationsPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceSamplerFilterMinmaxProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "filterMinmaxSingleComponentFormats" ] = bool( p.filterMinmaxSingleComponentFormats );
  j[ "filterMinmaxImageComponentMapping" ] = bool( p.filterMinmaxImageComponentMapping );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceSamplerFilterMinmaxProperties &p ) {
  to_json( j, PhysicalDeviceSamplerFilterMinmaxProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceSamplerFilterMinmaxProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSamplerFilterMinmaxProperties" );
  p.filterMinmaxSingleComponentFormats = j[ "filterMinmaxSingleComponentFormats" ];
  p.filterMinmaxImageComponentMapping = j[ "filterMinmaxImageComponentMapping" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceSamplerFilterMinmaxProperties &p ) {
  PhysicalDeviceSamplerFilterMinmaxProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSamplerFilterMinmaxProperties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceSamplerYcbcrConversionFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "samplerYcbcrConversion" ] = bool( p.samplerYcbcrConversion );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceSamplerYcbcrConversionFeatures &p ) {
  to_json( j, PhysicalDeviceSamplerYcbcrConversionFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceSamplerYcbcrConversionFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSamplerYcbcrConversionFeatures" );
  p.samplerYcbcrConversion = j[ "samplerYcbcrConversion" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceSamplerYcbcrConversionFeatures &p ) {
  PhysicalDeviceSamplerYcbcrConversionFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSamplerYcbcrConversionFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceScalarBlockLayoutFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "scalarBlockLayout" ] = bool( p.scalarBlockLayout );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceScalarBlockLayoutFeatures &p ) {
  to_json( j, PhysicalDeviceScalarBlockLayoutFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceScalarBlockLayoutFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceScalarBlockLayoutFeatures" );
  p.scalarBlockLayout = j[ "scalarBlockLayout" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceScalarBlockLayoutFeatures &p ) {
  PhysicalDeviceScalarBlockLayoutFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceScalarBlockLayoutFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceSeparateDepthStencilLayoutsFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "separateDepthStencilLayouts" ] = bool( p.separateDepthStencilLayouts );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures &p ) {
  to_json( j, PhysicalDeviceSeparateDepthStencilLayoutsFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceSeparateDepthStencilLayoutsFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSeparateDepthStencilLayoutsFeatures" );
  p.separateDepthStencilLayouts = j[ "separateDepthStencilLayouts" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures &p ) {
  PhysicalDeviceSeparateDepthStencilLayoutsFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderAtomicFloatFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderBufferFloat32Atomics" ] = bool( p.shaderBufferFloat32Atomics );
  j[ "shaderBufferFloat32AtomicAdd" ] = bool( p.shaderBufferFloat32AtomicAdd );
  j[ "shaderBufferFloat64Atomics" ] = bool( p.shaderBufferFloat64Atomics );
  j[ "shaderBufferFloat64AtomicAdd" ] = bool( p.shaderBufferFloat64AtomicAdd );
  j[ "shaderSharedFloat32Atomics" ] = bool( p.shaderSharedFloat32Atomics );
  j[ "shaderSharedFloat32AtomicAdd" ] = bool( p.shaderSharedFloat32AtomicAdd );
  j[ "shaderSharedFloat64Atomics" ] = bool( p.shaderSharedFloat64Atomics );
  j[ "shaderSharedFloat64AtomicAdd" ] = bool( p.shaderSharedFloat64AtomicAdd );
  j[ "shaderImageFloat32Atomics" ] = bool( p.shaderImageFloat32Atomics );
  j[ "shaderImageFloat32AtomicAdd" ] = bool( p.shaderImageFloat32AtomicAdd );
  j[ "sparseImageFloat32Atomics" ] = bool( p.sparseImageFloat32Atomics );
  j[ "sparseImageFloat32AtomicAdd" ] = bool( p.sparseImageFloat32AtomicAdd );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceShaderAtomicFloatFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderAtomicFloatFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderAtomicFloatFeaturesEXT" );
  p.shaderBufferFloat32Atomics = j[ "shaderBufferFloat32Atomics" ];
  p.shaderBufferFloat32AtomicAdd = j[ "shaderBufferFloat32AtomicAdd" ];
  p.shaderBufferFloat64Atomics = j[ "shaderBufferFloat64Atomics" ];
  p.shaderBufferFloat64AtomicAdd = j[ "shaderBufferFloat64AtomicAdd" ];
  p.shaderSharedFloat32Atomics = j[ "shaderSharedFloat32Atomics" ];
  p.shaderSharedFloat32AtomicAdd = j[ "shaderSharedFloat32AtomicAdd" ];
  p.shaderSharedFloat64Atomics = j[ "shaderSharedFloat64Atomics" ];
  p.shaderSharedFloat64AtomicAdd = j[ "shaderSharedFloat64AtomicAdd" ];
  p.shaderImageFloat32Atomics = j[ "shaderImageFloat32Atomics" ];
  p.shaderImageFloat32AtomicAdd = j[ "shaderImageFloat32AtomicAdd" ];
  p.sparseImageFloat32Atomics = j[ "sparseImageFloat32Atomics" ];
  p.sparseImageFloat32AtomicAdd = j[ "sparseImageFloat32AtomicAdd" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT &p ) {
  PhysicalDeviceShaderAtomicFloatFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderAtomicFloatFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderAtomicInt64Features &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderBufferInt64Atomics" ] = bool( p.shaderBufferInt64Atomics );
  j[ "shaderSharedInt64Atomics" ] = bool( p.shaderSharedInt64Atomics );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderAtomicInt64Features &p ) {
  to_json( j, PhysicalDeviceShaderAtomicInt64Features ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderAtomicInt64Features &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderAtomicInt64Features" );
  p.shaderBufferInt64Atomics = j[ "shaderBufferInt64Atomics" ];
  p.shaderSharedInt64Atomics = j[ "shaderSharedInt64Atomics" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderAtomicInt64Features &p ) {
  PhysicalDeviceShaderAtomicInt64Features temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderAtomicInt64Features ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderClockFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderSubgroupClock" ] = bool( p.shaderSubgroupClock );
  j[ "shaderDeviceClock" ] = bool( p.shaderDeviceClock );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderClockFeaturesKHR &p ) {
  to_json( j, PhysicalDeviceShaderClockFeaturesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderClockFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderClockFeaturesKHR" );
  p.shaderSubgroupClock = j[ "shaderSubgroupClock" ];
  p.shaderDeviceClock = j[ "shaderDeviceClock" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderClockFeaturesKHR &p ) {
  PhysicalDeviceShaderClockFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderClockFeaturesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderCoreProperties2AMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderCoreFeatures" ] = p.shaderCoreFeatures;
  j[ "activeComputeUnitCount" ] = p.activeComputeUnitCount;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderCoreProperties2AMD &p ) {
  to_json( j, PhysicalDeviceShaderCoreProperties2AMD ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderCoreProperties2AMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderCoreProperties2AMD" );
  p.shaderCoreFeatures = j[ "shaderCoreFeatures" ];
  p.activeComputeUnitCount = j[ "activeComputeUnitCount" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderCoreProperties2AMD &p ) {
  PhysicalDeviceShaderCoreProperties2AMD temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderCoreProperties2AMD ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderCorePropertiesAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderEngineCount" ] = p.shaderEngineCount;
  j[ "shaderArraysPerEngineCount" ] = p.shaderArraysPerEngineCount;
  j[ "computeUnitsPerShaderArray" ] = p.computeUnitsPerShaderArray;
  j[ "simdPerComputeUnit" ] = p.simdPerComputeUnit;
  j[ "wavefrontsPerSimd" ] = p.wavefrontsPerSimd;
  j[ "wavefrontSize" ] = p.wavefrontSize;
  j[ "sgprsPerSimd" ] = p.sgprsPerSimd;
  j[ "minSgprAllocation" ] = p.minSgprAllocation;
  j[ "maxSgprAllocation" ] = p.maxSgprAllocation;
  j[ "sgprAllocationGranularity" ] = p.sgprAllocationGranularity;
  j[ "vgprsPerSimd" ] = p.vgprsPerSimd;
  j[ "minVgprAllocation" ] = p.minVgprAllocation;
  j[ "maxVgprAllocation" ] = p.maxVgprAllocation;
  j[ "vgprAllocationGranularity" ] = p.vgprAllocationGranularity;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderCorePropertiesAMD &p ) {
  to_json( j, PhysicalDeviceShaderCorePropertiesAMD ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderCorePropertiesAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderCorePropertiesAMD" );
  p.shaderEngineCount = j[ "shaderEngineCount" ];
  p.shaderArraysPerEngineCount = j[ "shaderArraysPerEngineCount" ];
  p.computeUnitsPerShaderArray = j[ "computeUnitsPerShaderArray" ];
  p.simdPerComputeUnit = j[ "simdPerComputeUnit" ];
  p.wavefrontsPerSimd = j[ "wavefrontsPerSimd" ];
  p.wavefrontSize = j[ "wavefrontSize" ];
  p.sgprsPerSimd = j[ "sgprsPerSimd" ];
  p.minSgprAllocation = j[ "minSgprAllocation" ];
  p.maxSgprAllocation = j[ "maxSgprAllocation" ];
  p.sgprAllocationGranularity = j[ "sgprAllocationGranularity" ];
  p.vgprsPerSimd = j[ "vgprsPerSimd" ];
  p.minVgprAllocation = j[ "minVgprAllocation" ];
  p.maxVgprAllocation = j[ "maxVgprAllocation" ];
  p.vgprAllocationGranularity = j[ "vgprAllocationGranularity" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderCorePropertiesAMD &p ) {
  PhysicalDeviceShaderCorePropertiesAMD temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderCorePropertiesAMD ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderDemoteToHelperInvocation" ] = bool( p.shaderDemoteToHelperInvocation );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT" );
  p.shaderDemoteToHelperInvocation = j[ "shaderDemoteToHelperInvocation" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &p ) {
  PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderDrawParametersFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderDrawParameters" ] = bool( p.shaderDrawParameters );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderDrawParametersFeatures &p ) {
  to_json( j, PhysicalDeviceShaderDrawParametersFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderDrawParametersFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderDrawParametersFeatures" );
  p.shaderDrawParameters = j[ "shaderDrawParameters" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderDrawParametersFeatures &p ) {
  PhysicalDeviceShaderDrawParametersFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderDrawParametersFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderFloat16Int8Features &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderFloat16" ] = bool( p.shaderFloat16 );
  j[ "shaderInt8" ] = bool( p.shaderInt8 );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderFloat16Int8Features &p ) {
  to_json( j, PhysicalDeviceShaderFloat16Int8Features ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderFloat16Int8Features &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderFloat16Int8Features" );
  p.shaderFloat16 = j[ "shaderFloat16" ];
  p.shaderInt8 = j[ "shaderInt8" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderFloat16Int8Features &p ) {
  PhysicalDeviceShaderFloat16Int8Features temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderFloat16Int8Features ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderImageAtomicInt64FeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderImageInt64Atomics" ] = bool( p.shaderImageInt64Atomics );
  j[ "sparseImageInt64Atomics" ] = bool( p.sparseImageInt64Atomics );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT &p ) {
  to_json( j, PhysicalDeviceShaderImageAtomicInt64FeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderImageAtomicInt64FeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT" );
  p.shaderImageInt64Atomics = j[ "shaderImageInt64Atomics" ];
  p.sparseImageInt64Atomics = j[ "sparseImageInt64Atomics" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT &p ) {
  PhysicalDeviceShaderImageAtomicInt64FeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderImageFootprintFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "imageFootprint" ] = bool( p.imageFootprint );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderImageFootprintFeaturesNV &p ) {
  to_json( j, PhysicalDeviceShaderImageFootprintFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderImageFootprintFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderImageFootprintFeaturesNV" );
  p.imageFootprint = j[ "imageFootprint" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderImageFootprintFeaturesNV &p ) {
  PhysicalDeviceShaderImageFootprintFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderImageFootprintFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderIntegerFunctions2" ] = bool( p.shaderIntegerFunctions2 );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &p ) {
  to_json( j, PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL" );
  p.shaderIntegerFunctions2 = j[ "shaderIntegerFunctions2" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &p ) {
  PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderSMBuiltinsFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderSMBuiltins" ] = bool( p.shaderSMBuiltins );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV &p ) {
  to_json( j, PhysicalDeviceShaderSMBuiltinsFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderSMBuiltinsFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderSMBuiltinsFeaturesNV" );
  p.shaderSMBuiltins = j[ "shaderSMBuiltins" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV &p ) {
  PhysicalDeviceShaderSMBuiltinsFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderSMBuiltinsFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderSMBuiltinsPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderSMCount" ] = p.shaderSMCount;
  j[ "shaderWarpsPerSM" ] = p.shaderWarpsPerSM;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV &p ) {
  to_json( j, PhysicalDeviceShaderSMBuiltinsPropertiesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderSMBuiltinsPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderSMBuiltinsPropertiesNV" );
  p.shaderSMCount = j[ "shaderSMCount" ];
  p.shaderWarpsPerSM = j[ "shaderWarpsPerSM" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV &p ) {
  PhysicalDeviceShaderSMBuiltinsPropertiesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderSMBuiltinsPropertiesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderSubgroupExtendedTypesFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderSubgroupExtendedTypes" ] = bool( p.shaderSubgroupExtendedTypes );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures &p ) {
  to_json( j, PhysicalDeviceShaderSubgroupExtendedTypesFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderSubgroupExtendedTypesFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderSubgroupExtendedTypesFeatures" );
  p.shaderSubgroupExtendedTypes = j[ "shaderSubgroupExtendedTypes" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures &p ) {
  PhysicalDeviceShaderSubgroupExtendedTypesFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderSubgroupUniformControlFlow" ] = bool( p.shaderSubgroupUniformControlFlow );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR &p ) {
  to_json( j, PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR" );
  p.shaderSubgroupUniformControlFlow = j[ "shaderSubgroupUniformControlFlow" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR &p ) {
  PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShaderTerminateInvocationFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderTerminateInvocation" ] = bool( p.shaderTerminateInvocation );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR &p ) {
  to_json( j, PhysicalDeviceShaderTerminateInvocationFeaturesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShaderTerminateInvocationFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShaderTerminateInvocationFeaturesKHR" );
  p.shaderTerminateInvocation = j[ "shaderTerminateInvocation" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR &p ) {
  PhysicalDeviceShaderTerminateInvocationFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShadingRateImageFeaturesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shadingRateImage" ] = bool( p.shadingRateImage );
  j[ "shadingRateCoarseSampleOrder" ] = bool( p.shadingRateCoarseSampleOrder );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShadingRateImageFeaturesNV &p ) {
  to_json( j, PhysicalDeviceShadingRateImageFeaturesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShadingRateImageFeaturesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShadingRateImageFeaturesNV" );
  p.shadingRateImage = j[ "shadingRateImage" ];
  p.shadingRateCoarseSampleOrder = j[ "shadingRateCoarseSampleOrder" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShadingRateImageFeaturesNV &p ) {
  PhysicalDeviceShadingRateImageFeaturesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShadingRateImageFeaturesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceShadingRateImagePropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shadingRateTexelSize" ] = p.shadingRateTexelSize;
  j[ "shadingRatePaletteSize" ] = p.shadingRatePaletteSize;
  j[ "shadingRateMaxCoarseSamples" ] = p.shadingRateMaxCoarseSamples;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceShadingRateImagePropertiesNV &p ) {
  to_json( j, PhysicalDeviceShadingRateImagePropertiesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceShadingRateImagePropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceShadingRateImagePropertiesNV" );
  p.shadingRateTexelSize = j[ "shadingRateTexelSize" ];
  p.shadingRatePaletteSize = j[ "shadingRatePaletteSize" ];
  p.shadingRateMaxCoarseSamples = j[ "shadingRateMaxCoarseSamples" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceShadingRateImagePropertiesNV &p ) {
  PhysicalDeviceShadingRateImagePropertiesNV temp;
  from_json( j, temp );
  p = VkPhysicalDeviceShadingRateImagePropertiesNV ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceSparseImageFormatInfo2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "format" ] = p.format;
  j[ "type" ] = p.type;
  j[ "samples" ] = p.samples;
  j[ "usage" ] = p.usage;
  j[ "tiling" ] = p.tiling;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceSparseImageFormatInfo2 &p ) {
  to_json( j, PhysicalDeviceSparseImageFormatInfo2 ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceSparseImageFormatInfo2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSparseImageFormatInfo2" );
  p.format = j[ "format" ];
  p.type = j[ "type" ];
  p.samples = j[ "samples" ];
  p.usage = j[ "usage" ];
  p.tiling = j[ "tiling" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceSparseImageFormatInfo2 &p ) {
  PhysicalDeviceSparseImageFormatInfo2 temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSparseImageFormatInfo2 ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceSubgroupProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "subgroupSize" ] = p.subgroupSize;
  j[ "supportedStages" ] = p.supportedStages;
  j[ "supportedOperations" ] = p.supportedOperations;
  j[ "quadOperationsInAllStages" ] = bool( p.quadOperationsInAllStages );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceSubgroupProperties &p ) {
  to_json( j, PhysicalDeviceSubgroupProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceSubgroupProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSubgroupProperties" );
  p.subgroupSize = j[ "subgroupSize" ];
  p.supportedStages = j[ "supportedStages" ];
  p.supportedOperations = j[ "supportedOperations" ];
  p.quadOperationsInAllStages = j[ "quadOperationsInAllStages" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceSubgroupProperties &p ) {
  PhysicalDeviceSubgroupProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSubgroupProperties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceSubgroupSizeControlFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "subgroupSizeControl" ] = bool( p.subgroupSizeControl );
  j[ "computeFullSubgroups" ] = bool( p.computeFullSubgroups );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceSubgroupSizeControlFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceSubgroupSizeControlFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSubgroupSizeControlFeaturesEXT" );
  p.subgroupSizeControl = j[ "subgroupSizeControl" ];
  p.computeFullSubgroups = j[ "computeFullSubgroups" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceSubgroupSizeControlFeaturesEXT &p ) {
  PhysicalDeviceSubgroupSizeControlFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSubgroupSizeControlFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceSubgroupSizeControlPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "minSubgroupSize" ] = p.minSubgroupSize;
  j[ "maxSubgroupSize" ] = p.maxSubgroupSize;
  j[ "maxComputeWorkgroupSubgroups" ] = p.maxComputeWorkgroupSubgroups;
  j[ "requiredSubgroupSizeStages" ] = p.requiredSubgroupSizeStages;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceSubgroupSizeControlPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceSubgroupSizeControlPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSubgroupSizeControlPropertiesEXT" );
  p.minSubgroupSize = j[ "minSubgroupSize" ];
  p.maxSubgroupSize = j[ "maxSubgroupSize" ];
  p.maxComputeWorkgroupSubgroups = j[ "maxComputeWorkgroupSubgroups" ];
  p.requiredSubgroupSizeStages = j[ "requiredSubgroupSizeStages" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceSubgroupSizeControlPropertiesEXT &p ) {
  PhysicalDeviceSubgroupSizeControlPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSubgroupSizeControlPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceSubpassShadingFeaturesHUAWEI &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "subpassShading" ] = bool( p.subpassShading );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI &p ) {
  to_json( j, PhysicalDeviceSubpassShadingFeaturesHUAWEI ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceSubpassShadingFeaturesHUAWEI &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSubpassShadingFeaturesHUAWEI" );
  p.subpassShading = j[ "subpassShading" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceSubpassShadingFeaturesHUAWEI &p ) {
  PhysicalDeviceSubpassShadingFeaturesHUAWEI temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSubpassShadingFeaturesHUAWEI ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceSubpassShadingPropertiesHUAWEI &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxSubpassShadingWorkgroupSizeAspectRatio" ] = p.maxSubpassShadingWorkgroupSizeAspectRatio;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI &p ) {
  to_json( j, PhysicalDeviceSubpassShadingPropertiesHUAWEI ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceSubpassShadingPropertiesHUAWEI &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSubpassShadingPropertiesHUAWEI" );
  p.maxSubpassShadingWorkgroupSizeAspectRatio = j[ "maxSubpassShadingWorkgroupSizeAspectRatio" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI &p ) {
  PhysicalDeviceSubpassShadingPropertiesHUAWEI temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSubpassShadingPropertiesHUAWEI ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceSurfaceInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceSurfaceInfo2KHR &p ) {
  to_json( j, PhysicalDeviceSurfaceInfo2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceSurfaceInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSurfaceInfo2KHR" );
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceSurfaceInfo2KHR &p ) {
  PhysicalDeviceSurfaceInfo2KHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSurfaceInfo2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceSynchronization2FeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "synchronization2" ] = bool( p.synchronization2 );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceSynchronization2FeaturesKHR &p ) {
  to_json( j, PhysicalDeviceSynchronization2FeaturesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceSynchronization2FeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceSynchronization2FeaturesKHR" );
  p.synchronization2 = j[ "synchronization2" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceSynchronization2FeaturesKHR &p ) {
  PhysicalDeviceSynchronization2FeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceSynchronization2FeaturesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceTexelBufferAlignmentFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "texelBufferAlignment" ] = bool( p.texelBufferAlignment );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceTexelBufferAlignmentFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceTexelBufferAlignmentFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceTexelBufferAlignmentFeaturesEXT" );
  p.texelBufferAlignment = j[ "texelBufferAlignment" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT &p ) {
  PhysicalDeviceTexelBufferAlignmentFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceTexelBufferAlignmentPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "storageTexelBufferOffsetAlignmentBytes" ] = p.storageTexelBufferOffsetAlignmentBytes;
  j[ "storageTexelBufferOffsetSingleTexelAlignment" ] = bool( p.storageTexelBufferOffsetSingleTexelAlignment );
  j[ "uniformTexelBufferOffsetAlignmentBytes" ] = p.uniformTexelBufferOffsetAlignmentBytes;
  j[ "uniformTexelBufferOffsetSingleTexelAlignment" ] = bool( p.uniformTexelBufferOffsetSingleTexelAlignment );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceTexelBufferAlignmentPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceTexelBufferAlignmentPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceTexelBufferAlignmentPropertiesEXT" );
  p.storageTexelBufferOffsetAlignmentBytes = j[ "storageTexelBufferOffsetAlignmentBytes" ];
  p.storageTexelBufferOffsetSingleTexelAlignment = j[ "storageTexelBufferOffsetSingleTexelAlignment" ];
  p.uniformTexelBufferOffsetAlignmentBytes = j[ "uniformTexelBufferOffsetAlignmentBytes" ];
  p.uniformTexelBufferOffsetSingleTexelAlignment = j[ "uniformTexelBufferOffsetSingleTexelAlignment" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT &p ) {
  PhysicalDeviceTexelBufferAlignmentPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "textureCompressionASTC_HDR" ] = bool( p.textureCompressionASTC_HDR );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT" );
  p.textureCompressionASTC_HDR = j[ "textureCompressionASTC_HDR" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &p ) {
  PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceTimelineSemaphoreFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "timelineSemaphore" ] = bool( p.timelineSemaphore );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceTimelineSemaphoreFeatures &p ) {
  to_json( j, PhysicalDeviceTimelineSemaphoreFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceTimelineSemaphoreFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceTimelineSemaphoreFeatures" );
  p.timelineSemaphore = j[ "timelineSemaphore" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceTimelineSemaphoreFeatures &p ) {
  PhysicalDeviceTimelineSemaphoreFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceTimelineSemaphoreFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceTimelineSemaphoreProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxTimelineSemaphoreValueDifference" ] = p.maxTimelineSemaphoreValueDifference;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceTimelineSemaphoreProperties &p ) {
  to_json( j, PhysicalDeviceTimelineSemaphoreProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceTimelineSemaphoreProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceTimelineSemaphoreProperties" );
  p.maxTimelineSemaphoreValueDifference = j[ "maxTimelineSemaphoreValueDifference" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceTimelineSemaphoreProperties &p ) {
  PhysicalDeviceTimelineSemaphoreProperties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceTimelineSemaphoreProperties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceToolPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "name" ] = std::string( p.name.begin(), std::find( p.name.begin(), p.name.end(), '\0' ) );
  j[ "version" ] = std::string( p.version.begin(), std::find( p.version.begin(), p.version.end(), '\0' ) );
  j[ "purposes" ] = p.purposes;
  j[ "description" ] = std::string( p.description.begin(), std::find( p.description.begin(), p.description.end(), '\0' ) );
  j[ "layer" ] = std::string( p.layer.begin(), std::find( p.layer.begin(), p.layer.end(), '\0' ) );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceToolPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceToolPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceToolPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceToolPropertiesEXT" );
  {
    std::string s = j[ "name" ];
    if( !p.name.empty() ) {
      p.name[ p.name.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.name.size() - 1u ) ), p.name.begin() );
    }
  }
  {
    std::string s = j[ "version" ];
    if( !p.version.empty() ) {
      p.version[ p.version.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.version.size() - 1u ) ), p.version.begin() );
    }
  }
  p.purposes = j[ "purposes" ];
  {
    std::string s = j[ "description" ];
    if( !p.description.empty() ) {
      p.description[ p.description.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.description.size() - 1u ) ), p.description.begin() );
    }
  }
  {
    std::string s = j[ "layer" ];
    if( !p.layer.empty() ) {
      p.layer[ p.layer.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.layer.size() - 1u ) ), p.layer.begin() );
    }
  }
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceToolPropertiesEXT &p ) {
  PhysicalDeviceToolPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceToolPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceTransformFeedbackFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "transformFeedback" ] = bool( p.transformFeedback );
  j[ "geometryStreams" ] = bool( p.geometryStreams );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceTransformFeedbackFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceTransformFeedbackFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceTransformFeedbackFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceTransformFeedbackFeaturesEXT" );
  p.transformFeedback = j[ "transformFeedback" ];
  p.geometryStreams = j[ "geometryStreams" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceTransformFeedbackFeaturesEXT &p ) {
  PhysicalDeviceTransformFeedbackFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceTransformFeedbackFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceTransformFeedbackPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxTransformFeedbackStreams" ] = p.maxTransformFeedbackStreams;
  j[ "maxTransformFeedbackBuffers" ] = p.maxTransformFeedbackBuffers;
  j[ "maxTransformFeedbackBufferSize" ] = p.maxTransformFeedbackBufferSize;
  j[ "maxTransformFeedbackStreamDataSize" ] = p.maxTransformFeedbackStreamDataSize;
  j[ "maxTransformFeedbackBufferDataSize" ] = p.maxTransformFeedbackBufferDataSize;
  j[ "maxTransformFeedbackBufferDataStride" ] = p.maxTransformFeedbackBufferDataStride;
  j[ "transformFeedbackQueries" ] = bool( p.transformFeedbackQueries );
  j[ "transformFeedbackStreamsLinesTriangles" ] = bool( p.transformFeedbackStreamsLinesTriangles );
  j[ "transformFeedbackRasterizationStreamSelect" ] = bool( p.transformFeedbackRasterizationStreamSelect );
  j[ "transformFeedbackDraw" ] = bool( p.transformFeedbackDraw );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceTransformFeedbackPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceTransformFeedbackPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceTransformFeedbackPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceTransformFeedbackPropertiesEXT" );
  p.maxTransformFeedbackStreams = j[ "maxTransformFeedbackStreams" ];
  p.maxTransformFeedbackBuffers = j[ "maxTransformFeedbackBuffers" ];
  p.maxTransformFeedbackBufferSize = j[ "maxTransformFeedbackBufferSize" ];
  p.maxTransformFeedbackStreamDataSize = j[ "maxTransformFeedbackStreamDataSize" ];
  p.maxTransformFeedbackBufferDataSize = j[ "maxTransformFeedbackBufferDataSize" ];
  p.maxTransformFeedbackBufferDataStride = j[ "maxTransformFeedbackBufferDataStride" ];
  p.transformFeedbackQueries = j[ "transformFeedbackQueries" ];
  p.transformFeedbackStreamsLinesTriangles = j[ "transformFeedbackStreamsLinesTriangles" ];
  p.transformFeedbackRasterizationStreamSelect = j[ "transformFeedbackRasterizationStreamSelect" ];
  p.transformFeedbackDraw = j[ "transformFeedbackDraw" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceTransformFeedbackPropertiesEXT &p ) {
  PhysicalDeviceTransformFeedbackPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceTransformFeedbackPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceUniformBufferStandardLayoutFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "uniformBufferStandardLayout" ] = bool( p.uniformBufferStandardLayout );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceUniformBufferStandardLayoutFeatures &p ) {
  to_json( j, PhysicalDeviceUniformBufferStandardLayoutFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceUniformBufferStandardLayoutFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceUniformBufferStandardLayoutFeatures" );
  p.uniformBufferStandardLayout = j[ "uniformBufferStandardLayout" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceUniformBufferStandardLayoutFeatures &p ) {
  PhysicalDeviceUniformBufferStandardLayoutFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceUniformBufferStandardLayoutFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceVariablePointersFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "variablePointersStorageBuffer" ] = bool( p.variablePointersStorageBuffer );
  j[ "variablePointers" ] = bool( p.variablePointers );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceVariablePointersFeatures &p ) {
  to_json( j, PhysicalDeviceVariablePointersFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceVariablePointersFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVariablePointersFeatures" );
  p.variablePointersStorageBuffer = j[ "variablePointersStorageBuffer" ];
  p.variablePointers = j[ "variablePointers" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceVariablePointersFeatures &p ) {
  PhysicalDeviceVariablePointersFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVariablePointersFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceVertexAttributeDivisorFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "vertexAttributeInstanceRateDivisor" ] = bool( p.vertexAttributeInstanceRateDivisor );
  j[ "vertexAttributeInstanceRateZeroDivisor" ] = bool( p.vertexAttributeInstanceRateZeroDivisor );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceVertexAttributeDivisorFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceVertexAttributeDivisorFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVertexAttributeDivisorFeaturesEXT" );
  p.vertexAttributeInstanceRateDivisor = j[ "vertexAttributeInstanceRateDivisor" ];
  p.vertexAttributeInstanceRateZeroDivisor = j[ "vertexAttributeInstanceRateZeroDivisor" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT &p ) {
  PhysicalDeviceVertexAttributeDivisorFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceVertexAttributeDivisorPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxVertexAttribDivisor" ] = p.maxVertexAttribDivisor;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT &p ) {
  to_json( j, PhysicalDeviceVertexAttributeDivisorPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceVertexAttributeDivisorPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVertexAttributeDivisorPropertiesEXT" );
  p.maxVertexAttribDivisor = j[ "maxVertexAttribDivisor" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT &p ) {
  PhysicalDeviceVertexAttributeDivisorPropertiesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceVertexInputDynamicStateFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "vertexInputDynamicState" ] = bool( p.vertexInputDynamicState );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceVertexInputDynamicStateFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceVertexInputDynamicStateFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVertexInputDynamicStateFeaturesEXT" );
  p.vertexInputDynamicState = j[ "vertexInputDynamicState" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT &p ) {
  PhysicalDeviceVertexInputDynamicStateFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT ( temp );
}

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoProfileKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "videoCodecOperation" ] = p.videoCodecOperation;
  j[ "chromaSubsampling" ] = p.chromaSubsampling;
  j[ "lumaBitDepth" ] = p.lumaBitDepth;
  j[ "chromaBitDepth" ] = p.chromaBitDepth;
}
inline void to_json( nlohmann::json &j, const VkVideoProfileKHR &p ) {
  to_json( j, VideoProfileKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoProfileKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoProfileKHR" );
  p.videoCodecOperation = j[ "videoCodecOperation" ];
  p.chromaSubsampling = j[ "chromaSubsampling" ];
  p.lumaBitDepth = j[ "lumaBitDepth" ];
  p.chromaBitDepth = j[ "chromaBitDepth" ];
}
inline void from_json( const nlohmann::json &j, VkVideoProfileKHR &p ) {
  VideoProfileKHR temp;
  from_json( j, temp );
  p = VkVideoProfileKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoProfilesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "profileCount" ] = p.profileCount;
  j[ "pProfiles" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pProfiles ) );
}
inline void to_json( nlohmann::json &j, const VkVideoProfilesKHR &p ) {
  to_json( j, VideoProfilesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoProfilesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoProfilesKHR" );
  p.profileCount = j[ "profileCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoProfilesKHR &p ) {
  VideoProfilesKHR temp;
  from_json( j, temp );
  p = VkVideoProfilesKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const PhysicalDeviceVideoFormatInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "imageUsage" ] = p.imageUsage;
  j[ "pVideoProfiles" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pVideoProfiles ) );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceVideoFormatInfoKHR &p ) {
  to_json( j, PhysicalDeviceVideoFormatInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceVideoFormatInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVideoFormatInfoKHR" );
  p.imageUsage = j[ "imageUsage" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceVideoFormatInfoKHR &p ) {
  PhysicalDeviceVideoFormatInfoKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVideoFormatInfoKHR ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const PhysicalDeviceVulkan11Features &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "storageBuffer16BitAccess" ] = bool( p.storageBuffer16BitAccess );
  j[ "uniformAndStorageBuffer16BitAccess" ] = bool( p.uniformAndStorageBuffer16BitAccess );
  j[ "storagePushConstant16" ] = bool( p.storagePushConstant16 );
  j[ "storageInputOutput16" ] = bool( p.storageInputOutput16 );
  j[ "multiview" ] = bool( p.multiview );
  j[ "multiviewGeometryShader" ] = bool( p.multiviewGeometryShader );
  j[ "multiviewTessellationShader" ] = bool( p.multiviewTessellationShader );
  j[ "variablePointersStorageBuffer" ] = bool( p.variablePointersStorageBuffer );
  j[ "variablePointers" ] = bool( p.variablePointers );
  j[ "protectedMemory" ] = bool( p.protectedMemory );
  j[ "samplerYcbcrConversion" ] = bool( p.samplerYcbcrConversion );
  j[ "shaderDrawParameters" ] = bool( p.shaderDrawParameters );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceVulkan11Features &p ) {
  to_json( j, PhysicalDeviceVulkan11Features ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceVulkan11Features &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVulkan11Features" );
  p.storageBuffer16BitAccess = j[ "storageBuffer16BitAccess" ];
  p.uniformAndStorageBuffer16BitAccess = j[ "uniformAndStorageBuffer16BitAccess" ];
  p.storagePushConstant16 = j[ "storagePushConstant16" ];
  p.storageInputOutput16 = j[ "storageInputOutput16" ];
  p.multiview = j[ "multiview" ];
  p.multiviewGeometryShader = j[ "multiviewGeometryShader" ];
  p.multiviewTessellationShader = j[ "multiviewTessellationShader" ];
  p.variablePointersStorageBuffer = j[ "variablePointersStorageBuffer" ];
  p.variablePointers = j[ "variablePointers" ];
  p.protectedMemory = j[ "protectedMemory" ];
  p.samplerYcbcrConversion = j[ "samplerYcbcrConversion" ];
  p.shaderDrawParameters = j[ "shaderDrawParameters" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceVulkan11Features &p ) {
  PhysicalDeviceVulkan11Features temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVulkan11Features ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceVulkan11Properties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "deviceUUID" ] = nlohmann::json::array();
  std::copy( p.deviceUUID.begin(), p.deviceUUID.end(), std::back_inserter( j[ "deviceUUID" ] ) );
  j[ "driverUUID" ] = nlohmann::json::array();
  std::copy( p.driverUUID.begin(), p.driverUUID.end(), std::back_inserter( j[ "driverUUID" ] ) );
  j[ "deviceLUID" ] = nlohmann::json::array();
  std::copy( p.deviceLUID.begin(), p.deviceLUID.end(), std::back_inserter( j[ "deviceLUID" ] ) );
  j[ "deviceNodeMask" ] = p.deviceNodeMask;
  j[ "deviceLUIDValid" ] = bool( p.deviceLUIDValid );
  j[ "subgroupSize" ] = p.subgroupSize;
  j[ "subgroupSupportedStages" ] = p.subgroupSupportedStages;
  j[ "subgroupSupportedOperations" ] = p.subgroupSupportedOperations;
  j[ "subgroupQuadOperationsInAllStages" ] = bool( p.subgroupQuadOperationsInAllStages );
  j[ "pointClippingBehavior" ] = p.pointClippingBehavior;
  j[ "maxMultiviewViewCount" ] = p.maxMultiviewViewCount;
  j[ "maxMultiviewInstanceIndex" ] = p.maxMultiviewInstanceIndex;
  j[ "protectedNoFault" ] = bool( p.protectedNoFault );
  j[ "maxPerSetDescriptors" ] = p.maxPerSetDescriptors;
  j[ "maxMemoryAllocationSize" ] = p.maxMemoryAllocationSize;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceVulkan11Properties &p ) {
  to_json( j, PhysicalDeviceVulkan11Properties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceVulkan11Properties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVulkan11Properties" );
  if( !j[ "deviceUUID" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceVulkan11Properties.deviceUUID" );
  if( !j[ "deviceUUID" ].size() > p.deviceUUID.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceVulkan11Properties.deviceUUID" );
  std::fill( p.deviceUUID.begin(), p.deviceUUID.end(), 0 );
  std::copy( j[ "deviceUUID" ].begin(), j[ "deviceUUID" ].end(), p.deviceUUID.begin() );
  if( !j[ "driverUUID" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceVulkan11Properties.driverUUID" );
  if( !j[ "driverUUID" ].size() > p.driverUUID.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceVulkan11Properties.driverUUID" );
  std::fill( p.driverUUID.begin(), p.driverUUID.end(), 0 );
  std::copy( j[ "driverUUID" ].begin(), j[ "driverUUID" ].end(), p.driverUUID.begin() );
  if( !j[ "deviceLUID" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PhysicalDeviceVulkan11Properties.deviceLUID" );
  if( !j[ "deviceLUID" ].size() > p.deviceLUID.size() ) throw vulkan2json::invalid_array_value( "too many values in array for PhysicalDeviceVulkan11Properties.deviceLUID" );
  std::fill( p.deviceLUID.begin(), p.deviceLUID.end(), 0 );
  std::copy( j[ "deviceLUID" ].begin(), j[ "deviceLUID" ].end(), p.deviceLUID.begin() );
  p.deviceNodeMask = j[ "deviceNodeMask" ];
  p.deviceLUIDValid = j[ "deviceLUIDValid" ];
  p.subgroupSize = j[ "subgroupSize" ];
  p.subgroupSupportedStages = j[ "subgroupSupportedStages" ];
  p.subgroupSupportedOperations = j[ "subgroupSupportedOperations" ];
  p.subgroupQuadOperationsInAllStages = j[ "subgroupQuadOperationsInAllStages" ];
  p.pointClippingBehavior = j[ "pointClippingBehavior" ];
  p.maxMultiviewViewCount = j[ "maxMultiviewViewCount" ];
  p.maxMultiviewInstanceIndex = j[ "maxMultiviewInstanceIndex" ];
  p.protectedNoFault = j[ "protectedNoFault" ];
  p.maxPerSetDescriptors = j[ "maxPerSetDescriptors" ];
  p.maxMemoryAllocationSize = j[ "maxMemoryAllocationSize" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceVulkan11Properties &p ) {
  PhysicalDeviceVulkan11Properties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVulkan11Properties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceVulkan12Features &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "samplerMirrorClampToEdge" ] = bool( p.samplerMirrorClampToEdge );
  j[ "drawIndirectCount" ] = bool( p.drawIndirectCount );
  j[ "storageBuffer8BitAccess" ] = bool( p.storageBuffer8BitAccess );
  j[ "uniformAndStorageBuffer8BitAccess" ] = bool( p.uniformAndStorageBuffer8BitAccess );
  j[ "storagePushConstant8" ] = bool( p.storagePushConstant8 );
  j[ "shaderBufferInt64Atomics" ] = bool( p.shaderBufferInt64Atomics );
  j[ "shaderSharedInt64Atomics" ] = bool( p.shaderSharedInt64Atomics );
  j[ "shaderFloat16" ] = bool( p.shaderFloat16 );
  j[ "shaderInt8" ] = bool( p.shaderInt8 );
  j[ "descriptorIndexing" ] = bool( p.descriptorIndexing );
  j[ "shaderInputAttachmentArrayDynamicIndexing" ] = bool( p.shaderInputAttachmentArrayDynamicIndexing );
  j[ "shaderUniformTexelBufferArrayDynamicIndexing" ] = bool( p.shaderUniformTexelBufferArrayDynamicIndexing );
  j[ "shaderStorageTexelBufferArrayDynamicIndexing" ] = bool( p.shaderStorageTexelBufferArrayDynamicIndexing );
  j[ "shaderUniformBufferArrayNonUniformIndexing" ] = bool( p.shaderUniformBufferArrayNonUniformIndexing );
  j[ "shaderSampledImageArrayNonUniformIndexing" ] = bool( p.shaderSampledImageArrayNonUniformIndexing );
  j[ "shaderStorageBufferArrayNonUniformIndexing" ] = bool( p.shaderStorageBufferArrayNonUniformIndexing );
  j[ "shaderStorageImageArrayNonUniformIndexing" ] = bool( p.shaderStorageImageArrayNonUniformIndexing );
  j[ "shaderInputAttachmentArrayNonUniformIndexing" ] = bool( p.shaderInputAttachmentArrayNonUniformIndexing );
  j[ "shaderUniformTexelBufferArrayNonUniformIndexing" ] = bool( p.shaderUniformTexelBufferArrayNonUniformIndexing );
  j[ "shaderStorageTexelBufferArrayNonUniformIndexing" ] = bool( p.shaderStorageTexelBufferArrayNonUniformIndexing );
  j[ "descriptorBindingUniformBufferUpdateAfterBind" ] = bool( p.descriptorBindingUniformBufferUpdateAfterBind );
  j[ "descriptorBindingSampledImageUpdateAfterBind" ] = bool( p.descriptorBindingSampledImageUpdateAfterBind );
  j[ "descriptorBindingStorageImageUpdateAfterBind" ] = bool( p.descriptorBindingStorageImageUpdateAfterBind );
  j[ "descriptorBindingStorageBufferUpdateAfterBind" ] = bool( p.descriptorBindingStorageBufferUpdateAfterBind );
  j[ "descriptorBindingUniformTexelBufferUpdateAfterBind" ] = bool( p.descriptorBindingUniformTexelBufferUpdateAfterBind );
  j[ "descriptorBindingStorageTexelBufferUpdateAfterBind" ] = bool( p.descriptorBindingStorageTexelBufferUpdateAfterBind );
  j[ "descriptorBindingUpdateUnusedWhilePending" ] = bool( p.descriptorBindingUpdateUnusedWhilePending );
  j[ "descriptorBindingPartiallyBound" ] = bool( p.descriptorBindingPartiallyBound );
  j[ "descriptorBindingVariableDescriptorCount" ] = bool( p.descriptorBindingVariableDescriptorCount );
  j[ "runtimeDescriptorArray" ] = bool( p.runtimeDescriptorArray );
  j[ "samplerFilterMinmax" ] = bool( p.samplerFilterMinmax );
  j[ "scalarBlockLayout" ] = bool( p.scalarBlockLayout );
  j[ "imagelessFramebuffer" ] = bool( p.imagelessFramebuffer );
  j[ "uniformBufferStandardLayout" ] = bool( p.uniformBufferStandardLayout );
  j[ "shaderSubgroupExtendedTypes" ] = bool( p.shaderSubgroupExtendedTypes );
  j[ "separateDepthStencilLayouts" ] = bool( p.separateDepthStencilLayouts );
  j[ "hostQueryReset" ] = bool( p.hostQueryReset );
  j[ "timelineSemaphore" ] = bool( p.timelineSemaphore );
  j[ "bufferDeviceAddress" ] = bool( p.bufferDeviceAddress );
  j[ "bufferDeviceAddressCaptureReplay" ] = bool( p.bufferDeviceAddressCaptureReplay );
  j[ "bufferDeviceAddressMultiDevice" ] = bool( p.bufferDeviceAddressMultiDevice );
  j[ "vulkanMemoryModel" ] = bool( p.vulkanMemoryModel );
  j[ "vulkanMemoryModelDeviceScope" ] = bool( p.vulkanMemoryModelDeviceScope );
  j[ "vulkanMemoryModelAvailabilityVisibilityChains" ] = bool( p.vulkanMemoryModelAvailabilityVisibilityChains );
  j[ "shaderOutputViewportIndex" ] = bool( p.shaderOutputViewportIndex );
  j[ "shaderOutputLayer" ] = bool( p.shaderOutputLayer );
  j[ "subgroupBroadcastDynamicId" ] = bool( p.subgroupBroadcastDynamicId );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceVulkan12Features &p ) {
  to_json( j, PhysicalDeviceVulkan12Features ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceVulkan12Features &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVulkan12Features" );
  p.samplerMirrorClampToEdge = j[ "samplerMirrorClampToEdge" ];
  p.drawIndirectCount = j[ "drawIndirectCount" ];
  p.storageBuffer8BitAccess = j[ "storageBuffer8BitAccess" ];
  p.uniformAndStorageBuffer8BitAccess = j[ "uniformAndStorageBuffer8BitAccess" ];
  p.storagePushConstant8 = j[ "storagePushConstant8" ];
  p.shaderBufferInt64Atomics = j[ "shaderBufferInt64Atomics" ];
  p.shaderSharedInt64Atomics = j[ "shaderSharedInt64Atomics" ];
  p.shaderFloat16 = j[ "shaderFloat16" ];
  p.shaderInt8 = j[ "shaderInt8" ];
  p.descriptorIndexing = j[ "descriptorIndexing" ];
  p.shaderInputAttachmentArrayDynamicIndexing = j[ "shaderInputAttachmentArrayDynamicIndexing" ];
  p.shaderUniformTexelBufferArrayDynamicIndexing = j[ "shaderUniformTexelBufferArrayDynamicIndexing" ];
  p.shaderStorageTexelBufferArrayDynamicIndexing = j[ "shaderStorageTexelBufferArrayDynamicIndexing" ];
  p.shaderUniformBufferArrayNonUniformIndexing = j[ "shaderUniformBufferArrayNonUniformIndexing" ];
  p.shaderSampledImageArrayNonUniformIndexing = j[ "shaderSampledImageArrayNonUniformIndexing" ];
  p.shaderStorageBufferArrayNonUniformIndexing = j[ "shaderStorageBufferArrayNonUniformIndexing" ];
  p.shaderStorageImageArrayNonUniformIndexing = j[ "shaderStorageImageArrayNonUniformIndexing" ];
  p.shaderInputAttachmentArrayNonUniformIndexing = j[ "shaderInputAttachmentArrayNonUniformIndexing" ];
  p.shaderUniformTexelBufferArrayNonUniformIndexing = j[ "shaderUniformTexelBufferArrayNonUniformIndexing" ];
  p.shaderStorageTexelBufferArrayNonUniformIndexing = j[ "shaderStorageTexelBufferArrayNonUniformIndexing" ];
  p.descriptorBindingUniformBufferUpdateAfterBind = j[ "descriptorBindingUniformBufferUpdateAfterBind" ];
  p.descriptorBindingSampledImageUpdateAfterBind = j[ "descriptorBindingSampledImageUpdateAfterBind" ];
  p.descriptorBindingStorageImageUpdateAfterBind = j[ "descriptorBindingStorageImageUpdateAfterBind" ];
  p.descriptorBindingStorageBufferUpdateAfterBind = j[ "descriptorBindingStorageBufferUpdateAfterBind" ];
  p.descriptorBindingUniformTexelBufferUpdateAfterBind = j[ "descriptorBindingUniformTexelBufferUpdateAfterBind" ];
  p.descriptorBindingStorageTexelBufferUpdateAfterBind = j[ "descriptorBindingStorageTexelBufferUpdateAfterBind" ];
  p.descriptorBindingUpdateUnusedWhilePending = j[ "descriptorBindingUpdateUnusedWhilePending" ];
  p.descriptorBindingPartiallyBound = j[ "descriptorBindingPartiallyBound" ];
  p.descriptorBindingVariableDescriptorCount = j[ "descriptorBindingVariableDescriptorCount" ];
  p.runtimeDescriptorArray = j[ "runtimeDescriptorArray" ];
  p.samplerFilterMinmax = j[ "samplerFilterMinmax" ];
  p.scalarBlockLayout = j[ "scalarBlockLayout" ];
  p.imagelessFramebuffer = j[ "imagelessFramebuffer" ];
  p.uniformBufferStandardLayout = j[ "uniformBufferStandardLayout" ];
  p.shaderSubgroupExtendedTypes = j[ "shaderSubgroupExtendedTypes" ];
  p.separateDepthStencilLayouts = j[ "separateDepthStencilLayouts" ];
  p.hostQueryReset = j[ "hostQueryReset" ];
  p.timelineSemaphore = j[ "timelineSemaphore" ];
  p.bufferDeviceAddress = j[ "bufferDeviceAddress" ];
  p.bufferDeviceAddressCaptureReplay = j[ "bufferDeviceAddressCaptureReplay" ];
  p.bufferDeviceAddressMultiDevice = j[ "bufferDeviceAddressMultiDevice" ];
  p.vulkanMemoryModel = j[ "vulkanMemoryModel" ];
  p.vulkanMemoryModelDeviceScope = j[ "vulkanMemoryModelDeviceScope" ];
  p.vulkanMemoryModelAvailabilityVisibilityChains = j[ "vulkanMemoryModelAvailabilityVisibilityChains" ];
  p.shaderOutputViewportIndex = j[ "shaderOutputViewportIndex" ];
  p.shaderOutputLayer = j[ "shaderOutputLayer" ];
  p.subgroupBroadcastDynamicId = j[ "subgroupBroadcastDynamicId" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceVulkan12Features &p ) {
  PhysicalDeviceVulkan12Features temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVulkan12Features ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceVulkan12Properties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "driverID" ] = p.driverID;
  j[ "driverName" ] = std::string( p.driverName.begin(), std::find( p.driverName.begin(), p.driverName.end(), '\0' ) );
  j[ "driverInfo" ] = std::string( p.driverInfo.begin(), std::find( p.driverInfo.begin(), p.driverInfo.end(), '\0' ) );
  j[ "conformanceVersion" ] = p.conformanceVersion;
  j[ "denormBehaviorIndependence" ] = p.denormBehaviorIndependence;
  j[ "roundingModeIndependence" ] = p.roundingModeIndependence;
  j[ "shaderSignedZeroInfNanPreserveFloat16" ] = bool( p.shaderSignedZeroInfNanPreserveFloat16 );
  j[ "shaderSignedZeroInfNanPreserveFloat32" ] = bool( p.shaderSignedZeroInfNanPreserveFloat32 );
  j[ "shaderSignedZeroInfNanPreserveFloat64" ] = bool( p.shaderSignedZeroInfNanPreserveFloat64 );
  j[ "shaderDenormPreserveFloat16" ] = bool( p.shaderDenormPreserveFloat16 );
  j[ "shaderDenormPreserveFloat32" ] = bool( p.shaderDenormPreserveFloat32 );
  j[ "shaderDenormPreserveFloat64" ] = bool( p.shaderDenormPreserveFloat64 );
  j[ "shaderDenormFlushToZeroFloat16" ] = bool( p.shaderDenormFlushToZeroFloat16 );
  j[ "shaderDenormFlushToZeroFloat32" ] = bool( p.shaderDenormFlushToZeroFloat32 );
  j[ "shaderDenormFlushToZeroFloat64" ] = bool( p.shaderDenormFlushToZeroFloat64 );
  j[ "shaderRoundingModeRTEFloat16" ] = bool( p.shaderRoundingModeRTEFloat16 );
  j[ "shaderRoundingModeRTEFloat32" ] = bool( p.shaderRoundingModeRTEFloat32 );
  j[ "shaderRoundingModeRTEFloat64" ] = bool( p.shaderRoundingModeRTEFloat64 );
  j[ "shaderRoundingModeRTZFloat16" ] = bool( p.shaderRoundingModeRTZFloat16 );
  j[ "shaderRoundingModeRTZFloat32" ] = bool( p.shaderRoundingModeRTZFloat32 );
  j[ "shaderRoundingModeRTZFloat64" ] = bool( p.shaderRoundingModeRTZFloat64 );
  j[ "maxUpdateAfterBindDescriptorsInAllPools" ] = p.maxUpdateAfterBindDescriptorsInAllPools;
  j[ "shaderUniformBufferArrayNonUniformIndexingNative" ] = bool( p.shaderUniformBufferArrayNonUniformIndexingNative );
  j[ "shaderSampledImageArrayNonUniformIndexingNative" ] = bool( p.shaderSampledImageArrayNonUniformIndexingNative );
  j[ "shaderStorageBufferArrayNonUniformIndexingNative" ] = bool( p.shaderStorageBufferArrayNonUniformIndexingNative );
  j[ "shaderStorageImageArrayNonUniformIndexingNative" ] = bool( p.shaderStorageImageArrayNonUniformIndexingNative );
  j[ "shaderInputAttachmentArrayNonUniformIndexingNative" ] = bool( p.shaderInputAttachmentArrayNonUniformIndexingNative );
  j[ "robustBufferAccessUpdateAfterBind" ] = bool( p.robustBufferAccessUpdateAfterBind );
  j[ "quadDivergentImplicitLod" ] = bool( p.quadDivergentImplicitLod );
  j[ "maxPerStageDescriptorUpdateAfterBindSamplers" ] = p.maxPerStageDescriptorUpdateAfterBindSamplers;
  j[ "maxPerStageDescriptorUpdateAfterBindUniformBuffers" ] = p.maxPerStageDescriptorUpdateAfterBindUniformBuffers;
  j[ "maxPerStageDescriptorUpdateAfterBindStorageBuffers" ] = p.maxPerStageDescriptorUpdateAfterBindStorageBuffers;
  j[ "maxPerStageDescriptorUpdateAfterBindSampledImages" ] = p.maxPerStageDescriptorUpdateAfterBindSampledImages;
  j[ "maxPerStageDescriptorUpdateAfterBindStorageImages" ] = p.maxPerStageDescriptorUpdateAfterBindStorageImages;
  j[ "maxPerStageDescriptorUpdateAfterBindInputAttachments" ] = p.maxPerStageDescriptorUpdateAfterBindInputAttachments;
  j[ "maxPerStageUpdateAfterBindResources" ] = p.maxPerStageUpdateAfterBindResources;
  j[ "maxDescriptorSetUpdateAfterBindSamplers" ] = p.maxDescriptorSetUpdateAfterBindSamplers;
  j[ "maxDescriptorSetUpdateAfterBindUniformBuffers" ] = p.maxDescriptorSetUpdateAfterBindUniformBuffers;
  j[ "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic" ] = p.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
  j[ "maxDescriptorSetUpdateAfterBindStorageBuffers" ] = p.maxDescriptorSetUpdateAfterBindStorageBuffers;
  j[ "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic" ] = p.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
  j[ "maxDescriptorSetUpdateAfterBindSampledImages" ] = p.maxDescriptorSetUpdateAfterBindSampledImages;
  j[ "maxDescriptorSetUpdateAfterBindStorageImages" ] = p.maxDescriptorSetUpdateAfterBindStorageImages;
  j[ "maxDescriptorSetUpdateAfterBindInputAttachments" ] = p.maxDescriptorSetUpdateAfterBindInputAttachments;
  j[ "supportedDepthResolveModes" ] = p.supportedDepthResolveModes;
  j[ "supportedStencilResolveModes" ] = p.supportedStencilResolveModes;
  j[ "independentResolveNone" ] = bool( p.independentResolveNone );
  j[ "independentResolve" ] = bool( p.independentResolve );
  j[ "filterMinmaxSingleComponentFormats" ] = bool( p.filterMinmaxSingleComponentFormats );
  j[ "filterMinmaxImageComponentMapping" ] = bool( p.filterMinmaxImageComponentMapping );
  j[ "maxTimelineSemaphoreValueDifference" ] = p.maxTimelineSemaphoreValueDifference;
  j[ "framebufferIntegerColorSampleCounts" ] = p.framebufferIntegerColorSampleCounts;
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceVulkan12Properties &p ) {
  to_json( j, PhysicalDeviceVulkan12Properties ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceVulkan12Properties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVulkan12Properties" );
  p.driverID = j[ "driverID" ];
  {
    std::string s = j[ "driverName" ];
    if( !p.driverName.empty() ) {
      p.driverName[ p.driverName.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.driverName.size() - 1u ) ), p.driverName.begin() );
    }
  }
  {
    std::string s = j[ "driverInfo" ];
    if( !p.driverInfo.empty() ) {
      p.driverInfo[ p.driverInfo.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.driverInfo.size() - 1u ) ), p.driverInfo.begin() );
    }
  }
  p.conformanceVersion = j[ "conformanceVersion" ];
  p.denormBehaviorIndependence = j[ "denormBehaviorIndependence" ];
  p.roundingModeIndependence = j[ "roundingModeIndependence" ];
  p.shaderSignedZeroInfNanPreserveFloat16 = j[ "shaderSignedZeroInfNanPreserveFloat16" ];
  p.shaderSignedZeroInfNanPreserveFloat32 = j[ "shaderSignedZeroInfNanPreserveFloat32" ];
  p.shaderSignedZeroInfNanPreserveFloat64 = j[ "shaderSignedZeroInfNanPreserveFloat64" ];
  p.shaderDenormPreserveFloat16 = j[ "shaderDenormPreserveFloat16" ];
  p.shaderDenormPreserveFloat32 = j[ "shaderDenormPreserveFloat32" ];
  p.shaderDenormPreserveFloat64 = j[ "shaderDenormPreserveFloat64" ];
  p.shaderDenormFlushToZeroFloat16 = j[ "shaderDenormFlushToZeroFloat16" ];
  p.shaderDenormFlushToZeroFloat32 = j[ "shaderDenormFlushToZeroFloat32" ];
  p.shaderDenormFlushToZeroFloat64 = j[ "shaderDenormFlushToZeroFloat64" ];
  p.shaderRoundingModeRTEFloat16 = j[ "shaderRoundingModeRTEFloat16" ];
  p.shaderRoundingModeRTEFloat32 = j[ "shaderRoundingModeRTEFloat32" ];
  p.shaderRoundingModeRTEFloat64 = j[ "shaderRoundingModeRTEFloat64" ];
  p.shaderRoundingModeRTZFloat16 = j[ "shaderRoundingModeRTZFloat16" ];
  p.shaderRoundingModeRTZFloat32 = j[ "shaderRoundingModeRTZFloat32" ];
  p.shaderRoundingModeRTZFloat64 = j[ "shaderRoundingModeRTZFloat64" ];
  p.maxUpdateAfterBindDescriptorsInAllPools = j[ "maxUpdateAfterBindDescriptorsInAllPools" ];
  p.shaderUniformBufferArrayNonUniformIndexingNative = j[ "shaderUniformBufferArrayNonUniformIndexingNative" ];
  p.shaderSampledImageArrayNonUniformIndexingNative = j[ "shaderSampledImageArrayNonUniformIndexingNative" ];
  p.shaderStorageBufferArrayNonUniformIndexingNative = j[ "shaderStorageBufferArrayNonUniformIndexingNative" ];
  p.shaderStorageImageArrayNonUniformIndexingNative = j[ "shaderStorageImageArrayNonUniformIndexingNative" ];
  p.shaderInputAttachmentArrayNonUniformIndexingNative = j[ "shaderInputAttachmentArrayNonUniformIndexingNative" ];
  p.robustBufferAccessUpdateAfterBind = j[ "robustBufferAccessUpdateAfterBind" ];
  p.quadDivergentImplicitLod = j[ "quadDivergentImplicitLod" ];
  p.maxPerStageDescriptorUpdateAfterBindSamplers = j[ "maxPerStageDescriptorUpdateAfterBindSamplers" ];
  p.maxPerStageDescriptorUpdateAfterBindUniformBuffers = j[ "maxPerStageDescriptorUpdateAfterBindUniformBuffers" ];
  p.maxPerStageDescriptorUpdateAfterBindStorageBuffers = j[ "maxPerStageDescriptorUpdateAfterBindStorageBuffers" ];
  p.maxPerStageDescriptorUpdateAfterBindSampledImages = j[ "maxPerStageDescriptorUpdateAfterBindSampledImages" ];
  p.maxPerStageDescriptorUpdateAfterBindStorageImages = j[ "maxPerStageDescriptorUpdateAfterBindStorageImages" ];
  p.maxPerStageDescriptorUpdateAfterBindInputAttachments = j[ "maxPerStageDescriptorUpdateAfterBindInputAttachments" ];
  p.maxPerStageUpdateAfterBindResources = j[ "maxPerStageUpdateAfterBindResources" ];
  p.maxDescriptorSetUpdateAfterBindSamplers = j[ "maxDescriptorSetUpdateAfterBindSamplers" ];
  p.maxDescriptorSetUpdateAfterBindUniformBuffers = j[ "maxDescriptorSetUpdateAfterBindUniformBuffers" ];
  p.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = j[ "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic" ];
  p.maxDescriptorSetUpdateAfterBindStorageBuffers = j[ "maxDescriptorSetUpdateAfterBindStorageBuffers" ];
  p.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = j[ "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic" ];
  p.maxDescriptorSetUpdateAfterBindSampledImages = j[ "maxDescriptorSetUpdateAfterBindSampledImages" ];
  p.maxDescriptorSetUpdateAfterBindStorageImages = j[ "maxDescriptorSetUpdateAfterBindStorageImages" ];
  p.maxDescriptorSetUpdateAfterBindInputAttachments = j[ "maxDescriptorSetUpdateAfterBindInputAttachments" ];
  p.supportedDepthResolveModes = j[ "supportedDepthResolveModes" ];
  p.supportedStencilResolveModes = j[ "supportedStencilResolveModes" ];
  p.independentResolveNone = j[ "independentResolveNone" ];
  p.independentResolve = j[ "independentResolve" ];
  p.filterMinmaxSingleComponentFormats = j[ "filterMinmaxSingleComponentFormats" ];
  p.filterMinmaxImageComponentMapping = j[ "filterMinmaxImageComponentMapping" ];
  p.maxTimelineSemaphoreValueDifference = j[ "maxTimelineSemaphoreValueDifference" ];
  p.framebufferIntegerColorSampleCounts = j[ "framebufferIntegerColorSampleCounts" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceVulkan12Properties &p ) {
  PhysicalDeviceVulkan12Properties temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVulkan12Properties ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceVulkanMemoryModelFeatures &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "vulkanMemoryModel" ] = bool( p.vulkanMemoryModel );
  j[ "vulkanMemoryModelDeviceScope" ] = bool( p.vulkanMemoryModelDeviceScope );
  j[ "vulkanMemoryModelAvailabilityVisibilityChains" ] = bool( p.vulkanMemoryModelAvailabilityVisibilityChains );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceVulkanMemoryModelFeatures &p ) {
  to_json( j, PhysicalDeviceVulkanMemoryModelFeatures ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceVulkanMemoryModelFeatures &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceVulkanMemoryModelFeatures" );
  p.vulkanMemoryModel = j[ "vulkanMemoryModel" ];
  p.vulkanMemoryModelDeviceScope = j[ "vulkanMemoryModelDeviceScope" ];
  p.vulkanMemoryModelAvailabilityVisibilityChains = j[ "vulkanMemoryModelAvailabilityVisibilityChains" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceVulkanMemoryModelFeatures &p ) {
  PhysicalDeviceVulkanMemoryModelFeatures temp;
  from_json( j, temp );
  p = VkPhysicalDeviceVulkanMemoryModelFeatures ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "workgroupMemoryExplicitLayout" ] = bool( p.workgroupMemoryExplicitLayout );
  j[ "workgroupMemoryExplicitLayoutScalarBlockLayout" ] = bool( p.workgroupMemoryExplicitLayoutScalarBlockLayout );
  j[ "workgroupMemoryExplicitLayout8BitAccess" ] = bool( p.workgroupMemoryExplicitLayout8BitAccess );
  j[ "workgroupMemoryExplicitLayout16BitAccess" ] = bool( p.workgroupMemoryExplicitLayout16BitAccess );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR &p ) {
  to_json( j, PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR" );
  p.workgroupMemoryExplicitLayout = j[ "workgroupMemoryExplicitLayout" ];
  p.workgroupMemoryExplicitLayoutScalarBlockLayout = j[ "workgroupMemoryExplicitLayoutScalarBlockLayout" ];
  p.workgroupMemoryExplicitLayout8BitAccess = j[ "workgroupMemoryExplicitLayout8BitAccess" ];
  p.workgroupMemoryExplicitLayout16BitAccess = j[ "workgroupMemoryExplicitLayout16BitAccess" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR &p ) {
  PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "ycbcr2plane444Formats" ] = bool( p.ycbcr2plane444Formats );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT" );
  p.ycbcr2plane444Formats = j[ "ycbcr2plane444Formats" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT &p ) {
  PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceYcbcrImageArraysFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "ycbcrImageArrays" ] = bool( p.ycbcrImageArrays );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT &p ) {
  to_json( j, PhysicalDeviceYcbcrImageArraysFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceYcbcrImageArraysFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceYcbcrImageArraysFeaturesEXT" );
  p.ycbcrImageArrays = j[ "ycbcrImageArrays" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT &p ) {
  PhysicalDeviceYcbcrImageArraysFeaturesEXT temp;
  from_json( j, temp );
  p = VkPhysicalDeviceYcbcrImageArraysFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shaderZeroInitializeWorkgroupMemory" ] = bool( p.shaderZeroInitializeWorkgroupMemory );
}
inline void to_json( nlohmann::json &j, const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR &p ) {
  to_json( j, PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR" );
  p.shaderZeroInitializeWorkgroupMemory = j[ "shaderZeroInitializeWorkgroupMemory" ];
}
inline void from_json( const nlohmann::json &j, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR &p ) {
  PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR temp;
  from_json( j, temp );
  p = VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineCacheCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "initialDataSize" ] = p.initialDataSize;
  j[ "pInitialData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pInitialData ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineCacheCreateInfo &p ) {
  to_json( j, PipelineCacheCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineCacheCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineCacheCreateInfo" );
  p.flags = j[ "flags" ];
  p.initialDataSize = j[ "initialDataSize" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineCacheCreateInfo &p ) {
  PipelineCacheCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineCacheCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineColorBlendAdvancedStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcPremultiplied" ] = bool( p.srcPremultiplied );
  j[ "dstPremultiplied" ] = bool( p.dstPremultiplied );
  j[ "blendOverlap" ] = p.blendOverlap;
}
inline void to_json( nlohmann::json &j, const VkPipelineColorBlendAdvancedStateCreateInfoEXT &p ) {
  to_json( j, PipelineColorBlendAdvancedStateCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineColorBlendAdvancedStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineColorBlendAdvancedStateCreateInfoEXT" );
  p.srcPremultiplied = j[ "srcPremultiplied" ];
  p.dstPremultiplied = j[ "dstPremultiplied" ];
  p.blendOverlap = j[ "blendOverlap" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineColorBlendAdvancedStateCreateInfoEXT &p ) {
  PipelineColorBlendAdvancedStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineColorBlendAdvancedStateCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineColorWriteCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "attachmentCount" ] = p.attachmentCount;
  j[ "pColorWriteEnables" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pColorWriteEnables ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineColorWriteCreateInfoEXT &p ) {
  to_json( j, PipelineColorWriteCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineColorWriteCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineColorWriteCreateInfoEXT" );
  p.attachmentCount = j[ "attachmentCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineColorWriteCreateInfoEXT &p ) {
  PipelineColorWriteCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineColorWriteCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineCompilerControlCreateInfoAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "compilerControlFlags" ] = p.compilerControlFlags;
}
inline void to_json( nlohmann::json &j, const VkPipelineCompilerControlCreateInfoAMD &p ) {
  to_json( j, PipelineCompilerControlCreateInfoAMD ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineCompilerControlCreateInfoAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineCompilerControlCreateInfoAMD" );
  p.compilerControlFlags = j[ "compilerControlFlags" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineCompilerControlCreateInfoAMD &p ) {
  PipelineCompilerControlCreateInfoAMD temp;
  from_json( j, temp );
  p = VkPipelineCompilerControlCreateInfoAMD ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineCoverageModulationStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "coverageModulationMode" ] = p.coverageModulationMode;
  j[ "coverageModulationTableEnable" ] = bool( p.coverageModulationTableEnable );
  j[ "coverageModulationTableCount" ] = p.coverageModulationTableCount;
  j[ "pCoverageModulationTable" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCoverageModulationTable ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineCoverageModulationStateCreateInfoNV &p ) {
  to_json( j, PipelineCoverageModulationStateCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineCoverageModulationStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineCoverageModulationStateCreateInfoNV" );
  p.flags = j[ "flags" ];
  p.coverageModulationMode = j[ "coverageModulationMode" ];
  p.coverageModulationTableEnable = j[ "coverageModulationTableEnable" ];
  p.coverageModulationTableCount = j[ "coverageModulationTableCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineCoverageModulationStateCreateInfoNV &p ) {
  PipelineCoverageModulationStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineCoverageModulationStateCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineCoverageReductionStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "coverageReductionMode" ] = p.coverageReductionMode;
}
inline void to_json( nlohmann::json &j, const VkPipelineCoverageReductionStateCreateInfoNV &p ) {
  to_json( j, PipelineCoverageReductionStateCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineCoverageReductionStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineCoverageReductionStateCreateInfoNV" );
  p.flags = j[ "flags" ];
  p.coverageReductionMode = j[ "coverageReductionMode" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineCoverageReductionStateCreateInfoNV &p ) {
  PipelineCoverageReductionStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineCoverageReductionStateCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineCoverageToColorStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "coverageToColorEnable" ] = bool( p.coverageToColorEnable );
  j[ "coverageToColorLocation" ] = p.coverageToColorLocation;
}
inline void to_json( nlohmann::json &j, const VkPipelineCoverageToColorStateCreateInfoNV &p ) {
  to_json( j, PipelineCoverageToColorStateCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineCoverageToColorStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineCoverageToColorStateCreateInfoNV" );
  p.flags = j[ "flags" ];
  p.coverageToColorEnable = j[ "coverageToColorEnable" ];
  p.coverageToColorLocation = j[ "coverageToColorLocation" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineCoverageToColorStateCreateInfoNV &p ) {
  PipelineCoverageToColorStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineCoverageToColorStateCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineCreationFeedbackEXT &p ) {
  j = nlohmann::json::object();
  j[ "flags" ] = p.flags;
  j[ "duration" ] = p.duration;
}
inline void to_json( nlohmann::json &j, const VkPipelineCreationFeedbackEXT &p ) {
  to_json( j, PipelineCreationFeedbackEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineCreationFeedbackEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineCreationFeedbackEXT" );
  p.flags = j[ "flags" ];
  p.duration = j[ "duration" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineCreationFeedbackEXT &p ) {
  PipelineCreationFeedbackEXT temp;
  from_json( j, temp );
  p = VkPipelineCreationFeedbackEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineCreationFeedbackCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pPipelineCreationFeedback" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPipelineCreationFeedback ) );
  j[ "pipelineStageCreationFeedbackCount" ] = p.pipelineStageCreationFeedbackCount;
  j[ "pPipelineStageCreationFeedbacks" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPipelineStageCreationFeedbacks ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineCreationFeedbackCreateInfoEXT &p ) {
  to_json( j, PipelineCreationFeedbackCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineCreationFeedbackCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineCreationFeedbackCreateInfoEXT" );
  p.pipelineStageCreationFeedbackCount = j[ "pipelineStageCreationFeedbackCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineCreationFeedbackCreateInfoEXT &p ) {
  PipelineCreationFeedbackCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineCreationFeedbackCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineDiscardRectangleStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "discardRectangleMode" ] = p.discardRectangleMode;
  j[ "discardRectangleCount" ] = p.discardRectangleCount;
  j[ "pDiscardRectangles" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDiscardRectangles ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineDiscardRectangleStateCreateInfoEXT &p ) {
  to_json( j, PipelineDiscardRectangleStateCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineDiscardRectangleStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineDiscardRectangleStateCreateInfoEXT" );
  p.flags = j[ "flags" ];
  p.discardRectangleMode = j[ "discardRectangleMode" ];
  p.discardRectangleCount = j[ "discardRectangleCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineDiscardRectangleStateCreateInfoEXT &p ) {
  PipelineDiscardRectangleStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineDiscardRectangleStateCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineExecutableInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "executableIndex" ] = p.executableIndex;
}
inline void to_json( nlohmann::json &j, const VkPipelineExecutableInfoKHR &p ) {
  to_json( j, PipelineExecutableInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineExecutableInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineExecutableInfoKHR" );
  p.executableIndex = j[ "executableIndex" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineExecutableInfoKHR &p ) {
  PipelineExecutableInfoKHR temp;
  from_json( j, temp );
  p = VkPipelineExecutableInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineExecutableInternalRepresentationKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "name" ] = std::string( p.name.begin(), std::find( p.name.begin(), p.name.end(), '\0' ) );
  j[ "description" ] = std::string( p.description.begin(), std::find( p.description.begin(), p.description.end(), '\0' ) );
  j[ "isText" ] = bool( p.isText );
  j[ "dataSize" ] = p.dataSize;
  j[ "pData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pData ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineExecutableInternalRepresentationKHR &p ) {
  to_json( j, PipelineExecutableInternalRepresentationKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineExecutableInternalRepresentationKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineExecutableInternalRepresentationKHR" );
  {
    std::string s = j[ "name" ];
    if( !p.name.empty() ) {
      p.name[ p.name.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.name.size() - 1u ) ), p.name.begin() );
    }
  }
  {
    std::string s = j[ "description" ];
    if( !p.description.empty() ) {
      p.description[ p.description.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.description.size() - 1u ) ), p.description.begin() );
    }
  }
  p.isText = j[ "isText" ];
  p.dataSize = j[ "dataSize" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineExecutableInternalRepresentationKHR &p ) {
  PipelineExecutableInternalRepresentationKHR temp;
  from_json( j, temp );
  p = VkPipelineExecutableInternalRepresentationKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineExecutablePropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "stages" ] = p.stages;
  j[ "name" ] = std::string( p.name.begin(), std::find( p.name.begin(), p.name.end(), '\0' ) );
  j[ "description" ] = std::string( p.description.begin(), std::find( p.description.begin(), p.description.end(), '\0' ) );
  j[ "subgroupSize" ] = p.subgroupSize;
}
inline void to_json( nlohmann::json &j, const VkPipelineExecutablePropertiesKHR &p ) {
  to_json( j, PipelineExecutablePropertiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineExecutablePropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineExecutablePropertiesKHR" );
  p.stages = j[ "stages" ];
  {
    std::string s = j[ "name" ];
    if( !p.name.empty() ) {
      p.name[ p.name.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.name.size() - 1u ) ), p.name.begin() );
    }
  }
  {
    std::string s = j[ "description" ];
    if( !p.description.empty() ) {
      p.description[ p.description.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.description.size() - 1u ) ), p.description.begin() );
    }
  }
  p.subgroupSize = j[ "subgroupSize" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineExecutablePropertiesKHR &p ) {
  PipelineExecutablePropertiesKHR temp;
  from_json( j, temp );
  p = VkPipelineExecutablePropertiesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineExecutableStatisticKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "name" ] = std::string( p.name.begin(), std::find( p.name.begin(), p.name.end(), '\0' ) );
  j[ "description" ] = std::string( p.description.begin(), std::find( p.description.begin(), p.description.end(), '\0' ) );
  j[ "format" ] = p.format;
}
inline void to_json( nlohmann::json &j, const VkPipelineExecutableStatisticKHR &p ) {
  to_json( j, PipelineExecutableStatisticKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineExecutableStatisticKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineExecutableStatisticKHR" );
  {
    std::string s = j[ "name" ];
    if( !p.name.empty() ) {
      p.name[ p.name.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.name.size() - 1u ) ), p.name.begin() );
    }
  }
  {
    std::string s = j[ "description" ];
    if( !p.description.empty() ) {
      p.description[ p.description.size() - 1u ] = '\0';
      std::copy( s.begin(), std::next( s.begin(), std::min( s.size(), p.description.size() - 1u ) ), p.description.begin() );
    }
  }
  p.format = j[ "format" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineExecutableStatisticKHR &p ) {
  PipelineExecutableStatisticKHR temp;
  from_json( j, temp );
  p = VkPipelineExecutableStatisticKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineFragmentShadingRateEnumStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shadingRateType" ] = p.shadingRateType;
  j[ "shadingRate" ] = p.shadingRate;
  j[ "combinerOps" ] = nlohmann::json::array();
  std::copy( p.combinerOps.begin(), p.combinerOps.end(), std::back_inserter( j[ "combinerOps" ] ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineFragmentShadingRateEnumStateCreateInfoNV &p ) {
  to_json( j, PipelineFragmentShadingRateEnumStateCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineFragmentShadingRateEnumStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineFragmentShadingRateEnumStateCreateInfoNV" );
  p.shadingRateType = j[ "shadingRateType" ];
  p.shadingRate = j[ "shadingRate" ];
  if( !j[ "combinerOps" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PipelineFragmentShadingRateEnumStateCreateInfoNV.combinerOps" );
  if( !j[ "combinerOps" ].size() > p.combinerOps.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for PipelineFragmentShadingRateEnumStateCreateInfoNV.combinerOps" );
  std::fill( p.combinerOps.begin(), p.combinerOps.end(), std::remove_cv_t< std::remove_reference_t< decltype( *p.combinerOps.begin() ) > >() );
  std::copy( j[ "combinerOps" ].begin(), j[ "combinerOps" ].end(), p.combinerOps.begin() );
}
inline void from_json( const nlohmann::json &j, VkPipelineFragmentShadingRateEnumStateCreateInfoNV &p ) {
  PipelineFragmentShadingRateEnumStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineFragmentShadingRateEnumStateCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineFragmentShadingRateStateCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fragmentSize" ] = p.fragmentSize;
  j[ "combinerOps" ] = nlohmann::json::array();
  std::copy( p.combinerOps.begin(), p.combinerOps.end(), std::back_inserter( j[ "combinerOps" ] ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineFragmentShadingRateStateCreateInfoKHR &p ) {
  to_json( j, PipelineFragmentShadingRateStateCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineFragmentShadingRateStateCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineFragmentShadingRateStateCreateInfoKHR" );
  p.fragmentSize = j[ "fragmentSize" ];
  if( !j[ "combinerOps" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for PipelineFragmentShadingRateStateCreateInfoKHR.combinerOps" );
  if( !j[ "combinerOps" ].size() > p.combinerOps.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for PipelineFragmentShadingRateStateCreateInfoKHR.combinerOps" );
  std::fill( p.combinerOps.begin(), p.combinerOps.end(), std::remove_cv_t< std::remove_reference_t< decltype( *p.combinerOps.begin() ) > >() );
  std::copy( j[ "combinerOps" ].begin(), j[ "combinerOps" ].end(), p.combinerOps.begin() );
}
inline void from_json( const nlohmann::json &j, VkPipelineFragmentShadingRateStateCreateInfoKHR &p ) {
  PipelineFragmentShadingRateStateCreateInfoKHR temp;
  from_json( j, temp );
  p = VkPipelineFragmentShadingRateStateCreateInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineInfoKHR &p ) {
  to_json( j, PipelineInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineInfoKHR" );
}
inline void from_json( const nlohmann::json &j, VkPipelineInfoKHR &p ) {
  PipelineInfoKHR temp;
  from_json( j, temp );
  p = VkPipelineInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PushConstantRange &p ) {
  j = nlohmann::json::object();
  j[ "stageFlags" ] = p.stageFlags;
  j[ "offset" ] = p.offset;
  j[ "size" ] = p.size;
}
inline void to_json( nlohmann::json &j, const VkPushConstantRange &p ) {
  to_json( j, PushConstantRange ( p ) );
}
inline void from_json( const nlohmann::json &j, PushConstantRange &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PushConstantRange" );
  p.stageFlags = j[ "stageFlags" ];
  p.offset = j[ "offset" ];
  p.size = j[ "size" ];
}
inline void from_json( const nlohmann::json &j, VkPushConstantRange &p ) {
  PushConstantRange temp;
  from_json( j, temp );
  p = VkPushConstantRange ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineLayoutCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "setLayoutCount" ] = p.setLayoutCount;
  j[ "pSetLayouts" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSetLayouts ) );
  j[ "pushConstantRangeCount" ] = p.pushConstantRangeCount;
  j[ "pPushConstantRanges" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPushConstantRanges ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineLayoutCreateInfo &p ) {
  to_json( j, PipelineLayoutCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineLayoutCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineLayoutCreateInfo" );
  p.flags = j[ "flags" ];
  p.setLayoutCount = j[ "setLayoutCount" ];
  p.pushConstantRangeCount = j[ "pushConstantRangeCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineLayoutCreateInfo &p ) {
  PipelineLayoutCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineLayoutCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineLibraryCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "libraryCount" ] = p.libraryCount;
  j[ "pLibraries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pLibraries ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineLibraryCreateInfoKHR &p ) {
  to_json( j, PipelineLibraryCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineLibraryCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineLibraryCreateInfoKHR" );
  p.libraryCount = j[ "libraryCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineLibraryCreateInfoKHR &p ) {
  PipelineLibraryCreateInfoKHR temp;
  from_json( j, temp );
  p = VkPipelineLibraryCreateInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineRasterizationConservativeStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "conservativeRasterizationMode" ] = p.conservativeRasterizationMode;
  j[ "extraPrimitiveOverestimationSize" ] = p.extraPrimitiveOverestimationSize;
}
inline void to_json( nlohmann::json &j, const VkPipelineRasterizationConservativeStateCreateInfoEXT &p ) {
  to_json( j, PipelineRasterizationConservativeStateCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationConservativeStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRasterizationConservativeStateCreateInfoEXT" );
  p.flags = j[ "flags" ];
  p.conservativeRasterizationMode = j[ "conservativeRasterizationMode" ];
  p.extraPrimitiveOverestimationSize = j[ "extraPrimitiveOverestimationSize" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineRasterizationConservativeStateCreateInfoEXT &p ) {
  PipelineRasterizationConservativeStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineRasterizationConservativeStateCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineRasterizationDepthClipStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "depthClipEnable" ] = bool( p.depthClipEnable );
}
inline void to_json( nlohmann::json &j, const VkPipelineRasterizationDepthClipStateCreateInfoEXT &p ) {
  to_json( j, PipelineRasterizationDepthClipStateCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationDepthClipStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRasterizationDepthClipStateCreateInfoEXT" );
  p.flags = j[ "flags" ];
  p.depthClipEnable = j[ "depthClipEnable" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineRasterizationDepthClipStateCreateInfoEXT &p ) {
  PipelineRasterizationDepthClipStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineRasterizationDepthClipStateCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineRasterizationLineStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "lineRasterizationMode" ] = p.lineRasterizationMode;
  j[ "stippledLineEnable" ] = bool( p.stippledLineEnable );
  j[ "lineStippleFactor" ] = p.lineStippleFactor;
  j[ "lineStipplePattern" ] = p.lineStipplePattern;
}
inline void to_json( nlohmann::json &j, const VkPipelineRasterizationLineStateCreateInfoEXT &p ) {
  to_json( j, PipelineRasterizationLineStateCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationLineStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRasterizationLineStateCreateInfoEXT" );
  p.lineRasterizationMode = j[ "lineRasterizationMode" ];
  p.stippledLineEnable = j[ "stippledLineEnable" ];
  p.lineStippleFactor = j[ "lineStippleFactor" ];
  p.lineStipplePattern = j[ "lineStipplePattern" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineRasterizationLineStateCreateInfoEXT &p ) {
  PipelineRasterizationLineStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineRasterizationLineStateCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineRasterizationProvokingVertexStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "provokingVertexMode" ] = p.provokingVertexMode;
}
inline void to_json( nlohmann::json &j, const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT &p ) {
  to_json( j, PipelineRasterizationProvokingVertexStateCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationProvokingVertexStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRasterizationProvokingVertexStateCreateInfoEXT" );
  p.provokingVertexMode = j[ "provokingVertexMode" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineRasterizationProvokingVertexStateCreateInfoEXT &p ) {
  PipelineRasterizationProvokingVertexStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineRasterizationProvokingVertexStateCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineRasterizationStateRasterizationOrderAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "rasterizationOrder" ] = p.rasterizationOrder;
}
inline void to_json( nlohmann::json &j, const VkPipelineRasterizationStateRasterizationOrderAMD &p ) {
  to_json( j, PipelineRasterizationStateRasterizationOrderAMD ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationStateRasterizationOrderAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRasterizationStateRasterizationOrderAMD" );
  p.rasterizationOrder = j[ "rasterizationOrder" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineRasterizationStateRasterizationOrderAMD &p ) {
  PipelineRasterizationStateRasterizationOrderAMD temp;
  from_json( j, temp );
  p = VkPipelineRasterizationStateRasterizationOrderAMD ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineRasterizationStateStreamCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "rasterizationStream" ] = p.rasterizationStream;
}
inline void to_json( nlohmann::json &j, const VkPipelineRasterizationStateStreamCreateInfoEXT &p ) {
  to_json( j, PipelineRasterizationStateStreamCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineRasterizationStateStreamCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRasterizationStateStreamCreateInfoEXT" );
  p.flags = j[ "flags" ];
  p.rasterizationStream = j[ "rasterizationStream" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineRasterizationStateStreamCreateInfoEXT &p ) {
  PipelineRasterizationStateStreamCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineRasterizationStateStreamCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineRepresentativeFragmentTestStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "representativeFragmentTestEnable" ] = bool( p.representativeFragmentTestEnable );
}
inline void to_json( nlohmann::json &j, const VkPipelineRepresentativeFragmentTestStateCreateInfoNV &p ) {
  to_json( j, PipelineRepresentativeFragmentTestStateCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineRepresentativeFragmentTestStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineRepresentativeFragmentTestStateCreateInfoNV" );
  p.representativeFragmentTestEnable = j[ "representativeFragmentTestEnable" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineRepresentativeFragmentTestStateCreateInfoNV &p ) {
  PipelineRepresentativeFragmentTestStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineRepresentativeFragmentTestStateCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineSampleLocationsStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "sampleLocationsEnable" ] = bool( p.sampleLocationsEnable );
  j[ "sampleLocationsInfo" ] = p.sampleLocationsInfo;
}
inline void to_json( nlohmann::json &j, const VkPipelineSampleLocationsStateCreateInfoEXT &p ) {
  to_json( j, PipelineSampleLocationsStateCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineSampleLocationsStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineSampleLocationsStateCreateInfoEXT" );
  p.sampleLocationsEnable = j[ "sampleLocationsEnable" ];
  p.sampleLocationsInfo = j[ "sampleLocationsInfo" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineSampleLocationsStateCreateInfoEXT &p ) {
  PipelineSampleLocationsStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineSampleLocationsStateCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "requiredSubgroupSize" ] = p.requiredSubgroupSize;
}
inline void to_json( nlohmann::json &j, const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &p ) {
  to_json( j, PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT" );
  p.requiredSubgroupSize = j[ "requiredSubgroupSize" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &p ) {
  PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineTessellationDomainOriginStateCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "domainOrigin" ] = p.domainOrigin;
}
inline void to_json( nlohmann::json &j, const VkPipelineTessellationDomainOriginStateCreateInfo &p ) {
  to_json( j, PipelineTessellationDomainOriginStateCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineTessellationDomainOriginStateCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineTessellationDomainOriginStateCreateInfo" );
  p.domainOrigin = j[ "domainOrigin" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineTessellationDomainOriginStateCreateInfo &p ) {
  PipelineTessellationDomainOriginStateCreateInfo temp;
  from_json( j, temp );
  p = VkPipelineTessellationDomainOriginStateCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const VertexInputBindingDivisorDescriptionEXT &p ) {
  j = nlohmann::json::object();
  j[ "binding" ] = p.binding;
  j[ "divisor" ] = p.divisor;
}
inline void to_json( nlohmann::json &j, const VkVertexInputBindingDivisorDescriptionEXT &p ) {
  to_json( j, VertexInputBindingDivisorDescriptionEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VertexInputBindingDivisorDescriptionEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VertexInputBindingDivisorDescriptionEXT" );
  p.binding = j[ "binding" ];
  p.divisor = j[ "divisor" ];
}
inline void from_json( const nlohmann::json &j, VkVertexInputBindingDivisorDescriptionEXT &p ) {
  VertexInputBindingDivisorDescriptionEXT temp;
  from_json( j, temp );
  p = VkVertexInputBindingDivisorDescriptionEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineVertexInputDivisorStateCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "vertexBindingDivisorCount" ] = p.vertexBindingDivisorCount;
  j[ "pVertexBindingDivisors" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pVertexBindingDivisors ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineVertexInputDivisorStateCreateInfoEXT &p ) {
  to_json( j, PipelineVertexInputDivisorStateCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineVertexInputDivisorStateCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineVertexInputDivisorStateCreateInfoEXT" );
  p.vertexBindingDivisorCount = j[ "vertexBindingDivisorCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineVertexInputDivisorStateCreateInfoEXT &p ) {
  PipelineVertexInputDivisorStateCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPipelineVertexInputDivisorStateCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineViewportCoarseSampleOrderStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "sampleOrderType" ] = p.sampleOrderType;
  j[ "customSampleOrderCount" ] = p.customSampleOrderCount;
  j[ "pCustomSampleOrders" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCustomSampleOrders ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &p ) {
  to_json( j, PipelineViewportCoarseSampleOrderStateCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineViewportCoarseSampleOrderStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineViewportCoarseSampleOrderStateCreateInfoNV" );
  p.sampleOrderType = j[ "sampleOrderType" ];
  p.customSampleOrderCount = j[ "customSampleOrderCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &p ) {
  PipelineViewportCoarseSampleOrderStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineViewportCoarseSampleOrderStateCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineViewportExclusiveScissorStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "exclusiveScissorCount" ] = p.exclusiveScissorCount;
  j[ "pExclusiveScissors" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pExclusiveScissors ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineViewportExclusiveScissorStateCreateInfoNV &p ) {
  to_json( j, PipelineViewportExclusiveScissorStateCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineViewportExclusiveScissorStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineViewportExclusiveScissorStateCreateInfoNV" );
  p.exclusiveScissorCount = j[ "exclusiveScissorCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineViewportExclusiveScissorStateCreateInfoNV &p ) {
  PipelineViewportExclusiveScissorStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineViewportExclusiveScissorStateCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const ShadingRatePaletteNV &p ) {
  j = nlohmann::json::object();
  j[ "shadingRatePaletteEntryCount" ] = p.shadingRatePaletteEntryCount;
  j[ "pShadingRatePaletteEntries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pShadingRatePaletteEntries ) );
}
inline void to_json( nlohmann::json &j, const VkShadingRatePaletteNV &p ) {
  to_json( j, ShadingRatePaletteNV ( p ) );
}
inline void from_json( const nlohmann::json &j, ShadingRatePaletteNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ShadingRatePaletteNV" );
  p.shadingRatePaletteEntryCount = j[ "shadingRatePaletteEntryCount" ];
}
inline void from_json( const nlohmann::json &j, VkShadingRatePaletteNV &p ) {
  ShadingRatePaletteNV temp;
  from_json( j, temp );
  p = VkShadingRatePaletteNV ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineViewportShadingRateImageStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "shadingRateImageEnable" ] = bool( p.shadingRateImageEnable );
  j[ "viewportCount" ] = p.viewportCount;
  j[ "pShadingRatePalettes" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pShadingRatePalettes ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineViewportShadingRateImageStateCreateInfoNV &p ) {
  to_json( j, PipelineViewportShadingRateImageStateCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineViewportShadingRateImageStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineViewportShadingRateImageStateCreateInfoNV" );
  p.shadingRateImageEnable = j[ "shadingRateImageEnable" ];
  p.viewportCount = j[ "viewportCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineViewportShadingRateImageStateCreateInfoNV &p ) {
  PipelineViewportShadingRateImageStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineViewportShadingRateImageStateCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const ViewportSwizzleNV &p ) {
  j = nlohmann::json::object();
  j[ "x" ] = p.x;
  j[ "y" ] = p.y;
  j[ "z" ] = p.z;
  j[ "w" ] = p.w;
}
inline void to_json( nlohmann::json &j, const VkViewportSwizzleNV &p ) {
  to_json( j, ViewportSwizzleNV ( p ) );
}
inline void from_json( const nlohmann::json &j, ViewportSwizzleNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ViewportSwizzleNV" );
  p.x = j[ "x" ];
  p.y = j[ "y" ];
  p.z = j[ "z" ];
  p.w = j[ "w" ];
}
inline void from_json( const nlohmann::json &j, VkViewportSwizzleNV &p ) {
  ViewportSwizzleNV temp;
  from_json( j, temp );
  p = VkViewportSwizzleNV ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineViewportSwizzleStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "viewportCount" ] = p.viewportCount;
  j[ "pViewportSwizzles" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewportSwizzles ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineViewportSwizzleStateCreateInfoNV &p ) {
  to_json( j, PipelineViewportSwizzleStateCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineViewportSwizzleStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineViewportSwizzleStateCreateInfoNV" );
  p.flags = j[ "flags" ];
  p.viewportCount = j[ "viewportCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineViewportSwizzleStateCreateInfoNV &p ) {
  PipelineViewportSwizzleStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineViewportSwizzleStateCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const ViewportWScalingNV &p ) {
  j = nlohmann::json::object();
  j[ "xcoeff" ] = p.xcoeff;
  j[ "ycoeff" ] = p.ycoeff;
}
inline void to_json( nlohmann::json &j, const VkViewportWScalingNV &p ) {
  to_json( j, ViewportWScalingNV ( p ) );
}
inline void from_json( const nlohmann::json &j, ViewportWScalingNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ViewportWScalingNV" );
  p.xcoeff = j[ "xcoeff" ];
  p.ycoeff = j[ "ycoeff" ];
}
inline void from_json( const nlohmann::json &j, VkViewportWScalingNV &p ) {
  ViewportWScalingNV temp;
  from_json( j, temp );
  p = VkViewportWScalingNV ( temp );
}

inline void to_json( nlohmann::json &j, const PipelineViewportWScalingStateCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "viewportWScalingEnable" ] = bool( p.viewportWScalingEnable );
  j[ "viewportCount" ] = p.viewportCount;
  j[ "pViewportWScalings" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewportWScalings ) );
}
inline void to_json( nlohmann::json &j, const VkPipelineViewportWScalingStateCreateInfoNV &p ) {
  to_json( j, PipelineViewportWScalingStateCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, PipelineViewportWScalingStateCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PipelineViewportWScalingStateCreateInfoNV" );
  p.viewportWScalingEnable = j[ "viewportWScalingEnable" ];
  p.viewportCount = j[ "viewportCount" ];
}
inline void from_json( const nlohmann::json &j, VkPipelineViewportWScalingStateCreateInfoNV &p ) {
  PipelineViewportWScalingStateCreateInfoNV temp;
  from_json( j, temp );
  p = VkPipelineViewportWScalingStateCreateInfoNV ( temp );
}

#if defined( VK_USE_PLATFORM_GGP )
inline void to_json( nlohmann::json &j, const PresentFrameTokenGGP &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkPresentFrameTokenGGP &p ) {
  to_json( j, PresentFrameTokenGGP ( p ) );
}
inline void from_json( const nlohmann::json &j, PresentFrameTokenGGP &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PresentFrameTokenGGP" );
}
inline void from_json( const nlohmann::json &j, VkPresentFrameTokenGGP &p ) {
  PresentFrameTokenGGP temp;
  from_json( j, temp );
  p = VkPresentFrameTokenGGP ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const PresentInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "waitSemaphoreCount" ] = p.waitSemaphoreCount;
  j[ "pWaitSemaphores" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitSemaphores ) );
  j[ "swapchainCount" ] = p.swapchainCount;
  j[ "pSwapchains" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSwapchains ) );
  j[ "pImageIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pImageIndices ) );
  j[ "pResults" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pResults ) );
}
inline void to_json( nlohmann::json &j, const VkPresentInfoKHR &p ) {
  to_json( j, PresentInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PresentInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PresentInfoKHR" );
  p.waitSemaphoreCount = j[ "waitSemaphoreCount" ];
  p.swapchainCount = j[ "swapchainCount" ];
}
inline void from_json( const nlohmann::json &j, VkPresentInfoKHR &p ) {
  PresentInfoKHR temp;
  from_json( j, temp );
  p = VkPresentInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const RectLayerKHR &p ) {
  j = nlohmann::json::object();
  j[ "offset" ] = p.offset;
  j[ "extent" ] = p.extent;
  j[ "layer" ] = p.layer;
}
inline void to_json( nlohmann::json &j, const VkRectLayerKHR &p ) {
  to_json( j, RectLayerKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, RectLayerKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RectLayerKHR" );
  p.offset = j[ "offset" ];
  p.extent = j[ "extent" ];
  p.layer = j[ "layer" ];
}
inline void from_json( const nlohmann::json &j, VkRectLayerKHR &p ) {
  RectLayerKHR temp;
  from_json( j, temp );
  p = VkRectLayerKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PresentRegionKHR &p ) {
  j = nlohmann::json::object();
  j[ "rectangleCount" ] = p.rectangleCount;
  j[ "pRectangles" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRectangles ) );
}
inline void to_json( nlohmann::json &j, const VkPresentRegionKHR &p ) {
  to_json( j, PresentRegionKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PresentRegionKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PresentRegionKHR" );
  p.rectangleCount = j[ "rectangleCount" ];
}
inline void from_json( const nlohmann::json &j, VkPresentRegionKHR &p ) {
  PresentRegionKHR temp;
  from_json( j, temp );
  p = VkPresentRegionKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PresentRegionsKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "swapchainCount" ] = p.swapchainCount;
  j[ "pRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRegions ) );
}
inline void to_json( nlohmann::json &j, const VkPresentRegionsKHR &p ) {
  to_json( j, PresentRegionsKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, PresentRegionsKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PresentRegionsKHR" );
  p.swapchainCount = j[ "swapchainCount" ];
}
inline void from_json( const nlohmann::json &j, VkPresentRegionsKHR &p ) {
  PresentRegionsKHR temp;
  from_json( j, temp );
  p = VkPresentRegionsKHR ( temp );
}

inline void to_json( nlohmann::json &j, const PresentTimeGOOGLE &p ) {
  j = nlohmann::json::object();
  j[ "presentID" ] = p.presentID;
  j[ "desiredPresentTime" ] = p.desiredPresentTime;
}
inline void to_json( nlohmann::json &j, const VkPresentTimeGOOGLE &p ) {
  to_json( j, PresentTimeGOOGLE ( p ) );
}
inline void from_json( const nlohmann::json &j, PresentTimeGOOGLE &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PresentTimeGOOGLE" );
  p.presentID = j[ "presentID" ];
  p.desiredPresentTime = j[ "desiredPresentTime" ];
}
inline void from_json( const nlohmann::json &j, VkPresentTimeGOOGLE &p ) {
  PresentTimeGOOGLE temp;
  from_json( j, temp );
  p = VkPresentTimeGOOGLE ( temp );
}

inline void to_json( nlohmann::json &j, const PresentTimesInfoGOOGLE &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "swapchainCount" ] = p.swapchainCount;
  j[ "pTimes" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pTimes ) );
}
inline void to_json( nlohmann::json &j, const VkPresentTimesInfoGOOGLE &p ) {
  to_json( j, PresentTimesInfoGOOGLE ( p ) );
}
inline void from_json( const nlohmann::json &j, PresentTimesInfoGOOGLE &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PresentTimesInfoGOOGLE" );
  p.swapchainCount = j[ "swapchainCount" ];
}
inline void from_json( const nlohmann::json &j, VkPresentTimesInfoGOOGLE &p ) {
  PresentTimesInfoGOOGLE temp;
  from_json( j, temp );
  p = VkPresentTimesInfoGOOGLE ( temp );
}

inline void to_json( nlohmann::json &j, const PrivateDataSlotCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkPrivateDataSlotCreateInfoEXT &p ) {
  to_json( j, PrivateDataSlotCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, PrivateDataSlotCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for PrivateDataSlotCreateInfoEXT" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkPrivateDataSlotCreateInfoEXT &p ) {
  PrivateDataSlotCreateInfoEXT temp;
  from_json( j, temp );
  p = VkPrivateDataSlotCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const ProtectedSubmitInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "protectedSubmit" ] = bool( p.protectedSubmit );
}
inline void to_json( nlohmann::json &j, const VkProtectedSubmitInfo &p ) {
  to_json( j, ProtectedSubmitInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ProtectedSubmitInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ProtectedSubmitInfo" );
  p.protectedSubmit = j[ "protectedSubmit" ];
}
inline void from_json( const nlohmann::json &j, VkProtectedSubmitInfo &p ) {
  ProtectedSubmitInfo temp;
  from_json( j, temp );
  p = VkProtectedSubmitInfo ( temp );
}

inline void to_json( nlohmann::json &j, const QueryPoolCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "queryType" ] = p.queryType;
  j[ "queryCount" ] = p.queryCount;
  j[ "pipelineStatistics" ] = p.pipelineStatistics;
}
inline void to_json( nlohmann::json &j, const VkQueryPoolCreateInfo &p ) {
  to_json( j, QueryPoolCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, QueryPoolCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueryPoolCreateInfo" );
  p.flags = j[ "flags" ];
  p.queryType = j[ "queryType" ];
  p.queryCount = j[ "queryCount" ];
  p.pipelineStatistics = j[ "pipelineStatistics" ];
}
inline void from_json( const nlohmann::json &j, VkQueryPoolCreateInfo &p ) {
  QueryPoolCreateInfo temp;
  from_json( j, temp );
  p = VkQueryPoolCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const QueryPoolPerformanceCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "queueFamilyIndex" ] = p.queueFamilyIndex;
  j[ "counterIndexCount" ] = p.counterIndexCount;
  j[ "pCounterIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCounterIndices ) );
}
inline void to_json( nlohmann::json &j, const VkQueryPoolPerformanceCreateInfoKHR &p ) {
  to_json( j, QueryPoolPerformanceCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, QueryPoolPerformanceCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueryPoolPerformanceCreateInfoKHR" );
  p.queueFamilyIndex = j[ "queueFamilyIndex" ];
  p.counterIndexCount = j[ "counterIndexCount" ];
}
inline void from_json( const nlohmann::json &j, VkQueryPoolPerformanceCreateInfoKHR &p ) {
  QueryPoolPerformanceCreateInfoKHR temp;
  from_json( j, temp );
  p = VkQueryPoolPerformanceCreateInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const QueryPoolPerformanceQueryCreateInfoINTEL &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "performanceCountersSampling" ] = p.performanceCountersSampling;
}
inline void to_json( nlohmann::json &j, const VkQueryPoolPerformanceQueryCreateInfoINTEL &p ) {
  to_json( j, QueryPoolPerformanceQueryCreateInfoINTEL ( p ) );
}
inline void from_json( const nlohmann::json &j, QueryPoolPerformanceQueryCreateInfoINTEL &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueryPoolPerformanceQueryCreateInfoINTEL" );
  p.performanceCountersSampling = j[ "performanceCountersSampling" ];
}
inline void from_json( const nlohmann::json &j, VkQueryPoolPerformanceQueryCreateInfoINTEL &p ) {
  QueryPoolPerformanceQueryCreateInfoINTEL temp;
  from_json( j, temp );
  p = VkQueryPoolPerformanceQueryCreateInfoINTEL ( temp );
}

inline void to_json( nlohmann::json &j, const QueueFamilyCheckpointProperties2NV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "checkpointExecutionStageMask" ] = p.checkpointExecutionStageMask;
}
inline void to_json( nlohmann::json &j, const VkQueueFamilyCheckpointProperties2NV &p ) {
  to_json( j, QueueFamilyCheckpointProperties2NV ( p ) );
}
inline void from_json( const nlohmann::json &j, QueueFamilyCheckpointProperties2NV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueueFamilyCheckpointProperties2NV" );
  p.checkpointExecutionStageMask = j[ "checkpointExecutionStageMask" ];
}
inline void from_json( const nlohmann::json &j, VkQueueFamilyCheckpointProperties2NV &p ) {
  QueueFamilyCheckpointProperties2NV temp;
  from_json( j, temp );
  p = VkQueueFamilyCheckpointProperties2NV ( temp );
}

inline void to_json( nlohmann::json &j, const QueueFamilyCheckpointPropertiesNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "checkpointExecutionStageMask" ] = p.checkpointExecutionStageMask;
}
inline void to_json( nlohmann::json &j, const VkQueueFamilyCheckpointPropertiesNV &p ) {
  to_json( j, QueueFamilyCheckpointPropertiesNV ( p ) );
}
inline void from_json( const nlohmann::json &j, QueueFamilyCheckpointPropertiesNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueueFamilyCheckpointPropertiesNV" );
  p.checkpointExecutionStageMask = j[ "checkpointExecutionStageMask" ];
}
inline void from_json( const nlohmann::json &j, VkQueueFamilyCheckpointPropertiesNV &p ) {
  QueueFamilyCheckpointPropertiesNV temp;
  from_json( j, temp );
  p = VkQueueFamilyCheckpointPropertiesNV ( temp );
}

inline void to_json( nlohmann::json &j, const QueueFamilyGlobalPriorityPropertiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "priorityCount" ] = p.priorityCount;
  j[ "priorities" ] = nlohmann::json::array();
  std::copy( p.priorities.begin(), p.priorities.end(), std::back_inserter( j[ "priorities" ] ) );
}
inline void to_json( nlohmann::json &j, const VkQueueFamilyGlobalPriorityPropertiesEXT &p ) {
  to_json( j, QueueFamilyGlobalPriorityPropertiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, QueueFamilyGlobalPriorityPropertiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueueFamilyGlobalPriorityPropertiesEXT" );
  p.priorityCount = j[ "priorityCount" ];
  if( !j[ "priorities" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for QueueFamilyGlobalPriorityPropertiesEXT.priorities" );
  if( !j[ "priorities" ].size() > p.priorities.size() ) throw vulkan2json::invalid_array_value(  "too many values in array for QueueFamilyGlobalPriorityPropertiesEXT.priorities" );
  std::fill( p.priorities.begin(), p.priorities.end(), std::remove_cv_t< std::remove_reference_t< decltype( *p.priorities.begin() ) > >() );
  std::copy( j[ "priorities" ].begin(), j[ "priorities" ].end(), p.priorities.begin() );
}
inline void from_json( const nlohmann::json &j, VkQueueFamilyGlobalPriorityPropertiesEXT &p ) {
  QueueFamilyGlobalPriorityPropertiesEXT temp;
  from_json( j, temp );
  p = VkQueueFamilyGlobalPriorityPropertiesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const QueueFamilyProperties &p ) {
  j = nlohmann::json::object();
  j[ "queueFlags" ] = p.queueFlags;
  j[ "queueCount" ] = p.queueCount;
  j[ "timestampValidBits" ] = p.timestampValidBits;
  j[ "minImageTransferGranularity" ] = p.minImageTransferGranularity;
}
inline void to_json( nlohmann::json &j, const VkQueueFamilyProperties &p ) {
  to_json( j, QueueFamilyProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, QueueFamilyProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueueFamilyProperties" );
  p.queueFlags = j[ "queueFlags" ];
  p.queueCount = j[ "queueCount" ];
  p.timestampValidBits = j[ "timestampValidBits" ];
  p.minImageTransferGranularity = j[ "minImageTransferGranularity" ];
}
inline void from_json( const nlohmann::json &j, VkQueueFamilyProperties &p ) {
  QueueFamilyProperties temp;
  from_json( j, temp );
  p = VkQueueFamilyProperties ( temp );
}

inline void to_json( nlohmann::json &j, const QueueFamilyProperties2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "queueFamilyProperties" ] = p.queueFamilyProperties;
}
inline void to_json( nlohmann::json &j, const VkQueueFamilyProperties2 &p ) {
  to_json( j, QueueFamilyProperties2 ( p ) );
}
inline void from_json( const nlohmann::json &j, QueueFamilyProperties2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for QueueFamilyProperties2" );
  p.queueFamilyProperties = j[ "queueFamilyProperties" ];
}
inline void from_json( const nlohmann::json &j, VkQueueFamilyProperties2 &p ) {
  QueueFamilyProperties2 temp;
  from_json( j, temp );
  p = VkQueueFamilyProperties2 ( temp );
}

inline void to_json( nlohmann::json &j, const RayTracingShaderGroupCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "type" ] = p.type;
  j[ "generalShader" ] = p.generalShader;
  j[ "closestHitShader" ] = p.closestHitShader;
  j[ "anyHitShader" ] = p.anyHitShader;
  j[ "intersectionShader" ] = p.intersectionShader;
  j[ "pShaderGroupCaptureReplayHandle" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pShaderGroupCaptureReplayHandle ) );
}
inline void to_json( nlohmann::json &j, const VkRayTracingShaderGroupCreateInfoKHR &p ) {
  to_json( j, RayTracingShaderGroupCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, RayTracingShaderGroupCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RayTracingShaderGroupCreateInfoKHR" );
  p.type = j[ "type" ];
  p.generalShader = j[ "generalShader" ];
  p.closestHitShader = j[ "closestHitShader" ];
  p.anyHitShader = j[ "anyHitShader" ];
  p.intersectionShader = j[ "intersectionShader" ];
}
inline void from_json( const nlohmann::json &j, VkRayTracingShaderGroupCreateInfoKHR &p ) {
  RayTracingShaderGroupCreateInfoKHR temp;
  from_json( j, temp );
  p = VkRayTracingShaderGroupCreateInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const RayTracingPipelineInterfaceCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxPipelineRayPayloadSize" ] = p.maxPipelineRayPayloadSize;
  j[ "maxPipelineRayHitAttributeSize" ] = p.maxPipelineRayHitAttributeSize;
}
inline void to_json( nlohmann::json &j, const VkRayTracingPipelineInterfaceCreateInfoKHR &p ) {
  to_json( j, RayTracingPipelineInterfaceCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, RayTracingPipelineInterfaceCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RayTracingPipelineInterfaceCreateInfoKHR" );
  p.maxPipelineRayPayloadSize = j[ "maxPipelineRayPayloadSize" ];
  p.maxPipelineRayHitAttributeSize = j[ "maxPipelineRayHitAttributeSize" ];
}
inline void from_json( const nlohmann::json &j, VkRayTracingPipelineInterfaceCreateInfoKHR &p ) {
  RayTracingPipelineInterfaceCreateInfoKHR temp;
  from_json( j, temp );
  p = VkRayTracingPipelineInterfaceCreateInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const RayTracingPipelineCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "stageCount" ] = p.stageCount;
  j[ "pStages" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStages ) );
  j[ "groupCount" ] = p.groupCount;
  j[ "pGroups" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pGroups ) );
  j[ "maxPipelineRayRecursionDepth" ] = p.maxPipelineRayRecursionDepth;
  j[ "pLibraryInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pLibraryInfo ) );
  j[ "pLibraryInterface" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pLibraryInterface ) );
  j[ "pDynamicState" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDynamicState ) );
  j[ "basePipelineIndex" ] = p.basePipelineIndex;
}
inline void to_json( nlohmann::json &j, const VkRayTracingPipelineCreateInfoKHR &p ) {
  to_json( j, RayTracingPipelineCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, RayTracingPipelineCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RayTracingPipelineCreateInfoKHR" );
  p.flags = j[ "flags" ];
  p.stageCount = j[ "stageCount" ];
  p.groupCount = j[ "groupCount" ];
  p.maxPipelineRayRecursionDepth = j[ "maxPipelineRayRecursionDepth" ];
  p.basePipelineIndex = j[ "basePipelineIndex" ];
}
inline void from_json( const nlohmann::json &j, VkRayTracingPipelineCreateInfoKHR &p ) {
  RayTracingPipelineCreateInfoKHR temp;
  from_json( j, temp );
  p = VkRayTracingPipelineCreateInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const RayTracingShaderGroupCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "type" ] = p.type;
  j[ "generalShader" ] = p.generalShader;
  j[ "closestHitShader" ] = p.closestHitShader;
  j[ "anyHitShader" ] = p.anyHitShader;
  j[ "intersectionShader" ] = p.intersectionShader;
}
inline void to_json( nlohmann::json &j, const VkRayTracingShaderGroupCreateInfoNV &p ) {
  to_json( j, RayTracingShaderGroupCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, RayTracingShaderGroupCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RayTracingShaderGroupCreateInfoNV" );
  p.type = j[ "type" ];
  p.generalShader = j[ "generalShader" ];
  p.closestHitShader = j[ "closestHitShader" ];
  p.anyHitShader = j[ "anyHitShader" ];
  p.intersectionShader = j[ "intersectionShader" ];
}
inline void from_json( const nlohmann::json &j, VkRayTracingShaderGroupCreateInfoNV &p ) {
  RayTracingShaderGroupCreateInfoNV temp;
  from_json( j, temp );
  p = VkRayTracingShaderGroupCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const RayTracingPipelineCreateInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "stageCount" ] = p.stageCount;
  j[ "pStages" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStages ) );
  j[ "groupCount" ] = p.groupCount;
  j[ "pGroups" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pGroups ) );
  j[ "maxRecursionDepth" ] = p.maxRecursionDepth;
  j[ "basePipelineIndex" ] = p.basePipelineIndex;
}
inline void to_json( nlohmann::json &j, const VkRayTracingPipelineCreateInfoNV &p ) {
  to_json( j, RayTracingPipelineCreateInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, RayTracingPipelineCreateInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RayTracingPipelineCreateInfoNV" );
  p.flags = j[ "flags" ];
  p.stageCount = j[ "stageCount" ];
  p.groupCount = j[ "groupCount" ];
  p.maxRecursionDepth = j[ "maxRecursionDepth" ];
  p.basePipelineIndex = j[ "basePipelineIndex" ];
}
inline void from_json( const nlohmann::json &j, VkRayTracingPipelineCreateInfoNV &p ) {
  RayTracingPipelineCreateInfoNV temp;
  from_json( j, temp );
  p = VkRayTracingPipelineCreateInfoNV ( temp );
}

inline void to_json( nlohmann::json &j, const RefreshCycleDurationGOOGLE &p ) {
  j = nlohmann::json::object();
  j[ "refreshDuration" ] = p.refreshDuration;
}
inline void to_json( nlohmann::json &j, const VkRefreshCycleDurationGOOGLE &p ) {
  to_json( j, RefreshCycleDurationGOOGLE ( p ) );
}
inline void from_json( const nlohmann::json &j, RefreshCycleDurationGOOGLE &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RefreshCycleDurationGOOGLE" );
  p.refreshDuration = j[ "refreshDuration" ];
}
inline void from_json( const nlohmann::json &j, VkRefreshCycleDurationGOOGLE &p ) {
  RefreshCycleDurationGOOGLE temp;
  from_json( j, temp );
  p = VkRefreshCycleDurationGOOGLE ( temp );
}

inline void to_json( nlohmann::json &j, const RenderPassAttachmentBeginInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "attachmentCount" ] = p.attachmentCount;
  j[ "pAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttachments ) );
}
inline void to_json( nlohmann::json &j, const VkRenderPassAttachmentBeginInfo &p ) {
  to_json( j, RenderPassAttachmentBeginInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, RenderPassAttachmentBeginInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassAttachmentBeginInfo" );
  p.attachmentCount = j[ "attachmentCount" ];
}
inline void from_json( const nlohmann::json &j, VkRenderPassAttachmentBeginInfo &p ) {
  RenderPassAttachmentBeginInfo temp;
  from_json( j, temp );
  p = VkRenderPassAttachmentBeginInfo ( temp );
}

inline void to_json( nlohmann::json &j, const RenderPassBeginInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "renderArea" ] = p.renderArea;
  j[ "clearValueCount" ] = p.clearValueCount;
  j[ "pClearValues" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pClearValues ) );
}
inline void to_json( nlohmann::json &j, const VkRenderPassBeginInfo &p ) {
  to_json( j, RenderPassBeginInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, RenderPassBeginInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassBeginInfo" );
  p.renderArea = j[ "renderArea" ];
  p.clearValueCount = j[ "clearValueCount" ];
}
inline void from_json( const nlohmann::json &j, VkRenderPassBeginInfo &p ) {
  RenderPassBeginInfo temp;
  from_json( j, temp );
  p = VkRenderPassBeginInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SubpassDescription &p ) {
  j = nlohmann::json::object();
  j[ "flags" ] = p.flags;
  j[ "pipelineBindPoint" ] = p.pipelineBindPoint;
  j[ "inputAttachmentCount" ] = p.inputAttachmentCount;
  j[ "pInputAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pInputAttachments ) );
  j[ "colorAttachmentCount" ] = p.colorAttachmentCount;
  j[ "pColorAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pColorAttachments ) );
  j[ "pResolveAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pResolveAttachments ) );
  j[ "pDepthStencilAttachment" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDepthStencilAttachment ) );
  j[ "preserveAttachmentCount" ] = p.preserveAttachmentCount;
  j[ "pPreserveAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPreserveAttachments ) );
}
inline void to_json( nlohmann::json &j, const VkSubpassDescription &p ) {
  to_json( j, SubpassDescription ( p ) );
}
inline void from_json( const nlohmann::json &j, SubpassDescription &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassDescription" );
  p.flags = j[ "flags" ];
  p.pipelineBindPoint = j[ "pipelineBindPoint" ];
  p.inputAttachmentCount = j[ "inputAttachmentCount" ];
  p.colorAttachmentCount = j[ "colorAttachmentCount" ];
  p.preserveAttachmentCount = j[ "preserveAttachmentCount" ];
}
inline void from_json( const nlohmann::json &j, VkSubpassDescription &p ) {
  SubpassDescription temp;
  from_json( j, temp );
  p = VkSubpassDescription ( temp );
}

inline void to_json( nlohmann::json &j, const SubpassDependency &p ) {
  j = nlohmann::json::object();
  j[ "srcSubpass" ] = p.srcSubpass;
  j[ "dstSubpass" ] = p.dstSubpass;
  j[ "srcStageMask" ] = p.srcStageMask;
  j[ "dstStageMask" ] = p.dstStageMask;
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
  j[ "dependencyFlags" ] = p.dependencyFlags;
}
inline void to_json( nlohmann::json &j, const VkSubpassDependency &p ) {
  to_json( j, SubpassDependency ( p ) );
}
inline void from_json( const nlohmann::json &j, SubpassDependency &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassDependency" );
  p.srcSubpass = j[ "srcSubpass" ];
  p.dstSubpass = j[ "dstSubpass" ];
  p.srcStageMask = j[ "srcStageMask" ];
  p.dstStageMask = j[ "dstStageMask" ];
  p.srcAccessMask = j[ "srcAccessMask" ];
  p.dstAccessMask = j[ "dstAccessMask" ];
  p.dependencyFlags = j[ "dependencyFlags" ];
}
inline void from_json( const nlohmann::json &j, VkSubpassDependency &p ) {
  SubpassDependency temp;
  from_json( j, temp );
  p = VkSubpassDependency ( temp );
}

inline void to_json( nlohmann::json &j, const RenderPassCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "attachmentCount" ] = p.attachmentCount;
  j[ "pAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttachments ) );
  j[ "subpassCount" ] = p.subpassCount;
  j[ "pSubpasses" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSubpasses ) );
  j[ "dependencyCount" ] = p.dependencyCount;
  j[ "pDependencies" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDependencies ) );
}
inline void to_json( nlohmann::json &j, const VkRenderPassCreateInfo &p ) {
  to_json( j, RenderPassCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, RenderPassCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassCreateInfo" );
  p.flags = j[ "flags" ];
  p.attachmentCount = j[ "attachmentCount" ];
  p.subpassCount = j[ "subpassCount" ];
  p.dependencyCount = j[ "dependencyCount" ];
}
inline void from_json( const nlohmann::json &j, VkRenderPassCreateInfo &p ) {
  RenderPassCreateInfo temp;
  from_json( j, temp );
  p = VkRenderPassCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SubpassDescription2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pipelineBindPoint" ] = p.pipelineBindPoint;
  j[ "viewMask" ] = p.viewMask;
  j[ "inputAttachmentCount" ] = p.inputAttachmentCount;
  j[ "pInputAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pInputAttachments ) );
  j[ "colorAttachmentCount" ] = p.colorAttachmentCount;
  j[ "pColorAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pColorAttachments ) );
  j[ "pResolveAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pResolveAttachments ) );
  j[ "pDepthStencilAttachment" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDepthStencilAttachment ) );
  j[ "preserveAttachmentCount" ] = p.preserveAttachmentCount;
  j[ "pPreserveAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPreserveAttachments ) );
}
inline void to_json( nlohmann::json &j, const VkSubpassDescription2 &p ) {
  to_json( j, SubpassDescription2 ( p ) );
}
inline void from_json( const nlohmann::json &j, SubpassDescription2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassDescription2" );
  p.flags = j[ "flags" ];
  p.pipelineBindPoint = j[ "pipelineBindPoint" ];
  p.viewMask = j[ "viewMask" ];
  p.inputAttachmentCount = j[ "inputAttachmentCount" ];
  p.colorAttachmentCount = j[ "colorAttachmentCount" ];
  p.preserveAttachmentCount = j[ "preserveAttachmentCount" ];
}
inline void from_json( const nlohmann::json &j, VkSubpassDescription2 &p ) {
  SubpassDescription2 temp;
  from_json( j, temp );
  p = VkSubpassDescription2 ( temp );
}

inline void to_json( nlohmann::json &j, const SubpassDependency2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcSubpass" ] = p.srcSubpass;
  j[ "dstSubpass" ] = p.dstSubpass;
  j[ "srcStageMask" ] = p.srcStageMask;
  j[ "dstStageMask" ] = p.dstStageMask;
  j[ "srcAccessMask" ] = p.srcAccessMask;
  j[ "dstAccessMask" ] = p.dstAccessMask;
  j[ "dependencyFlags" ] = p.dependencyFlags;
  j[ "viewOffset" ] = p.viewOffset;
}
inline void to_json( nlohmann::json &j, const VkSubpassDependency2 &p ) {
  to_json( j, SubpassDependency2 ( p ) );
}
inline void from_json( const nlohmann::json &j, SubpassDependency2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassDependency2" );
  p.srcSubpass = j[ "srcSubpass" ];
  p.dstSubpass = j[ "dstSubpass" ];
  p.srcStageMask = j[ "srcStageMask" ];
  p.dstStageMask = j[ "dstStageMask" ];
  p.srcAccessMask = j[ "srcAccessMask" ];
  p.dstAccessMask = j[ "dstAccessMask" ];
  p.dependencyFlags = j[ "dependencyFlags" ];
  p.viewOffset = j[ "viewOffset" ];
}
inline void from_json( const nlohmann::json &j, VkSubpassDependency2 &p ) {
  SubpassDependency2 temp;
  from_json( j, temp );
  p = VkSubpassDependency2 ( temp );
}

inline void to_json( nlohmann::json &j, const RenderPassCreateInfo2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "attachmentCount" ] = p.attachmentCount;
  j[ "pAttachments" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttachments ) );
  j[ "subpassCount" ] = p.subpassCount;
  j[ "pSubpasses" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSubpasses ) );
  j[ "dependencyCount" ] = p.dependencyCount;
  j[ "pDependencies" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDependencies ) );
  j[ "correlatedViewMaskCount" ] = p.correlatedViewMaskCount;
  j[ "pCorrelatedViewMasks" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCorrelatedViewMasks ) );
}
inline void to_json( nlohmann::json &j, const VkRenderPassCreateInfo2 &p ) {
  to_json( j, RenderPassCreateInfo2 ( p ) );
}
inline void from_json( const nlohmann::json &j, RenderPassCreateInfo2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassCreateInfo2" );
  p.flags = j[ "flags" ];
  p.attachmentCount = j[ "attachmentCount" ];
  p.subpassCount = j[ "subpassCount" ];
  p.dependencyCount = j[ "dependencyCount" ];
  p.correlatedViewMaskCount = j[ "correlatedViewMaskCount" ];
}
inline void from_json( const nlohmann::json &j, VkRenderPassCreateInfo2 &p ) {
  RenderPassCreateInfo2 temp;
  from_json( j, temp );
  p = VkRenderPassCreateInfo2 ( temp );
}

inline void to_json( nlohmann::json &j, const RenderPassFragmentDensityMapCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fragmentDensityMapAttachment" ] = p.fragmentDensityMapAttachment;
}
inline void to_json( nlohmann::json &j, const VkRenderPassFragmentDensityMapCreateInfoEXT &p ) {
  to_json( j, RenderPassFragmentDensityMapCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, RenderPassFragmentDensityMapCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassFragmentDensityMapCreateInfoEXT" );
  p.fragmentDensityMapAttachment = j[ "fragmentDensityMapAttachment" ];
}
inline void from_json( const nlohmann::json &j, VkRenderPassFragmentDensityMapCreateInfoEXT &p ) {
  RenderPassFragmentDensityMapCreateInfoEXT temp;
  from_json( j, temp );
  p = VkRenderPassFragmentDensityMapCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const RenderPassInputAttachmentAspectCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "aspectReferenceCount" ] = p.aspectReferenceCount;
  j[ "pAspectReferences" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAspectReferences ) );
}
inline void to_json( nlohmann::json &j, const VkRenderPassInputAttachmentAspectCreateInfo &p ) {
  to_json( j, RenderPassInputAttachmentAspectCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, RenderPassInputAttachmentAspectCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassInputAttachmentAspectCreateInfo" );
  p.aspectReferenceCount = j[ "aspectReferenceCount" ];
}
inline void from_json( const nlohmann::json &j, VkRenderPassInputAttachmentAspectCreateInfo &p ) {
  RenderPassInputAttachmentAspectCreateInfo temp;
  from_json( j, temp );
  p = VkRenderPassInputAttachmentAspectCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const RenderPassMultiviewCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "subpassCount" ] = p.subpassCount;
  j[ "pViewMasks" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewMasks ) );
  j[ "dependencyCount" ] = p.dependencyCount;
  j[ "pViewOffsets" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pViewOffsets ) );
  j[ "correlationMaskCount" ] = p.correlationMaskCount;
  j[ "pCorrelationMasks" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCorrelationMasks ) );
}
inline void to_json( nlohmann::json &j, const VkRenderPassMultiviewCreateInfo &p ) {
  to_json( j, RenderPassMultiviewCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, RenderPassMultiviewCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassMultiviewCreateInfo" );
  p.subpassCount = j[ "subpassCount" ];
  p.dependencyCount = j[ "dependencyCount" ];
  p.correlationMaskCount = j[ "correlationMaskCount" ];
}
inline void from_json( const nlohmann::json &j, VkRenderPassMultiviewCreateInfo &p ) {
  RenderPassMultiviewCreateInfo temp;
  from_json( j, temp );
  p = VkRenderPassMultiviewCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SubpassSampleLocationsEXT &p ) {
  j = nlohmann::json::object();
  j[ "subpassIndex" ] = p.subpassIndex;
  j[ "sampleLocationsInfo" ] = p.sampleLocationsInfo;
}
inline void to_json( nlohmann::json &j, const VkSubpassSampleLocationsEXT &p ) {
  to_json( j, SubpassSampleLocationsEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, SubpassSampleLocationsEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassSampleLocationsEXT" );
  p.subpassIndex = j[ "subpassIndex" ];
  p.sampleLocationsInfo = j[ "sampleLocationsInfo" ];
}
inline void from_json( const nlohmann::json &j, VkSubpassSampleLocationsEXT &p ) {
  SubpassSampleLocationsEXT temp;
  from_json( j, temp );
  p = VkSubpassSampleLocationsEXT ( temp );
}

inline void to_json( nlohmann::json &j, const RenderPassSampleLocationsBeginInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "attachmentInitialSampleLocationsCount" ] = p.attachmentInitialSampleLocationsCount;
  j[ "pAttachmentInitialSampleLocations" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAttachmentInitialSampleLocations ) );
  j[ "postSubpassSampleLocationsCount" ] = p.postSubpassSampleLocationsCount;
  j[ "pPostSubpassSampleLocations" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPostSubpassSampleLocations ) );
}
inline void to_json( nlohmann::json &j, const VkRenderPassSampleLocationsBeginInfoEXT &p ) {
  to_json( j, RenderPassSampleLocationsBeginInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, RenderPassSampleLocationsBeginInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassSampleLocationsBeginInfoEXT" );
  p.attachmentInitialSampleLocationsCount = j[ "attachmentInitialSampleLocationsCount" ];
  p.postSubpassSampleLocationsCount = j[ "postSubpassSampleLocationsCount" ];
}
inline void from_json( const nlohmann::json &j, VkRenderPassSampleLocationsBeginInfoEXT &p ) {
  RenderPassSampleLocationsBeginInfoEXT temp;
  from_json( j, temp );
  p = VkRenderPassSampleLocationsBeginInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const RenderPassTransformBeginInfoQCOM &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "transform" ] = p.transform;
}
inline void to_json( nlohmann::json &j, const VkRenderPassTransformBeginInfoQCOM &p ) {
  to_json( j, RenderPassTransformBeginInfoQCOM ( p ) );
}
inline void from_json( const nlohmann::json &j, RenderPassTransformBeginInfoQCOM &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for RenderPassTransformBeginInfoQCOM" );
  p.transform = j[ "transform" ];
}
inline void from_json( const nlohmann::json &j, VkRenderPassTransformBeginInfoQCOM &p ) {
  RenderPassTransformBeginInfoQCOM temp;
  from_json( j, temp );
  p = VkRenderPassTransformBeginInfoQCOM ( temp );
}

inline void to_json( nlohmann::json &j, const ResolveImageInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "srcImageLayout" ] = p.srcImageLayout;
  j[ "dstImageLayout" ] = p.dstImageLayout;
  j[ "regionCount" ] = p.regionCount;
  j[ "pRegions" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRegions ) );
}
inline void to_json( nlohmann::json &j, const VkResolveImageInfo2KHR &p ) {
  to_json( j, ResolveImageInfo2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, ResolveImageInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ResolveImageInfo2KHR" );
  p.srcImageLayout = j[ "srcImageLayout" ];
  p.dstImageLayout = j[ "dstImageLayout" ];
  p.regionCount = j[ "regionCount" ];
}
inline void from_json( const nlohmann::json &j, VkResolveImageInfo2KHR &p ) {
  ResolveImageInfo2KHR temp;
  from_json( j, temp );
  p = VkResolveImageInfo2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const SamplerCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "magFilter" ] = p.magFilter;
  j[ "minFilter" ] = p.minFilter;
  j[ "mipmapMode" ] = p.mipmapMode;
  j[ "addressModeU" ] = p.addressModeU;
  j[ "addressModeV" ] = p.addressModeV;
  j[ "addressModeW" ] = p.addressModeW;
  j[ "mipLodBias" ] = p.mipLodBias;
  j[ "anisotropyEnable" ] = bool( p.anisotropyEnable );
  j[ "maxAnisotropy" ] = p.maxAnisotropy;
  j[ "compareEnable" ] = bool( p.compareEnable );
  j[ "compareOp" ] = p.compareOp;
  j[ "minLod" ] = p.minLod;
  j[ "maxLod" ] = p.maxLod;
  j[ "borderColor" ] = p.borderColor;
  j[ "unnormalizedCoordinates" ] = bool( p.unnormalizedCoordinates );
}
inline void to_json( nlohmann::json &j, const VkSamplerCreateInfo &p ) {
  to_json( j, SamplerCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SamplerCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SamplerCreateInfo" );
  p.flags = j[ "flags" ];
  p.magFilter = j[ "magFilter" ];
  p.minFilter = j[ "minFilter" ];
  p.mipmapMode = j[ "mipmapMode" ];
  p.addressModeU = j[ "addressModeU" ];
  p.addressModeV = j[ "addressModeV" ];
  p.addressModeW = j[ "addressModeW" ];
  p.mipLodBias = j[ "mipLodBias" ];
  p.anisotropyEnable = j[ "anisotropyEnable" ];
  p.maxAnisotropy = j[ "maxAnisotropy" ];
  p.compareEnable = j[ "compareEnable" ];
  p.compareOp = j[ "compareOp" ];
  p.minLod = j[ "minLod" ];
  p.maxLod = j[ "maxLod" ];
  p.borderColor = j[ "borderColor" ];
  p.unnormalizedCoordinates = j[ "unnormalizedCoordinates" ];
}
inline void from_json( const nlohmann::json &j, VkSamplerCreateInfo &p ) {
  SamplerCreateInfo temp;
  from_json( j, temp );
  p = VkSamplerCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SamplerCustomBorderColorCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "format" ] = p.format;
}
inline void to_json( nlohmann::json &j, const VkSamplerCustomBorderColorCreateInfoEXT &p ) {
  to_json( j, SamplerCustomBorderColorCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, SamplerCustomBorderColorCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SamplerCustomBorderColorCreateInfoEXT" );
  p.format = j[ "format" ];
}
inline void from_json( const nlohmann::json &j, VkSamplerCustomBorderColorCreateInfoEXT &p ) {
  SamplerCustomBorderColorCreateInfoEXT temp;
  from_json( j, temp );
  p = VkSamplerCustomBorderColorCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const SamplerReductionModeCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "reductionMode" ] = p.reductionMode;
}
inline void to_json( nlohmann::json &j, const VkSamplerReductionModeCreateInfo &p ) {
  to_json( j, SamplerReductionModeCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SamplerReductionModeCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SamplerReductionModeCreateInfo" );
  p.reductionMode = j[ "reductionMode" ];
}
inline void from_json( const nlohmann::json &j, VkSamplerReductionModeCreateInfo &p ) {
  SamplerReductionModeCreateInfo temp;
  from_json( j, temp );
  p = VkSamplerReductionModeCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SamplerYcbcrConversionCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "format" ] = p.format;
  j[ "ycbcrModel" ] = p.ycbcrModel;
  j[ "ycbcrRange" ] = p.ycbcrRange;
  j[ "components" ] = p.components;
  j[ "xChromaOffset" ] = p.xChromaOffset;
  j[ "yChromaOffset" ] = p.yChromaOffset;
  j[ "chromaFilter" ] = p.chromaFilter;
  j[ "forceExplicitReconstruction" ] = bool( p.forceExplicitReconstruction );
}
inline void to_json( nlohmann::json &j, const VkSamplerYcbcrConversionCreateInfo &p ) {
  to_json( j, SamplerYcbcrConversionCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SamplerYcbcrConversionCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SamplerYcbcrConversionCreateInfo" );
  p.format = j[ "format" ];
  p.ycbcrModel = j[ "ycbcrModel" ];
  p.ycbcrRange = j[ "ycbcrRange" ];
  p.components = j[ "components" ];
  p.xChromaOffset = j[ "xChromaOffset" ];
  p.yChromaOffset = j[ "yChromaOffset" ];
  p.chromaFilter = j[ "chromaFilter" ];
  p.forceExplicitReconstruction = j[ "forceExplicitReconstruction" ];
}
inline void from_json( const nlohmann::json &j, VkSamplerYcbcrConversionCreateInfo &p ) {
  SamplerYcbcrConversionCreateInfo temp;
  from_json( j, temp );
  p = VkSamplerYcbcrConversionCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SamplerYcbcrConversionImageFormatProperties &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "combinedImageSamplerDescriptorCount" ] = p.combinedImageSamplerDescriptorCount;
}
inline void to_json( nlohmann::json &j, const VkSamplerYcbcrConversionImageFormatProperties &p ) {
  to_json( j, SamplerYcbcrConversionImageFormatProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, SamplerYcbcrConversionImageFormatProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SamplerYcbcrConversionImageFormatProperties" );
  p.combinedImageSamplerDescriptorCount = j[ "combinedImageSamplerDescriptorCount" ];
}
inline void from_json( const nlohmann::json &j, VkSamplerYcbcrConversionImageFormatProperties &p ) {
  SamplerYcbcrConversionImageFormatProperties temp;
  from_json( j, temp );
  p = VkSamplerYcbcrConversionImageFormatProperties ( temp );
}

inline void to_json( nlohmann::json &j, const SamplerYcbcrConversionInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkSamplerYcbcrConversionInfo &p ) {
  to_json( j, SamplerYcbcrConversionInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SamplerYcbcrConversionInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SamplerYcbcrConversionInfo" );
}
inline void from_json( const nlohmann::json &j, VkSamplerYcbcrConversionInfo &p ) {
  SamplerYcbcrConversionInfo temp;
  from_json( j, temp );
  p = VkSamplerYcbcrConversionInfo ( temp );
}

#if defined( VK_USE_PLATFORM_SCREEN_QNX )
inline void to_json( nlohmann::json &j, const ScreenSurfaceCreateInfoQNX &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "context" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.context ) );
  j[ "window" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.window ) );
}
inline void to_json( nlohmann::json &j, const VkScreenSurfaceCreateInfoQNX &p ) {
  to_json( j, ScreenSurfaceCreateInfoQNX ( p ) );
}
inline void from_json( const nlohmann::json &j, ScreenSurfaceCreateInfoQNX &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ScreenSurfaceCreateInfoQNX" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkScreenSurfaceCreateInfoQNX &p ) {
  ScreenSurfaceCreateInfoQNX temp;
  from_json( j, temp );
  p = VkScreenSurfaceCreateInfoQNX ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const SemaphoreCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkSemaphoreCreateInfo &p ) {
  to_json( j, SemaphoreCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SemaphoreCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SemaphoreCreateInfo" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkSemaphoreCreateInfo &p ) {
  SemaphoreCreateInfo temp;
  from_json( j, temp );
  p = VkSemaphoreCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SemaphoreGetFdInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkSemaphoreGetFdInfoKHR &p ) {
  to_json( j, SemaphoreGetFdInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, SemaphoreGetFdInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SemaphoreGetFdInfoKHR" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkSemaphoreGetFdInfoKHR &p ) {
  SemaphoreGetFdInfoKHR temp;
  from_json( j, temp );
  p = VkSemaphoreGetFdInfoKHR ( temp );
}

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const SemaphoreGetWin32HandleInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkSemaphoreGetWin32HandleInfoKHR &p ) {
  to_json( j, SemaphoreGetWin32HandleInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, SemaphoreGetWin32HandleInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SemaphoreGetWin32HandleInfoKHR" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkSemaphoreGetWin32HandleInfoKHR &p ) {
  SemaphoreGetWin32HandleInfoKHR temp;
  from_json( j, temp );
  p = VkSemaphoreGetWin32HandleInfoKHR ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_FUCHSIA )
inline void to_json( nlohmann::json &j, const SemaphoreGetZirconHandleInfoFUCHSIA &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "handleType" ] = p.handleType;
}
inline void to_json( nlohmann::json &j, const VkSemaphoreGetZirconHandleInfoFUCHSIA &p ) {
  to_json( j, SemaphoreGetZirconHandleInfoFUCHSIA ( p ) );
}
inline void from_json( const nlohmann::json &j, SemaphoreGetZirconHandleInfoFUCHSIA &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SemaphoreGetZirconHandleInfoFUCHSIA" );
  p.handleType = j[ "handleType" ];
}
inline void from_json( const nlohmann::json &j, VkSemaphoreGetZirconHandleInfoFUCHSIA &p ) {
  SemaphoreGetZirconHandleInfoFUCHSIA temp;
  from_json( j, temp );
  p = VkSemaphoreGetZirconHandleInfoFUCHSIA ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const SemaphoreSignalInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "value" ] = p.value;
}
inline void to_json( nlohmann::json &j, const VkSemaphoreSignalInfo &p ) {
  to_json( j, SemaphoreSignalInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SemaphoreSignalInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SemaphoreSignalInfo" );
  p.value = j[ "value" ];
}
inline void from_json( const nlohmann::json &j, VkSemaphoreSignalInfo &p ) {
  SemaphoreSignalInfo temp;
  from_json( j, temp );
  p = VkSemaphoreSignalInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SemaphoreSubmitInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "value" ] = p.value;
  j[ "stageMask" ] = p.stageMask;
  j[ "deviceIndex" ] = p.deviceIndex;
}
inline void to_json( nlohmann::json &j, const VkSemaphoreSubmitInfoKHR &p ) {
  to_json( j, SemaphoreSubmitInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, SemaphoreSubmitInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SemaphoreSubmitInfoKHR" );
  p.value = j[ "value" ];
  p.stageMask = j[ "stageMask" ];
  p.deviceIndex = j[ "deviceIndex" ];
}
inline void from_json( const nlohmann::json &j, VkSemaphoreSubmitInfoKHR &p ) {
  SemaphoreSubmitInfoKHR temp;
  from_json( j, temp );
  p = VkSemaphoreSubmitInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const SemaphoreTypeCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "semaphoreType" ] = p.semaphoreType;
  j[ "initialValue" ] = p.initialValue;
}
inline void to_json( nlohmann::json &j, const VkSemaphoreTypeCreateInfo &p ) {
  to_json( j, SemaphoreTypeCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SemaphoreTypeCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SemaphoreTypeCreateInfo" );
  p.semaphoreType = j[ "semaphoreType" ];
  p.initialValue = j[ "initialValue" ];
}
inline void from_json( const nlohmann::json &j, VkSemaphoreTypeCreateInfo &p ) {
  SemaphoreTypeCreateInfo temp;
  from_json( j, temp );
  p = VkSemaphoreTypeCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SemaphoreWaitInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "semaphoreCount" ] = p.semaphoreCount;
  j[ "pSemaphores" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSemaphores ) );
  j[ "pValues" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pValues ) );
}
inline void to_json( nlohmann::json &j, const VkSemaphoreWaitInfo &p ) {
  to_json( j, SemaphoreWaitInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SemaphoreWaitInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SemaphoreWaitInfo" );
  p.flags = j[ "flags" ];
  p.semaphoreCount = j[ "semaphoreCount" ];
}
inline void from_json( const nlohmann::json &j, VkSemaphoreWaitInfo &p ) {
  SemaphoreWaitInfo temp;
  from_json( j, temp );
  p = VkSemaphoreWaitInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SetStateFlagsIndirectCommandNV &p ) {
  j = nlohmann::json::object();
  j[ "data" ] = p.data;
}
inline void to_json( nlohmann::json &j, const VkSetStateFlagsIndirectCommandNV &p ) {
  to_json( j, SetStateFlagsIndirectCommandNV ( p ) );
}
inline void from_json( const nlohmann::json &j, SetStateFlagsIndirectCommandNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SetStateFlagsIndirectCommandNV" );
  p.data = j[ "data" ];
}
inline void from_json( const nlohmann::json &j, VkSetStateFlagsIndirectCommandNV &p ) {
  SetStateFlagsIndirectCommandNV temp;
  from_json( j, temp );
  p = VkSetStateFlagsIndirectCommandNV ( temp );
}

inline void to_json( nlohmann::json &j, const ShaderModuleCreateInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "codeSize" ] = p.codeSize;
  j[ "pCode" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCode ) );
}
inline void to_json( nlohmann::json &j, const VkShaderModuleCreateInfo &p ) {
  to_json( j, ShaderModuleCreateInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, ShaderModuleCreateInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ShaderModuleCreateInfo" );
  p.flags = j[ "flags" ];
  p.codeSize = j[ "codeSize" ];
}
inline void from_json( const nlohmann::json &j, VkShaderModuleCreateInfo &p ) {
  ShaderModuleCreateInfo temp;
  from_json( j, temp );
  p = VkShaderModuleCreateInfo ( temp );
}

inline void to_json( nlohmann::json &j, const ShaderModuleValidationCacheCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkShaderModuleValidationCacheCreateInfoEXT &p ) {
  to_json( j, ShaderModuleValidationCacheCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ShaderModuleValidationCacheCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ShaderModuleValidationCacheCreateInfoEXT" );
}
inline void from_json( const nlohmann::json &j, VkShaderModuleValidationCacheCreateInfoEXT &p ) {
  ShaderModuleValidationCacheCreateInfoEXT temp;
  from_json( j, temp );
  p = VkShaderModuleValidationCacheCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const ShaderResourceUsageAMD &p ) {
  j = nlohmann::json::object();
  j[ "numUsedVgprs" ] = p.numUsedVgprs;
  j[ "numUsedSgprs" ] = p.numUsedSgprs;
  j[ "ldsSizePerLocalWorkGroup" ] = p.ldsSizePerLocalWorkGroup;
  j[ "ldsUsageSizeInBytes" ] = p.ldsUsageSizeInBytes;
  j[ "scratchMemUsageInBytes" ] = p.scratchMemUsageInBytes;
}
inline void to_json( nlohmann::json &j, const VkShaderResourceUsageAMD &p ) {
  to_json( j, ShaderResourceUsageAMD ( p ) );
}
inline void from_json( const nlohmann::json &j, ShaderResourceUsageAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ShaderResourceUsageAMD" );
  p.numUsedVgprs = j[ "numUsedVgprs" ];
  p.numUsedSgprs = j[ "numUsedSgprs" ];
  p.ldsSizePerLocalWorkGroup = j[ "ldsSizePerLocalWorkGroup" ];
  p.ldsUsageSizeInBytes = j[ "ldsUsageSizeInBytes" ];
  p.scratchMemUsageInBytes = j[ "scratchMemUsageInBytes" ];
}
inline void from_json( const nlohmann::json &j, VkShaderResourceUsageAMD &p ) {
  ShaderResourceUsageAMD temp;
  from_json( j, temp );
  p = VkShaderResourceUsageAMD ( temp );
}

inline void to_json( nlohmann::json &j, const ShaderStatisticsInfoAMD &p ) {
  j = nlohmann::json::object();
  j[ "shaderStageMask" ] = p.shaderStageMask;
  j[ "resourceUsage" ] = p.resourceUsage;
  j[ "numPhysicalVgprs" ] = p.numPhysicalVgprs;
  j[ "numPhysicalSgprs" ] = p.numPhysicalSgprs;
  j[ "numAvailableVgprs" ] = p.numAvailableVgprs;
  j[ "numAvailableSgprs" ] = p.numAvailableSgprs;
  j[ "computeWorkGroupSize" ] = nlohmann::json::array();
  std::copy( p.computeWorkGroupSize.begin(), p.computeWorkGroupSize.end(), std::back_inserter( j[ "computeWorkGroupSize" ] ) );
}
inline void to_json( nlohmann::json &j, const VkShaderStatisticsInfoAMD &p ) {
  to_json( j, ShaderStatisticsInfoAMD ( p ) );
}
inline void from_json( const nlohmann::json &j, ShaderStatisticsInfoAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ShaderStatisticsInfoAMD" );
  p.shaderStageMask = j[ "shaderStageMask" ];
  p.resourceUsage = j[ "resourceUsage" ];
  p.numPhysicalVgprs = j[ "numPhysicalVgprs" ];
  p.numPhysicalSgprs = j[ "numPhysicalSgprs" ];
  p.numAvailableVgprs = j[ "numAvailableVgprs" ];
  p.numAvailableSgprs = j[ "numAvailableSgprs" ];
  if( !j[ "computeWorkGroupSize" ].is_array() ) throw vulkan2json::invalid_array_value( "incompatible value for ShaderStatisticsInfoAMD.computeWorkGroupSize" );
  if( !j[ "computeWorkGroupSize" ].size() > p.computeWorkGroupSize.size() ) throw vulkan2json::invalid_array_value( "too many values in array for ShaderStatisticsInfoAMD.computeWorkGroupSize" );
  std::fill( p.computeWorkGroupSize.begin(), p.computeWorkGroupSize.end(), 0 );
  std::copy( j[ "computeWorkGroupSize" ].begin(), j[ "computeWorkGroupSize" ].end(), p.computeWorkGroupSize.begin() );
}
inline void from_json( const nlohmann::json &j, VkShaderStatisticsInfoAMD &p ) {
  ShaderStatisticsInfoAMD temp;
  from_json( j, temp );
  p = VkShaderStatisticsInfoAMD ( temp );
}

inline void to_json( nlohmann::json &j, const SharedPresentSurfaceCapabilitiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "sharedPresentSupportedUsageFlags" ] = p.sharedPresentSupportedUsageFlags;
}
inline void to_json( nlohmann::json &j, const VkSharedPresentSurfaceCapabilitiesKHR &p ) {
  to_json( j, SharedPresentSurfaceCapabilitiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, SharedPresentSurfaceCapabilitiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SharedPresentSurfaceCapabilitiesKHR" );
  p.sharedPresentSupportedUsageFlags = j[ "sharedPresentSupportedUsageFlags" ];
}
inline void from_json( const nlohmann::json &j, VkSharedPresentSurfaceCapabilitiesKHR &p ) {
  SharedPresentSurfaceCapabilitiesKHR temp;
  from_json( j, temp );
  p = VkSharedPresentSurfaceCapabilitiesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const SparseImageFormatProperties &p ) {
  j = nlohmann::json::object();
  j[ "aspectMask" ] = p.aspectMask;
  j[ "imageGranularity" ] = p.imageGranularity;
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkSparseImageFormatProperties &p ) {
  to_json( j, SparseImageFormatProperties ( p ) );
}
inline void from_json( const nlohmann::json &j, SparseImageFormatProperties &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseImageFormatProperties" );
  p.aspectMask = j[ "aspectMask" ];
  p.imageGranularity = j[ "imageGranularity" ];
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkSparseImageFormatProperties &p ) {
  SparseImageFormatProperties temp;
  from_json( j, temp );
  p = VkSparseImageFormatProperties ( temp );
}

inline void to_json( nlohmann::json &j, const SparseImageFormatProperties2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "properties" ] = p.properties;
}
inline void to_json( nlohmann::json &j, const VkSparseImageFormatProperties2 &p ) {
  to_json( j, SparseImageFormatProperties2 ( p ) );
}
inline void from_json( const nlohmann::json &j, SparseImageFormatProperties2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseImageFormatProperties2" );
  p.properties = j[ "properties" ];
}
inline void from_json( const nlohmann::json &j, VkSparseImageFormatProperties2 &p ) {
  SparseImageFormatProperties2 temp;
  from_json( j, temp );
  p = VkSparseImageFormatProperties2 ( temp );
}

inline void to_json( nlohmann::json &j, const SparseImageMemoryRequirements &p ) {
  j = nlohmann::json::object();
  j[ "formatProperties" ] = p.formatProperties;
  j[ "imageMipTailFirstLod" ] = p.imageMipTailFirstLod;
  j[ "imageMipTailSize" ] = p.imageMipTailSize;
  j[ "imageMipTailOffset" ] = p.imageMipTailOffset;
  j[ "imageMipTailStride" ] = p.imageMipTailStride;
}
inline void to_json( nlohmann::json &j, const VkSparseImageMemoryRequirements &p ) {
  to_json( j, SparseImageMemoryRequirements ( p ) );
}
inline void from_json( const nlohmann::json &j, SparseImageMemoryRequirements &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseImageMemoryRequirements" );
  p.formatProperties = j[ "formatProperties" ];
  p.imageMipTailFirstLod = j[ "imageMipTailFirstLod" ];
  p.imageMipTailSize = j[ "imageMipTailSize" ];
  p.imageMipTailOffset = j[ "imageMipTailOffset" ];
  p.imageMipTailStride = j[ "imageMipTailStride" ];
}
inline void from_json( const nlohmann::json &j, VkSparseImageMemoryRequirements &p ) {
  SparseImageMemoryRequirements temp;
  from_json( j, temp );
  p = VkSparseImageMemoryRequirements ( temp );
}

inline void to_json( nlohmann::json &j, const SparseImageMemoryRequirements2 &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryRequirements" ] = p.memoryRequirements;
}
inline void to_json( nlohmann::json &j, const VkSparseImageMemoryRequirements2 &p ) {
  to_json( j, SparseImageMemoryRequirements2 ( p ) );
}
inline void from_json( const nlohmann::json &j, SparseImageMemoryRequirements2 &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SparseImageMemoryRequirements2" );
  p.memoryRequirements = j[ "memoryRequirements" ];
}
inline void from_json( const nlohmann::json &j, VkSparseImageMemoryRequirements2 &p ) {
  SparseImageMemoryRequirements2 temp;
  from_json( j, temp );
  p = VkSparseImageMemoryRequirements2 ( temp );
}

#if defined( VK_USE_PLATFORM_GGP )
inline void to_json( nlohmann::json &j, const StreamDescriptorSurfaceCreateInfoGGP &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkStreamDescriptorSurfaceCreateInfoGGP &p ) {
  to_json( j, StreamDescriptorSurfaceCreateInfoGGP ( p ) );
}
inline void from_json( const nlohmann::json &j, StreamDescriptorSurfaceCreateInfoGGP &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for StreamDescriptorSurfaceCreateInfoGGP" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkStreamDescriptorSurfaceCreateInfoGGP &p ) {
  StreamDescriptorSurfaceCreateInfoGGP temp;
  from_json( j, temp );
  p = VkStreamDescriptorSurfaceCreateInfoGGP ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const StridedDeviceAddressRegionKHR &p ) {
  j = nlohmann::json::object();
  j[ "stride" ] = p.stride;
  j[ "size" ] = p.size;
}
inline void to_json( nlohmann::json &j, const VkStridedDeviceAddressRegionKHR &p ) {
  to_json( j, StridedDeviceAddressRegionKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, StridedDeviceAddressRegionKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for StridedDeviceAddressRegionKHR" );
  p.stride = j[ "stride" ];
  p.size = j[ "size" ];
}
inline void from_json( const nlohmann::json &j, VkStridedDeviceAddressRegionKHR &p ) {
  StridedDeviceAddressRegionKHR temp;
  from_json( j, temp );
  p = VkStridedDeviceAddressRegionKHR ( temp );
}

inline void to_json( nlohmann::json &j, const SubmitInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "waitSemaphoreCount" ] = p.waitSemaphoreCount;
  j[ "pWaitSemaphores" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitSemaphores ) );
  j[ "pWaitDstStageMask" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitDstStageMask ) );
  j[ "commandBufferCount" ] = p.commandBufferCount;
  j[ "pCommandBuffers" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCommandBuffers ) );
  j[ "signalSemaphoreCount" ] = p.signalSemaphoreCount;
  j[ "pSignalSemaphores" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSignalSemaphores ) );
}
inline void to_json( nlohmann::json &j, const VkSubmitInfo &p ) {
  to_json( j, SubmitInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SubmitInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubmitInfo" );
  p.waitSemaphoreCount = j[ "waitSemaphoreCount" ];
  p.commandBufferCount = j[ "commandBufferCount" ];
  p.signalSemaphoreCount = j[ "signalSemaphoreCount" ];
}
inline void from_json( const nlohmann::json &j, VkSubmitInfo &p ) {
  SubmitInfo temp;
  from_json( j, temp );
  p = VkSubmitInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SubmitInfo2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "waitSemaphoreInfoCount" ] = p.waitSemaphoreInfoCount;
  j[ "pWaitSemaphoreInfos" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitSemaphoreInfos ) );
  j[ "commandBufferInfoCount" ] = p.commandBufferInfoCount;
  j[ "pCommandBufferInfos" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCommandBufferInfos ) );
  j[ "signalSemaphoreInfoCount" ] = p.signalSemaphoreInfoCount;
  j[ "pSignalSemaphoreInfos" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSignalSemaphoreInfos ) );
}
inline void to_json( nlohmann::json &j, const VkSubmitInfo2KHR &p ) {
  to_json( j, SubmitInfo2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, SubmitInfo2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubmitInfo2KHR" );
  p.flags = j[ "flags" ];
  p.waitSemaphoreInfoCount = j[ "waitSemaphoreInfoCount" ];
  p.commandBufferInfoCount = j[ "commandBufferInfoCount" ];
  p.signalSemaphoreInfoCount = j[ "signalSemaphoreInfoCount" ];
}
inline void from_json( const nlohmann::json &j, VkSubmitInfo2KHR &p ) {
  SubmitInfo2KHR temp;
  from_json( j, temp );
  p = VkSubmitInfo2KHR ( temp );
}

inline void to_json( nlohmann::json &j, const SubpassBeginInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "contents" ] = p.contents;
}
inline void to_json( nlohmann::json &j, const VkSubpassBeginInfo &p ) {
  to_json( j, SubpassBeginInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SubpassBeginInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassBeginInfo" );
  p.contents = j[ "contents" ];
}
inline void from_json( const nlohmann::json &j, VkSubpassBeginInfo &p ) {
  SubpassBeginInfo temp;
  from_json( j, temp );
  p = VkSubpassBeginInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SubpassDescriptionDepthStencilResolve &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "depthResolveMode" ] = p.depthResolveMode;
  j[ "stencilResolveMode" ] = p.stencilResolveMode;
  j[ "pDepthStencilResolveAttachment" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDepthStencilResolveAttachment ) );
}
inline void to_json( nlohmann::json &j, const VkSubpassDescriptionDepthStencilResolve &p ) {
  to_json( j, SubpassDescriptionDepthStencilResolve ( p ) );
}
inline void from_json( const nlohmann::json &j, SubpassDescriptionDepthStencilResolve &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassDescriptionDepthStencilResolve" );
  p.depthResolveMode = j[ "depthResolveMode" ];
  p.stencilResolveMode = j[ "stencilResolveMode" ];
}
inline void from_json( const nlohmann::json &j, VkSubpassDescriptionDepthStencilResolve &p ) {
  SubpassDescriptionDepthStencilResolve temp;
  from_json( j, temp );
  p = VkSubpassDescriptionDepthStencilResolve ( temp );
}

inline void to_json( nlohmann::json &j, const SubpassEndInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkSubpassEndInfo &p ) {
  to_json( j, SubpassEndInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, SubpassEndInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassEndInfo" );
}
inline void from_json( const nlohmann::json &j, VkSubpassEndInfo &p ) {
  SubpassEndInfo temp;
  from_json( j, temp );
  p = VkSubpassEndInfo ( temp );
}

inline void to_json( nlohmann::json &j, const SubpassShadingPipelineCreateInfoHUAWEI &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "subpass" ] = p.subpass;
}
inline void to_json( nlohmann::json &j, const VkSubpassShadingPipelineCreateInfoHUAWEI &p ) {
  to_json( j, SubpassShadingPipelineCreateInfoHUAWEI ( p ) );
}
inline void from_json( const nlohmann::json &j, SubpassShadingPipelineCreateInfoHUAWEI &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SubpassShadingPipelineCreateInfoHUAWEI" );
  p.subpass = j[ "subpass" ];
}
inline void from_json( const nlohmann::json &j, VkSubpassShadingPipelineCreateInfoHUAWEI &p ) {
  SubpassShadingPipelineCreateInfoHUAWEI temp;
  from_json( j, temp );
  p = VkSubpassShadingPipelineCreateInfoHUAWEI ( temp );
}

inline void to_json( nlohmann::json &j, const SurfaceCapabilities2EXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "minImageCount" ] = p.minImageCount;
  j[ "maxImageCount" ] = p.maxImageCount;
  j[ "currentExtent" ] = p.currentExtent;
  j[ "minImageExtent" ] = p.minImageExtent;
  j[ "maxImageExtent" ] = p.maxImageExtent;
  j[ "maxImageArrayLayers" ] = p.maxImageArrayLayers;
  j[ "supportedTransforms" ] = p.supportedTransforms;
  j[ "currentTransform" ] = p.currentTransform;
  j[ "supportedCompositeAlpha" ] = p.supportedCompositeAlpha;
  j[ "supportedUsageFlags" ] = p.supportedUsageFlags;
  j[ "supportedSurfaceCounters" ] = p.supportedSurfaceCounters;
}
inline void to_json( nlohmann::json &j, const VkSurfaceCapabilities2EXT &p ) {
  to_json( j, SurfaceCapabilities2EXT ( p ) );
}
inline void from_json( const nlohmann::json &j, SurfaceCapabilities2EXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceCapabilities2EXT" );
  p.minImageCount = j[ "minImageCount" ];
  p.maxImageCount = j[ "maxImageCount" ];
  p.currentExtent = j[ "currentExtent" ];
  p.minImageExtent = j[ "minImageExtent" ];
  p.maxImageExtent = j[ "maxImageExtent" ];
  p.maxImageArrayLayers = j[ "maxImageArrayLayers" ];
  p.supportedTransforms = j[ "supportedTransforms" ];
  p.currentTransform = j[ "currentTransform" ];
  p.supportedCompositeAlpha = j[ "supportedCompositeAlpha" ];
  p.supportedUsageFlags = j[ "supportedUsageFlags" ];
  p.supportedSurfaceCounters = j[ "supportedSurfaceCounters" ];
}
inline void from_json( const nlohmann::json &j, VkSurfaceCapabilities2EXT &p ) {
  SurfaceCapabilities2EXT temp;
  from_json( j, temp );
  p = VkSurfaceCapabilities2EXT ( temp );
}

inline void to_json( nlohmann::json &j, const SurfaceCapabilitiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "minImageCount" ] = p.minImageCount;
  j[ "maxImageCount" ] = p.maxImageCount;
  j[ "currentExtent" ] = p.currentExtent;
  j[ "minImageExtent" ] = p.minImageExtent;
  j[ "maxImageExtent" ] = p.maxImageExtent;
  j[ "maxImageArrayLayers" ] = p.maxImageArrayLayers;
  j[ "supportedTransforms" ] = p.supportedTransforms;
  j[ "currentTransform" ] = p.currentTransform;
  j[ "supportedCompositeAlpha" ] = p.supportedCompositeAlpha;
  j[ "supportedUsageFlags" ] = p.supportedUsageFlags;
}
inline void to_json( nlohmann::json &j, const VkSurfaceCapabilitiesKHR &p ) {
  to_json( j, SurfaceCapabilitiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, SurfaceCapabilitiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceCapabilitiesKHR" );
  p.minImageCount = j[ "minImageCount" ];
  p.maxImageCount = j[ "maxImageCount" ];
  p.currentExtent = j[ "currentExtent" ];
  p.minImageExtent = j[ "minImageExtent" ];
  p.maxImageExtent = j[ "maxImageExtent" ];
  p.maxImageArrayLayers = j[ "maxImageArrayLayers" ];
  p.supportedTransforms = j[ "supportedTransforms" ];
  p.currentTransform = j[ "currentTransform" ];
  p.supportedCompositeAlpha = j[ "supportedCompositeAlpha" ];
  p.supportedUsageFlags = j[ "supportedUsageFlags" ];
}
inline void from_json( const nlohmann::json &j, VkSurfaceCapabilitiesKHR &p ) {
  SurfaceCapabilitiesKHR temp;
  from_json( j, temp );
  p = VkSurfaceCapabilitiesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const SurfaceCapabilities2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "surfaceCapabilities" ] = p.surfaceCapabilities;
}
inline void to_json( nlohmann::json &j, const VkSurfaceCapabilities2KHR &p ) {
  to_json( j, SurfaceCapabilities2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, SurfaceCapabilities2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceCapabilities2KHR" );
  p.surfaceCapabilities = j[ "surfaceCapabilities" ];
}
inline void from_json( const nlohmann::json &j, VkSurfaceCapabilities2KHR &p ) {
  SurfaceCapabilities2KHR temp;
  from_json( j, temp );
  p = VkSurfaceCapabilities2KHR ( temp );
}

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const SurfaceCapabilitiesFullScreenExclusiveEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fullScreenExclusiveSupported" ] = bool( p.fullScreenExclusiveSupported );
}
inline void to_json( nlohmann::json &j, const VkSurfaceCapabilitiesFullScreenExclusiveEXT &p ) {
  to_json( j, SurfaceCapabilitiesFullScreenExclusiveEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, SurfaceCapabilitiesFullScreenExclusiveEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceCapabilitiesFullScreenExclusiveEXT" );
  p.fullScreenExclusiveSupported = j[ "fullScreenExclusiveSupported" ];
}
inline void from_json( const nlohmann::json &j, VkSurfaceCapabilitiesFullScreenExclusiveEXT &p ) {
  SurfaceCapabilitiesFullScreenExclusiveEXT temp;
  from_json( j, temp );
  p = VkSurfaceCapabilitiesFullScreenExclusiveEXT ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const SurfaceFormatKHR &p ) {
  j = nlohmann::json::object();
  j[ "format" ] = p.format;
  j[ "colorSpace" ] = p.colorSpace;
}
inline void to_json( nlohmann::json &j, const VkSurfaceFormatKHR &p ) {
  to_json( j, SurfaceFormatKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, SurfaceFormatKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceFormatKHR" );
  p.format = j[ "format" ];
  p.colorSpace = j[ "colorSpace" ];
}
inline void from_json( const nlohmann::json &j, VkSurfaceFormatKHR &p ) {
  SurfaceFormatKHR temp;
  from_json( j, temp );
  p = VkSurfaceFormatKHR ( temp );
}

inline void to_json( nlohmann::json &j, const SurfaceFormat2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "surfaceFormat" ] = p.surfaceFormat;
}
inline void to_json( nlohmann::json &j, const VkSurfaceFormat2KHR &p ) {
  to_json( j, SurfaceFormat2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, SurfaceFormat2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceFormat2KHR" );
  p.surfaceFormat = j[ "surfaceFormat" ];
}
inline void from_json( const nlohmann::json &j, VkSurfaceFormat2KHR &p ) {
  SurfaceFormat2KHR temp;
  from_json( j, temp );
  p = VkSurfaceFormat2KHR ( temp );
}

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const SurfaceFullScreenExclusiveInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fullScreenExclusive" ] = p.fullScreenExclusive;
}
inline void to_json( nlohmann::json &j, const VkSurfaceFullScreenExclusiveInfoEXT &p ) {
  to_json( j, SurfaceFullScreenExclusiveInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, SurfaceFullScreenExclusiveInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceFullScreenExclusiveInfoEXT" );
  p.fullScreenExclusive = j[ "fullScreenExclusive" ];
}
inline void from_json( const nlohmann::json &j, VkSurfaceFullScreenExclusiveInfoEXT &p ) {
  SurfaceFullScreenExclusiveInfoEXT temp;
  from_json( j, temp );
  p = VkSurfaceFullScreenExclusiveInfoEXT ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const SurfaceFullScreenExclusiveWin32InfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkSurfaceFullScreenExclusiveWin32InfoEXT &p ) {
  to_json( j, SurfaceFullScreenExclusiveWin32InfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, SurfaceFullScreenExclusiveWin32InfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceFullScreenExclusiveWin32InfoEXT" );
}
inline void from_json( const nlohmann::json &j, VkSurfaceFullScreenExclusiveWin32InfoEXT &p ) {
  SurfaceFullScreenExclusiveWin32InfoEXT temp;
  from_json( j, temp );
  p = VkSurfaceFullScreenExclusiveWin32InfoEXT ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const SurfaceProtectedCapabilitiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "supportsProtected" ] = bool( p.supportsProtected );
}
inline void to_json( nlohmann::json &j, const VkSurfaceProtectedCapabilitiesKHR &p ) {
  to_json( j, SurfaceProtectedCapabilitiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, SurfaceProtectedCapabilitiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SurfaceProtectedCapabilitiesKHR" );
  p.supportsProtected = j[ "supportsProtected" ];
}
inline void from_json( const nlohmann::json &j, VkSurfaceProtectedCapabilitiesKHR &p ) {
  SurfaceProtectedCapabilitiesKHR temp;
  from_json( j, temp );
  p = VkSurfaceProtectedCapabilitiesKHR ( temp );
}

inline void to_json( nlohmann::json &j, const SwapchainCounterCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "surfaceCounters" ] = p.surfaceCounters;
}
inline void to_json( nlohmann::json &j, const VkSwapchainCounterCreateInfoEXT &p ) {
  to_json( j, SwapchainCounterCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, SwapchainCounterCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SwapchainCounterCreateInfoEXT" );
  p.surfaceCounters = j[ "surfaceCounters" ];
}
inline void from_json( const nlohmann::json &j, VkSwapchainCounterCreateInfoEXT &p ) {
  SwapchainCounterCreateInfoEXT temp;
  from_json( j, temp );
  p = VkSwapchainCounterCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const SwapchainCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "minImageCount" ] = p.minImageCount;
  j[ "imageFormat" ] = p.imageFormat;
  j[ "imageColorSpace" ] = p.imageColorSpace;
  j[ "imageExtent" ] = p.imageExtent;
  j[ "imageArrayLayers" ] = p.imageArrayLayers;
  j[ "imageUsage" ] = p.imageUsage;
  j[ "imageSharingMode" ] = p.imageSharingMode;
  j[ "queueFamilyIndexCount" ] = p.queueFamilyIndexCount;
  j[ "pQueueFamilyIndices" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pQueueFamilyIndices ) );
  j[ "preTransform" ] = p.preTransform;
  j[ "compositeAlpha" ] = p.compositeAlpha;
  j[ "presentMode" ] = p.presentMode;
  j[ "clipped" ] = bool( p.clipped );
}
inline void to_json( nlohmann::json &j, const VkSwapchainCreateInfoKHR &p ) {
  to_json( j, SwapchainCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, SwapchainCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SwapchainCreateInfoKHR" );
  p.flags = j[ "flags" ];
  p.minImageCount = j[ "minImageCount" ];
  p.imageFormat = j[ "imageFormat" ];
  p.imageColorSpace = j[ "imageColorSpace" ];
  p.imageExtent = j[ "imageExtent" ];
  p.imageArrayLayers = j[ "imageArrayLayers" ];
  p.imageUsage = j[ "imageUsage" ];
  p.imageSharingMode = j[ "imageSharingMode" ];
  p.queueFamilyIndexCount = j[ "queueFamilyIndexCount" ];
  p.preTransform = j[ "preTransform" ];
  p.compositeAlpha = j[ "compositeAlpha" ];
  p.presentMode = j[ "presentMode" ];
  p.clipped = j[ "clipped" ];
}
inline void from_json( const nlohmann::json &j, VkSwapchainCreateInfoKHR &p ) {
  SwapchainCreateInfoKHR temp;
  from_json( j, temp );
  p = VkSwapchainCreateInfoKHR ( temp );
}

inline void to_json( nlohmann::json &j, const SwapchainDisplayNativeHdrCreateInfoAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "localDimmingEnable" ] = bool( p.localDimmingEnable );
}
inline void to_json( nlohmann::json &j, const VkSwapchainDisplayNativeHdrCreateInfoAMD &p ) {
  to_json( j, SwapchainDisplayNativeHdrCreateInfoAMD ( p ) );
}
inline void from_json( const nlohmann::json &j, SwapchainDisplayNativeHdrCreateInfoAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for SwapchainDisplayNativeHdrCreateInfoAMD" );
  p.localDimmingEnable = j[ "localDimmingEnable" ];
}
inline void from_json( const nlohmann::json &j, VkSwapchainDisplayNativeHdrCreateInfoAMD &p ) {
  SwapchainDisplayNativeHdrCreateInfoAMD temp;
  from_json( j, temp );
  p = VkSwapchainDisplayNativeHdrCreateInfoAMD ( temp );
}

inline void to_json( nlohmann::json &j, const TextureLODGatherFormatPropertiesAMD &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "supportsTextureGatherLODBiasAMD" ] = bool( p.supportsTextureGatherLODBiasAMD );
}
inline void to_json( nlohmann::json &j, const VkTextureLODGatherFormatPropertiesAMD &p ) {
  to_json( j, TextureLODGatherFormatPropertiesAMD ( p ) );
}
inline void from_json( const nlohmann::json &j, TextureLODGatherFormatPropertiesAMD &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for TextureLODGatherFormatPropertiesAMD" );
  p.supportsTextureGatherLODBiasAMD = j[ "supportsTextureGatherLODBiasAMD" ];
}
inline void from_json( const nlohmann::json &j, VkTextureLODGatherFormatPropertiesAMD &p ) {
  TextureLODGatherFormatPropertiesAMD temp;
  from_json( j, temp );
  p = VkTextureLODGatherFormatPropertiesAMD ( temp );
}

inline void to_json( nlohmann::json &j, const TimelineSemaphoreSubmitInfo &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "waitSemaphoreValueCount" ] = p.waitSemaphoreValueCount;
  j[ "pWaitSemaphoreValues" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pWaitSemaphoreValues ) );
  j[ "signalSemaphoreValueCount" ] = p.signalSemaphoreValueCount;
  j[ "pSignalSemaphoreValues" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSignalSemaphoreValues ) );
}
inline void to_json( nlohmann::json &j, const VkTimelineSemaphoreSubmitInfo &p ) {
  to_json( j, TimelineSemaphoreSubmitInfo ( p ) );
}
inline void from_json( const nlohmann::json &j, TimelineSemaphoreSubmitInfo &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for TimelineSemaphoreSubmitInfo" );
  p.waitSemaphoreValueCount = j[ "waitSemaphoreValueCount" ];
  p.signalSemaphoreValueCount = j[ "signalSemaphoreValueCount" ];
}
inline void from_json( const nlohmann::json &j, VkTimelineSemaphoreSubmitInfo &p ) {
  TimelineSemaphoreSubmitInfo temp;
  from_json( j, temp );
  p = VkTimelineSemaphoreSubmitInfo ( temp );
}

inline void to_json( nlohmann::json &j, const TraceRaysIndirectCommandKHR &p ) {
  j = nlohmann::json::object();
  j[ "width" ] = p.width;
  j[ "height" ] = p.height;
  j[ "depth" ] = p.depth;
}
inline void to_json( nlohmann::json &j, const VkTraceRaysIndirectCommandKHR &p ) {
  to_json( j, TraceRaysIndirectCommandKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, TraceRaysIndirectCommandKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for TraceRaysIndirectCommandKHR" );
  p.width = j[ "width" ];
  p.height = j[ "height" ];
  p.depth = j[ "depth" ];
}
inline void from_json( const nlohmann::json &j, VkTraceRaysIndirectCommandKHR &p ) {
  TraceRaysIndirectCommandKHR temp;
  from_json( j, temp );
  p = VkTraceRaysIndirectCommandKHR ( temp );
}

inline void to_json( nlohmann::json &j, const ValidationCacheCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "initialDataSize" ] = p.initialDataSize;
  j[ "pInitialData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pInitialData ) );
}
inline void to_json( nlohmann::json &j, const VkValidationCacheCreateInfoEXT &p ) {
  to_json( j, ValidationCacheCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ValidationCacheCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ValidationCacheCreateInfoEXT" );
  p.flags = j[ "flags" ];
  p.initialDataSize = j[ "initialDataSize" ];
}
inline void from_json( const nlohmann::json &j, VkValidationCacheCreateInfoEXT &p ) {
  ValidationCacheCreateInfoEXT temp;
  from_json( j, temp );
  p = VkValidationCacheCreateInfoEXT ( temp );
}

inline void to_json( nlohmann::json &j, const ValidationFeaturesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "enabledValidationFeatureCount" ] = p.enabledValidationFeatureCount;
  j[ "pEnabledValidationFeatures" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pEnabledValidationFeatures ) );
  j[ "disabledValidationFeatureCount" ] = p.disabledValidationFeatureCount;
  j[ "pDisabledValidationFeatures" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDisabledValidationFeatures ) );
}
inline void to_json( nlohmann::json &j, const VkValidationFeaturesEXT &p ) {
  to_json( j, ValidationFeaturesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ValidationFeaturesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ValidationFeaturesEXT" );
  p.enabledValidationFeatureCount = j[ "enabledValidationFeatureCount" ];
  p.disabledValidationFeatureCount = j[ "disabledValidationFeatureCount" ];
}
inline void from_json( const nlohmann::json &j, VkValidationFeaturesEXT &p ) {
  ValidationFeaturesEXT temp;
  from_json( j, temp );
  p = VkValidationFeaturesEXT ( temp );
}

inline void to_json( nlohmann::json &j, const ValidationFlagsEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "disabledValidationCheckCount" ] = p.disabledValidationCheckCount;
  j[ "pDisabledValidationChecks" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pDisabledValidationChecks ) );
}
inline void to_json( nlohmann::json &j, const VkValidationFlagsEXT &p ) {
  to_json( j, ValidationFlagsEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, ValidationFlagsEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ValidationFlagsEXT" );
  p.disabledValidationCheckCount = j[ "disabledValidationCheckCount" ];
}
inline void from_json( const nlohmann::json &j, VkValidationFlagsEXT &p ) {
  ValidationFlagsEXT temp;
  from_json( j, temp );
  p = VkValidationFlagsEXT ( temp );
}

inline void to_json( nlohmann::json &j, const VertexInputAttributeDescription2EXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "location" ] = p.location;
  j[ "binding" ] = p.binding;
  j[ "format" ] = p.format;
  j[ "offset" ] = p.offset;
}
inline void to_json( nlohmann::json &j, const VkVertexInputAttributeDescription2EXT &p ) {
  to_json( j, VertexInputAttributeDescription2EXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VertexInputAttributeDescription2EXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VertexInputAttributeDescription2EXT" );
  p.location = j[ "location" ];
  p.binding = j[ "binding" ];
  p.format = j[ "format" ];
  p.offset = j[ "offset" ];
}
inline void from_json( const nlohmann::json &j, VkVertexInputAttributeDescription2EXT &p ) {
  VertexInputAttributeDescription2EXT temp;
  from_json( j, temp );
  p = VkVertexInputAttributeDescription2EXT ( temp );
}

inline void to_json( nlohmann::json &j, const VertexInputBindingDescription2EXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "binding" ] = p.binding;
  j[ "stride" ] = p.stride;
  j[ "inputRate" ] = p.inputRate;
  j[ "divisor" ] = p.divisor;
}
inline void to_json( nlohmann::json &j, const VkVertexInputBindingDescription2EXT &p ) {
  to_json( j, VertexInputBindingDescription2EXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VertexInputBindingDescription2EXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VertexInputBindingDescription2EXT" );
  p.binding = j[ "binding" ];
  p.stride = j[ "stride" ];
  p.inputRate = j[ "inputRate" ];
  p.divisor = j[ "divisor" ];
}
inline void from_json( const nlohmann::json &j, VkVertexInputBindingDescription2EXT &p ) {
  VertexInputBindingDescription2EXT temp;
  from_json( j, temp );
  p = VkVertexInputBindingDescription2EXT ( temp );
}

#if defined( VK_USE_PLATFORM_VI_NN )
inline void to_json( nlohmann::json &j, const ViSurfaceCreateInfoNN &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "window" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.window ) );
}
inline void to_json( nlohmann::json &j, const VkViSurfaceCreateInfoNN &p ) {
  to_json( j, ViSurfaceCreateInfoNN ( p ) );
}
inline void from_json( const nlohmann::json &j, ViSurfaceCreateInfoNN &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for ViSurfaceCreateInfoNN" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkViSurfaceCreateInfoNN &p ) {
  ViSurfaceCreateInfoNN temp;
  from_json( j, temp );
  p = VkViSurfaceCreateInfoNN ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoPictureResourceKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "codedOffset" ] = p.codedOffset;
  j[ "codedExtent" ] = p.codedExtent;
  j[ "baseArrayLayer" ] = p.baseArrayLayer;
}
inline void to_json( nlohmann::json &j, const VkVideoPictureResourceKHR &p ) {
  to_json( j, VideoPictureResourceKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoPictureResourceKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoPictureResourceKHR" );
  p.codedOffset = j[ "codedOffset" ];
  p.codedExtent = j[ "codedExtent" ];
  p.baseArrayLayer = j[ "baseArrayLayer" ];
}
inline void from_json( const nlohmann::json &j, VkVideoPictureResourceKHR &p ) {
  VideoPictureResourceKHR temp;
  from_json( j, temp );
  p = VkVideoPictureResourceKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoReferenceSlotKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "slotIndex" ] = p.slotIndex;
  j[ "pPictureResource" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPictureResource ) );
}
inline void to_json( nlohmann::json &j, const VkVideoReferenceSlotKHR &p ) {
  to_json( j, VideoReferenceSlotKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoReferenceSlotKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoReferenceSlotKHR" );
  p.slotIndex = j[ "slotIndex" ];
}
inline void from_json( const nlohmann::json &j, VkVideoReferenceSlotKHR &p ) {
  VideoReferenceSlotKHR temp;
  from_json( j, temp );
  p = VkVideoReferenceSlotKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoBeginCodingInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "codecQualityPreset" ] = p.codecQualityPreset;
  j[ "referenceSlotCount" ] = p.referenceSlotCount;
  j[ "pReferenceSlots" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pReferenceSlots ) );
}
inline void to_json( nlohmann::json &j, const VkVideoBeginCodingInfoKHR &p ) {
  to_json( j, VideoBeginCodingInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoBeginCodingInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoBeginCodingInfoKHR" );
  p.flags = j[ "flags" ];
  p.codecQualityPreset = j[ "codecQualityPreset" ];
  p.referenceSlotCount = j[ "referenceSlotCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoBeginCodingInfoKHR &p ) {
  VideoBeginCodingInfoKHR temp;
  from_json( j, temp );
  p = VkVideoBeginCodingInfoKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoBindMemoryKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryBindIndex" ] = p.memoryBindIndex;
  j[ "memoryOffset" ] = p.memoryOffset;
  j[ "memorySize" ] = p.memorySize;
}
inline void to_json( nlohmann::json &j, const VkVideoBindMemoryKHR &p ) {
  to_json( j, VideoBindMemoryKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoBindMemoryKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoBindMemoryKHR" );
  p.memoryBindIndex = j[ "memoryBindIndex" ];
  p.memoryOffset = j[ "memoryOffset" ];
  p.memorySize = j[ "memorySize" ];
}
inline void from_json( const nlohmann::json &j, VkVideoBindMemoryKHR &p ) {
  VideoBindMemoryKHR temp;
  from_json( j, temp );
  p = VkVideoBindMemoryKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoCapabilitiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "capabilityFlags" ] = p.capabilityFlags;
  j[ "minBitstreamBufferOffsetAlignment" ] = p.minBitstreamBufferOffsetAlignment;
  j[ "minBitstreamBufferSizeAlignment" ] = p.minBitstreamBufferSizeAlignment;
  j[ "videoPictureExtentGranularity" ] = p.videoPictureExtentGranularity;
  j[ "minExtent" ] = p.minExtent;
  j[ "maxExtent" ] = p.maxExtent;
  j[ "maxReferencePicturesSlotsCount" ] = p.maxReferencePicturesSlotsCount;
  j[ "maxReferencePicturesActiveCount" ] = p.maxReferencePicturesActiveCount;
}
inline void to_json( nlohmann::json &j, const VkVideoCapabilitiesKHR &p ) {
  to_json( j, VideoCapabilitiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoCapabilitiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoCapabilitiesKHR" );
  p.capabilityFlags = j[ "capabilityFlags" ];
  p.minBitstreamBufferOffsetAlignment = j[ "minBitstreamBufferOffsetAlignment" ];
  p.minBitstreamBufferSizeAlignment = j[ "minBitstreamBufferSizeAlignment" ];
  p.videoPictureExtentGranularity = j[ "videoPictureExtentGranularity" ];
  p.minExtent = j[ "minExtent" ];
  p.maxExtent = j[ "maxExtent" ];
  p.maxReferencePicturesSlotsCount = j[ "maxReferencePicturesSlotsCount" ];
  p.maxReferencePicturesActiveCount = j[ "maxReferencePicturesActiveCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoCapabilitiesKHR &p ) {
  VideoCapabilitiesKHR temp;
  from_json( j, temp );
  p = VkVideoCapabilitiesKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoCodingControlInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkVideoCodingControlInfoKHR &p ) {
  to_json( j, VideoCodingControlInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoCodingControlInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoCodingControlInfoKHR" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkVideoCodingControlInfoKHR &p ) {
  VideoCodingControlInfoKHR temp;
  from_json( j, temp );
  p = VkVideoCodingControlInfoKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH264CapabilitiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxLevel" ] = p.maxLevel;
  j[ "fieldOffsetGranularity" ] = p.fieldOffsetGranularity;
  j[ "stdExtensionVersion" ] = p.stdExtensionVersion;
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH264CapabilitiesEXT &p ) {
  to_json( j, VideoDecodeH264CapabilitiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH264CapabilitiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH264CapabilitiesEXT" );
  p.maxLevel = j[ "maxLevel" ];
  p.fieldOffsetGranularity = j[ "fieldOffsetGranularity" ];
  p.stdExtensionVersion = j[ "stdExtensionVersion" ];
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH264CapabilitiesEXT &p ) {
  VideoDecodeH264CapabilitiesEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH264CapabilitiesEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH264DpbSlotInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pStdReferenceInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStdReferenceInfo ) );
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH264DpbSlotInfoEXT &p ) {
  to_json( j, VideoDecodeH264DpbSlotInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH264DpbSlotInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH264DpbSlotInfoEXT" );
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH264DpbSlotInfoEXT &p ) {
  VideoDecodeH264DpbSlotInfoEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH264DpbSlotInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH264MvcEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pStdMvc" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStdMvc ) );
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH264MvcEXT &p ) {
  to_json( j, VideoDecodeH264MvcEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH264MvcEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH264MvcEXT" );
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH264MvcEXT &p ) {
  VideoDecodeH264MvcEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH264MvcEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH264PictureInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pStdPictureInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStdPictureInfo ) );
  j[ "slicesCount" ] = p.slicesCount;
  j[ "pSlicesDataOffsets" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSlicesDataOffsets ) );
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH264PictureInfoEXT &p ) {
  to_json( j, VideoDecodeH264PictureInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH264PictureInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH264PictureInfoEXT" );
  p.slicesCount = j[ "slicesCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH264PictureInfoEXT &p ) {
  VideoDecodeH264PictureInfoEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH264PictureInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH264ProfileEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "fieldLayout" ] = p.fieldLayout;
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH264ProfileEXT &p ) {
  to_json( j, VideoDecodeH264ProfileEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH264ProfileEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH264ProfileEXT" );
  p.fieldLayout = j[ "fieldLayout" ];
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH264ProfileEXT &p ) {
  VideoDecodeH264ProfileEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH264ProfileEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH264SessionCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pStdExtensionVersion" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStdExtensionVersion ) );
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH264SessionCreateInfoEXT &p ) {
  to_json( j, VideoDecodeH264SessionCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH264SessionCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH264SessionCreateInfoEXT" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH264SessionCreateInfoEXT &p ) {
  VideoDecodeH264SessionCreateInfoEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH264SessionCreateInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH264SessionParametersAddInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "spsStdCount" ] = p.spsStdCount;
  j[ "pSpsStd" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSpsStd ) );
  j[ "ppsStdCount" ] = p.ppsStdCount;
  j[ "pPpsStd" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPpsStd ) );
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH264SessionParametersAddInfoEXT &p ) {
  to_json( j, VideoDecodeH264SessionParametersAddInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH264SessionParametersAddInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH264SessionParametersAddInfoEXT" );
  p.spsStdCount = j[ "spsStdCount" ];
  p.ppsStdCount = j[ "ppsStdCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH264SessionParametersAddInfoEXT &p ) {
  VideoDecodeH264SessionParametersAddInfoEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH264SessionParametersAddInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH264SessionParametersCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxSpsStdCount" ] = p.maxSpsStdCount;
  j[ "maxPpsStdCount" ] = p.maxPpsStdCount;
  j[ "pParametersAddInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pParametersAddInfo ) );
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH264SessionParametersCreateInfoEXT &p ) {
  to_json( j, VideoDecodeH264SessionParametersCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH264SessionParametersCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH264SessionParametersCreateInfoEXT" );
  p.maxSpsStdCount = j[ "maxSpsStdCount" ];
  p.maxPpsStdCount = j[ "maxPpsStdCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH264SessionParametersCreateInfoEXT &p ) {
  VideoDecodeH264SessionParametersCreateInfoEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH264SessionParametersCreateInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH265CapabilitiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxLevel" ] = p.maxLevel;
  j[ "stdExtensionVersion" ] = p.stdExtensionVersion;
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH265CapabilitiesEXT &p ) {
  to_json( j, VideoDecodeH265CapabilitiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH265CapabilitiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH265CapabilitiesEXT" );
  p.maxLevel = j[ "maxLevel" ];
  p.stdExtensionVersion = j[ "stdExtensionVersion" ];
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH265CapabilitiesEXT &p ) {
  VideoDecodeH265CapabilitiesEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH265CapabilitiesEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH265DpbSlotInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pStdReferenceInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStdReferenceInfo ) );
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH265DpbSlotInfoEXT &p ) {
  to_json( j, VideoDecodeH265DpbSlotInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH265DpbSlotInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH265DpbSlotInfoEXT" );
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH265DpbSlotInfoEXT &p ) {
  VideoDecodeH265DpbSlotInfoEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH265DpbSlotInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH265PictureInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pStdPictureInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStdPictureInfo ) );
  j[ "slicesCount" ] = p.slicesCount;
  j[ "pSlicesDataOffsets" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSlicesDataOffsets ) );
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH265PictureInfoEXT &p ) {
  to_json( j, VideoDecodeH265PictureInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH265PictureInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH265PictureInfoEXT" );
  p.slicesCount = j[ "slicesCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH265PictureInfoEXT &p ) {
  VideoDecodeH265PictureInfoEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH265PictureInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH265ProfileEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH265ProfileEXT &p ) {
  to_json( j, VideoDecodeH265ProfileEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH265ProfileEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH265ProfileEXT" );
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH265ProfileEXT &p ) {
  VideoDecodeH265ProfileEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH265ProfileEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH265SessionCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "pStdExtensionVersion" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStdExtensionVersion ) );
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH265SessionCreateInfoEXT &p ) {
  to_json( j, VideoDecodeH265SessionCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH265SessionCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH265SessionCreateInfoEXT" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH265SessionCreateInfoEXT &p ) {
  VideoDecodeH265SessionCreateInfoEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH265SessionCreateInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH265SessionParametersAddInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "spsStdCount" ] = p.spsStdCount;
  j[ "pSpsStd" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSpsStd ) );
  j[ "ppsStdCount" ] = p.ppsStdCount;
  j[ "pPpsStd" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPpsStd ) );
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH265SessionParametersAddInfoEXT &p ) {
  to_json( j, VideoDecodeH265SessionParametersAddInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH265SessionParametersAddInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH265SessionParametersAddInfoEXT" );
  p.spsStdCount = j[ "spsStdCount" ];
  p.ppsStdCount = j[ "ppsStdCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH265SessionParametersAddInfoEXT &p ) {
  VideoDecodeH265SessionParametersAddInfoEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH265SessionParametersAddInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeH265SessionParametersCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxSpsStdCount" ] = p.maxSpsStdCount;
  j[ "maxPpsStdCount" ] = p.maxPpsStdCount;
  j[ "pParametersAddInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pParametersAddInfo ) );
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeH265SessionParametersCreateInfoEXT &p ) {
  to_json( j, VideoDecodeH265SessionParametersCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeH265SessionParametersCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeH265SessionParametersCreateInfoEXT" );
  p.maxSpsStdCount = j[ "maxSpsStdCount" ];
  p.maxPpsStdCount = j[ "maxPpsStdCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeH265SessionParametersCreateInfoEXT &p ) {
  VideoDecodeH265SessionParametersCreateInfoEXT temp;
  from_json( j, temp );
  p = VkVideoDecodeH265SessionParametersCreateInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoDecodeInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "codedOffset" ] = p.codedOffset;
  j[ "codedExtent" ] = p.codedExtent;
  j[ "srcBufferOffset" ] = p.srcBufferOffset;
  j[ "srcBufferRange" ] = p.srcBufferRange;
  j[ "dstPictureResource" ] = p.dstPictureResource;
  j[ "pSetupReferenceSlot" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSetupReferenceSlot ) );
  j[ "referenceSlotCount" ] = p.referenceSlotCount;
  j[ "pReferenceSlots" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pReferenceSlots ) );
}
inline void to_json( nlohmann::json &j, const VkVideoDecodeInfoKHR &p ) {
  to_json( j, VideoDecodeInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoDecodeInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoDecodeInfoKHR" );
  p.flags = j[ "flags" ];
  p.codedOffset = j[ "codedOffset" ];
  p.codedExtent = j[ "codedExtent" ];
  p.srcBufferOffset = j[ "srcBufferOffset" ];
  p.srcBufferRange = j[ "srcBufferRange" ];
  p.dstPictureResource = j[ "dstPictureResource" ];
  p.referenceSlotCount = j[ "referenceSlotCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoDecodeInfoKHR &p ) {
  VideoDecodeInfoKHR temp;
  from_json( j, temp );
  p = VkVideoDecodeInfoKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoEncodeH264CapabilitiesEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "inputModeFlags" ] = p.inputModeFlags;
  j[ "outputModeFlags" ] = p.outputModeFlags;
  j[ "minPictureSizeInMbs" ] = p.minPictureSizeInMbs;
  j[ "maxPictureSizeInMbs" ] = p.maxPictureSizeInMbs;
  j[ "inputImageDataAlignment" ] = p.inputImageDataAlignment;
  j[ "maxNumL0ReferenceForP" ] = p.maxNumL0ReferenceForP;
  j[ "maxNumL0ReferenceForB" ] = p.maxNumL0ReferenceForB;
  j[ "maxNumL1Reference" ] = p.maxNumL1Reference;
  j[ "qualityLevelCount" ] = p.qualityLevelCount;
  j[ "stdExtensionVersion" ] = p.stdExtensionVersion;
}
inline void to_json( nlohmann::json &j, const VkVideoEncodeH264CapabilitiesEXT &p ) {
  to_json( j, VideoEncodeH264CapabilitiesEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264CapabilitiesEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoEncodeH264CapabilitiesEXT" );
  p.flags = j[ "flags" ];
  p.inputModeFlags = j[ "inputModeFlags" ];
  p.outputModeFlags = j[ "outputModeFlags" ];
  p.minPictureSizeInMbs = j[ "minPictureSizeInMbs" ];
  p.maxPictureSizeInMbs = j[ "maxPictureSizeInMbs" ];
  p.inputImageDataAlignment = j[ "inputImageDataAlignment" ];
  p.maxNumL0ReferenceForP = j[ "maxNumL0ReferenceForP" ];
  p.maxNumL0ReferenceForB = j[ "maxNumL0ReferenceForB" ];
  p.maxNumL1Reference = j[ "maxNumL1Reference" ];
  p.qualityLevelCount = j[ "qualityLevelCount" ];
  p.stdExtensionVersion = j[ "stdExtensionVersion" ];
}
inline void from_json( const nlohmann::json &j, VkVideoEncodeH264CapabilitiesEXT &p ) {
  VideoEncodeH264CapabilitiesEXT temp;
  from_json( j, temp );
  p = VkVideoEncodeH264CapabilitiesEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoEncodeH264DpbSlotInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "slotIndex" ] = p.slotIndex;
  j[ "pStdPictureInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStdPictureInfo ) );
}
inline void to_json( nlohmann::json &j, const VkVideoEncodeH264DpbSlotInfoEXT &p ) {
  to_json( j, VideoEncodeH264DpbSlotInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264DpbSlotInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoEncodeH264DpbSlotInfoEXT" );
  p.slotIndex = j[ "slotIndex" ];
}
inline void from_json( const nlohmann::json &j, VkVideoEncodeH264DpbSlotInfoEXT &p ) {
  VideoEncodeH264DpbSlotInfoEXT temp;
  from_json( j, temp );
  p = VkVideoEncodeH264DpbSlotInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoEncodeH264EmitPictureParametersEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "spsId" ] = p.spsId;
  j[ "emitSpsEnable" ] = bool( p.emitSpsEnable );
  j[ "ppsIdEntryCount" ] = p.ppsIdEntryCount;
  j[ "ppsIdEntries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.ppsIdEntries ) );
}
inline void to_json( nlohmann::json &j, const VkVideoEncodeH264EmitPictureParametersEXT &p ) {
  to_json( j, VideoEncodeH264EmitPictureParametersEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264EmitPictureParametersEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoEncodeH264EmitPictureParametersEXT" );
  p.spsId = j[ "spsId" ];
  p.emitSpsEnable = j[ "emitSpsEnable" ];
  p.ppsIdEntryCount = j[ "ppsIdEntryCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoEncodeH264EmitPictureParametersEXT &p ) {
  VideoEncodeH264EmitPictureParametersEXT temp;
  from_json( j, temp );
  p = VkVideoEncodeH264EmitPictureParametersEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoEncodeH264NaluSliceEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "pSliceHeaderStd" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSliceHeaderStd ) );
  j[ "mbCount" ] = p.mbCount;
  j[ "refFinalList0EntryCount" ] = p.refFinalList0EntryCount;
  j[ "pRefFinalList0Entries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRefFinalList0Entries ) );
  j[ "refFinalList1EntryCount" ] = p.refFinalList1EntryCount;
  j[ "pRefFinalList1Entries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRefFinalList1Entries ) );
  j[ "precedingNaluBytes" ] = p.precedingNaluBytes;
  j[ "minQp" ] = p.minQp;
  j[ "maxQp" ] = p.maxQp;
}
inline void to_json( nlohmann::json &j, const VkVideoEncodeH264NaluSliceEXT &p ) {
  to_json( j, VideoEncodeH264NaluSliceEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264NaluSliceEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoEncodeH264NaluSliceEXT" );
  p.mbCount = j[ "mbCount" ];
  p.refFinalList0EntryCount = j[ "refFinalList0EntryCount" ];
  p.refFinalList1EntryCount = j[ "refFinalList1EntryCount" ];
  p.precedingNaluBytes = j[ "precedingNaluBytes" ];
  p.minQp = j[ "minQp" ];
  p.maxQp = j[ "maxQp" ];
}
inline void from_json( const nlohmann::json &j, VkVideoEncodeH264NaluSliceEXT &p ) {
  VideoEncodeH264NaluSliceEXT temp;
  from_json( j, temp );
  p = VkVideoEncodeH264NaluSliceEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoEncodeH264ProfileEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkVideoEncodeH264ProfileEXT &p ) {
  to_json( j, VideoEncodeH264ProfileEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264ProfileEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoEncodeH264ProfileEXT" );
}
inline void from_json( const nlohmann::json &j, VkVideoEncodeH264ProfileEXT &p ) {
  VideoEncodeH264ProfileEXT temp;
  from_json( j, temp );
  p = VkVideoEncodeH264ProfileEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoEncodeH264SessionCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "maxPictureSizeInMbs" ] = p.maxPictureSizeInMbs;
  j[ "pStdExtensionVersion" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pStdExtensionVersion ) );
}
inline void to_json( nlohmann::json &j, const VkVideoEncodeH264SessionCreateInfoEXT &p ) {
  to_json( j, VideoEncodeH264SessionCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264SessionCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoEncodeH264SessionCreateInfoEXT" );
  p.flags = j[ "flags" ];
  p.maxPictureSizeInMbs = j[ "maxPictureSizeInMbs" ];
}
inline void from_json( const nlohmann::json &j, VkVideoEncodeH264SessionCreateInfoEXT &p ) {
  VideoEncodeH264SessionCreateInfoEXT temp;
  from_json( j, temp );
  p = VkVideoEncodeH264SessionCreateInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoEncodeH264SessionParametersAddInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "spsStdCount" ] = p.spsStdCount;
  j[ "pSpsStd" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSpsStd ) );
  j[ "ppsStdCount" ] = p.ppsStdCount;
  j[ "pPpsStd" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pPpsStd ) );
}
inline void to_json( nlohmann::json &j, const VkVideoEncodeH264SessionParametersAddInfoEXT &p ) {
  to_json( j, VideoEncodeH264SessionParametersAddInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264SessionParametersAddInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoEncodeH264SessionParametersAddInfoEXT" );
  p.spsStdCount = j[ "spsStdCount" ];
  p.ppsStdCount = j[ "ppsStdCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoEncodeH264SessionParametersAddInfoEXT &p ) {
  VideoEncodeH264SessionParametersAddInfoEXT temp;
  from_json( j, temp );
  p = VkVideoEncodeH264SessionParametersAddInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoEncodeH264SessionParametersCreateInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "maxSpsStdCount" ] = p.maxSpsStdCount;
  j[ "maxPpsStdCount" ] = p.maxPpsStdCount;
  j[ "pParametersAddInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pParametersAddInfo ) );
}
inline void to_json( nlohmann::json &j, const VkVideoEncodeH264SessionParametersCreateInfoEXT &p ) {
  to_json( j, VideoEncodeH264SessionParametersCreateInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264SessionParametersCreateInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoEncodeH264SessionParametersCreateInfoEXT" );
  p.maxSpsStdCount = j[ "maxSpsStdCount" ];
  p.maxPpsStdCount = j[ "maxPpsStdCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoEncodeH264SessionParametersCreateInfoEXT &p ) {
  VideoEncodeH264SessionParametersCreateInfoEXT temp;
  from_json( j, temp );
  p = VkVideoEncodeH264SessionParametersCreateInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoEncodeH264VclFrameInfoEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "refDefaultFinalList0EntryCount" ] = p.refDefaultFinalList0EntryCount;
  j[ "pRefDefaultFinalList0Entries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRefDefaultFinalList0Entries ) );
  j[ "refDefaultFinalList1EntryCount" ] = p.refDefaultFinalList1EntryCount;
  j[ "pRefDefaultFinalList1Entries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pRefDefaultFinalList1Entries ) );
  j[ "naluSliceEntryCount" ] = p.naluSliceEntryCount;
  j[ "pNaluSliceEntries" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNaluSliceEntries ) );
  j[ "pCurrentPictureInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pCurrentPictureInfo ) );
}
inline void to_json( nlohmann::json &j, const VkVideoEncodeH264VclFrameInfoEXT &p ) {
  to_json( j, VideoEncodeH264VclFrameInfoEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoEncodeH264VclFrameInfoEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoEncodeH264VclFrameInfoEXT" );
  p.refDefaultFinalList0EntryCount = j[ "refDefaultFinalList0EntryCount" ];
  p.refDefaultFinalList1EntryCount = j[ "refDefaultFinalList1EntryCount" ];
  p.naluSliceEntryCount = j[ "naluSliceEntryCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoEncodeH264VclFrameInfoEXT &p ) {
  VideoEncodeH264VclFrameInfoEXT temp;
  from_json( j, temp );
  p = VkVideoEncodeH264VclFrameInfoEXT ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoEncodeInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "qualityLevel" ] = p.qualityLevel;
  j[ "codedExtent" ] = p.codedExtent;
  j[ "dstBitstreamBufferOffset" ] = p.dstBitstreamBufferOffset;
  j[ "dstBitstreamBufferMaxRange" ] = p.dstBitstreamBufferMaxRange;
  j[ "srcPictureResource" ] = p.srcPictureResource;
  j[ "pSetupReferenceSlot" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pSetupReferenceSlot ) );
  j[ "referenceSlotCount" ] = p.referenceSlotCount;
  j[ "pReferenceSlots" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pReferenceSlots ) );
}
inline void to_json( nlohmann::json &j, const VkVideoEncodeInfoKHR &p ) {
  to_json( j, VideoEncodeInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoEncodeInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoEncodeInfoKHR" );
  p.flags = j[ "flags" ];
  p.qualityLevel = j[ "qualityLevel" ];
  p.codedExtent = j[ "codedExtent" ];
  p.dstBitstreamBufferOffset = j[ "dstBitstreamBufferOffset" ];
  p.dstBitstreamBufferMaxRange = j[ "dstBitstreamBufferMaxRange" ];
  p.srcPictureResource = j[ "srcPictureResource" ];
  p.referenceSlotCount = j[ "referenceSlotCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoEncodeInfoKHR &p ) {
  VideoEncodeInfoKHR temp;
  from_json( j, temp );
  p = VkVideoEncodeInfoKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoEncodeRateControlInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "rateControlMode" ] = p.rateControlMode;
  j[ "averageBitrate" ] = p.averageBitrate;
  j[ "peakToAverageBitrateRatio" ] = p.peakToAverageBitrateRatio;
  j[ "frameRateNumerator" ] = p.frameRateNumerator;
  j[ "frameRateDenominator" ] = p.frameRateDenominator;
  j[ "virtualBufferSizeInMs" ] = p.virtualBufferSizeInMs;
}
inline void to_json( nlohmann::json &j, const VkVideoEncodeRateControlInfoKHR &p ) {
  to_json( j, VideoEncodeRateControlInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoEncodeRateControlInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoEncodeRateControlInfoKHR" );
  p.flags = j[ "flags" ];
  p.rateControlMode = j[ "rateControlMode" ];
  p.averageBitrate = j[ "averageBitrate" ];
  p.peakToAverageBitrateRatio = j[ "peakToAverageBitrateRatio" ];
  p.frameRateNumerator = j[ "frameRateNumerator" ];
  p.frameRateDenominator = j[ "frameRateDenominator" ];
  p.virtualBufferSizeInMs = j[ "virtualBufferSizeInMs" ];
}
inline void from_json( const nlohmann::json &j, VkVideoEncodeRateControlInfoKHR &p ) {
  VideoEncodeRateControlInfoKHR temp;
  from_json( j, temp );
  p = VkVideoEncodeRateControlInfoKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoEndCodingInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkVideoEndCodingInfoKHR &p ) {
  to_json( j, VideoEndCodingInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoEndCodingInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoEndCodingInfoKHR" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkVideoEndCodingInfoKHR &p ) {
  VideoEndCodingInfoKHR temp;
  from_json( j, temp );
  p = VkVideoEndCodingInfoKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoFormatPropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "format" ] = p.format;
}
inline void to_json( nlohmann::json &j, const VkVideoFormatPropertiesKHR &p ) {
  to_json( j, VideoFormatPropertiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoFormatPropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoFormatPropertiesKHR" );
  p.format = j[ "format" ];
}
inline void from_json( const nlohmann::json &j, VkVideoFormatPropertiesKHR &p ) {
  VideoFormatPropertiesKHR temp;
  from_json( j, temp );
  p = VkVideoFormatPropertiesKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoGetMemoryPropertiesKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "memoryBindIndex" ] = p.memoryBindIndex;
  j[ "pMemoryRequirements" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pMemoryRequirements ) );
}
inline void to_json( nlohmann::json &j, const VkVideoGetMemoryPropertiesKHR &p ) {
  to_json( j, VideoGetMemoryPropertiesKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoGetMemoryPropertiesKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoGetMemoryPropertiesKHR" );
  p.memoryBindIndex = j[ "memoryBindIndex" ];
}
inline void from_json( const nlohmann::json &j, VkVideoGetMemoryPropertiesKHR &p ) {
  VideoGetMemoryPropertiesKHR temp;
  from_json( j, temp );
  p = VkVideoGetMemoryPropertiesKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoQueueFamilyProperties2KHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "videoCodecOperations" ] = p.videoCodecOperations;
}
inline void to_json( nlohmann::json &j, const VkVideoQueueFamilyProperties2KHR &p ) {
  to_json( j, VideoQueueFamilyProperties2KHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoQueueFamilyProperties2KHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoQueueFamilyProperties2KHR" );
  p.videoCodecOperations = j[ "videoCodecOperations" ];
}
inline void from_json( const nlohmann::json &j, VkVideoQueueFamilyProperties2KHR &p ) {
  VideoQueueFamilyProperties2KHR temp;
  from_json( j, temp );
  p = VkVideoQueueFamilyProperties2KHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoSessionCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "queueFamilyIndex" ] = p.queueFamilyIndex;
  j[ "flags" ] = p.flags;
  j[ "pVideoProfile" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pVideoProfile ) );
  j[ "pictureFormat" ] = p.pictureFormat;
  j[ "maxCodedExtent" ] = p.maxCodedExtent;
  j[ "referencePicturesFormat" ] = p.referencePicturesFormat;
  j[ "maxReferencePicturesSlotsCount" ] = p.maxReferencePicturesSlotsCount;
  j[ "maxReferencePicturesActiveCount" ] = p.maxReferencePicturesActiveCount;
}
inline void to_json( nlohmann::json &j, const VkVideoSessionCreateInfoKHR &p ) {
  to_json( j, VideoSessionCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoSessionCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoSessionCreateInfoKHR" );
  p.queueFamilyIndex = j[ "queueFamilyIndex" ];
  p.flags = j[ "flags" ];
  p.pictureFormat = j[ "pictureFormat" ];
  p.maxCodedExtent = j[ "maxCodedExtent" ];
  p.referencePicturesFormat = j[ "referencePicturesFormat" ];
  p.maxReferencePicturesSlotsCount = j[ "maxReferencePicturesSlotsCount" ];
  p.maxReferencePicturesActiveCount = j[ "maxReferencePicturesActiveCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoSessionCreateInfoKHR &p ) {
  VideoSessionCreateInfoKHR temp;
  from_json( j, temp );
  p = VkVideoSessionCreateInfoKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoSessionParametersCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
}
inline void to_json( nlohmann::json &j, const VkVideoSessionParametersCreateInfoKHR &p ) {
  to_json( j, VideoSessionParametersCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoSessionParametersCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoSessionParametersCreateInfoKHR" );
}
inline void from_json( const nlohmann::json &j, VkVideoSessionParametersCreateInfoKHR &p ) {
  VideoSessionParametersCreateInfoKHR temp;
  from_json( j, temp );
  p = VkVideoSessionParametersCreateInfoKHR ( temp );
}
#endif

#if defined( VK_ENABLE_BETA_EXTENSIONS )
inline void to_json( nlohmann::json &j, const VideoSessionParametersUpdateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "updateSequenceCount" ] = p.updateSequenceCount;
}
inline void to_json( nlohmann::json &j, const VkVideoSessionParametersUpdateInfoKHR &p ) {
  to_json( j, VideoSessionParametersUpdateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, VideoSessionParametersUpdateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for VideoSessionParametersUpdateInfoKHR" );
  p.updateSequenceCount = j[ "updateSequenceCount" ];
}
inline void from_json( const nlohmann::json &j, VkVideoSessionParametersUpdateInfoKHR &p ) {
  VideoSessionParametersUpdateInfoKHR temp;
  from_json( j, temp );
  p = VkVideoSessionParametersUpdateInfoKHR ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_WAYLAND_KHR )
inline void to_json( nlohmann::json &j, const WaylandSurfaceCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "display" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.display ) );
  j[ "surface" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.surface ) );
}
inline void to_json( nlohmann::json &j, const VkWaylandSurfaceCreateInfoKHR &p ) {
  to_json( j, WaylandSurfaceCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, WaylandSurfaceCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for WaylandSurfaceCreateInfoKHR" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkWaylandSurfaceCreateInfoKHR &p ) {
  WaylandSurfaceCreateInfoKHR temp;
  from_json( j, temp );
  p = VkWaylandSurfaceCreateInfoKHR ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const Win32KeyedMutexAcquireReleaseInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "acquireCount" ] = p.acquireCount;
  j[ "pAcquireSyncs" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAcquireSyncs ) );
  j[ "pAcquireKeys" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAcquireKeys ) );
  j[ "pAcquireTimeouts" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAcquireTimeouts ) );
  j[ "releaseCount" ] = p.releaseCount;
  j[ "pReleaseSyncs" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pReleaseSyncs ) );
  j[ "pReleaseKeys" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pReleaseKeys ) );
}
inline void to_json( nlohmann::json &j, const VkWin32KeyedMutexAcquireReleaseInfoKHR &p ) {
  to_json( j, Win32KeyedMutexAcquireReleaseInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, Win32KeyedMutexAcquireReleaseInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Win32KeyedMutexAcquireReleaseInfoKHR" );
  p.acquireCount = j[ "acquireCount" ];
  p.releaseCount = j[ "releaseCount" ];
}
inline void from_json( const nlohmann::json &j, VkWin32KeyedMutexAcquireReleaseInfoKHR &p ) {
  Win32KeyedMutexAcquireReleaseInfoKHR temp;
  from_json( j, temp );
  p = VkWin32KeyedMutexAcquireReleaseInfoKHR ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const Win32KeyedMutexAcquireReleaseInfoNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "acquireCount" ] = p.acquireCount;
  j[ "pAcquireSyncs" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAcquireSyncs ) );
  j[ "pAcquireKeys" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAcquireKeys ) );
  j[ "pAcquireTimeoutMilliseconds" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAcquireTimeoutMilliseconds ) );
  j[ "releaseCount" ] = p.releaseCount;
  j[ "pReleaseSyncs" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pReleaseSyncs ) );
  j[ "pReleaseKeys" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pReleaseKeys ) );
}
inline void to_json( nlohmann::json &j, const VkWin32KeyedMutexAcquireReleaseInfoNV &p ) {
  to_json( j, Win32KeyedMutexAcquireReleaseInfoNV ( p ) );
}
inline void from_json( const nlohmann::json &j, Win32KeyedMutexAcquireReleaseInfoNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Win32KeyedMutexAcquireReleaseInfoNV" );
  p.acquireCount = j[ "acquireCount" ];
  p.releaseCount = j[ "releaseCount" ];
}
inline void from_json( const nlohmann::json &j, VkWin32KeyedMutexAcquireReleaseInfoNV &p ) {
  Win32KeyedMutexAcquireReleaseInfoNV temp;
  from_json( j, temp );
  p = VkWin32KeyedMutexAcquireReleaseInfoNV ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_WIN32_KHR )
inline void to_json( nlohmann::json &j, const Win32SurfaceCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
}
inline void to_json( nlohmann::json &j, const VkWin32SurfaceCreateInfoKHR &p ) {
  to_json( j, Win32SurfaceCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, Win32SurfaceCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for Win32SurfaceCreateInfoKHR" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkWin32SurfaceCreateInfoKHR &p ) {
  Win32SurfaceCreateInfoKHR temp;
  from_json( j, temp );
  p = VkWin32SurfaceCreateInfoKHR ( temp );
}
#endif

inline void to_json( nlohmann::json &j, const WriteDescriptorSet &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dstBinding" ] = p.dstBinding;
  j[ "dstArrayElement" ] = p.dstArrayElement;
  j[ "descriptorCount" ] = p.descriptorCount;
  j[ "descriptorType" ] = p.descriptorType;
  j[ "pImageInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pImageInfo ) );
  j[ "pBufferInfo" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pBufferInfo ) );
  j[ "pTexelBufferView" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pTexelBufferView ) );
}
inline void to_json( nlohmann::json &j, const VkWriteDescriptorSet &p ) {
  to_json( j, WriteDescriptorSet ( p ) );
}
inline void from_json( const nlohmann::json &j, WriteDescriptorSet &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for WriteDescriptorSet" );
  p.dstBinding = j[ "dstBinding" ];
  p.dstArrayElement = j[ "dstArrayElement" ];
  p.descriptorCount = j[ "descriptorCount" ];
  p.descriptorType = j[ "descriptorType" ];
}
inline void from_json( const nlohmann::json &j, VkWriteDescriptorSet &p ) {
  WriteDescriptorSet temp;
  from_json( j, temp );
  p = VkWriteDescriptorSet ( temp );
}

inline void to_json( nlohmann::json &j, const WriteDescriptorSetAccelerationStructureKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "accelerationStructureCount" ] = p.accelerationStructureCount;
  j[ "pAccelerationStructures" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAccelerationStructures ) );
}
inline void to_json( nlohmann::json &j, const VkWriteDescriptorSetAccelerationStructureKHR &p ) {
  to_json( j, WriteDescriptorSetAccelerationStructureKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, WriteDescriptorSetAccelerationStructureKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for WriteDescriptorSetAccelerationStructureKHR" );
  p.accelerationStructureCount = j[ "accelerationStructureCount" ];
}
inline void from_json( const nlohmann::json &j, VkWriteDescriptorSetAccelerationStructureKHR &p ) {
  WriteDescriptorSetAccelerationStructureKHR temp;
  from_json( j, temp );
  p = VkWriteDescriptorSetAccelerationStructureKHR ( temp );
}

inline void to_json( nlohmann::json &j, const WriteDescriptorSetAccelerationStructureNV &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "accelerationStructureCount" ] = p.accelerationStructureCount;
  j[ "pAccelerationStructures" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pAccelerationStructures ) );
}
inline void to_json( nlohmann::json &j, const VkWriteDescriptorSetAccelerationStructureNV &p ) {
  to_json( j, WriteDescriptorSetAccelerationStructureNV ( p ) );
}
inline void from_json( const nlohmann::json &j, WriteDescriptorSetAccelerationStructureNV &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for WriteDescriptorSetAccelerationStructureNV" );
  p.accelerationStructureCount = j[ "accelerationStructureCount" ];
}
inline void from_json( const nlohmann::json &j, VkWriteDescriptorSetAccelerationStructureNV &p ) {
  WriteDescriptorSetAccelerationStructureNV temp;
  from_json( j, temp );
  p = VkWriteDescriptorSetAccelerationStructureNV ( temp );
}

inline void to_json( nlohmann::json &j, const WriteDescriptorSetInlineUniformBlockEXT &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "dataSize" ] = p.dataSize;
  j[ "pData" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pData ) );
}
inline void to_json( nlohmann::json &j, const VkWriteDescriptorSetInlineUniformBlockEXT &p ) {
  to_json( j, WriteDescriptorSetInlineUniformBlockEXT ( p ) );
}
inline void from_json( const nlohmann::json &j, WriteDescriptorSetInlineUniformBlockEXT &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for WriteDescriptorSetInlineUniformBlockEXT" );
  p.dataSize = j[ "dataSize" ];
}
inline void from_json( const nlohmann::json &j, VkWriteDescriptorSetInlineUniformBlockEXT &p ) {
  WriteDescriptorSetInlineUniformBlockEXT temp;
  from_json( j, temp );
  p = VkWriteDescriptorSetInlineUniformBlockEXT ( temp );
}

#if defined( VK_USE_PLATFORM_XCB_KHR )
inline void to_json( nlohmann::json &j, const XcbSurfaceCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "connection" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.connection ) );
}
inline void to_json( nlohmann::json &j, const VkXcbSurfaceCreateInfoKHR &p ) {
  to_json( j, XcbSurfaceCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, XcbSurfaceCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for XcbSurfaceCreateInfoKHR" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkXcbSurfaceCreateInfoKHR &p ) {
  XcbSurfaceCreateInfoKHR temp;
  from_json( j, temp );
  p = VkXcbSurfaceCreateInfoKHR ( temp );
}
#endif

#if defined( VK_USE_PLATFORM_XLIB_KHR )
inline void to_json( nlohmann::json &j, const XlibSurfaceCreateInfoKHR &p ) {
  j = nlohmann::json::object();
  j[ "sType" ] = p.sType;
  j[ "pNext" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.pNext ) );
  j[ "flags" ] = p.flags;
  j[ "dpy" ] = reinterpret_cast< std::uintptr_t >( reinterpret_cast< const void* >( p.dpy ) );
}
inline void to_json( nlohmann::json &j, const VkXlibSurfaceCreateInfoKHR &p ) {
  to_json( j, XlibSurfaceCreateInfoKHR ( p ) );
}
inline void from_json( const nlohmann::json &j, XlibSurfaceCreateInfoKHR &p ) {
  if( !j.is_object() ) throw vulkan2json::invalid_object_value( "incompatible value for XlibSurfaceCreateInfoKHR" );
  p.flags = j[ "flags" ];
}
inline void from_json( const nlohmann::json &j, VkXlibSurfaceCreateInfoKHR &p ) {
  XlibSurfaceCreateInfoKHR temp;
  from_json( j, temp );
  p = VkXlibSurfaceCreateInfoKHR ( temp );
}
#endif


}

#endif

